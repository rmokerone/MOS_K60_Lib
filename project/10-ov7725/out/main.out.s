
out/main.elf:     file format elf32-littlearm


Disassembly of section .vectortable:

00000000 <__vector_table>:
   0:	20000000 	andcs	r0, r0, r0
   4:	00000915 	andeq	r0, r0, r5, lsl r9
	...
  40:	00002e01 	andeq	r2, r0, r1, lsl #28
  44:	00002e2d 	andeq	r2, r0, sp, lsr #28
  48:	00002e59 	andeq	r2, r0, r9, asr lr
  4c:	00002e85 	andeq	r2, r0, r5, lsl #29
  50:	00002eb1 			; <UNDEFINED> instruction: 0x00002eb1
  54:	00002edd 	ldrdeq	r2, [r0], -sp
  58:	00002f09 	andeq	r2, r0, r9, lsl #30
  5c:	00002f35 	andeq	r2, r0, r5, lsr pc
  60:	00002f61 	andeq	r2, r0, r1, ror #30
  64:	00002f8d 	andeq	r2, r0, sp, lsl #31
  68:	00002fb9 			; <UNDEFINED> instruction: 0x00002fb9
  6c:	00002fe5 	andeq	r2, r0, r5, ror #31
  70:	00003011 	andeq	r3, r0, r1, lsl r0
  74:	0000303d 	andeq	r3, r0, sp, lsr r0
  78:	00003069 	andeq	r3, r0, r9, rrx
  7c:	00003095 	muleq	r0, r5, r0
  80:	000008d9 	ldrdeq	r0, [r0], -r9
  84:	000008d9 	ldrdeq	r0, [r0], -r9
  88:	000008d9 	ldrdeq	r0, [r0], -r9
  8c:	000008d9 	ldrdeq	r0, [r0], -r9
  90:	000008d9 	ldrdeq	r0, [r0], -r9
  94:	000008d9 	ldrdeq	r0, [r0], -r9
  98:	000008d9 	ldrdeq	r0, [r0], -r9
  9c:	000008d9 	ldrdeq	r0, [r0], -r9
  a0:	000008d9 	ldrdeq	r0, [r0], -r9
  a4:	000008d9 	ldrdeq	r0, [r0], -r9
  a8:	00006f4d 	andeq	r6, r0, sp, asr #30
  ac:	0000709d 	muleq	r0, sp, r0
  b0:	000071ed 	andeq	r7, r0, sp, ror #3
  b4:	000008d9 	ldrdeq	r0, [r0], -r9
  b8:	000008d9 	ldrdeq	r0, [r0], -r9
  bc:	000008d9 	ldrdeq	r0, [r0], -r9
  c0:	000008d9 	ldrdeq	r0, [r0], -r9
  c4:	000008d9 	ldrdeq	r0, [r0], -r9
  c8:	000008d9 	ldrdeq	r0, [r0], -r9
  cc:	000008d9 	ldrdeq	r0, [r0], -r9
  d0:	000008d9 	ldrdeq	r0, [r0], -r9
  d4:	000008d9 	ldrdeq	r0, [r0], -r9
  d8:	000008d9 	ldrdeq	r0, [r0], -r9
  dc:	000008d9 	ldrdeq	r0, [r0], -r9
  e0:	000008d9 	ldrdeq	r0, [r0], -r9
  e4:	000008d9 	ldrdeq	r0, [r0], -r9
  e8:	000008d9 	ldrdeq	r0, [r0], -r9
  ec:	000008d9 	ldrdeq	r0, [r0], -r9
  f0:	000008d9 	ldrdeq	r0, [r0], -r9
  f4:	00007a2d 	andeq	r7, r0, sp, lsr #20
  f8:	000008d9 	ldrdeq	r0, [r0], -r9
  fc:	00007a9d 	muleq	r0, sp, sl
 100:	000008d9 	ldrdeq	r0, [r0], -r9
 104:	00007b0d 	andeq	r7, r0, sp, lsl #22
 108:	000008d9 	ldrdeq	r0, [r0], -r9
 10c:	00007b7d 	andeq	r7, r0, sp, ror fp
 110:	000008d9 	ldrdeq	r0, [r0], -r9
 114:	00007bed 	andeq	r7, r0, sp, ror #23
 118:	000008d9 	ldrdeq	r0, [r0], -r9
 11c:	00007c5d 	andeq	r7, r0, sp, asr ip
 120:	000008d9 	ldrdeq	r0, [r0], -r9
 124:	00002879 	andeq	r2, r0, r9, ror r8
 128:	0000288d 	andeq	r2, r0, sp, lsl #17
 12c:	000008d9 	ldrdeq	r0, [r0], -r9
 130:	000008d9 	ldrdeq	r0, [r0], -r9
 134:	000008d9 	ldrdeq	r0, [r0], -r9
 138:	00004c55 	andeq	r4, r0, r5, asr ip
 13c:	00004c69 	andeq	r4, r0, r9, ror #24
 140:	00004c7d 	andeq	r4, r0, sp, ror ip
 144:	000008d9 	ldrdeq	r0, [r0], -r9
 148:	000008d9 	ldrdeq	r0, [r0], -r9
 14c:	000008d9 	ldrdeq	r0, [r0], -r9
 150:	00006409 	andeq	r6, r0, r9, lsl #8
 154:	00006439 	andeq	r6, r0, r9, lsr r4
 158:	00006469 	andeq	r6, r0, r9, ror #8
 15c:	00006499 	muleq	r0, r9, r4
 160:	00005e9d 	muleq	r0, sp, lr
 164:	000008d9 	ldrdeq	r0, [r0], -r9
 168:	000008d9 	ldrdeq	r0, [r0], -r9
 16c:	000008d9 	ldrdeq	r0, [r0], -r9
 170:	000008d9 	ldrdeq	r0, [r0], -r9
 174:	000008d9 	ldrdeq	r0, [r0], -r9
 178:	000008d9 	ldrdeq	r0, [r0], -r9
 17c:	000008d9 	ldrdeq	r0, [r0], -r9
 180:	000008d9 	ldrdeq	r0, [r0], -r9
 184:	000008d9 	ldrdeq	r0, [r0], -r9
 188:	000008d9 	ldrdeq	r0, [r0], -r9
 18c:	000008d9 	ldrdeq	r0, [r0], -r9
 190:	000008d9 	ldrdeq	r0, [r0], -r9
 194:	000008d9 	ldrdeq	r0, [r0], -r9
 198:	000008d9 	ldrdeq	r0, [r0], -r9
 19c:	000050d5 	ldrdeq	r5, [r0], -r5	; <UNPREDICTABLE>
 1a0:	000050f9 	strdeq	r5, [r0], -r9
 1a4:	0000511d 	andeq	r5, r0, sp, lsl r1
 1a8:	00005141 	andeq	r5, r0, r1, asr #2
 1ac:	00005165 	andeq	r5, r0, r5, ror #2
 1b0:	000008d9 	ldrdeq	r0, [r0], -r9
 1b4:	000008d9 	ldrdeq	r0, [r0], -r9
 1b8:	000008d9 	ldrdeq	r0, [r0], -r9
 1bc:	000008d9 	ldrdeq	r0, [r0], -r9
 1c0:	000008d9 	ldrdeq	r0, [r0], -r9
 1c4:	000008d9 	ldrdeq	r0, [r0], -r9
 1c8:	000008d9 	ldrdeq	r0, [r0], -r9
 1cc:	000008d9 	ldrdeq	r0, [r0], -r9
 1d0:	000008d9 	ldrdeq	r0, [r0], -r9
 1d4:	000008d9 	ldrdeq	r0, [r0], -r9
 1d8:	000008d9 	ldrdeq	r0, [r0], -r9
 1dc:	000008d9 	ldrdeq	r0, [r0], -r9
 1e0:	000008d9 	ldrdeq	r0, [r0], -r9
 1e4:	000008d9 	ldrdeq	r0, [r0], -r9
 1e8:	000008d9 	ldrdeq	r0, [r0], -r9
 1ec:	000008d9 	ldrdeq	r0, [r0], -r9
 1f0:	000008d9 	ldrdeq	r0, [r0], -r9
 1f4:	000008d9 	ldrdeq	r0, [r0], -r9
 1f8:	000008d9 	ldrdeq	r0, [r0], -r9
 1fc:	000008d9 	ldrdeq	r0, [r0], -r9
 200:	000008d9 	ldrdeq	r0, [r0], -r9
 204:	000008d9 	ldrdeq	r0, [r0], -r9
 208:	000008d9 	ldrdeq	r0, [r0], -r9
 20c:	000008d9 	ldrdeq	r0, [r0], -r9
 210:	000008d9 	ldrdeq	r0, [r0], -r9
 214:	000008d9 	ldrdeq	r0, [r0], -r9
 218:	000008d9 	ldrdeq	r0, [r0], -r9
 21c:	000008d9 	ldrdeq	r0, [r0], -r9
 220:	000008d9 	ldrdeq	r0, [r0], -r9
 224:	000008d9 	ldrdeq	r0, [r0], -r9
 228:	000008d9 	ldrdeq	r0, [r0], -r9
 22c:	000008d9 	ldrdeq	r0, [r0], -r9
 230:	000008d9 	ldrdeq	r0, [r0], -r9
 234:	000008d9 	ldrdeq	r0, [r0], -r9
 238:	000008d9 	ldrdeq	r0, [r0], -r9
 23c:	000008d9 	ldrdeq	r0, [r0], -r9
 240:	000008d9 	ldrdeq	r0, [r0], -r9
 244:	000008d9 	ldrdeq	r0, [r0], -r9
 248:	000008d9 	ldrdeq	r0, [r0], -r9
 24c:	000008d9 	ldrdeq	r0, [r0], -r9
 250:	000008d9 	ldrdeq	r0, [r0], -r9
 254:	000008d9 	ldrdeq	r0, [r0], -r9
 258:	000008d9 	ldrdeq	r0, [r0], -r9
 25c:	000008d9 	ldrdeq	r0, [r0], -r9
 260:	000008d9 	ldrdeq	r0, [r0], -r9
 264:	000008d9 	ldrdeq	r0, [r0], -r9
 268:	000008d9 	ldrdeq	r0, [r0], -r9
 26c:	000008d9 	ldrdeq	r0, [r0], -r9
 270:	000008d9 	ldrdeq	r0, [r0], -r9
 274:	000008d9 	ldrdeq	r0, [r0], -r9
 278:	000008d9 	ldrdeq	r0, [r0], -r9
 27c:	000008d9 	ldrdeq	r0, [r0], -r9
 280:	000008d9 	ldrdeq	r0, [r0], -r9
 284:	000008d9 	ldrdeq	r0, [r0], -r9
 288:	000008d9 	ldrdeq	r0, [r0], -r9
 28c:	000008d9 	ldrdeq	r0, [r0], -r9
 290:	000008d9 	ldrdeq	r0, [r0], -r9
 294:	000008d9 	ldrdeq	r0, [r0], -r9
 298:	000008d9 	ldrdeq	r0, [r0], -r9
 29c:	000008d9 	ldrdeq	r0, [r0], -r9
 2a0:	000008d9 	ldrdeq	r0, [r0], -r9
 2a4:	000008d9 	ldrdeq	r0, [r0], -r9
 2a8:	000008d9 	ldrdeq	r0, [r0], -r9
 2ac:	000008d9 	ldrdeq	r0, [r0], -r9
 2b0:	000008d9 	ldrdeq	r0, [r0], -r9
 2b4:	000008d9 	ldrdeq	r0, [r0], -r9
 2b8:	000008d9 	ldrdeq	r0, [r0], -r9
 2bc:	000008d9 	ldrdeq	r0, [r0], -r9
 2c0:	000008d9 	ldrdeq	r0, [r0], -r9
 2c4:	000008d9 	ldrdeq	r0, [r0], -r9
 2c8:	000008d9 	ldrdeq	r0, [r0], -r9
 2cc:	000008d9 	ldrdeq	r0, [r0], -r9
 2d0:	000008d9 	ldrdeq	r0, [r0], -r9
 2d4:	000008d9 	ldrdeq	r0, [r0], -r9
 2d8:	000008d9 	ldrdeq	r0, [r0], -r9
 2dc:	000008d9 	ldrdeq	r0, [r0], -r9
 2e0:	000008d9 	ldrdeq	r0, [r0], -r9
 2e4:	000008d9 	ldrdeq	r0, [r0], -r9
 2e8:	000008d9 	ldrdeq	r0, [r0], -r9
 2ec:	000008d9 	ldrdeq	r0, [r0], -r9
 2f0:	000008d9 	ldrdeq	r0, [r0], -r9
 2f4:	000008d9 	ldrdeq	r0, [r0], -r9
 2f8:	000008d9 	ldrdeq	r0, [r0], -r9
 2fc:	000008d9 	ldrdeq	r0, [r0], -r9
 300:	000008d9 	ldrdeq	r0, [r0], -r9
 304:	000008d9 	ldrdeq	r0, [r0], -r9
 308:	000008d9 	ldrdeq	r0, [r0], -r9
 30c:	000008d9 	ldrdeq	r0, [r0], -r9
 310:	000008d9 	ldrdeq	r0, [r0], -r9
 314:	000008d9 	ldrdeq	r0, [r0], -r9
 318:	000008d9 	ldrdeq	r0, [r0], -r9
 31c:	000008d9 	ldrdeq	r0, [r0], -r9
 320:	000008d9 	ldrdeq	r0, [r0], -r9
 324:	000008d9 	ldrdeq	r0, [r0], -r9
 328:	000008d9 	ldrdeq	r0, [r0], -r9
 32c:	000008d9 	ldrdeq	r0, [r0], -r9
 330:	000008d9 	ldrdeq	r0, [r0], -r9
 334:	000008d9 	ldrdeq	r0, [r0], -r9
 338:	000008d9 	ldrdeq	r0, [r0], -r9
 33c:	000008d9 	ldrdeq	r0, [r0], -r9
 340:	000008d9 	ldrdeq	r0, [r0], -r9
 344:	000008d9 	ldrdeq	r0, [r0], -r9
 348:	000008d9 	ldrdeq	r0, [r0], -r9
 34c:	000008d9 	ldrdeq	r0, [r0], -r9
 350:	000008d9 	ldrdeq	r0, [r0], -r9
 354:	000008d9 	ldrdeq	r0, [r0], -r9
 358:	000008d9 	ldrdeq	r0, [r0], -r9
 35c:	000008d9 	ldrdeq	r0, [r0], -r9
 360:	000008d9 	ldrdeq	r0, [r0], -r9
 364:	000008d9 	ldrdeq	r0, [r0], -r9
 368:	000008d9 	ldrdeq	r0, [r0], -r9
 36c:	000008d9 	ldrdeq	r0, [r0], -r9
 370:	000008d9 	ldrdeq	r0, [r0], -r9
 374:	000008d9 	ldrdeq	r0, [r0], -r9
 378:	000008d9 	ldrdeq	r0, [r0], -r9
 37c:	000008d9 	ldrdeq	r0, [r0], -r9
 380:	000008d9 	ldrdeq	r0, [r0], -r9
 384:	000008d9 	ldrdeq	r0, [r0], -r9
 388:	000008d9 	ldrdeq	r0, [r0], -r9
 38c:	000008d9 	ldrdeq	r0, [r0], -r9
 390:	000008d9 	ldrdeq	r0, [r0], -r9
 394:	000008d9 	ldrdeq	r0, [r0], -r9
 398:	000008d9 	ldrdeq	r0, [r0], -r9
 39c:	000008d9 	ldrdeq	r0, [r0], -r9
 3a0:	000008d9 	ldrdeq	r0, [r0], -r9
 3a4:	000008d9 	ldrdeq	r0, [r0], -r9
 3a8:	000008d9 	ldrdeq	r0, [r0], -r9
 3ac:	000008d9 	ldrdeq	r0, [r0], -r9
 3b0:	000008d9 	ldrdeq	r0, [r0], -r9
 3b4:	000008d9 	ldrdeq	r0, [r0], -r9
 3b8:	000008d9 	ldrdeq	r0, [r0], -r9
 3bc:	000008d9 	ldrdeq	r0, [r0], -r9
 3c0:	000008d9 	ldrdeq	r0, [r0], -r9
 3c4:	000008d9 	ldrdeq	r0, [r0], -r9
 3c8:	000008d9 	ldrdeq	r0, [r0], -r9
 3cc:	000008d9 	ldrdeq	r0, [r0], -r9
 3d0:	000008d9 	ldrdeq	r0, [r0], -r9
 3d4:	000008d9 	ldrdeq	r0, [r0], -r9
 3d8:	000008d9 	ldrdeq	r0, [r0], -r9
 3dc:	000008d9 	ldrdeq	r0, [r0], -r9
 3e0:	000008d9 	ldrdeq	r0, [r0], -r9
 3e4:	000008d9 	ldrdeq	r0, [r0], -r9
 3e8:	000008d9 	ldrdeq	r0, [r0], -r9
 3ec:	000008d9 	ldrdeq	r0, [r0], -r9
 3f0:	000008d9 	ldrdeq	r0, [r0], -r9
 3f4:	000008d9 	ldrdeq	r0, [r0], -r9
 3f8:	000008d9 	ldrdeq	r0, [r0], -r9
 3fc:	000008d9 	ldrdeq	r0, [r0], -r9
 400:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
 404:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
 408:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
 40c:	fffffffe 			; <UNDEFINED> instruction: 0xfffffffe

Disassembly of section .text:

00000800 <main>:
extern GPIO_InitTypeDef OV_PTA_init;

extern char ready_send_flag;

int main (void)
{
     800:	b580      	push	{r7, lr}
     802:	b084      	sub	sp, #16
     804:	af04      	add	r7, sp, #16

    Ov7725_Init ();
     806:	f000 fae3 	bl	dd0 <Ov7725_Init>
    Ov7725_Delay();
     80a:	f000 fbe1 	bl	fd0 <Ov7725_Delay>

    //Ov7725_Dma_Init();
    Ov7725_Gpio_Init ();
     80e:	f000 fd8d 	bl	132c <Ov7725_Gpio_Init>
    dma_portx2buff_init (DMA_CH0, (void *)(&GPIOB_PDIR), (void *)img,PORTA_DMAREQ ,DMA_BYTE1, PHOTO_SIZE / 8, DADDR_KEEPON);
     812:	f04f 0300 	mov.w	r3, #0
     816:	9300      	str	r3, [sp, #0]
     818:	f44f 7316 	mov.w	r3, #600	; 0x258
     81c:	9301      	str	r3, [sp, #4]
     81e:	f04f 0301 	mov.w	r3, #1
     822:	9302      	str	r3, [sp, #8]
     824:	f04f 0000 	mov.w	r0, #0
     828:	f24f 0150 	movw	r1, #61520	; 0xf050
     82c:	f2c4 010f 	movt	r1, #16399	; 0x400f
     830:	f240 027c 	movw	r2, #124	; 0x7c
     834:	f6c1 72ff 	movt	r2, #8191	; 0x1fff
     838:	f04f 0331 	mov.w	r3, #49	; 0x31
     83c:	f000 fecc 	bl	15d8 <dma_portx2buff_init>
    //装载DMA中断
    DMA_ISR[DMA_CH0] = Ov7725_eagle_dma;
     840:	f241 6304 	movw	r3, #5636	; 0x1604
     844:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
     848:	f241 0215 	movw	r2, #4117	; 0x1015
     84c:	f2c0 0200 	movt	r2, #0
     850:	601a      	str	r2, [r3, #0]
    //关闭DMA通道
    DMA_DIS(DMA_CH0);
     852:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     856:	f2c4 0300 	movt	r3, #16384	; 0x4000
     85a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
     85e:	f2c4 0200 	movt	r2, #16384	; 0x4000
     862:	6a52      	ldr	r2, [r2, #36]	; 0x24
     864:	f022 0201 	bic.w	r2, r2, #1
     868:	625a      	str	r2, [r3, #36]	; 0x24
    //关GPIO中断
    disable_irq(INT_PORTA - 16);
     86a:	f04f 0057 	mov.w	r0, #87	; 0x57
     86e:	f000 fa13 	bl	c98 <disable_irq>
    //清DMA中断置为标志
    DMA_IRQ_CLEAN(DMA_CH0);
     872:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     876:	f2c4 0300 	movt	r3, #16384	; 0x4000
     87a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
     87e:	f2c4 0200 	movt	r2, #16384	; 0x4000
     882:	6a52      	ldr	r2, [r2, #36]	; 0x24
     884:	f042 0201 	orr.w	r2, r2, #1
     888:	625a      	str	r2, [r3, #36]	; 0x24
    //使能DMA中断
    DMA_IRQ_EN (DMA_CH0);
     88a:	f04f 0000 	mov.w	r0, #0
     88e:	f000 f93f 	bl	b10 <enable_irq>
    //开启GPIO中断
    LPLD_GPIO_EnableIrq(OV_PTA_init);
     892:	f241 53a8 	movw	r3, #5544	; 0x15a8
     896:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
     89a:	691a      	ldr	r2, [r3, #16]
     89c:	9200      	str	r2, [sp, #0]
     89e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
     8a0:	f004 faa2 	bl	4de8 <LPLD_GPIO_EnableIrq>
     8a4:	e000      	b.n	8a8 <main+0xa8>
            //发送图片到上位机
            //get_midline(Pix_Data, 60, 80);
            Ov7725_sendimg (Pix_Data, PHOTO_SIZE);
            ready_send_flag = 0;
        }
    }
     8a6:	bf00      	nop
    {
        //获取图像
        //Ov7725_eagle_get_img ();
        //解压图像
        //Ov7725_img_extract (Pix_Data, img, PHOTO_SIZE/8);
        if(ready_send_flag)
     8a8:	f240 0378 	movw	r3, #120	; 0x78
     8ac:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
     8b0:	781b      	ldrb	r3, [r3, #0]
     8b2:	2b00      	cmp	r3, #0
     8b4:	d0f7      	beq.n	8a6 <main+0xa6>
        {
            //发送图片到上位机
            //get_midline(Pix_Data, 60, 80);
            Ov7725_sendimg (Pix_Data, PHOTO_SIZE);
     8b6:	f240 20d4 	movw	r0, #724	; 0x2d4
     8ba:	f6c1 70ff 	movt	r0, #8191	; 0x1fff
     8be:	f44f 5196 	mov.w	r1, #4800	; 0x12c0
     8c2:	f000 fd0d 	bl	12e0 <Ov7725_sendimg>
            ready_send_flag = 0;
     8c6:	f240 0378 	movw	r3, #120	; 0x78
     8ca:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
     8ce:	f04f 0200 	mov.w	r2, #0
     8d2:	701a      	strb	r2, [r3, #0]
        }
    }
     8d4:	e7e7      	b.n	8a6 <main+0xa6>
     8d6:	bf00      	nop

000008d8 <CAN0_Bus_Off_IRQHandler>:
 * \param  void
 *
 * \return void
 */
void Default_Handler(void)
{
     8d8:	b580      	push	{r7, lr}
     8da:	b082      	sub	sp, #8
     8dc:	af00      	add	r7, sp, #0
#define VECTORNUM       (*(volatile char *) (0xE000ED04))
  //while (1);
  char vtr = VECTORNUM;
     8de:	f64e 5304 	movw	r3, #60676	; 0xed04
     8e2:	f2ce 0300 	movt	r3, #57344	; 0xe000
     8e6:	781b      	ldrb	r3, [r3, #0]
     8e8:	71fb      	strb	r3, [r7, #7]
  printf ("\n ******************\n");
     8ea:	f648 30d0 	movw	r0, #35792	; 0x8bd0
     8ee:	f2c0 0000 	movt	r0, #0
     8f2:	f007 fe77 	bl	85e4 <printf>
  printf ("Default Handler Error\n");
     8f6:	f648 30e8 	movw	r0, #35816	; 0x8be8
     8fa:	f2c0 0000 	movt	r0, #0
     8fe:	f007 fe71 	bl	85e4 <printf>
  printf ("On vector %d **** Interrupt\n", vtr);
     902:	79fb      	ldrb	r3, [r7, #7]
     904:	f648 4000 	movw	r0, #35840	; 0x8c00
     908:	f2c0 0000 	movt	r0, #0
     90c:	4619      	mov	r1, r3
     90e:	f007 fe69 	bl	85e4 <printf>
  while (1);
     912:	e7fe      	b.n	912 <CAN0_Bus_Off_IRQHandler+0x3a>

00000914 <Reset_Handler>:
 * \param  void
 *
 * \return void
 */
void Reset_Handler(void)
{
     914:	b580      	push	{r7, lr}
     916:	b082      	sub	sp, #8
     918:	af00      	add	r7, sp, #0
  unsigned char *source;
  unsigned char *destination;

  /* watchdog disable */
  *((volatile unsigned short *)0x4005200E) = 0xC520;
     91a:	f242 030e 	movw	r3, #8206	; 0x200e
     91e:	f2c4 0305 	movt	r3, #16389	; 0x4005
     922:	f24c 5220 	movw	r2, #50464	; 0xc520
     926:	801a      	strh	r2, [r3, #0]
  *((volatile unsigned short *)0x4005200E) = 0xD928;
     928:	f242 030e 	movw	r3, #8206	; 0x200e
     92c:	f2c4 0305 	movt	r3, #16389	; 0x4005
     930:	f64d 1228 	movw	r2, #55592	; 0xd928
     934:	801a      	strh	r2, [r3, #0]
  *((volatile unsigned short *)0x40052000) = 0x01D2;
     936:	f44f 5300 	mov.w	r3, #8192	; 0x2000
     93a:	f2c4 0305 	movt	r3, #16389	; 0x4005
     93e:	f44f 72e9 	mov.w	r2, #466	; 0x1d2
     942:	801a      	strh	r2, [r3, #0]

  /* copy data values from ROM to RAM */
  source = (unsigned char *)&_etext;
     944:	f648 43a8 	movw	r3, #36008	; 0x8ca8
     948:	f2c0 0300 	movt	r3, #0
     94c:	607b      	str	r3, [r7, #4]
  destination = (unsigned char *)&_sdata;
     94e:	f240 0300 	movw	r3, #0
     952:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
     956:	603b      	str	r3, [r7, #0]
  while (destination < (unsigned char*)&_edata) {
     958:	e00b      	b.n	972 <Reset_Handler+0x5e>
    *(destination++) = *(source++);
     95a:	687b      	ldr	r3, [r7, #4]
     95c:	781a      	ldrb	r2, [r3, #0]
     95e:	683b      	ldr	r3, [r7, #0]
     960:	701a      	strb	r2, [r3, #0]
     962:	683b      	ldr	r3, [r7, #0]
     964:	f103 0301 	add.w	r3, r3, #1
     968:	603b      	str	r3, [r7, #0]
     96a:	687b      	ldr	r3, [r7, #4]
     96c:	f103 0301 	add.w	r3, r3, #1
     970:	607b      	str	r3, [r7, #4]
  *((volatile unsigned short *)0x40052000) = 0x01D2;

  /* copy data values from ROM to RAM */
  source = (unsigned char *)&_etext;
  destination = (unsigned char *)&_sdata;
  while (destination < (unsigned char*)&_edata) {
     972:	683a      	ldr	r2, [r7, #0]
     974:	f240 0378 	movw	r3, #120	; 0x78
     978:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
     97c:	429a      	cmp	r2, r3
     97e:	d3ec      	bcc.n	95a <Reset_Handler+0x46>
    *(destination++) = *(source++);
  }

  /* clear bss section */
  source = (unsigned char *)&_sbss;
     980:	f240 0378 	movw	r3, #120	; 0x78
     984:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
     988:	607b      	str	r3, [r7, #4]
  destination = (unsigned char *)&_ebss;
     98a:	f241 63f8 	movw	r3, #5880	; 0x16f8
     98e:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
     992:	603b      	str	r3, [r7, #0]
  while (source < destination ) {
     994:	e007      	b.n	9a6 <Reset_Handler+0x92>
    *source++ = 0;
     996:	687b      	ldr	r3, [r7, #4]
     998:	f04f 0200 	mov.w	r2, #0
     99c:	701a      	strb	r2, [r3, #0]
     99e:	687b      	ldr	r3, [r7, #4]
     9a0:	f103 0301 	add.w	r3, r3, #1
     9a4:	607b      	str	r3, [r7, #4]
  }

  /* clear bss section */
  source = (unsigned char *)&_sbss;
  destination = (unsigned char *)&_ebss;
  while (source < destination ) {
     9a6:	687a      	ldr	r2, [r7, #4]
     9a8:	683b      	ldr	r3, [r7, #0]
     9aa:	429a      	cmp	r2, r3
     9ac:	d3f3      	bcc.n	996 <Reset_Handler+0x82>
    *source++ = 0;
  }
 //进入系统初始化函数
  SystemInit();
     9ae:	f000 f803 	bl	9b8 <SystemInit>
 //进入用户函数
  main();
     9b2:	f7ff ff25 	bl	800 <main>

  while(1);
     9b6:	e7fe      	b.n	9b6 <Reset_Handler+0xa2>

000009b8 <SystemInit>:
 * \param  void
 *
 * \return void
 */
void SystemInit(void)
{
     9b8:	b580      	push	{r7, lr}
     9ba:	af00      	add	r7, sp, #0
  //使能所有IO口时钟
  SIM_SCGC5 |= (SIM_SCGC5_PORTA_MASK | SIM_SCGC5_PORTB_MASK
     9bc:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
     9c0:	f2c4 0304 	movt	r3, #16388	; 0x4004
     9c4:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
     9c8:	f2c4 0204 	movt	r2, #16388	; 0x4004
     9cc:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
     9d0:	f102 0218 	add.w	r2, r2, #24
     9d4:	6812      	ldr	r2, [r2, #0]
     9d6:	f442 5278 	orr.w	r2, r2, #15872	; 0x3e00
     9da:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
     9de:	f103 0318 	add.w	r3, r3, #24
     9e2:	601a      	str	r2, [r3, #0]
              | SIM_SCGC5_PORTC_MASK | SIM_SCGC5_PORTD_MASK
              | SIM_SCGC5_PORTE_MASK);
  //初始化各部分时钟：系统内核主频、总线时钟、FlexBus时钟、Flash时钟
  LPLD_PLL_Setup(CORE_CLK_MHZ);
     9e4:	f04f 0096 	mov.w	r0, #150	; 0x96
     9e8:	f004 fd82 	bl	54f0 <LPLD_PLL_Setup>
  
  //更新内核主频
  SystemCoreClockUpdate();
     9ec:	f000 f85e 	bl	aac <SystemCoreClockUpdate>
  
  //获取各部分时钟
  g_core_clock = SystemCoreClock;
     9f0:	f240 0300 	movw	r3, #0
     9f4:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
     9f8:	681a      	ldr	r2, [r3, #0]
     9fa:	f240 0368 	movw	r3, #104	; 0x68
     9fe:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
     a02:	601a      	str	r2, [r3, #0]
  g_bus_clock = g_core_clock / ((uint32_t)((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV2_MASK) >> SIM_CLKDIV1_OUTDIV2_SHIFT)+ 1u);
     a04:	f240 0368 	movw	r3, #104	; 0x68
     a08:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
     a0c:	681a      	ldr	r2, [r3, #0]
     a0e:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
     a12:	f2c4 0304 	movt	r3, #16388	; 0x4004
     a16:	f503 5382 	add.w	r3, r3, #4160	; 0x1040
     a1a:	f103 0304 	add.w	r3, r3, #4
     a1e:	681b      	ldr	r3, [r3, #0]
     a20:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
     a24:	ea4f 6313 	mov.w	r3, r3, lsr #24
     a28:	f103 0301 	add.w	r3, r3, #1
     a2c:	fbb2 f2f3 	udiv	r2, r2, r3
     a30:	f240 036c 	movw	r3, #108	; 0x6c
     a34:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
     a38:	601a      	str	r2, [r3, #0]
  g_flexbus_clock =  g_core_clock / ((uint32_t)((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV3_MASK) >> SIM_CLKDIV1_OUTDIV3_SHIFT)+ 1u);
     a3a:	f240 0368 	movw	r3, #104	; 0x68
     a3e:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
     a42:	681a      	ldr	r2, [r3, #0]
     a44:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
     a48:	f2c4 0304 	movt	r3, #16388	; 0x4004
     a4c:	f503 5382 	add.w	r3, r3, #4160	; 0x1040
     a50:	f103 0304 	add.w	r3, r3, #4
     a54:	681b      	ldr	r3, [r3, #0]
     a56:	f403 0370 	and.w	r3, r3, #15728640	; 0xf00000
     a5a:	ea4f 5313 	mov.w	r3, r3, lsr #20
     a5e:	f103 0301 	add.w	r3, r3, #1
     a62:	fbb2 f2f3 	udiv	r2, r2, r3
     a66:	f240 0374 	movw	r3, #116	; 0x74
     a6a:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
     a6e:	601a      	str	r2, [r3, #0]
  g_flash_clock =  g_core_clock / ((uint32_t)((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV4_MASK) >> SIM_CLKDIV1_OUTDIV4_SHIFT)+ 1u);
     a70:	f240 0368 	movw	r3, #104	; 0x68
     a74:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
     a78:	681a      	ldr	r2, [r3, #0]
     a7a:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
     a7e:	f2c4 0304 	movt	r3, #16388	; 0x4004
     a82:	f503 5382 	add.w	r3, r3, #4160	; 0x1040
     a86:	f103 0304 	add.w	r3, r3, #4
     a8a:	681b      	ldr	r3, [r3, #0]
     a8c:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
     a90:	ea4f 4313 	mov.w	r3, r3, lsr #16
     a94:	f103 0301 	add.w	r3, r3, #1
     a98:	fbb2 f2f3 	udiv	r2, r2, r3
     a9c:	f240 0370 	movw	r3, #112	; 0x70
     aa0:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
     aa4:	601a      	str	r2, [r3, #0]
 
    //初始化系统终端
  systemTerm ();
     aa6:	f000 f971 	bl	d8c <systemTerm>
}
     aaa:	bd80      	pop	{r7, pc}

00000aac <SystemCoreClockUpdate>:
 *
 * @brief  更新全局变量SystemCoreClock的值，以便获取最新的系统内核频率。
 *         
 */
void SystemCoreClockUpdate (void) 
{
     aac:	b480      	push	{r7}
     aae:	b083      	sub	sp, #12
     ab0:	af00      	add	r7, sp, #0
    uint32_t temp;
    temp =  CPU_XTAL_CLK_HZ *((uint32_t)(MCG_C6 & MCG_C6_VDIV_MASK) + 16u );
     ab2:	f44f 4380 	mov.w	r3, #16384	; 0x4000
     ab6:	f2c4 0306 	movt	r3, #16390	; 0x4006
     aba:	795b      	ldrb	r3, [r3, #5]
     abc:	b2db      	uxtb	r3, r3
     abe:	f003 021f 	and.w	r2, r3, #31
     ac2:	f24f 0380 	movw	r3, #61568	; 0xf080
     ac6:	f2c0 23fa 	movt	r3, #762	; 0x2fa
     aca:	fb03 f202 	mul.w	r2, r3, r2
     ace:	f44f 6300 	mov.w	r3, #2048	; 0x800
     ad2:	f6c2 73af 	movt	r3, #12207	; 0x2faf
     ad6:	18d3      	adds	r3, r2, r3
     ad8:	607b      	str	r3, [r7, #4]
    temp = (uint32_t)(temp/((uint32_t)(MCG_C5 & MCG_C5_PRDIV_MASK) +1u ))/2;
     ada:	f44f 4380 	mov.w	r3, #16384	; 0x4000
     ade:	f2c4 0306 	movt	r3, #16390	; 0x4006
     ae2:	791b      	ldrb	r3, [r3, #4]
     ae4:	b2db      	uxtb	r3, r3
     ae6:	f003 0307 	and.w	r3, r3, #7
     aea:	f103 0301 	add.w	r3, r3, #1
     aee:	687a      	ldr	r2, [r7, #4]
     af0:	fbb2 f3f3 	udiv	r3, r2, r3
     af4:	ea4f 0353 	mov.w	r3, r3, lsr #1
     af8:	607b      	str	r3, [r7, #4]
    SystemCoreClock = temp;
     afa:	f240 0300 	movw	r3, #0
     afe:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
     b02:	687a      	ldr	r2, [r7, #4]
     b04:	601a      	str	r2, [r3, #0]
}
     b06:	f107 070c 	add.w	r7, r7, #12
     b0a:	46bd      	mov	sp, r7
     b0c:	bc80      	pop	{r7}
     b0e:	4770      	bx	lr

00000b10 <enable_irq>:
/*
 * 使能中断
 */

void enable_irq (int irq)
{
     b10:	b480      	push	{r7}
     b12:	b085      	sub	sp, #20
     b14:	af00      	add	r7, sp, #0
     b16:	6078      	str	r0, [r7, #4]
    int div;
    if (irq > 105)
     b18:	687b      	ldr	r3, [r7, #4]
     b1a:	2b69      	cmp	r3, #105	; 0x69
     b1c:	dd02      	ble.n	b24 <enable_irq+0x14>
        irq = 105;
     b1e:	f04f 0369 	mov.w	r3, #105	; 0x69
     b22:	607b      	str	r3, [r7, #4]
    div = irq / 32;
     b24:	687b      	ldr	r3, [r7, #4]
     b26:	2b00      	cmp	r3, #0
     b28:	da01      	bge.n	b2e <enable_irq+0x1e>
     b2a:	f103 031f 	add.w	r3, r3, #31
     b2e:	ea4f 1363 	mov.w	r3, r3, asr #5
     b32:	60fb      	str	r3, [r7, #12]
    switch (div)
     b34:	68fb      	ldr	r3, [r7, #12]
     b36:	2b03      	cmp	r3, #3
     b38:	f200 80a8 	bhi.w	c8c <enable_irq+0x17c>
     b3c:	a201      	add	r2, pc, #4	; (adr r2, b44 <enable_irq+0x34>)
     b3e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     b42:	bf00      	nop
     b44:	00000b55 	andeq	r0, r0, r5, asr fp
     b48:	00000ba3 	andeq	r0, r0, r3, lsr #23
     b4c:	00000bf1 	strdeq	r0, [r0], -r1
     b50:	00000c3f 	andeq	r0, r0, pc, lsr ip
    {
        case 0x0:
            NVICICPR0 |= 1 << (irq & 0x1F);
     b54:	f44f 4361 	mov.w	r3, #57600	; 0xe100
     b58:	f2ce 0300 	movt	r3, #57344	; 0xe000
     b5c:	f44f 4261 	mov.w	r2, #57600	; 0xe100
     b60:	f2ce 0200 	movt	r2, #57344	; 0xe000
     b64:	f8d2 1180 	ldr.w	r1, [r2, #384]	; 0x180
     b68:	687a      	ldr	r2, [r7, #4]
     b6a:	f002 021f 	and.w	r2, r2, #31
     b6e:	f04f 0001 	mov.w	r0, #1
     b72:	fa00 f202 	lsl.w	r2, r0, r2
     b76:	430a      	orrs	r2, r1
     b78:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
            NVICISER0 |= 1 << (irq & 0x1F);
     b7c:	f44f 4361 	mov.w	r3, #57600	; 0xe100
     b80:	f2ce 0300 	movt	r3, #57344	; 0xe000
     b84:	f44f 4261 	mov.w	r2, #57600	; 0xe100
     b88:	f2ce 0200 	movt	r2, #57344	; 0xe000
     b8c:	6811      	ldr	r1, [r2, #0]
     b8e:	687a      	ldr	r2, [r7, #4]
     b90:	f002 021f 	and.w	r2, r2, #31
     b94:	f04f 0001 	mov.w	r0, #1
     b98:	fa00 f202 	lsl.w	r2, r0, r2
     b9c:	430a      	orrs	r2, r1
     b9e:	601a      	str	r2, [r3, #0]
            break;
     ba0:	e074      	b.n	c8c <enable_irq+0x17c>
        case 0x1:
            NVICICPR1 |= 1 << (irq & 0x1F);
     ba2:	f44f 4361 	mov.w	r3, #57600	; 0xe100
     ba6:	f2ce 0300 	movt	r3, #57344	; 0xe000
     baa:	f44f 4261 	mov.w	r2, #57600	; 0xe100
     bae:	f2ce 0200 	movt	r2, #57344	; 0xe000
     bb2:	f8d2 1184 	ldr.w	r1, [r2, #388]	; 0x184
     bb6:	687a      	ldr	r2, [r7, #4]
     bb8:	f002 021f 	and.w	r2, r2, #31
     bbc:	f04f 0001 	mov.w	r0, #1
     bc0:	fa00 f202 	lsl.w	r2, r0, r2
     bc4:	430a      	orrs	r2, r1
     bc6:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
            NVICISER1 |= 1 << (irq & 0x1F);
     bca:	f44f 4361 	mov.w	r3, #57600	; 0xe100
     bce:	f2ce 0300 	movt	r3, #57344	; 0xe000
     bd2:	f44f 4261 	mov.w	r2, #57600	; 0xe100
     bd6:	f2ce 0200 	movt	r2, #57344	; 0xe000
     bda:	6851      	ldr	r1, [r2, #4]
     bdc:	687a      	ldr	r2, [r7, #4]
     bde:	f002 021f 	and.w	r2, r2, #31
     be2:	f04f 0001 	mov.w	r0, #1
     be6:	fa00 f202 	lsl.w	r2, r0, r2
     bea:	430a      	orrs	r2, r1
     bec:	605a      	str	r2, [r3, #4]
            break;
     bee:	e04d      	b.n	c8c <enable_irq+0x17c>
        case 0x2:
            NVICICPR2 |= 1 << (irq & 0x1F);
     bf0:	f44f 4361 	mov.w	r3, #57600	; 0xe100
     bf4:	f2ce 0300 	movt	r3, #57344	; 0xe000
     bf8:	f44f 4261 	mov.w	r2, #57600	; 0xe100
     bfc:	f2ce 0200 	movt	r2, #57344	; 0xe000
     c00:	f8d2 1188 	ldr.w	r1, [r2, #392]	; 0x188
     c04:	687a      	ldr	r2, [r7, #4]
     c06:	f002 021f 	and.w	r2, r2, #31
     c0a:	f04f 0001 	mov.w	r0, #1
     c0e:	fa00 f202 	lsl.w	r2, r0, r2
     c12:	430a      	orrs	r2, r1
     c14:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
            NVICISER2 |= 1 << (irq & 0x1F);
     c18:	f44f 4361 	mov.w	r3, #57600	; 0xe100
     c1c:	f2ce 0300 	movt	r3, #57344	; 0xe000
     c20:	f44f 4261 	mov.w	r2, #57600	; 0xe100
     c24:	f2ce 0200 	movt	r2, #57344	; 0xe000
     c28:	6891      	ldr	r1, [r2, #8]
     c2a:	687a      	ldr	r2, [r7, #4]
     c2c:	f002 021f 	and.w	r2, r2, #31
     c30:	f04f 0001 	mov.w	r0, #1
     c34:	fa00 f202 	lsl.w	r2, r0, r2
     c38:	430a      	orrs	r2, r1
     c3a:	609a      	str	r2, [r3, #8]
            break;
     c3c:	e026      	b.n	c8c <enable_irq+0x17c>
        case 0x3:
            NVICICPR3 |= 1 << (irq & 0x1F);
     c3e:	f44f 4361 	mov.w	r3, #57600	; 0xe100
     c42:	f2ce 0300 	movt	r3, #57344	; 0xe000
     c46:	f44f 4261 	mov.w	r2, #57600	; 0xe100
     c4a:	f2ce 0200 	movt	r2, #57344	; 0xe000
     c4e:	f8d2 118c 	ldr.w	r1, [r2, #396]	; 0x18c
     c52:	687a      	ldr	r2, [r7, #4]
     c54:	f002 021f 	and.w	r2, r2, #31
     c58:	f04f 0001 	mov.w	r0, #1
     c5c:	fa00 f202 	lsl.w	r2, r0, r2
     c60:	430a      	orrs	r2, r1
     c62:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c
            NVICISER3 |= 1 << (irq & 0x1F);
     c66:	f44f 4361 	mov.w	r3, #57600	; 0xe100
     c6a:	f2ce 0300 	movt	r3, #57344	; 0xe000
     c6e:	f44f 4261 	mov.w	r2, #57600	; 0xe100
     c72:	f2ce 0200 	movt	r2, #57344	; 0xe000
     c76:	68d1      	ldr	r1, [r2, #12]
     c78:	687a      	ldr	r2, [r7, #4]
     c7a:	f002 021f 	and.w	r2, r2, #31
     c7e:	f04f 0001 	mov.w	r0, #1
     c82:	fa00 f202 	lsl.w	r2, r0, r2
     c86:	430a      	orrs	r2, r1
     c88:	60da      	str	r2, [r3, #12]
            break;
     c8a:	bf00      	nop
    }
}
     c8c:	f107 0714 	add.w	r7, r7, #20
     c90:	46bd      	mov	sp, r7
     c92:	bc80      	pop	{r7}
     c94:	4770      	bx	lr
     c96:	bf00      	nop

00000c98 <disable_irq>:
/*
 * 关闭中断
 */

void disable_irq (int irq)
{
     c98:	b480      	push	{r7}
     c9a:	b085      	sub	sp, #20
     c9c:	af00      	add	r7, sp, #0
     c9e:	6078      	str	r0, [r7, #4]
    int div;
    if (irq > 105)
     ca0:	687b      	ldr	r3, [r7, #4]
     ca2:	2b69      	cmp	r3, #105	; 0x69
     ca4:	dd02      	ble.n	cac <disable_irq+0x14>
        irq = 105;
     ca6:	f04f 0369 	mov.w	r3, #105	; 0x69
     caa:	607b      	str	r3, [r7, #4]
    div = irq / 32;
     cac:	687b      	ldr	r3, [r7, #4]
     cae:	2b00      	cmp	r3, #0
     cb0:	da01      	bge.n	cb6 <disable_irq+0x1e>
     cb2:	f103 031f 	add.w	r3, r3, #31
     cb6:	ea4f 1363 	mov.w	r3, r3, asr #5
     cba:	60fb      	str	r3, [r7, #12]
    switch (div)
     cbc:	68fb      	ldr	r3, [r7, #12]
     cbe:	2b03      	cmp	r3, #3
     cc0:	d85e      	bhi.n	d80 <disable_irq+0xe8>
     cc2:	a201      	add	r2, pc, #4	; (adr r2, cc8 <disable_irq+0x30>)
     cc4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     cc8:	00000cd9 	ldrdeq	r0, [r0], -r9
     ccc:	00000d03 	andeq	r0, r0, r3, lsl #26
     cd0:	00000d2d 	andeq	r0, r0, sp, lsr #26
     cd4:	00000d57 	andeq	r0, r0, r7, asr sp
    {
        case 0x0:
            NVICICPR0 |= 1 << (irq & 0x1F);
     cd8:	f44f 4361 	mov.w	r3, #57600	; 0xe100
     cdc:	f2ce 0300 	movt	r3, #57344	; 0xe000
     ce0:	f44f 4261 	mov.w	r2, #57600	; 0xe100
     ce4:	f2ce 0200 	movt	r2, #57344	; 0xe000
     ce8:	f8d2 1180 	ldr.w	r1, [r2, #384]	; 0x180
     cec:	687a      	ldr	r2, [r7, #4]
     cee:	f002 021f 	and.w	r2, r2, #31
     cf2:	f04f 0001 	mov.w	r0, #1
     cf6:	fa00 f202 	lsl.w	r2, r0, r2
     cfa:	430a      	orrs	r2, r1
     cfc:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
            break;
     d00:	e03e      	b.n	d80 <disable_irq+0xe8>
        case 0x1:
            NVICICPR1 |= 1 << (irq & 0x1F);
     d02:	f44f 4361 	mov.w	r3, #57600	; 0xe100
     d06:	f2ce 0300 	movt	r3, #57344	; 0xe000
     d0a:	f44f 4261 	mov.w	r2, #57600	; 0xe100
     d0e:	f2ce 0200 	movt	r2, #57344	; 0xe000
     d12:	f8d2 1184 	ldr.w	r1, [r2, #388]	; 0x184
     d16:	687a      	ldr	r2, [r7, #4]
     d18:	f002 021f 	and.w	r2, r2, #31
     d1c:	f04f 0001 	mov.w	r0, #1
     d20:	fa00 f202 	lsl.w	r2, r0, r2
     d24:	430a      	orrs	r2, r1
     d26:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
            break;
     d2a:	e029      	b.n	d80 <disable_irq+0xe8>
        case 0x2:
            NVICICPR2 |= 1 << (irq & 0x1F);
     d2c:	f44f 4361 	mov.w	r3, #57600	; 0xe100
     d30:	f2ce 0300 	movt	r3, #57344	; 0xe000
     d34:	f44f 4261 	mov.w	r2, #57600	; 0xe100
     d38:	f2ce 0200 	movt	r2, #57344	; 0xe000
     d3c:	f8d2 1188 	ldr.w	r1, [r2, #392]	; 0x188
     d40:	687a      	ldr	r2, [r7, #4]
     d42:	f002 021f 	and.w	r2, r2, #31
     d46:	f04f 0001 	mov.w	r0, #1
     d4a:	fa00 f202 	lsl.w	r2, r0, r2
     d4e:	430a      	orrs	r2, r1
     d50:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
            break;
     d54:	e014      	b.n	d80 <disable_irq+0xe8>
        case 0x3:
            NVICICPR3 |= 1 << (irq & 0x1F);
     d56:	f44f 4361 	mov.w	r3, #57600	; 0xe100
     d5a:	f2ce 0300 	movt	r3, #57344	; 0xe000
     d5e:	f44f 4261 	mov.w	r2, #57600	; 0xe100
     d62:	f2ce 0200 	movt	r2, #57344	; 0xe000
     d66:	f8d2 118c 	ldr.w	r1, [r2, #396]	; 0x18c
     d6a:	687a      	ldr	r2, [r7, #4]
     d6c:	f002 021f 	and.w	r2, r2, #31
     d70:	f04f 0001 	mov.w	r0, #1
     d74:	fa00 f202 	lsl.w	r2, r0, r2
     d78:	430a      	orrs	r2, r1
     d7a:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c
            break;
     d7e:	bf00      	nop
    }
}
     d80:	f107 0714 	add.w	r7, r7, #20
     d84:	46bd      	mov	sp, r7
     d86:	bc80      	pop	{r7}
     d88:	4770      	bx	lr
     d8a:	bf00      	nop

00000d8c <systemTerm>:
/*
 * 系统终端初始化函数
 */

 void systemTerm (void)
 {
     d8c:	b580      	push	{r7, lr}
     d8e:	b088      	sub	sp, #32
     d90:	af02      	add	r7, sp, #8
     UART_InitTypeDef uart_init_struct;
     uart_init_struct.UART_Uartx = TERM_PORT;
     d92:	f44f 4320 	mov.w	r3, #40960	; 0xa000
     d96:	f2c4 030e 	movt	r3, #16398	; 0x400e
     d9a:	607b      	str	r3, [r7, #4]
     uart_init_struct.UART_BaudRate = TERM_BAUD;
     d9c:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
     da0:	60bb      	str	r3, [r7, #8]
     uart_init_struct.UART_RxPin = TERM_RX;
     da2:	f04f 034a 	mov.w	r3, #74	; 0x4a
     da6:	737b      	strb	r3, [r7, #13]
     uart_init_struct.UART_TxPin = TERM_TX;
     da8:	f04f 034b 	mov.w	r3, #75	; 0x4b
     dac:	733b      	strb	r3, [r7, #12]
     uart_init_struct.UART_RxIntEnable = TERM_RX_IRQ;
     dae:	f04f 0300 	mov.w	r3, #0
     db2:	73bb      	strb	r3, [r7, #14]
     uart_init_struct.UART_RxIsr = TERM_RX_FUN;
     db4:	f04f 0300 	mov.w	r3, #0
     db8:	613b      	str	r3, [r7, #16]

     LPLD_UART_Init (uart_init_struct);
     dba:	697b      	ldr	r3, [r7, #20]
     dbc:	9300      	str	r3, [sp, #0]
     dbe:	f107 0304 	add.w	r3, r7, #4
     dc2:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
     dc4:	f006 faba 	bl	733c <LPLD_UART_Init>
#if (TERM_RX_IRQ == TRUE)
     LPLD_UART_EnableIrq (uart_init_struct);
#endif

 }
     dc8:	f107 0718 	add.w	r7, r7, #24
     dcc:	46bd      	mov	sp, r7
     dce:	bd80      	pop	{r7, pc}

00000dd0 <Ov7725_Init>:
//图像状态
volatile IMG_STATUS_e ov7725_eagle_img_flag = IMG_FINISH;

//ov7725初始化 
uint8 Ov7725_Init (void)
{
     dd0:	b580      	push	{r7, lr}
     dd2:	b08e      	sub	sp, #56	; 0x38
     dd4:	af00      	add	r7, sp, #0
    uint16 i = 0;
     dd6:	f04f 0300 	mov.w	r3, #0
     dda:	86fb      	strh	r3, [r7, #54]	; 0x36
    uint8 device_Id = 0;
     ddc:	f04f 0300 	mov.w	r3, #0
     de0:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
    uint8 reg_Buff[50] = {0};
     de4:	463b      	mov	r3, r7
     de6:	f04f 0200 	mov.w	r2, #0
     dea:	601a      	str	r2, [r3, #0]
     dec:	f103 0304 	add.w	r3, r3, #4
     df0:	f04f 0200 	mov.w	r2, #0
     df4:	601a      	str	r2, [r3, #0]
     df6:	f103 0304 	add.w	r3, r3, #4
     dfa:	f04f 0200 	mov.w	r2, #0
     dfe:	601a      	str	r2, [r3, #0]
     e00:	f103 0304 	add.w	r3, r3, #4
     e04:	f04f 0200 	mov.w	r2, #0
     e08:	601a      	str	r2, [r3, #0]
     e0a:	f103 0304 	add.w	r3, r3, #4
     e0e:	f04f 0200 	mov.w	r2, #0
     e12:	601a      	str	r2, [r3, #0]
     e14:	f103 0304 	add.w	r3, r3, #4
     e18:	f04f 0200 	mov.w	r2, #0
     e1c:	601a      	str	r2, [r3, #0]
     e1e:	f103 0304 	add.w	r3, r3, #4
     e22:	f04f 0200 	mov.w	r2, #0
     e26:	601a      	str	r2, [r3, #0]
     e28:	f103 0304 	add.w	r3, r3, #4
     e2c:	f04f 0200 	mov.w	r2, #0
     e30:	601a      	str	r2, [r3, #0]
     e32:	f103 0304 	add.w	r3, r3, #4
     e36:	f04f 0200 	mov.w	r2, #0
     e3a:	601a      	str	r2, [r3, #0]
     e3c:	f103 0304 	add.w	r3, r3, #4
     e40:	f04f 0200 	mov.w	r2, #0
     e44:	601a      	str	r2, [r3, #0]
     e46:	f103 0304 	add.w	r3, r3, #4
     e4a:	f04f 0200 	mov.w	r2, #0
     e4e:	601a      	str	r2, [r3, #0]
     e50:	f103 0304 	add.w	r3, r3, #4
     e54:	f04f 0200 	mov.w	r2, #0
     e58:	601a      	str	r2, [r3, #0]
     e5a:	f103 0304 	add.w	r3, r3, #4
     e5e:	f04f 0200 	mov.w	r2, #0
     e62:	801a      	strh	r2, [r3, #0]
     e64:	f103 0302 	add.w	r3, r3, #2

    LPLD_SCCB_Init ();
     e68:	f000 fdee 	bl	1a48 <LPLD_SCCB_Init>
    
    Ov7725_Delay();
     e6c:	f000 f8b0 	bl	fd0 <Ov7725_Delay>

    while (!LPLD_SCCB_WriteReg (OV7725_COM7, 0x80))
     e70:	e010      	b.n	e94 <Ov7725_Init+0xc4>
    {
        if (i ++ >= 500)
     e72:	8efa      	ldrh	r2, [r7, #54]	; 0x36
     e74:	f240 13f3 	movw	r3, #499	; 0x1f3
     e78:	429a      	cmp	r2, r3
     e7a:	bf94      	ite	ls
     e7c:	2300      	movls	r3, #0
     e7e:	2301      	movhi	r3, #1
     e80:	b2db      	uxtb	r3, r3
     e82:	8efa      	ldrh	r2, [r7, #54]	; 0x36
     e84:	f102 0201 	add.w	r2, r2, #1
     e88:	86fa      	strh	r2, [r7, #54]	; 0x36
     e8a:	2b00      	cmp	r3, #0
     e8c:	d002      	beq.n	e94 <Ov7725_Init+0xc4>
            return 0;
     e8e:	f04f 0300 	mov.w	r3, #0
     e92:	e098      	b.n	fc6 <Ov7725_Init+0x1f6>

    LPLD_SCCB_Init ();
    
    Ov7725_Delay();

    while (!LPLD_SCCB_WriteReg (OV7725_COM7, 0x80))
     e94:	f04f 0012 	mov.w	r0, #18
     e98:	f04f 0180 	mov.w	r1, #128	; 0x80
     e9c:	f000 fdf4 	bl	1a88 <LPLD_SCCB_WriteReg>
     ea0:	4603      	mov	r3, r0
     ea2:	2b00      	cmp	r3, #0
     ea4:	d0e5      	beq.n	e72 <Ov7725_Init+0xa2>
    {
        if (i ++ >= 500)
            return 0;
    }

    Ov7725_Delay();
     ea6:	f000 f893 	bl	fd0 <Ov7725_Delay>
    
    while (0 == LPLD_SCCB_ReadReg (OV7725_VER, &device_Id, 1));
     eaa:	bf00      	nop
     eac:	f107 0335 	add.w	r3, r7, #53	; 0x35
     eb0:	f04f 000b 	mov.w	r0, #11
     eb4:	4619      	mov	r1, r3
     eb6:	f04f 0201 	mov.w	r2, #1
     eba:	f000 fe19 	bl	1af0 <LPLD_SCCB_ReadReg>
     ebe:	4603      	mov	r3, r0
     ec0:	2b00      	cmp	r3, #0
     ec2:	d0f3      	beq.n	eac <Ov7725_Init+0xdc>

    printf ("You get ID success, SENSOR ID is 0x%x", device_Id);
     ec4:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
     ec8:	f648 4020 	movw	r0, #35872	; 0x8c20
     ecc:	f2c0 0000 	movt	r0, #0
     ed0:	4619      	mov	r1, r3
     ed2:	f007 fb87 	bl	85e4 <printf>
    printf ("nconfig register Number is %d\n", ov7725_eagle_cfgnum);
     ed6:	f240 0366 	movw	r3, #102	; 0x66
     eda:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
     ede:	781b      	ldrb	r3, [r3, #0]
     ee0:	f648 4048 	movw	r0, #35912	; 0x8c48
     ee4:	f2c0 0000 	movt	r0, #0
     ee8:	4619      	mov	r1, r3
     eea:	f007 fb7b 	bl	85e4 <printf>

    //判断摄像头是否为ov7725
    if (device_Id == OV7725_ID)
     eee:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
     ef2:	2b21      	cmp	r3, #33	; 0x21
     ef4:	d162      	bne.n	fbc <Ov7725_Init+0x1ec>
    {
        for (i = 0; i < ov7725_eagle_cfgnum; i++)
     ef6:	f04f 0300 	mov.w	r3, #0
     efa:	86fb      	strh	r3, [r7, #54]	; 0x36
     efc:	e055      	b.n	faa <Ov7725_Init+0x1da>
        {
            if (0 == LPLD_SCCB_WriteReg(ov7725_eagle_reg[i].addr, ov7725_eagle_reg[i].val))
     efe:	8efa      	ldrh	r2, [r7, #54]	; 0x36
     f00:	f240 0304 	movw	r3, #4
     f04:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
     f08:	f813 3012 	ldrb.w	r3, [r3, r2, lsl #1]
     f0c:	4619      	mov	r1, r3
     f0e:	8efb      	ldrh	r3, [r7, #54]	; 0x36
     f10:	f240 0204 	movw	r2, #4
     f14:	f6c1 72ff 	movt	r2, #8191	; 0x1fff
     f18:	ea4f 0343 	mov.w	r3, r3, lsl #1
     f1c:	18d3      	adds	r3, r2, r3
     f1e:	785b      	ldrb	r3, [r3, #1]
     f20:	4608      	mov	r0, r1
     f22:	4619      	mov	r1, r3
     f24:	f000 fdb0 	bl	1a88 <LPLD_SCCB_WriteReg>
     f28:	4603      	mov	r3, r0
     f2a:	2b00      	cmp	r3, #0
     f2c:	d110      	bne.n	f50 <Ov7725_Init+0x180>
            {
               printf ("error: writeReg error 0x%x\n", ov7725_eagle_reg[i].addr);
     f2e:	8efa      	ldrh	r2, [r7, #54]	; 0x36
     f30:	f240 0304 	movw	r3, #4
     f34:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
     f38:	f813 3012 	ldrb.w	r3, [r3, r2, lsl #1]
     f3c:	f648 4068 	movw	r0, #35944	; 0x8c68
     f40:	f2c0 0000 	movt	r0, #0
     f44:	4619      	mov	r1, r3
     f46:	f007 fb4d 	bl	85e4 <printf>
                return 0;
     f4a:	f04f 0300 	mov.w	r3, #0
     f4e:	e03a      	b.n	fc6 <Ov7725_Init+0x1f6>
            }
            if (LPLD_SCCB_ReadReg(ov7725_eagle_reg[i].addr, &reg_Buff[i], 1))
     f50:	8efa      	ldrh	r2, [r7, #54]	; 0x36
     f52:	f240 0304 	movw	r3, #4
     f56:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
     f5a:	f813 2012 	ldrb.w	r2, [r3, r2, lsl #1]
     f5e:	8efb      	ldrh	r3, [r7, #54]	; 0x36
     f60:	4639      	mov	r1, r7
     f62:	18cb      	adds	r3, r1, r3
     f64:	4610      	mov	r0, r2
     f66:	4619      	mov	r1, r3
     f68:	f04f 0201 	mov.w	r2, #1
     f6c:	f000 fdc0 	bl	1af0 <LPLD_SCCB_ReadReg>
     f70:	4603      	mov	r3, r0
     f72:	2b00      	cmp	r3, #0
     f74:	d015      	beq.n	fa2 <Ov7725_Init+0x1d2>
            {
                printf ("writeRe 0x%x success: 0x%x\n", ov7725_eagle_reg[i].addr, reg_Buff[i]);
     f76:	8efa      	ldrh	r2, [r7, #54]	; 0x36
     f78:	f240 0304 	movw	r3, #4
     f7c:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
     f80:	f813 3012 	ldrb.w	r3, [r3, r2, lsl #1]
     f84:	461a      	mov	r2, r3
     f86:	8efb      	ldrh	r3, [r7, #54]	; 0x36
     f88:	f107 0138 	add.w	r1, r7, #56	; 0x38
     f8c:	18cb      	adds	r3, r1, r3
     f8e:	f813 3c38 	ldrb.w	r3, [r3, #-56]
     f92:	f648 4084 	movw	r0, #35972	; 0x8c84
     f96:	f2c0 0000 	movt	r0, #0
     f9a:	4611      	mov	r1, r2
     f9c:	461a      	mov	r2, r3
     f9e:	f007 fb21 	bl	85e4 <printf>
    printf ("nconfig register Number is %d\n", ov7725_eagle_cfgnum);

    //判断摄像头是否为ov7725
    if (device_Id == OV7725_ID)
    {
        for (i = 0; i < ov7725_eagle_cfgnum; i++)
     fa2:	8efb      	ldrh	r3, [r7, #54]	; 0x36
     fa4:	f103 0301 	add.w	r3, r3, #1
     fa8:	86fb      	strh	r3, [r7, #54]	; 0x36
     faa:	f240 0366 	movw	r3, #102	; 0x66
     fae:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
     fb2:	781b      	ldrb	r3, [r3, #0]
     fb4:	8efa      	ldrh	r2, [r7, #54]	; 0x36
     fb6:	429a      	cmp	r2, r3
     fb8:	d3a1      	bcc.n	efe <Ov7725_Init+0x12e>
     fba:	e002      	b.n	fc2 <Ov7725_Init+0x1f2>
            }
        }
    }
    else
    {
        return 0;
     fbc:	f04f 0300 	mov.w	r3, #0
     fc0:	e001      	b.n	fc6 <Ov7725_Init+0x1f6>
    }
    return 1;
     fc2:	f04f 0301 	mov.w	r3, #1

}
     fc6:	4618      	mov	r0, r3
     fc8:	f107 0738 	add.w	r7, r7, #56	; 0x38
     fcc:	46bd      	mov	sp, r7
     fce:	bd80      	pop	{r7, pc}

00000fd0 <Ov7725_Delay>:

//ov7725延时函数
void Ov7725_Delay(void)
{
     fd0:	b480      	push	{r7}
     fd2:	b083      	sub	sp, #12
     fd4:	af00      	add	r7, sp, #0
    uint16 i, n;
    for (i = 0; i < 3000; i++)
     fd6:	f04f 0300 	mov.w	r3, #0
     fda:	80fb      	strh	r3, [r7, #6]
     fdc:	e00f      	b.n	ffe <Ov7725_Delay+0x2e>
    {
        for (n = 0; n < 200; n++)
     fde:	f04f 0300 	mov.w	r3, #0
     fe2:	80bb      	strh	r3, [r7, #4]
     fe4:	e004      	b.n	ff0 <Ov7725_Delay+0x20>
        {
            asm("nop");
     fe6:	bf00      	nop
void Ov7725_Delay(void)
{
    uint16 i, n;
    for (i = 0; i < 3000; i++)
    {
        for (n = 0; n < 200; n++)
     fe8:	88bb      	ldrh	r3, [r7, #4]
     fea:	f103 0301 	add.w	r3, r3, #1
     fee:	80bb      	strh	r3, [r7, #4]
     ff0:	88bb      	ldrh	r3, [r7, #4]
     ff2:	2bc7      	cmp	r3, #199	; 0xc7
     ff4:	d9f7      	bls.n	fe6 <Ov7725_Delay+0x16>

//ov7725延时函数
void Ov7725_Delay(void)
{
    uint16 i, n;
    for (i = 0; i < 3000; i++)
     ff6:	88fb      	ldrh	r3, [r7, #6]
     ff8:	f103 0301 	add.w	r3, r3, #1
     ffc:	80fb      	strh	r3, [r7, #6]
     ffe:	88fa      	ldrh	r2, [r7, #6]
    1000:	f640 33b7 	movw	r3, #2999	; 0xbb7
    1004:	429a      	cmp	r2, r3
    1006:	d9ea      	bls.n	fde <Ov7725_Delay+0xe>
        for (n = 0; n < 200; n++)
        {
            asm("nop");
        }
    }
}
    1008:	f107 070c 	add.w	r7, r7, #12
    100c:	46bd      	mov	sp, r7
    100e:	bc80      	pop	{r7}
    1010:	4770      	bx	lr
    1012:	bf00      	nop

00001014 <Ov7725_eagle_dma>:

//DMA中断触发函数
void Ov7725_eagle_dma (void)
{
    1014:	b580      	push	{r7, lr}
    1016:	b082      	sub	sp, #8
    1018:	af02      	add	r7, sp, #8
    ov7725_eagle_img_flag = IMG_FINISH;
    101a:	f240 0367 	movw	r3, #103	; 0x67
    101e:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    1022:	f04f 0201 	mov.w	r2, #1
    1026:	701a      	strb	r2, [r3, #0]
    //关闭DMA通道
    DMA_DIS(DMA_CH0);
    1028:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    102c:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1030:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    1034:	f2c4 0200 	movt	r2, #16384	; 0x4000
    1038:	6a52      	ldr	r2, [r2, #36]	; 0x24
    103a:	f022 0201 	bic.w	r2, r2, #1
    103e:	625a      	str	r2, [r3, #36]	; 0x24
    //DMA0->INT |= 0x1u << 0;
    //enable_irq(INT_PORTA - 16);
    //图片进行解压
    Ov7725_img_extract(Pix_Data, img, PHOTO_SIZE/8);
    1040:	f240 20d4 	movw	r0, #724	; 0x2d4
    1044:	f6c1 70ff 	movt	r0, #8191	; 0x1fff
    1048:	f240 017c 	movw	r1, #124	; 0x7c
    104c:	f6c1 71ff 	movt	r1, #8191	; 0x1fff
    1050:	f44f 7216 	mov.w	r2, #600	; 0x258
    1054:	f000 f898 	bl	1188 <Ov7725_img_extract>
    //解压完成标志置位
    ready_send_flag = 1;
    1058:	f240 0378 	movw	r3, #120	; 0x78
    105c:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    1060:	f04f 0201 	mov.w	r2, #1
    1064:	701a      	strb	r2, [r3, #0]
    get_midline(Pix_Data, 60, 80);
    1066:	f240 20d4 	movw	r0, #724	; 0x2d4
    106a:	f6c1 70ff 	movt	r0, #8191	; 0x1fff
    106e:	f04f 013c 	mov.w	r1, #60	; 0x3c
    1072:	f04f 0250 	mov.w	r2, #80	; 0x50
    1076:	f000 fbf1 	bl	185c <get_midline>
         //重新装载DMA目标地址
        DMA_DADDR(DMA_CH0) = (uint32)img;
    107a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    107e:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1082:	f240 027c 	movw	r2, #124	; 0x7c
    1086:	f6c1 72ff 	movt	r2, #8191	; 0x1fff
    108a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    108e:	f103 0310 	add.w	r3, r3, #16
    1092:	601a      	str	r2, [r3, #0]
   //Ov7725_sendimg(Pix_Data, PHOTO_SIZE);
    //clear PORTA isr set bit
    PORTA_ISFR = ~0;
    1094:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    1098:	f2c4 0304 	movt	r3, #16388	; 0x4004
    109c:	f04f 32ff 	mov.w	r2, #4294967295
    10a0:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
    LPLD_GPIO_EnableIrq(OV_PTA_init);
    10a4:	f241 53a8 	movw	r3, #5544	; 0x15a8
    10a8:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    10ac:	691a      	ldr	r2, [r3, #16]
    10ae:	9200      	str	r2, [sp, #0]
    10b0:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
    10b2:	f003 fe99 	bl	4de8 <LPLD_GPIO_EnableIrq>
    //DMA0->INT |= 0x1u << 0;
}
    10b6:	46bd      	mov	sp, r7
    10b8:	bd80      	pop	{r7, pc}
    10ba:	bf00      	nop

000010bc <Ov7725_eagle_vsync>:

//场中断开始判断函数
void Ov7725_eagle_vsync(void)
{
    10bc:	b580      	push	{r7, lr}
    10be:	af00      	add	r7, sp, #0
    //printf ("runing eagle_vsync\n");
    //判断场中断是否开始
    if (ov7725_eagle_img_flag == IMG_START)
    10c0:	f240 0367 	movw	r3, #103	; 0x67
    10c4:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    10c8:	781b      	ldrb	r3, [r3, #0]
    10ca:	b2db      	uxtb	r3, r3
    10cc:	2b04      	cmp	r3, #4
    10ce:	d124      	bne.n	111a <Ov7725_eagle_vsync+0x5e>
    {
        ov7725_eagle_img_flag = IMG_GATHER;
    10d0:	f240 0367 	movw	r3, #103	; 0x67
    10d4:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    10d8:	f04f 0203 	mov.w	r2, #3
    10dc:	701a      	strb	r2, [r3, #0]
        disable_irq (INT_PORTA - 16);
    10de:	f04f 0057 	mov.w	r0, #87	; 0x57
    10e2:	f7ff fdd9 	bl	c98 <disable_irq>
        //LPLD_GPIO_DisableIrq(OV_PTA_init);
        //enable_irq (DMA_CH0 + INT_DMA0_DMA16 - 16);
        DMA_EN(DMA_CH0);
    10e6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    10ea:	f2c4 0300 	movt	r3, #16384	; 0x4000
    10ee:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    10f2:	f2c4 0200 	movt	r2, #16384	; 0x4000
    10f6:	68d2      	ldr	r2, [r2, #12]
    10f8:	f042 0201 	orr.w	r2, r2, #1
    10fc:	60da      	str	r2, [r3, #12]
        //LPLD_DMA_EnableIrq(OV_dma_init);
        //重新装载DMA目标地址
        DMA_DADDR(DMA_CH0) = (uint32)img;
    10fe:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    1102:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1106:	f240 027c 	movw	r2, #124	; 0x7c
    110a:	f6c1 72ff 	movt	r2, #8191	; 0x1fff
    110e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    1112:	f103 0310 	add.w	r3, r3, #16
    1116:	601a      	str	r2, [r3, #0]
    1118:	e00a      	b.n	1130 <Ov7725_eagle_vsync+0x74>
    }
    else
    {
        //disable_irq (INT_PORTA);
        //LPLD_GPIO_DisableIrq(OV_PTA_init);
        disable_irq (INT_PORTA - 16);
    111a:	f04f 0057 	mov.w	r0, #87	; 0x57
    111e:	f7ff fdbb 	bl	c98 <disable_irq>
        ov7725_eagle_img_flag = IMG_FAIL;
    1122:	f240 0367 	movw	r3, #103	; 0x67
    1126:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    112a:	f04f 0202 	mov.w	r2, #2
    112e:	701a      	strb	r2, [r3, #0]
    }
}
    1130:	bd80      	pop	{r7, pc}
    1132:	bf00      	nop

00001134 <Ov7725_eagle_get_img>:

//ov7725开始采集图像
void Ov7725_eagle_get_img(void)
{
    1134:	b580      	push	{r7, lr}
    1136:	b082      	sub	sp, #8
    1138:	af02      	add	r7, sp, #8
    ov7725_eagle_img_flag = IMG_START;
    113a:	f240 0367 	movw	r3, #103	; 0x67
    113e:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    1142:	f04f 0204 	mov.w	r2, #4
    1146:	701a      	strb	r2, [r3, #0]
    //write 1 clear int 
    PORTA_ISFR = ~0;
    1148:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    114c:	f2c4 0304 	movt	r3, #16388	; 0x4004
    1150:	f04f 32ff 	mov.w	r2, #4294967295
    1154:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
    DMA_DADDR(DMA_CH0) = (uint32)img;
    1158:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    115c:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1160:	f240 027c 	movw	r2, #124	; 0x7c
    1164:	f6c1 72ff 	movt	r2, #8191	; 0x1fff
    1168:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    116c:	f103 0310 	add.w	r3, r3, #16
    1170:	601a      	str	r2, [r3, #0]
    LPLD_GPIO_EnableIrq(OV_PTA_init);
    1172:	f241 53a8 	movw	r3, #5544	; 0x15a8
    1176:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    117a:	691a      	ldr	r2, [r3, #16]
    117c:	9200      	str	r2, [sp, #0]
    117e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
    1180:	f003 fe32 	bl	4de8 <LPLD_GPIO_EnableIrq>
}
    1184:	46bd      	mov	sp, r7
    1186:	bd80      	pop	{r7, pc}

00001188 <Ov7725_img_extract>:
 *  @param      srclen          二值化图像的占用空间大小
 *  @since      v5.0            img_extract(img, imgbuff,CAMERA_SIZE);
 *  Sample usage:   sendimg(imgbuff, CAMERA_W * CAMERA_H);                    //发送到上位机
 */
void Ov7725_img_extract(uint8 *dst, uint8 *src, uint32 srclen)
{
    1188:	b480      	push	{r7}
    118a:	b087      	sub	sp, #28
    118c:	af00      	add	r7, sp, #0
    118e:	60f8      	str	r0, [r7, #12]
    1190:	60b9      	str	r1, [r7, #8]
    1192:	607a      	str	r2, [r7, #4]
    uint8 colour[2] = {255, 0}; //0 和 1 分别对应的颜色
    1194:	f04f 03ff 	mov.w	r3, #255	; 0xff
    1198:	753b      	strb	r3, [r7, #20]
    119a:	f04f 0300 	mov.w	r3, #0
    119e:	757b      	strb	r3, [r7, #21]
    //注：野火的摄像头 1(or255)表示 白色，0表示 黑色
    uint8 tmpsrc;
    while(srclen --)
    11a0:	e08b      	b.n	12ba <Ov7725_img_extract+0x132>
    {
        tmpsrc = *src++;
    11a2:	68bb      	ldr	r3, [r7, #8]
    11a4:	781b      	ldrb	r3, [r3, #0]
    11a6:	75fb      	strb	r3, [r7, #23]
    11a8:	68bb      	ldr	r3, [r7, #8]
    11aa:	f103 0301 	add.w	r3, r3, #1
    11ae:	60bb      	str	r3, [r7, #8]
        *dst++ = colour[(tmpsrc >> 7) & 0x01];
    11b0:	7dfb      	ldrb	r3, [r7, #23]
    11b2:	ea4f 13d3 	mov.w	r3, r3, lsr #7
    11b6:	b2db      	uxtb	r3, r3
    11b8:	f003 0301 	and.w	r3, r3, #1
    11bc:	f107 0218 	add.w	r2, r7, #24
    11c0:	18d3      	adds	r3, r2, r3
    11c2:	f813 2c04 	ldrb.w	r2, [r3, #-4]
    11c6:	68fb      	ldr	r3, [r7, #12]
    11c8:	701a      	strb	r2, [r3, #0]
    11ca:	68fb      	ldr	r3, [r7, #12]
    11cc:	f103 0301 	add.w	r3, r3, #1
    11d0:	60fb      	str	r3, [r7, #12]
        *dst++ = colour[(tmpsrc >> 6) & 0x01];
    11d2:	7dfb      	ldrb	r3, [r7, #23]
    11d4:	ea4f 1393 	mov.w	r3, r3, lsr #6
    11d8:	b2db      	uxtb	r3, r3
    11da:	f003 0301 	and.w	r3, r3, #1
    11de:	f107 0218 	add.w	r2, r7, #24
    11e2:	18d3      	adds	r3, r2, r3
    11e4:	f813 2c04 	ldrb.w	r2, [r3, #-4]
    11e8:	68fb      	ldr	r3, [r7, #12]
    11ea:	701a      	strb	r2, [r3, #0]
    11ec:	68fb      	ldr	r3, [r7, #12]
    11ee:	f103 0301 	add.w	r3, r3, #1
    11f2:	60fb      	str	r3, [r7, #12]
        *dst++ = colour[(tmpsrc >> 5) & 0x01];
    11f4:	7dfb      	ldrb	r3, [r7, #23]
    11f6:	ea4f 1353 	mov.w	r3, r3, lsr #5
    11fa:	b2db      	uxtb	r3, r3
    11fc:	f003 0301 	and.w	r3, r3, #1
    1200:	f107 0218 	add.w	r2, r7, #24
    1204:	18d3      	adds	r3, r2, r3
    1206:	f813 2c04 	ldrb.w	r2, [r3, #-4]
    120a:	68fb      	ldr	r3, [r7, #12]
    120c:	701a      	strb	r2, [r3, #0]
    120e:	68fb      	ldr	r3, [r7, #12]
    1210:	f103 0301 	add.w	r3, r3, #1
    1214:	60fb      	str	r3, [r7, #12]
        *dst++ = colour[(tmpsrc >> 4) & 0x01];
    1216:	7dfb      	ldrb	r3, [r7, #23]
    1218:	ea4f 1313 	mov.w	r3, r3, lsr #4
    121c:	b2db      	uxtb	r3, r3
    121e:	f003 0301 	and.w	r3, r3, #1
    1222:	f107 0218 	add.w	r2, r7, #24
    1226:	18d3      	adds	r3, r2, r3
    1228:	f813 2c04 	ldrb.w	r2, [r3, #-4]
    122c:	68fb      	ldr	r3, [r7, #12]
    122e:	701a      	strb	r2, [r3, #0]
    1230:	68fb      	ldr	r3, [r7, #12]
    1232:	f103 0301 	add.w	r3, r3, #1
    1236:	60fb      	str	r3, [r7, #12]
        *dst++ = colour[(tmpsrc >> 3) & 0x01];
    1238:	7dfb      	ldrb	r3, [r7, #23]
    123a:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    123e:	b2db      	uxtb	r3, r3
    1240:	f003 0301 	and.w	r3, r3, #1
    1244:	f107 0218 	add.w	r2, r7, #24
    1248:	18d3      	adds	r3, r2, r3
    124a:	f813 2c04 	ldrb.w	r2, [r3, #-4]
    124e:	68fb      	ldr	r3, [r7, #12]
    1250:	701a      	strb	r2, [r3, #0]
    1252:	68fb      	ldr	r3, [r7, #12]
    1254:	f103 0301 	add.w	r3, r3, #1
    1258:	60fb      	str	r3, [r7, #12]
        *dst++ = colour[(tmpsrc >> 2) & 0x01];
    125a:	7dfb      	ldrb	r3, [r7, #23]
    125c:	ea4f 0393 	mov.w	r3, r3, lsr #2
    1260:	b2db      	uxtb	r3, r3
    1262:	f003 0301 	and.w	r3, r3, #1
    1266:	f107 0218 	add.w	r2, r7, #24
    126a:	18d3      	adds	r3, r2, r3
    126c:	f813 2c04 	ldrb.w	r2, [r3, #-4]
    1270:	68fb      	ldr	r3, [r7, #12]
    1272:	701a      	strb	r2, [r3, #0]
    1274:	68fb      	ldr	r3, [r7, #12]
    1276:	f103 0301 	add.w	r3, r3, #1
    127a:	60fb      	str	r3, [r7, #12]
        *dst++ = colour[(tmpsrc >> 1) & 0x01];
    127c:	7dfb      	ldrb	r3, [r7, #23]
    127e:	ea4f 0353 	mov.w	r3, r3, lsr #1
    1282:	b2db      	uxtb	r3, r3
    1284:	f003 0301 	and.w	r3, r3, #1
    1288:	f107 0218 	add.w	r2, r7, #24
    128c:	18d3      	adds	r3, r2, r3
    128e:	f813 2c04 	ldrb.w	r2, [r3, #-4]
    1292:	68fb      	ldr	r3, [r7, #12]
    1294:	701a      	strb	r2, [r3, #0]
    1296:	68fb      	ldr	r3, [r7, #12]
    1298:	f103 0301 	add.w	r3, r3, #1
    129c:	60fb      	str	r3, [r7, #12]
        *dst++ = colour[(tmpsrc >> 0) & 0x01];
    129e:	7dfb      	ldrb	r3, [r7, #23]
    12a0:	f003 0301 	and.w	r3, r3, #1
    12a4:	f107 0218 	add.w	r2, r7, #24
    12a8:	18d3      	adds	r3, r2, r3
    12aa:	f813 2c04 	ldrb.w	r2, [r3, #-4]
    12ae:	68fb      	ldr	r3, [r7, #12]
    12b0:	701a      	strb	r2, [r3, #0]
    12b2:	68fb      	ldr	r3, [r7, #12]
    12b4:	f103 0301 	add.w	r3, r3, #1
    12b8:	60fb      	str	r3, [r7, #12]
void Ov7725_img_extract(uint8 *dst, uint8 *src, uint32 srclen)
{
    uint8 colour[2] = {255, 0}; //0 和 1 分别对应的颜色
    //注：野火的摄像头 1(or255)表示 白色，0表示 黑色
    uint8 tmpsrc;
    while(srclen --)
    12ba:	687b      	ldr	r3, [r7, #4]
    12bc:	2b00      	cmp	r3, #0
    12be:	bf0c      	ite	eq
    12c0:	2300      	moveq	r3, #0
    12c2:	2301      	movne	r3, #1
    12c4:	b2db      	uxtb	r3, r3
    12c6:	687a      	ldr	r2, [r7, #4]
    12c8:	f102 32ff 	add.w	r2, r2, #4294967295
    12cc:	607a      	str	r2, [r7, #4]
    12ce:	2b00      	cmp	r3, #0
    12d0:	f47f af67 	bne.w	11a2 <Ov7725_img_extract+0x1a>
        *dst++ = colour[(tmpsrc >> 3) & 0x01];
        *dst++ = colour[(tmpsrc >> 2) & 0x01];
        *dst++ = colour[(tmpsrc >> 1) & 0x01];
        *dst++ = colour[(tmpsrc >> 0) & 0x01];
    }
}
    12d4:	f107 071c 	add.w	r7, r7, #28
    12d8:	46bd      	mov	sp, r7
    12da:	bc80      	pop	{r7}
    12dc:	4770      	bx	lr
    12de:	bf00      	nop

000012e0 <Ov7725_sendimg>:
 *  @note       不同的上位机，不同的命令，这里使用 eSmartCameraCar软件，
                如果使用其他上位机，则需要修改代码。
 *  Sample usage:   sendimg(imgbuff, CAMERA_W * CAMERA_H);                    //发送到上位机
 */
void Ov7725_sendimg(uint8 *imgaddr, uint32 imgsize)
{
    12e0:	b580      	push	{r7, lr}
    12e2:	b084      	sub	sp, #16
    12e4:	af00      	add	r7, sp, #0
    12e6:	6078      	str	r0, [r7, #4]
    12e8:	6039      	str	r1, [r7, #0]
    uint8 cmd[4] = {0, 255, 1, 0 };    //yy_摄像头串口调试 使用的命令
    12ea:	f648 43a0 	movw	r3, #36000	; 0x8ca0
    12ee:	f2c0 0300 	movt	r3, #0
    12f2:	f107 020c 	add.w	r2, r7, #12
    12f6:	6818      	ldr	r0, [r3, #0]
    12f8:	6010      	str	r0, [r2, #0]
    
    LPLD_UART_PutCharArr(TERM_PORT, (char *)cmd, sizeof(cmd));
    12fa:	f107 030c 	add.w	r3, r7, #12
    12fe:	f44f 4020 	mov.w	r0, #40960	; 0xa000
    1302:	f2c4 000e 	movt	r0, #16398	; 0x400e
    1306:	4619      	mov	r1, r3
    1308:	f04f 0204 	mov.w	r2, #4
    130c:	f006 fac2 	bl	7894 <LPLD_UART_PutCharArr>
    LPLD_UART_PutCharArr(TERM_PORT, (char *)imgaddr, imgsize);
    1310:	683b      	ldr	r3, [r7, #0]
    1312:	f44f 4020 	mov.w	r0, #40960	; 0xa000
    1316:	f2c4 000e 	movt	r0, #16398	; 0x400e
    131a:	6879      	ldr	r1, [r7, #4]
    131c:	461a      	mov	r2, r3
    131e:	f006 fab9 	bl	7894 <LPLD_UART_PutCharArr>

    //uart_putbuff(FIRE_PORT, cmd, sizeof(cmd));    //先发送命令

    //uart_putbuff(FIRE_PORT, imgaddr, imgsize); //再发送图像
}
    1322:	f107 0710 	add.w	r7, r7, #16
    1326:	46bd      	mov	sp, r7
    1328:	bd80      	pop	{r7, pc}
    132a:	bf00      	nop

0000132c <Ov7725_Gpio_Init>:

//OV7725GPIO口初始化
void Ov7725_Gpio_Init(void)
{
    132c:	b580      	push	{r7, lr}
    132e:	b082      	sub	sp, #8
    1330:	af02      	add	r7, sp, #8
    //OV数据口初始化 B0～B7
    OV_PTB_init.GPIO_PTx = PTB;
    1332:	f241 53bc 	movw	r3, #5564	; 0x15bc
    1336:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    133a:	f24f 0240 	movw	r2, #61504	; 0xf040
    133e:	f2c4 020f 	movt	r2, #16399	; 0x400f
    1342:	601a      	str	r2, [r3, #0]
    OV_PTB_init.GPIO_Dir = DIR_INPUT;
    1344:	f241 53bc 	movw	r3, #5564	; 0x15bc
    1348:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    134c:	f04f 0200 	mov.w	r2, #0
    1350:	731a      	strb	r2, [r3, #12]
    OV_PTB_init.GPIO_Pins = GPIO_Pin0_7;
    1352:	f241 53bc 	movw	r3, #5564	; 0x15bc
    1356:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    135a:	f04f 02ff 	mov.w	r2, #255	; 0xff
    135e:	605a      	str	r2, [r3, #4]
    //禁止中断和DMA请求 禁用PULL 输入源下拉
    OV_PTB_init.GPIO_PinControl = IRQC_DIS |
    1360:	f241 53bc 	movw	r3, #5564	; 0x15bc
    1364:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    1368:	f04f 0202 	mov.w	r2, #2
    136c:	609a      	str	r2, [r3, #8]
                                  INPUT_PULL_DIS|
                                  INPUT_PULL_DOWN;
    LPLD_GPIO_Init (OV_PTB_init);
    136e:	f241 53bc 	movw	r3, #5564	; 0x15bc
    1372:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    1376:	691a      	ldr	r2, [r3, #16]
    1378:	9200      	str	r2, [sp, #0]
    137a:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
    137c:	f003 fc88 	bl	4c90 <LPLD_GPIO_Init>

    //OV场信号接口初始化 A29 
    OV_PTA_init.GPIO_PTx = PTA;
    1380:	f241 53a8 	movw	r3, #5544	; 0x15a8
    1384:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    1388:	f44f 4270 	mov.w	r2, #61440	; 0xf000
    138c:	f2c4 020f 	movt	r2, #16399	; 0x400f
    1390:	601a      	str	r2, [r3, #0]
    OV_PTA_init.GPIO_Dir = DIR_INPUT;
    1392:	f241 53a8 	movw	r3, #5544	; 0x15a8
    1396:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    139a:	f04f 0200 	mov.w	r2, #0
    139e:	731a      	strb	r2, [r3, #12]
    OV_PTA_init.GPIO_Pins = GPIO_Pin29;
    13a0:	f241 53a8 	movw	r3, #5544	; 0x15a8
    13a4:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    13a8:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
    13ac:	605a      	str	r2, [r3, #4]
    //场中断IO设置，上升沿触发IR，输入上拉，使能滤波
    OV_PTA_init.GPIO_PinControl = IRQC_RI |
    13ae:	f241 53a8 	movw	r3, #5544	; 0x15a8
    13b2:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    13b6:	f04f 0213 	mov.w	r2, #19
    13ba:	f2c0 0209 	movt	r2, #9
    13be:	609a      	str	r2, [r3, #8]
                                    INPUT_PULL_UP|
                                    INPUT_PF_EN;
    OV_PTA_init.GPIO_Isr = Ov7725_isr;
    13c0:	f241 53a8 	movw	r3, #5544	; 0x15a8
    13c4:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    13c8:	f241 524d 	movw	r2, #5453	; 0x154d
    13cc:	f2c0 0200 	movt	r2, #0
    13d0:	611a      	str	r2, [r3, #16]
    LPLD_GPIO_Init (OV_PTA_init);
    13d2:	f241 53a8 	movw	r3, #5544	; 0x15a8
    13d6:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    13da:	691a      	ldr	r2, [r3, #16]
    13dc:	9200      	str	r2, [sp, #0]
    13de:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
    13e0:	f003 fc56 	bl	4c90 <LPLD_GPIO_Init>

    //OV PCLK信号接口初始化: PTA27-PCLK 
    OV_PTD_init.GPIO_PTx = PTA;
    13e4:	f241 5394 	movw	r3, #5524	; 0x1594
    13e8:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    13ec:	f44f 4270 	mov.w	r2, #61440	; 0xf000
    13f0:	f2c4 020f 	movt	r2, #16399	; 0x400f
    13f4:	601a      	str	r2, [r3, #0]
    OV_PTD_init.GPIO_Pins = GPIO_Pin27;
    13f6:	f241 5394 	movw	r3, #5524	; 0x1594
    13fa:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    13fe:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
    1402:	605a      	str	r2, [r3, #4]
    OV_PTD_init.GPIO_Dir = DIR_INPUT;
    1404:	f241 5394 	movw	r3, #5524	; 0x1594
    1408:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    140c:	f04f 0200 	mov.w	r2, #0
    1410:	731a      	strb	r2, [r3, #12]
    //PCLK信号，下降沿触发DMA，输入上拉
    OV_PTD_init.GPIO_PinControl = IRQC_DMAFA | INPUT_PULL_UP;
    1412:	f241 5394 	movw	r3, #5524	; 0x1594
    1416:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    141a:	f04f 0203 	mov.w	r2, #3
    141e:	f2c0 0202 	movt	r2, #2
    1422:	609a      	str	r2, [r3, #8]
    LPLD_GPIO_Init (OV_PTD_init);
    1424:	f241 5394 	movw	r3, #5524	; 0x1594
    1428:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    142c:	691a      	ldr	r2, [r3, #16]
    142e:	9200      	str	r2, [sp, #0]
    1430:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
    1432:	f003 fc2d 	bl	4c90 <LPLD_GPIO_Init>

}
    1436:	46bd      	mov	sp, r7
    1438:	bd80      	pop	{r7, pc}
    143a:	bf00      	nop

0000143c <Ov7725_Dma_Init>:
 
//OV7725 DMA初始化 
void Ov7725_Dma_Init (void)
{
    143c:	b5f0      	push	{r4, r5, r6, r7, lr}
    143e:	b089      	sub	sp, #36	; 0x24
    1440:	af08      	add	r7, sp, #32
    OV_dma_init.DMA_CHx = DMA_CH0;
    1442:	f241 53d0 	movw	r3, #5584	; 0x15d0
    1446:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    144a:	f04f 0200 	mov.w	r2, #0
    144e:	701a      	strb	r2, [r3, #0]
    OV_dma_init.DMA_Req = PORTA_DMAREQ;
    1450:	f241 53d0 	movw	r3, #5584	; 0x15d0
    1454:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    1458:	f04f 0231 	mov.w	r2, #49	; 0x31
    145c:	705a      	strb	r2, [r3, #1]
    OV_dma_init.DMA_MajorLoopCnt = PHOTO_SIZE / 8;
    145e:	f241 53d0 	movw	r3, #5584	; 0x15d0
    1462:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    1466:	f44f 7216 	mov.w	r2, #600	; 0x258
    146a:	809a      	strh	r2, [r3, #4]
    OV_dma_init.DMA_MinorByteCnt = 1;
    146c:	f241 53d0 	movw	r3, #5584	; 0x15d0
    1470:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    1474:	f04f 0201 	mov.w	r2, #1
    1478:	609a      	str	r2, [r3, #8]
    
    OV_dma_init.DMA_SourceAddr = (uint32)(&GPIOB_PDIR);
    147a:	f241 53d0 	movw	r3, #5584	; 0x15d0
    147e:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    1482:	f24f 0250 	movw	r2, #61520	; 0xf050
    1486:	f2c4 020f 	movt	r2, #16399	; 0x400f
    148a:	60da      	str	r2, [r3, #12]
    OV_dma_init.DMA_DestAddr = (uint32)img;
    148c:	f240 027c 	movw	r2, #124	; 0x7c
    1490:	f6c1 72ff 	movt	r2, #8191	; 0x1fff
    1494:	f241 53d0 	movw	r3, #5584	; 0x15d0
    1498:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    149c:	619a      	str	r2, [r3, #24]
    OV_dma_init.DMA_DestAddrOffset = 1;
    149e:	f241 53d0 	movw	r3, #5584	; 0x15d0
    14a2:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    14a6:	f04f 0201 	mov.w	r2, #1
    14aa:	83da      	strh	r2, [r3, #30]
    OV_dma_init.DMA_Isr = Ov7725_eagle_dma;
    14ac:	f241 53d0 	movw	r3, #5584	; 0x15d0
    14b0:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    14b4:	f241 0215 	movw	r2, #4117	; 0x1015
    14b8:	f2c0 0200 	movt	r2, #0
    14bc:	629a      	str	r2, [r3, #40]	; 0x28
    LPLD_DMA_Init (OV_dma_init);
    14be:	f241 56d0 	movw	r6, #5584	; 0x15d0
    14c2:	f6c1 76ff 	movt	r6, #8191	; 0x1fff
    14c6:	466c      	mov	r4, sp
    14c8:	f106 0510 	add.w	r5, r6, #16
    14cc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    14ce:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    14d0:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
    14d4:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    14d8:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
    14dc:	f001 f9e0 	bl	28a0 <LPLD_DMA_Init>

    LPLD_DMA_DisableReq(DMA_CH0);
    14e0:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    14e4:	f2c4 0300 	movt	r3, #16384	; 0x4000
    14e8:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    14ec:	f2c4 0200 	movt	r2, #16384	; 0x4000
    14f0:	68d2      	ldr	r2, [r2, #12]
    14f2:	f022 0201 	bic.w	r2, r2, #1
    14f6:	60da      	str	r2, [r3, #12]
    //disable_irq (INT_PORTA - 16);
    LPLD_GPIO_EnableIrq (OV_PTA_init);
    14f8:	f241 53a8 	movw	r3, #5544	; 0x15a8
    14fc:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    1500:	691a      	ldr	r2, [r3, #16]
    1502:	9200      	str	r2, [sp, #0]
    1504:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
    1506:	f003 fc6f 	bl	4de8 <LPLD_GPIO_EnableIrq>
    DMA0->INT |= 0x1u <<0;
    150a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    150e:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1512:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    1516:	f2c4 0200 	movt	r2, #16384	; 0x4000
    151a:	6a52      	ldr	r2, [r2, #36]	; 0x24
    151c:	f042 0201 	orr.w	r2, r2, #1
    1520:	625a      	str	r2, [r3, #36]	; 0x24
    //允许DMA通道传输完成中断
    //enable_irq (DMA_CH0);
    LPLD_DMA_EnableIrq (OV_dma_init);
    1522:	f241 56d0 	movw	r6, #5584	; 0x15d0
    1526:	f6c1 76ff 	movt	r6, #8191	; 0x1fff
    152a:	466c      	mov	r4, sp
    152c:	f106 0510 	add.w	r5, r6, #16
    1530:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    1532:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    1534:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
    1538:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    153c:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
    1540:	f001 fc0c 	bl	2d5c <LPLD_DMA_EnableIrq>
    //使能通道x的DMA请求
    //LPLD_DMA_EnableReq(DMA_CH0);
}
    1544:	f107 0704 	add.w	r7, r7, #4
    1548:	46bd      	mov	sp, r7
    154a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000154c <Ov7725_isr>:

//ov7725中断
void Ov7725_isr (void)
{
    154c:	b580      	push	{r7, lr}
    154e:	b082      	sub	sp, #8
    1550:	af00      	add	r7, sp, #0
    uint8 n = 0;
    1552:	f04f 0300 	mov.w	r3, #0
    1556:	71fb      	strb	r3, [r7, #7]
    while (!PORTA_ISFR);
    1558:	bf00      	nop
    155a:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    155e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    1562:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    1566:	2b00      	cmp	r3, #0
    1568:	d0f7      	beq.n	155a <Ov7725_isr+0xe>
    uint32 flag = (PORTA->ISFR);
    156a:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    156e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    1572:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    1576:	603b      	str	r3, [r7, #0]
    (PORTA -> ISFR) = ~0;
    1578:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    157c:	f2c4 0304 	movt	r3, #16388	; 0x4004
    1580:	f04f 32ff 	mov.w	r2, #4294967295
    1584:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
   
    n = 29;
    1588:	f04f 031d 	mov.w	r3, #29
    158c:	71fb      	strb	r3, [r7, #7]
    //printf ("flag = %x\n", flag);
    if (flag & (1<<n))
    158e:	79fb      	ldrb	r3, [r7, #7]
    1590:	f04f 0201 	mov.w	r2, #1
    1594:	fa02 f303 	lsl.w	r3, r2, r3
    1598:	461a      	mov	r2, r3
    159a:	683b      	ldr	r3, [r7, #0]
    159c:	4013      	ands	r3, r2
    159e:	2b00      	cmp	r3, #0
    15a0:	d016      	beq.n	15d0 <Ov7725_isr+0x84>
    {
        //场中断开始 
        //set 場中断
        ov7725_eagle_img_flag = IMG_START;
    15a2:	f240 0367 	movw	r3, #103	; 0x67
    15a6:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    15aa:	f04f 0204 	mov.w	r2, #4
    15ae:	701a      	strb	r2, [r3, #0]
        //关闭PORTA中断
        disable_irq (INT_PORTA - 16);
    15b0:	f04f 0057 	mov.w	r0, #87	; 0x57
    15b4:	f7ff fb70 	bl	c98 <disable_irq>
        //LPLD_GPIO_DisableIrq(OV_PTA_init);
        //enable_irq (DMA_CH0 + INT_DMA0_DMA16 - 16);
        //重新装载DMA目标地址
        //DMA_DADDR(DMA_CH0) = (uint32)img;
        //开启DMA通道
        DMA_EN(DMA_CH0);
    15b8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    15bc:	f2c4 0300 	movt	r3, #16384	; 0x4000
    15c0:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    15c4:	f2c4 0200 	movt	r2, #16384	; 0x4000
    15c8:	68d2      	ldr	r2, [r2, #12]
    15ca:	f042 0201 	orr.w	r2, r2, #1
    15ce:	60da      	str	r2, [r3, #12]
        //LPLD_DMA_EnableIrq(OV_dma_init);
    }
}
    15d0:	f107 0708 	add.w	r7, r7, #8
    15d4:	46bd      	mov	sp, r7
    15d6:	bd80      	pop	{r7, pc}

000015d8 <dma_portx2buff_init>:

//移植野火的函数
void dma_portx2buff_init(uint8 CHn, void *SADDR, void *DADDR, uint8 dma_req, DMA_BYTEn byten, uint32 count, uint32 cfg)
{
    15d8:	b480      	push	{r7}
    15da:	b087      	sub	sp, #28
    15dc:	af00      	add	r7, sp, #0
    15de:	60b9      	str	r1, [r7, #8]
    15e0:	607a      	str	r2, [r7, #4]
    15e2:	4602      	mov	r2, r0
    15e4:	73fa      	strb	r2, [r7, #15]
    15e6:	73bb      	strb	r3, [r7, #14]
    uint8 BYTEs = (byten == DMA_BYTE1 ? 1 : (byten == DMA_BYTE2 ? 2 : (byten == DMA_BYTE4 ? 4 : 16)));
    15e8:	f897 3020 	ldrb.w	r3, [r7, #32]
    15ec:	2b00      	cmp	r3, #0
    15ee:	d010      	beq.n	1612 <dma_portx2buff_init+0x3a>
    15f0:	f897 3020 	ldrb.w	r3, [r7, #32]
    15f4:	2b01      	cmp	r3, #1
    15f6:	d009      	beq.n	160c <dma_portx2buff_init+0x34>
    15f8:	f897 3020 	ldrb.w	r3, [r7, #32]
    15fc:	2b02      	cmp	r3, #2
    15fe:	d102      	bne.n	1606 <dma_portx2buff_init+0x2e>
    1600:	f04f 0304 	mov.w	r3, #4
    1604:	e001      	b.n	160a <dma_portx2buff_init+0x32>
    1606:	f04f 0310 	mov.w	r3, #16
    160a:	e001      	b.n	1610 <dma_portx2buff_init+0x38>
    160c:	f04f 0302 	mov.w	r3, #2
    1610:	e001      	b.n	1616 <dma_portx2buff_init+0x3e>
    1612:	f04f 0301 	mov.w	r3, #1
    1616:	75fb      	strb	r3, [r7, #23]
    
    SIM_SCGC7 |= SIM_SCGC7_DMA_MASK;
    1618:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    161c:	f2c4 0304 	movt	r3, #16388	; 0x4004
    1620:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    1624:	f2c4 0204 	movt	r2, #16388	; 0x4004
    1628:	f502 5282 	add.w	r2, r2, #4160	; 0x1040
    162c:	6812      	ldr	r2, [r2, #0]
    162e:	f042 0202 	orr.w	r2, r2, #2
    1632:	f503 5382 	add.w	r3, r3, #4160	; 0x1040
    1636:	601a      	str	r2, [r3, #0]
    SIM_SCGC6 |= SIM_SCGC6_DMAMUX0_MASK;
    1638:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    163c:	f2c4 0304 	movt	r3, #16388	; 0x4004
    1640:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    1644:	f2c4 0204 	movt	r2, #16388	; 0x4004
    1648:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    164c:	f102 021c 	add.w	r2, r2, #28
    1650:	6812      	ldr	r2, [r2, #0]
    1652:	f042 0202 	orr.w	r2, r2, #2
    1656:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    165a:	f103 031c 	add.w	r3, r3, #28
    165e:	601a      	str	r2, [r3, #0]

    DMA_SADDR(CHn) = (uint32) SADDR;
    1660:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    1664:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1668:	7bf9      	ldrb	r1, [r7, #15]
    166a:	68ba      	ldr	r2, [r7, #8]
    166c:	f101 0180 	add.w	r1, r1, #128	; 0x80
    1670:	ea4f 1141 	mov.w	r1, r1, lsl #5
    1674:	185b      	adds	r3, r3, r1
    1676:	601a      	str	r2, [r3, #0]
    DMA_DADDR(CHn) = (uint32) DADDR;
    1678:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    167c:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1680:	7bf9      	ldrb	r1, [r7, #15]
    1682:	687a      	ldr	r2, [r7, #4]
    1684:	ea4f 1141 	mov.w	r1, r1, lsl #5
    1688:	185b      	adds	r3, r3, r1
    168a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    168e:	f103 0310 	add.w	r3, r3, #16
    1692:	601a      	str	r2, [r3, #0]
    DMA_SOFF(CHn) = 0x00u;
    1694:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    1698:	f2c4 0300 	movt	r3, #16384	; 0x4000
    169c:	7bfa      	ldrb	r2, [r7, #15]
    169e:	f102 0280 	add.w	r2, r2, #128	; 0x80
    16a2:	ea4f 1242 	mov.w	r2, r2, lsl #5
    16a6:	189b      	adds	r3, r3, r2
    16a8:	f04f 0200 	mov.w	r2, #0
    16ac:	809a      	strh	r2, [r3, #4]
    DMA_DOFF(CHn) = BYTEs;
    16ae:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    16b2:	f2c4 0300 	movt	r3, #16384	; 0x4000
    16b6:	7bf9      	ldrb	r1, [r7, #15]
    16b8:	7dfa      	ldrb	r2, [r7, #23]
    16ba:	b292      	uxth	r2, r2
    16bc:	ea4f 1141 	mov.w	r1, r1, lsl #5
    16c0:	185b      	adds	r3, r3, r1
    16c2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    16c6:	f103 0310 	add.w	r3, r3, #16
    16ca:	809a      	strh	r2, [r3, #4]
    DMA_ATTR(CHn) = (0
    16cc:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    16d0:	f2c4 0300 	movt	r3, #16384	; 0x4000
    16d4:	7bf9      	ldrb	r1, [r7, #15]
                     |DMA_ATTR_SMOD(0x0)
                     |DMA_ATTR_SSIZE(byten)
    16d6:	f897 2020 	ldrb.w	r2, [r7, #32]
    16da:	b292      	uxth	r2, r2
    16dc:	ea4f 2202 	mov.w	r2, r2, lsl #8
    16e0:	b292      	uxth	r2, r2

    DMA_SADDR(CHn) = (uint32) SADDR;
    DMA_DADDR(CHn) = (uint32) DADDR;
    DMA_SOFF(CHn) = 0x00u;
    DMA_DOFF(CHn) = BYTEs;
    DMA_ATTR(CHn) = (0
    16e2:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    16e6:	b290      	uxth	r0, r2
    16e8:	f897 2020 	ldrb.w	r2, [r7, #32]
    16ec:	b292      	uxth	r2, r2
    16ee:	f002 0207 	and.w	r2, r2, #7
    16f2:	b292      	uxth	r2, r2
    16f4:	4302      	orrs	r2, r0
    16f6:	b292      	uxth	r2, r2
    16f8:	f101 0180 	add.w	r1, r1, #128	; 0x80
    16fc:	ea4f 1141 	mov.w	r1, r1, lsl #5
    1700:	185b      	adds	r3, r3, r1
    1702:	80da      	strh	r2, [r3, #6]
                     |DMA_ATTR_SMOD(0x0)
                     |DMA_ATTR_SSIZE(byten)
                     |DMA_ATTR_DMOD(0x0)
                     |DMA_ATTR_DSIZE(byten)
                    );
    DMA_CITER_ELINKNO(CHn) = DMA_CITER_ELINKNO_CITER(count);
    1704:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    1708:	f2c4 0300 	movt	r3, #16384	; 0x4000
    170c:	7bf9      	ldrb	r1, [r7, #15]
    170e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    1710:	b292      	uxth	r2, r2
    1712:	ea4f 4242 	mov.w	r2, r2, lsl #17
    1716:	ea4f 4252 	mov.w	r2, r2, lsr #17
    171a:	b292      	uxth	r2, r2
    171c:	ea4f 1141 	mov.w	r1, r1, lsl #5
    1720:	185b      	adds	r3, r3, r1
    1722:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    1726:	f103 0310 	add.w	r3, r3, #16
    172a:	80da      	strh	r2, [r3, #6]
    DMA_BITER_ELINKNO(CHn) = DMA_BITER_ELINKNO_BITER(count);
    172c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    1730:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1734:	7bf9      	ldrb	r1, [r7, #15]
    1736:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    1738:	b292      	uxth	r2, r2
    173a:	ea4f 4242 	mov.w	r2, r2, lsl #17
    173e:	ea4f 4252 	mov.w	r2, r2, lsr #17
    1742:	b292      	uxth	r2, r2
    1744:	ea4f 1141 	mov.w	r1, r1, lsl #5
    1748:	185b      	adds	r3, r3, r1
    174a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    174e:	f103 0318 	add.w	r3, r3, #24
    1752:	80da      	strh	r2, [r3, #6]

    DMA_CR &= ~DMA_CR_EMLM_MASK;
    1754:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    1758:	f2c4 0300 	movt	r3, #16384	; 0x4000
    175c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    1760:	f2c4 0200 	movt	r2, #16384	; 0x4000
    1764:	6812      	ldr	r2, [r2, #0]
    1766:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    176a:	601a      	str	r2, [r3, #0]

    DMA_NBYTES_MLNO(CHn) = DMA_NBYTES_MLNO_NBYTES(BYTEs);
    176c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    1770:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1774:	7bf9      	ldrb	r1, [r7, #15]
    1776:	7dfa      	ldrb	r2, [r7, #23]
    1778:	ea4f 1141 	mov.w	r1, r1, lsl #5
    177c:	185b      	adds	r3, r3, r1
    177e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    1782:	f103 0308 	add.w	r3, r3, #8
    1786:	601a      	str	r2, [r3, #0]

    DMA_SLAST(CHn) = 0;
    1788:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    178c:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1790:	7bfa      	ldrb	r2, [r7, #15]
    1792:	ea4f 1242 	mov.w	r2, r2, lsl #5
    1796:	189b      	adds	r3, r3, r2
    1798:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    179c:	f103 0308 	add.w	r3, r3, #8
    17a0:	f04f 0200 	mov.w	r2, #0
    17a4:	605a      	str	r2, [r3, #4]
    DMA_DLAST_SGA(CHn) = (uint32)((cfg & DADDR_KEEPON) == 0 ? (-count) : 0);
    17a6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    17aa:	f2c4 0300 	movt	r3, #16384	; 0x4000
    17ae:	7bf9      	ldrb	r1, [r7, #15]
    17b0:	6aba      	ldr	r2, [r7, #40]	; 0x28
    17b2:	f002 0201 	and.w	r2, r2, #1
    17b6:	2a00      	cmp	r2, #0
    17b8:	d103      	bne.n	17c2 <dma_portx2buff_init+0x1ea>
    17ba:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    17bc:	f1c2 0200 	rsb	r2, r2, #0
    17c0:	e001      	b.n	17c6 <dma_portx2buff_init+0x1ee>
    17c2:	f04f 0200 	mov.w	r2, #0
    17c6:	ea4f 1141 	mov.w	r1, r1, lsl #5
    17ca:	185b      	adds	r3, r3, r1
    17cc:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    17d0:	f103 0318 	add.w	r3, r3, #24
    17d4:	601a      	str	r2, [r3, #0]
    DMA_CSR(CHn) = (0
    17d6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    17da:	f2c4 0300 	movt	r3, #16384	; 0x4000
    17de:	7bfa      	ldrb	r2, [r7, #15]
    17e0:	ea4f 1242 	mov.w	r2, r2, lsl #5
    17e4:	189b      	adds	r3, r3, r2
    17e6:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    17ea:	f103 0318 	add.w	r3, r3, #24
    17ee:	f24c 020a 	movw	r2, #49162	; 0xc00a
    17f2:	809a      	strh	r2, [r3, #4]
                    |DMA_CSR_BWC(3)
                    |DMA_CSR_DREQ_MASK
                    |DMA_CSR_INTMAJOR_MASK
                   );

    DMAMUX_CHCFG_REG(DMAMUX0_BASE_PTR, CHn) = (0                
    17f4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    17f8:	f2c4 0302 	movt	r3, #16386	; 0x4002
    17fc:	7bfa      	ldrb	r2, [r7, #15]
    17fe:	7bb9      	ldrb	r1, [r7, #14]
    1800:	f001 013f 	and.w	r1, r1, #63	; 0x3f
    1804:	b2c9      	uxtb	r1, r1
    1806:	f061 017f 	orn	r1, r1, #127	; 0x7f
    180a:	b2c9      	uxtb	r1, r1
    180c:	5499      	strb	r1, [r3, r2]
    |DMAMUX_CHCFG_ENBL_MASK
    |DMAMUX_CHCFG_SOURCE(dma_req));
    DMA_DIS(CHn);
    180e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    1812:	f2c4 0300 	movt	r3, #16384	; 0x4000
    1816:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    181a:	f2c4 0200 	movt	r2, #16384	; 0x4000
    181e:	6a51      	ldr	r1, [r2, #36]	; 0x24
    1820:	7bfa      	ldrb	r2, [r7, #15]
    1822:	f04f 0001 	mov.w	r0, #1
    1826:	fa00 f202 	lsl.w	r2, r0, r2
    182a:	ea6f 0202 	mvn.w	r2, r2
    182e:	400a      	ands	r2, r1
    1830:	625a      	str	r2, [r3, #36]	; 0x24
    DMA_IRQ_CLEAN(CHn);
    1832:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    1836:	f2c4 0300 	movt	r3, #16384	; 0x4000
    183a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    183e:	f2c4 0200 	movt	r2, #16384	; 0x4000
    1842:	6a51      	ldr	r1, [r2, #36]	; 0x24
    1844:	7bfa      	ldrb	r2, [r7, #15]
    1846:	f04f 0001 	mov.w	r0, #1
    184a:	fa00 f202 	lsl.w	r2, r0, r2
    184e:	430a      	orrs	r2, r1
    1850:	625a      	str	r2, [r3, #36]	; 0x24
}
    1852:	f107 071c 	add.w	r7, r7, #28
    1856:	46bd      	mov	sp, r7
    1858:	bc80      	pop	{r7}
    185a:	4770      	bx	lr

0000185c <get_midline>:


//提取中线
void get_midline(uint8 *img, uint8 h, uint8 w)
{
    185c:	b480      	push	{r7}
    185e:	b085      	sub	sp, #20
    1860:	af00      	add	r7, sp, #0
    1862:	6078      	str	r0, [r7, #4]
    1864:	4613      	mov	r3, r2
    1866:	460a      	mov	r2, r1
    1868:	70fa      	strb	r2, [r7, #3]
    186a:	70bb      	strb	r3, [r7, #2]
    int16 p = 0, i = 0, line_mid = 39;
    186c:	f04f 0300 	mov.w	r3, #0
    1870:	81fb      	strh	r3, [r7, #14]
    1872:	f04f 0300 	mov.w	r3, #0
    1876:	81bb      	strh	r3, [r7, #12]
    1878:	f04f 0327 	mov.w	r3, #39	; 0x27
    187c:	817b      	strh	r3, [r7, #10]
    int8 side_left = 0, side_right = 79;
    187e:	f04f 0300 	mov.w	r3, #0
    1882:	727b      	strb	r3, [r7, #9]
    1884:	f04f 034f 	mov.w	r3, #79	; 0x4f
    1888:	723b      	strb	r3, [r7, #8]

    if (img[(h-1)*w + line_mid] == 0xff)
    188a:	78fb      	ldrb	r3, [r7, #3]
    188c:	f103 33ff 	add.w	r3, r3, #4294967295
    1890:	78ba      	ldrb	r2, [r7, #2]
    1892:	fb02 f203 	mul.w	r2, r2, r3
    1896:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
    189a:	18d3      	adds	r3, r2, r3
    189c:	687a      	ldr	r2, [r7, #4]
    189e:	18d3      	adds	r3, r2, r3
    18a0:	781b      	ldrb	r3, [r3, #0]
    18a2:	2bff      	cmp	r3, #255	; 0xff
    18a4:	f040 80ca 	bne.w	1a3c <get_midline+0x1e0>
    {
        for (i = h - 1; i >= 0; i --)
    18a8:	78fb      	ldrb	r3, [r7, #3]
    18aa:	b29b      	uxth	r3, r3
    18ac:	f103 33ff 	add.w	r3, r3, #4294967295
    18b0:	b29b      	uxth	r3, r3
    18b2:	81bb      	strh	r3, [r7, #12]
    18b4:	e0bd      	b.n	1a32 <get_midline+0x1d6>
        {
            for (p = line_mid - 1; p > 0; p --)
    18b6:	897b      	ldrh	r3, [r7, #10]
    18b8:	f103 33ff 	add.w	r3, r3, #4294967295
    18bc:	b29b      	uxth	r3, r3
    18be:	81fb      	strh	r3, [r7, #14]
    18c0:	e045      	b.n	194e <get_midline+0xf2>
            {
                if (img[i * w + p] == 0)
    18c2:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
    18c6:	78ba      	ldrb	r2, [r7, #2]
    18c8:	fb02 f203 	mul.w	r2, r2, r3
    18cc:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
    18d0:	18d3      	adds	r3, r2, r3
    18d2:	687a      	ldr	r2, [r7, #4]
    18d4:	18d3      	adds	r3, r2, r3
    18d6:	781b      	ldrb	r3, [r3, #0]
    18d8:	2b00      	cmp	r3, #0
    18da:	d134      	bne.n	1946 <get_midline+0xea>
                    if ((img[i * w + p - 1] == 0) 
    18dc:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
    18e0:	78ba      	ldrb	r2, [r7, #2]
    18e2:	fb02 f203 	mul.w	r2, r2, r3
    18e6:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
    18ea:	18d3      	adds	r3, r2, r3
    18ec:	f103 33ff 	add.w	r3, r3, #4294967295
    18f0:	687a      	ldr	r2, [r7, #4]
    18f2:	18d3      	adds	r3, r2, r3
    18f4:	781b      	ldrb	r3, [r3, #0]
    18f6:	2b00      	cmp	r3, #0
    18f8:	d125      	bne.n	1946 <get_midline+0xea>
                            && (line_mid-p-1>= 0))
    18fa:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
    18fe:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
    1902:	1ad3      	subs	r3, r2, r3
    1904:	f103 33ff 	add.w	r3, r3, #4294967295
    1908:	2b00      	cmp	r3, #0
    190a:	db1c      	blt.n	1946 <get_midline+0xea>
                    {
                        side_left = p;
    190c:	89fb      	ldrh	r3, [r7, #14]
    190e:	727b      	strb	r3, [r7, #9]
                        p = p - 2;
    1910:	89fb      	ldrh	r3, [r7, #14]
    1912:	f1a3 0302 	sub.w	r3, r3, #2
    1916:	b29b      	uxth	r3, r3
    1918:	81fb      	strh	r3, [r7, #14]
                        for (; p >= 0; p --)
    191a:	e010      	b.n	193e <get_midline+0xe2>
                            img[i * w + p] = 0;
    191c:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
    1920:	78ba      	ldrb	r2, [r7, #2]
    1922:	fb02 f203 	mul.w	r2, r2, r3
    1926:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
    192a:	18d3      	adds	r3, r2, r3
    192c:	687a      	ldr	r2, [r7, #4]
    192e:	18d3      	adds	r3, r2, r3
    1930:	f04f 0200 	mov.w	r2, #0
    1934:	701a      	strb	r2, [r3, #0]
                    if ((img[i * w + p - 1] == 0) 
                            && (line_mid-p-1>= 0))
                    {
                        side_left = p;
                        p = p - 2;
                        for (; p >= 0; p --)
    1936:	89fb      	ldrh	r3, [r7, #14]
    1938:	f103 33ff 	add.w	r3, r3, #4294967295
    193c:	81fb      	strh	r3, [r7, #14]
    193e:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
    1942:	2b00      	cmp	r3, #0
    1944:	daea      	bge.n	191c <get_midline+0xc0>

    if (img[(h-1)*w + line_mid] == 0xff)
    {
        for (i = h - 1; i >= 0; i --)
        {
            for (p = line_mid - 1; p > 0; p --)
    1946:	89fb      	ldrh	r3, [r7, #14]
    1948:	f103 33ff 	add.w	r3, r3, #4294967295
    194c:	81fb      	strh	r3, [r7, #14]
    194e:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
    1952:	2b00      	cmp	r3, #0
    1954:	dcb5      	bgt.n	18c2 <get_midline+0x66>
                        p = p - 2;
                        for (; p >= 0; p --)
                            img[i * w + p] = 0;
                    }
            }
            for (p = line_mid + 1; p < w -1; p ++)
    1956:	897b      	ldrh	r3, [r7, #10]
    1958:	f103 0301 	add.w	r3, r3, #1
    195c:	b29b      	uxth	r3, r3
    195e:	81fb      	strh	r3, [r7, #14]
    1960:	e044      	b.n	19ec <get_midline+0x190>
            {
                if (img[i * w + p] == 0)
    1962:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
    1966:	78ba      	ldrb	r2, [r7, #2]
    1968:	fb02 f203 	mul.w	r2, r2, r3
    196c:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
    1970:	18d3      	adds	r3, r2, r3
    1972:	687a      	ldr	r2, [r7, #4]
    1974:	18d3      	adds	r3, r2, r3
    1976:	781b      	ldrb	r3, [r3, #0]
    1978:	2b00      	cmp	r3, #0
    197a:	d133      	bne.n	19e4 <get_midline+0x188>
                {
                    if ((img[i * w + p + 1] == 0)&&(p+1<w))
    197c:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
    1980:	78ba      	ldrb	r2, [r7, #2]
    1982:	fb02 f203 	mul.w	r2, r2, r3
    1986:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
    198a:	18d3      	adds	r3, r2, r3
    198c:	f103 0301 	add.w	r3, r3, #1
    1990:	687a      	ldr	r2, [r7, #4]
    1992:	18d3      	adds	r3, r2, r3
    1994:	781b      	ldrb	r3, [r3, #0]
    1996:	2b00      	cmp	r3, #0
    1998:	d124      	bne.n	19e4 <get_midline+0x188>
    199a:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
    199e:	f103 0201 	add.w	r2, r3, #1
    19a2:	78bb      	ldrb	r3, [r7, #2]
    19a4:	429a      	cmp	r2, r3
    19a6:	da1d      	bge.n	19e4 <get_midline+0x188>
                    {
                        side_right = p;
    19a8:	89fb      	ldrh	r3, [r7, #14]
    19aa:	723b      	strb	r3, [r7, #8]
                        p = p + 2;
    19ac:	89fb      	ldrh	r3, [r7, #14]
    19ae:	f103 0302 	add.w	r3, r3, #2
    19b2:	b29b      	uxth	r3, r3
    19b4:	81fb      	strh	r3, [r7, #14]
                        for (; p < w; p ++)
    19b6:	e010      	b.n	19da <get_midline+0x17e>
                            img[i * w + p] = 0;
    19b8:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
    19bc:	78ba      	ldrb	r2, [r7, #2]
    19be:	fb02 f203 	mul.w	r2, r2, r3
    19c2:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
    19c6:	18d3      	adds	r3, r2, r3
    19c8:	687a      	ldr	r2, [r7, #4]
    19ca:	18d3      	adds	r3, r2, r3
    19cc:	f04f 0200 	mov.w	r2, #0
    19d0:	701a      	strb	r2, [r3, #0]
                {
                    if ((img[i * w + p + 1] == 0)&&(p+1<w))
                    {
                        side_right = p;
                        p = p + 2;
                        for (; p < w; p ++)
    19d2:	89fb      	ldrh	r3, [r7, #14]
    19d4:	f103 0301 	add.w	r3, r3, #1
    19d8:	81fb      	strh	r3, [r7, #14]
    19da:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
    19de:	78bb      	ldrb	r3, [r7, #2]
    19e0:	429a      	cmp	r2, r3
    19e2:	dbe9      	blt.n	19b8 <get_midline+0x15c>
                        p = p - 2;
                        for (; p >= 0; p --)
                            img[i * w + p] = 0;
                    }
            }
            for (p = line_mid + 1; p < w -1; p ++)
    19e4:	89fb      	ldrh	r3, [r7, #14]
    19e6:	f103 0301 	add.w	r3, r3, #1
    19ea:	81fb      	strh	r3, [r7, #14]
    19ec:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
    19f0:	78bb      	ldrb	r3, [r7, #2]
    19f2:	f103 33ff 	add.w	r3, r3, #4294967295
    19f6:	429a      	cmp	r2, r3
    19f8:	dbb3      	blt.n	1962 <get_midline+0x106>
                        for (; p < w; p ++)
                            img[i * w + p] = 0;
                    }
                }
            }
            line_mid = (side_left + side_right) / 2;
    19fa:	f997 2009 	ldrsb.w	r2, [r7, #9]
    19fe:	f997 3008 	ldrsb.w	r3, [r7, #8]
    1a02:	18d3      	adds	r3, r2, r3
    1a04:	ea4f 72d3 	mov.w	r2, r3, lsr #31
    1a08:	18d3      	adds	r3, r2, r3
    1a0a:	ea4f 0363 	mov.w	r3, r3, asr #1
    1a0e:	817b      	strh	r3, [r7, #10]
            img[i * w + line_mid] = 0;
    1a10:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
    1a14:	78ba      	ldrb	r2, [r7, #2]
    1a16:	fb02 f203 	mul.w	r2, r2, r3
    1a1a:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
    1a1e:	18d3      	adds	r3, r2, r3
    1a20:	687a      	ldr	r2, [r7, #4]
    1a22:	18d3      	adds	r3, r2, r3
    1a24:	f04f 0200 	mov.w	r2, #0
    1a28:	701a      	strb	r2, [r3, #0]
    int16 p = 0, i = 0, line_mid = 39;
    int8 side_left = 0, side_right = 79;

    if (img[(h-1)*w + line_mid] == 0xff)
    {
        for (i = h - 1; i >= 0; i --)
    1a2a:	89bb      	ldrh	r3, [r7, #12]
    1a2c:	f103 33ff 	add.w	r3, r3, #4294967295
    1a30:	81bb      	strh	r3, [r7, #12]
    1a32:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
    1a36:	2b00      	cmp	r3, #0
    1a38:	f6bf af3d 	bge.w	18b6 <get_midline+0x5a>
            }
            line_mid = (side_left + side_right) / 2;
            img[i * w + line_mid] = 0;
        }
    }
}
    1a3c:	f107 0714 	add.w	r7, r7, #20
    1a40:	46bd      	mov	sp, r7
    1a42:	bc80      	pop	{r7}
    1a44:	4770      	bx	lr
    1a46:	bf00      	nop

00001a48 <LPLD_SCCB_Init>:
  ptb.GPIO_PinControl = NULL;
  LPLD_GPIO_Init(ptb);
}*/

void LPLD_SCCB_Init(void)
{
    1a48:	b580      	push	{r7, lr}
    1a4a:	b088      	sub	sp, #32
    1a4c:	af02      	add	r7, sp, #8
  GPIO_InitTypeDef ptb;
  /********û޸ֵ ʼ***********/
  ptb.GPIO_PTx = PTA;
    1a4e:	f44f 4370 	mov.w	r3, #61440	; 0xf000
    1a52:	f2c4 030f 	movt	r3, #16399	; 0x400f
    1a56:	607b      	str	r3, [r7, #4]
  ptb.GPIO_Pins = GPIO_Pin25 | GPIO_Pin26;
    1a58:	f04f 63c0 	mov.w	r3, #100663296	; 0x6000000
    1a5c:	60bb      	str	r3, [r7, #8]
  /********û޸ֵ ***********/
  ptb.GPIO_Dir = DIR_OUTPUT;
    1a5e:	f04f 0301 	mov.w	r3, #1
    1a62:	743b      	strb	r3, [r7, #16]
  ptb.GPIO_Output = OUTPUT_H;
    1a64:	f04f 0301 	mov.w	r3, #1
    1a68:	747b      	strb	r3, [r7, #17]
  ptb.GPIO_PinControl = INPUT_PULL_UP;
    1a6a:	f04f 0303 	mov.w	r3, #3
    1a6e:	60fb      	str	r3, [r7, #12]
  LPLD_GPIO_Init(ptb);
    1a70:	697b      	ldr	r3, [r7, #20]
    1a72:	9300      	str	r3, [sp, #0]
    1a74:	f107 0304 	add.w	r3, r7, #4
    1a78:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
    1a7a:	f003 f909 	bl	4c90 <LPLD_GPIO_Init>
}
    1a7e:	f107 0718 	add.w	r7, r7, #24
    1a82:	46bd      	mov	sp, r7
    1a84:	bd80      	pop	{r7, pc}
    1a86:	bf00      	nop

00001a88 <LPLD_SCCB_WriteReg>:
 * :
 *    1-ɹ
 *    0-ʧ
 */
uint8 LPLD_SCCB_WriteReg(uint16 reg_addr , uint8 data)
{		
    1a88:	b580      	push	{r7, lr}
    1a8a:	b082      	sub	sp, #8
    1a8c:	af00      	add	r7, sp, #0
    1a8e:	4602      	mov	r2, r0
    1a90:	460b      	mov	r3, r1
    1a92:	80fa      	strh	r2, [r7, #6]
    1a94:	717b      	strb	r3, [r7, #5]
  if(!LPLD_SCCB_Start())
    1a96:	f000 f889 	bl	1bac <LPLD_SCCB_Start>
    1a9a:	4603      	mov	r3, r0
    1a9c:	2b00      	cmp	r3, #0
    1a9e:	d102      	bne.n	1aa6 <LPLD_SCCB_WriteReg+0x1e>
  {
    return 0;
    1aa0:	f04f 0300 	mov.w	r3, #0
    1aa4:	e01e      	b.n	1ae4 <LPLD_SCCB_WriteReg+0x5c>
  }
  LPLD_SCCB_SendByte(SCCB_DEV_ADR ); 
    1aa6:	f04f 0042 	mov.w	r0, #66	; 0x42
    1aaa:	f000 f9bd 	bl	1e28 <LPLD_SCCB_SendByte>
  if(!LPLD_SCCB_WaitAck())
    1aae:	f000 f96d 	bl	1d8c <LPLD_SCCB_WaitAck>
    1ab2:	4603      	mov	r3, r0
    1ab4:	2b00      	cmp	r3, #0
    1ab6:	d104      	bne.n	1ac2 <LPLD_SCCB_WriteReg+0x3a>
  {
    LPLD_SCCB_Stop(); 
    1ab8:	f000 f8e0 	bl	1c7c <LPLD_SCCB_Stop>
    return 0;
    1abc:	f04f 0300 	mov.w	r3, #0
    1ac0:	e010      	b.n	1ae4 <LPLD_SCCB_WriteReg+0x5c>
  }
  LPLD_SCCB_SendByte((uint8)(reg_addr & 0x00FF));   
    1ac2:	88fb      	ldrh	r3, [r7, #6]
    1ac4:	b2db      	uxtb	r3, r3
    1ac6:	4618      	mov	r0, r3
    1ac8:	f000 f9ae 	bl	1e28 <LPLD_SCCB_SendByte>
  LPLD_SCCB_WaitAck();	
    1acc:	f000 f95e 	bl	1d8c <LPLD_SCCB_WaitAck>
  LPLD_SCCB_SendByte(data);
    1ad0:	797b      	ldrb	r3, [r7, #5]
    1ad2:	4618      	mov	r0, r3
    1ad4:	f000 f9a8 	bl	1e28 <LPLD_SCCB_SendByte>
  LPLD_SCCB_WaitAck();   
    1ad8:	f000 f958 	bl	1d8c <LPLD_SCCB_WaitAck>
  LPLD_SCCB_Stop(); 
    1adc:	f000 f8ce 	bl	1c7c <LPLD_SCCB_Stop>
  return 1;
    1ae0:	f04f 0301 	mov.w	r3, #1
}									 
    1ae4:	4618      	mov	r0, r3
    1ae6:	f107 0708 	add.w	r7, r7, #8
    1aea:	46bd      	mov	sp, r7
    1aec:	bd80      	pop	{r7, pc}
    1aee:	bf00      	nop

00001af0 <LPLD_SCCB_ReadReg>:
 * :
 *    1-ɹ
 *    0-ʧ
 */          
uint8 LPLD_SCCB_ReadReg(uint8 reg_addr, uint8* data, uint16 length)
{	
    1af0:	b580      	push	{r7, lr}
    1af2:	b082      	sub	sp, #8
    1af4:	af00      	add	r7, sp, #0
    1af6:	6039      	str	r1, [r7, #0]
    1af8:	4613      	mov	r3, r2
    1afa:	4602      	mov	r2, r0
    1afc:	71fa      	strb	r2, [r7, #7]
    1afe:	80bb      	strh	r3, [r7, #4]
  if(!LPLD_SCCB_Start())
    1b00:	f000 f854 	bl	1bac <LPLD_SCCB_Start>
    1b04:	4603      	mov	r3, r0
    1b06:	2b00      	cmp	r3, #0
    1b08:	d102      	bne.n	1b10 <LPLD_SCCB_ReadReg+0x20>
  {
    return 0;
    1b0a:	f04f 0300 	mov.w	r3, #0
    1b0e:	e048      	b.n	1ba2 <LPLD_SCCB_ReadReg+0xb2>
  }
  LPLD_SCCB_SendByte( SCCB_DEV_ADR ); 
    1b10:	f04f 0042 	mov.w	r0, #66	; 0x42
    1b14:	f000 f988 	bl	1e28 <LPLD_SCCB_SendByte>
  if( !LPLD_SCCB_WaitAck() )
    1b18:	f000 f938 	bl	1d8c <LPLD_SCCB_WaitAck>
    1b1c:	4603      	mov	r3, r0
    1b1e:	2b00      	cmp	r3, #0
    1b20:	d104      	bne.n	1b2c <LPLD_SCCB_ReadReg+0x3c>
  {
    LPLD_SCCB_Stop(); 
    1b22:	f000 f8ab 	bl	1c7c <LPLD_SCCB_Stop>
    return 0;
    1b26:	f04f 0300 	mov.w	r3, #0
    1b2a:	e03a      	b.n	1ba2 <LPLD_SCCB_ReadReg+0xb2>
  }
  LPLD_SCCB_SendByte( reg_addr ); 
    1b2c:	79fb      	ldrb	r3, [r7, #7]
    1b2e:	4618      	mov	r0, r3
    1b30:	f000 f97a 	bl	1e28 <LPLD_SCCB_SendByte>
  LPLD_SCCB_WaitAck();	
    1b34:	f000 f92a 	bl	1d8c <LPLD_SCCB_WaitAck>
  LPLD_SCCB_Stop(); 
    1b38:	f000 f8a0 	bl	1c7c <LPLD_SCCB_Stop>
  
  if(!LPLD_SCCB_Start())
    1b3c:	f000 f836 	bl	1bac <LPLD_SCCB_Start>
    1b40:	4603      	mov	r3, r0
    1b42:	2b00      	cmp	r3, #0
    1b44:	d102      	bne.n	1b4c <LPLD_SCCB_ReadReg+0x5c>
  {
    return 0;
    1b46:	f04f 0300 	mov.w	r3, #0
    1b4a:	e02a      	b.n	1ba2 <LPLD_SCCB_ReadReg+0xb2>
  }
  LPLD_SCCB_SendByte( SCCB_DEV_ADR + 1 );
    1b4c:	f04f 0043 	mov.w	r0, #67	; 0x43
    1b50:	f000 f96a 	bl	1e28 <LPLD_SCCB_SendByte>
  
  if(!LPLD_SCCB_WaitAck())
    1b54:	f000 f91a 	bl	1d8c <LPLD_SCCB_WaitAck>
    1b58:	4603      	mov	r3, r0
    1b5a:	2b00      	cmp	r3, #0
    1b5c:	d11a      	bne.n	1b94 <LPLD_SCCB_ReadReg+0xa4>
  {
    LPLD_SCCB_Stop(); 
    1b5e:	f000 f88d 	bl	1c7c <LPLD_SCCB_Stop>
    return 0;
    1b62:	f04f 0300 	mov.w	r3, #0
    1b66:	e01c      	b.n	1ba2 <LPLD_SCCB_ReadReg+0xb2>
  }
  while(length)
  {
    *data = LPLD_SCCB_ReceiveByte();
    1b68:	f000 f9b0 	bl	1ecc <LPLD_SCCB_ReceiveByte>
    1b6c:	4603      	mov	r3, r0
    1b6e:	461a      	mov	r2, r3
    1b70:	683b      	ldr	r3, [r7, #0]
    1b72:	701a      	strb	r2, [r3, #0]
    if(length == 1)
    1b74:	88bb      	ldrh	r3, [r7, #4]
    1b76:	2b01      	cmp	r3, #1
    1b78:	d102      	bne.n	1b80 <LPLD_SCCB_ReadReg+0x90>
    {
      LPLD_SCCB_NoAck();
    1b7a:	f000 f8d7 	bl	1d2c <LPLD_SCCB_NoAck>
    1b7e:	e001      	b.n	1b84 <LPLD_SCCB_ReadReg+0x94>
    }
    else
    {
      LPLD_SCCB_Ack(); 
    1b80:	f000 f8a4 	bl	1ccc <LPLD_SCCB_Ack>
    }
    data++;
    1b84:	683b      	ldr	r3, [r7, #0]
    1b86:	f103 0301 	add.w	r3, r3, #1
    1b8a:	603b      	str	r3, [r7, #0]
    length--;
    1b8c:	88bb      	ldrh	r3, [r7, #4]
    1b8e:	f103 33ff 	add.w	r3, r3, #4294967295
    1b92:	80bb      	strh	r3, [r7, #4]
  if(!LPLD_SCCB_WaitAck())
  {
    LPLD_SCCB_Stop(); 
    return 0;
  }
  while(length)
    1b94:	88bb      	ldrh	r3, [r7, #4]
    1b96:	2b00      	cmp	r3, #0
    1b98:	d1e6      	bne.n	1b68 <LPLD_SCCB_ReadReg+0x78>
      LPLD_SCCB_Ack(); 
    }
    data++;
    length--;
  }
  LPLD_SCCB_Stop();
    1b9a:	f000 f86f 	bl	1c7c <LPLD_SCCB_Stop>
  return 1;
    1b9e:	f04f 0301 	mov.w	r3, #1
}
    1ba2:	4618      	mov	r0, r3
    1ba4:	f107 0708 	add.w	r7, r7, #8
    1ba8:	46bd      	mov	sp, r7
    1baa:	bd80      	pop	{r7, pc}

00001bac <LPLD_SCCB_Start>:
/*
 * LPLD_SCCB_Start
 * SCCBʼźţڲ
 */
uint8 LPLD_SCCB_Start(void)
{
    1bac:	b580      	push	{r7, lr}
    1bae:	af00      	add	r7, sp, #0
  SCCB_SDA_O=1;//ߵƽ
    1bb0:	f04f 0364 	mov.w	r3, #100	; 0x64
    1bb4:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1bb8:	f04f 0201 	mov.w	r2, #1
    1bbc:	601a      	str	r2, [r3, #0]
  SCCB_SCL=1;   //ʱߵƽ 
    1bbe:	f04f 0368 	mov.w	r3, #104	; 0x68
    1bc2:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1bc6:	f04f 0201 	mov.w	r2, #1
    1bca:	601a      	str	r2, [r3, #0]
  SCCB_DELAY();
    1bcc:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    1bd0:	f000 f9de 	bl	1f90 <LPLD_SCCB_Delay>
  
  SCCB_SDA_IN();//Ϊ
    1bd4:	f44f 7339 	mov.w	r3, #740	; 0x2e4
    1bd8:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1bdc:	f04f 0200 	mov.w	r2, #0
    1be0:	601a      	str	r2, [r3, #0]
  if(!SCCB_SDA_I)
    1be2:	f44f 7319 	mov.w	r3, #612	; 0x264
    1be6:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1bea:	681b      	ldr	r3, [r3, #0]
    1bec:	2b00      	cmp	r3, #0
    1bee:	d109      	bne.n	1c04 <LPLD_SCCB_Start+0x58>
  {
    SCCB_SDA_OUT();	
    1bf0:	f44f 7339 	mov.w	r3, #740	; 0x2e4
    1bf4:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1bf8:	f04f 0201 	mov.w	r2, #1
    1bfc:	601a      	str	r2, [r3, #0]
    return 0;
    1bfe:	f04f 0300 	mov.w	r3, #0
    1c02:	e039      	b.n	1c78 <LPLD_SCCB_Start+0xcc>
  }
  SCCB_SDA_OUT();//Ϊ;	
    1c04:	f44f 7339 	mov.w	r3, #740	; 0x2e4
    1c08:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1c0c:	f04f 0201 	mov.w	r2, #1
    1c10:	601a      	str	r2, [r3, #0]
  SCCB_SDA_O=0; //͵ƽ
    1c12:	f04f 0364 	mov.w	r3, #100	; 0x64
    1c16:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1c1a:	f04f 0200 	mov.w	r2, #0
    1c1e:	601a      	str	r2, [r3, #0]
  
  SCCB_DELAY();
    1c20:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    1c24:	f000 f9b4 	bl	1f90 <LPLD_SCCB_Delay>
  
  SCCB_SDA_IN();//Ϊ
    1c28:	f44f 7339 	mov.w	r3, #740	; 0x2e4
    1c2c:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1c30:	f04f 0200 	mov.w	r2, #0
    1c34:	601a      	str	r2, [r3, #0]
  if(SCCB_SDA_I) 
    1c36:	f44f 7319 	mov.w	r3, #612	; 0x264
    1c3a:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1c3e:	681b      	ldr	r3, [r3, #0]
    1c40:	2b00      	cmp	r3, #0
    1c42:	d009      	beq.n	1c58 <LPLD_SCCB_Start+0xac>
  {
    SCCB_SDA_OUT();
    1c44:	f44f 7339 	mov.w	r3, #740	; 0x2e4
    1c48:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1c4c:	f04f 0201 	mov.w	r2, #1
    1c50:	601a      	str	r2, [r3, #0]
    return 0;
    1c52:	f04f 0300 	mov.w	r3, #0
    1c56:	e00f      	b.n	1c78 <LPLD_SCCB_Start+0xcc>
  }
  SCCB_SDA_OUT();//Ϊ
    1c58:	f44f 7339 	mov.w	r3, #740	; 0x2e4
    1c5c:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1c60:	f04f 0201 	mov.w	r2, #1
    1c64:	601a      	str	r2, [r3, #0]
  SCCB_SDA_O=0;//͵ƽ
    1c66:	f04f 0364 	mov.w	r3, #100	; 0x64
    1c6a:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1c6e:	f04f 0200 	mov.w	r2, #0
    1c72:	601a      	str	r2, [r3, #0]
  return 1;
    1c74:	f04f 0301 	mov.w	r3, #1
}
    1c78:	4618      	mov	r0, r3
    1c7a:	bd80      	pop	{r7, pc}

00001c7c <LPLD_SCCB_Stop>:
/*
 * LPLD_SCCB_Stop
 * SCCBֹͣźţڲ
 */
static void LPLD_SCCB_Stop(void)
{
    1c7c:	b580      	push	{r7, lr}
    1c7e:	af00      	add	r7, sp, #0
  SCCB_SCL=0;
    1c80:	f04f 0368 	mov.w	r3, #104	; 0x68
    1c84:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1c88:	f04f 0200 	mov.w	r2, #0
    1c8c:	601a      	str	r2, [r3, #0]
  SCCB_SDA_O=0;
    1c8e:	f04f 0364 	mov.w	r3, #100	; 0x64
    1c92:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1c96:	f04f 0200 	mov.w	r2, #0
    1c9a:	601a      	str	r2, [r3, #0]
  SCCB_DELAY();
    1c9c:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    1ca0:	f000 f976 	bl	1f90 <LPLD_SCCB_Delay>
  
  SCCB_SCL=1;
    1ca4:	f04f 0368 	mov.w	r3, #104	; 0x68
    1ca8:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1cac:	f04f 0201 	mov.w	r2, #1
    1cb0:	601a      	str	r2, [r3, #0]
  SCCB_SDA_O=1;
    1cb2:	f04f 0364 	mov.w	r3, #100	; 0x64
    1cb6:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1cba:	f04f 0201 	mov.w	r2, #1
    1cbe:	601a      	str	r2, [r3, #0]
  SCCB_DELAY();
    1cc0:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    1cc4:	f000 f964 	bl	1f90 <LPLD_SCCB_Delay>
}
    1cc8:	bd80      	pop	{r7, pc}
    1cca:	bf00      	nop

00001ccc <LPLD_SCCB_Ack>:
/*
 * LPLD_SCCB_Stop
 * SCCBӦźţڲ
 */
static void LPLD_SCCB_Ack(void)
{	
    1ccc:	b580      	push	{r7, lr}
    1cce:	af00      	add	r7, sp, #0
  SCCB_SCL=0;
    1cd0:	f04f 0368 	mov.w	r3, #104	; 0x68
    1cd4:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1cd8:	f04f 0200 	mov.w	r2, #0
    1cdc:	601a      	str	r2, [r3, #0]
  SCCB_DELAY();
    1cde:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    1ce2:	f000 f955 	bl	1f90 <LPLD_SCCB_Delay>
  
  SCCB_SDA_O=0;
    1ce6:	f04f 0364 	mov.w	r3, #100	; 0x64
    1cea:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1cee:	f04f 0200 	mov.w	r2, #0
    1cf2:	601a      	str	r2, [r3, #0]
  SCCB_DELAY();
    1cf4:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    1cf8:	f000 f94a 	bl	1f90 <LPLD_SCCB_Delay>
  
  SCCB_SCL=1;
    1cfc:	f04f 0368 	mov.w	r3, #104	; 0x68
    1d00:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1d04:	f04f 0201 	mov.w	r2, #1
    1d08:	601a      	str	r2, [r3, #0]
  SCCB_DELAY();
    1d0a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    1d0e:	f000 f93f 	bl	1f90 <LPLD_SCCB_Delay>
  
  SCCB_SCL=0;
    1d12:	f04f 0368 	mov.w	r3, #104	; 0x68
    1d16:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1d1a:	f04f 0200 	mov.w	r2, #0
    1d1e:	601a      	str	r2, [r3, #0]
  SCCB_DELAY();
    1d20:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    1d24:	f000 f934 	bl	1f90 <LPLD_SCCB_Delay>
}
    1d28:	bd80      	pop	{r7, pc}
    1d2a:	bf00      	nop

00001d2c <LPLD_SCCB_NoAck>:
/*
 * LPLD_SCCB_NoAck
 * SCCBӦźţڲ
 */
static void LPLD_SCCB_NoAck(void)
{	
    1d2c:	b580      	push	{r7, lr}
    1d2e:	af00      	add	r7, sp, #0
  SCCB_SCL=0;
    1d30:	f04f 0368 	mov.w	r3, #104	; 0x68
    1d34:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1d38:	f04f 0200 	mov.w	r2, #0
    1d3c:	601a      	str	r2, [r3, #0]
  SCCB_DELAY();
    1d3e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    1d42:	f000 f925 	bl	1f90 <LPLD_SCCB_Delay>
  SCCB_SDA_O=1;
    1d46:	f04f 0364 	mov.w	r3, #100	; 0x64
    1d4a:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1d4e:	f04f 0201 	mov.w	r2, #1
    1d52:	601a      	str	r2, [r3, #0]
  SCCB_DELAY();
    1d54:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    1d58:	f000 f91a 	bl	1f90 <LPLD_SCCB_Delay>
  SCCB_SCL=1;
    1d5c:	f04f 0368 	mov.w	r3, #104	; 0x68
    1d60:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1d64:	f04f 0201 	mov.w	r2, #1
    1d68:	601a      	str	r2, [r3, #0]
  SCCB_DELAY();
    1d6a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    1d6e:	f000 f90f 	bl	1f90 <LPLD_SCCB_Delay>
  SCCB_SCL=0;
    1d72:	f04f 0368 	mov.w	r3, #104	; 0x68
    1d76:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1d7a:	f04f 0200 	mov.w	r2, #0
    1d7e:	601a      	str	r2, [r3, #0]
  SCCB_DELAY();
    1d80:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    1d84:	f000 f904 	bl	1f90 <LPLD_SCCB_Delay>
}
    1d88:	bd80      	pop	{r7, pc}
    1d8a:	bf00      	nop

00001d8c <LPLD_SCCB_WaitAck>:
/*
 * LPLD_SCCB_WaitAck
 * SCCBȴӦźţڲ
 */
static uint8 LPLD_SCCB_WaitAck(void) 	
{
    1d8c:	b580      	push	{r7, lr}
    1d8e:	af00      	add	r7, sp, #0
  SCCB_SCL=0;//ʱߵ͵ƽ
    1d90:	f04f 0368 	mov.w	r3, #104	; 0x68
    1d94:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1d98:	f04f 0200 	mov.w	r2, #0
    1d9c:	601a      	str	r2, [r3, #0]
  SCCB_DELAY(); 
    1d9e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    1da2:	f000 f8f5 	bl	1f90 <LPLD_SCCB_Delay>
  
 SCCB_SDA_IN();//Ϊ**
    1da6:	f44f 7339 	mov.w	r3, #740	; 0x2e4
    1daa:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1dae:	f04f 0200 	mov.w	r2, #0
    1db2:	601a      	str	r2, [r3, #0]
  SCCB_DELAY();
    1db4:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    1db8:	f000 f8ea 	bl	1f90 <LPLD_SCCB_Delay>
  
  SCCB_SCL=1;//ʱ߸ߵƽ
    1dbc:	f04f 0368 	mov.w	r3, #104	; 0x68
    1dc0:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1dc4:	f04f 0201 	mov.w	r2, #1
    1dc8:	601a      	str	r2, [r3, #0]
  
  SCCB_DELAY();
    1dca:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    1dce:	f000 f8df 	bl	1f90 <LPLD_SCCB_Delay>
  
  if(SCCB_SDA_I)
    1dd2:	f44f 7319 	mov.w	r3, #612	; 0x264
    1dd6:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1dda:	681b      	ldr	r3, [r3, #0]
    1ddc:	2b00      	cmp	r3, #0
    1dde:	d010      	beq.n	1e02 <LPLD_SCCB_WaitAck+0x76>
  {
    SCCB_SDA_OUT();
    1de0:	f44f 7339 	mov.w	r3, #740	; 0x2e4
    1de4:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1de8:	f04f 0201 	mov.w	r2, #1
    1dec:	601a      	str	r2, [r3, #0]
    SCCB_SCL=0;
    1dee:	f04f 0368 	mov.w	r3, #104	; 0x68
    1df2:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1df6:	f04f 0200 	mov.w	r2, #0
    1dfa:	601a      	str	r2, [r3, #0]
    return 0;
    1dfc:	f04f 0300 	mov.w	r3, #0
    1e00:	e00f      	b.n	1e22 <LPLD_SCCB_WaitAck+0x96>
  }
  SCCB_SDA_OUT();//Ϊ
    1e02:	f44f 7339 	mov.w	r3, #740	; 0x2e4
    1e06:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1e0a:	f04f 0201 	mov.w	r2, #1
    1e0e:	601a      	str	r2, [r3, #0]
  SCCB_SCL=0; //ʱߵ͵ƽ
    1e10:	f04f 0368 	mov.w	r3, #104	; 0x68
    1e14:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1e18:	f04f 0200 	mov.w	r2, #0
    1e1c:	601a      	str	r2, [r3, #0]
  return 1;
    1e1e:	f04f 0301 	mov.w	r3, #1
}
    1e22:	4618      	mov	r0, r3
    1e24:	bd80      	pop	{r7, pc}
    1e26:	bf00      	nop

00001e28 <LPLD_SCCB_SendByte>:
/*
 * LPLD_SCCB_SendByte
 * SCCBݣڲ
 */
static void LPLD_SCCB_SendByte(uint8 data) 
{
    1e28:	b580      	push	{r7, lr}
    1e2a:	b084      	sub	sp, #16
    1e2c:	af00      	add	r7, sp, #0
    1e2e:	4603      	mov	r3, r0
    1e30:	71fb      	strb	r3, [r7, #7]
  uint8 i=8;
    1e32:	f04f 0308 	mov.w	r3, #8
    1e36:	73fb      	strb	r3, [r7, #15]
  while(i--)
    1e38:	e030      	b.n	1e9c <LPLD_SCCB_SendByte+0x74>
  {
    SCCB_SCL=0;
    1e3a:	f04f 0368 	mov.w	r3, #104	; 0x68
    1e3e:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1e42:	f04f 0200 	mov.w	r2, #0
    1e46:	601a      	str	r2, [r3, #0]
    SCCB_DELAY();
    1e48:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    1e4c:	f000 f8a0 	bl	1f90 <LPLD_SCCB_Delay>
    if(data&0x80)
    1e50:	79fb      	ldrb	r3, [r7, #7]
    1e52:	b25b      	sxtb	r3, r3
    1e54:	2b00      	cmp	r3, #0
    1e56:	da07      	bge.n	1e68 <LPLD_SCCB_SendByte+0x40>
    {
      SCCB_SDA_O=1; 
    1e58:	f04f 0364 	mov.w	r3, #100	; 0x64
    1e5c:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1e60:	f04f 0201 	mov.w	r2, #1
    1e64:	601a      	str	r2, [r3, #0]
    1e66:	e006      	b.n	1e76 <LPLD_SCCB_SendByte+0x4e>
    }
    else 
    {
      SCCB_SDA_O=0;   
    1e68:	f04f 0364 	mov.w	r3, #100	; 0x64
    1e6c:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1e70:	f04f 0200 	mov.w	r2, #0
    1e74:	601a      	str	r2, [r3, #0]
    }
    data<<=1;
    1e76:	79fb      	ldrb	r3, [r7, #7]
    1e78:	ea4f 0343 	mov.w	r3, r3, lsl #1
    1e7c:	71fb      	strb	r3, [r7, #7]
    SCCB_DELAY();
    1e7e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    1e82:	f000 f885 	bl	1f90 <LPLD_SCCB_Delay>
    SCCB_SCL=1;
    1e86:	f04f 0368 	mov.w	r3, #104	; 0x68
    1e8a:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1e8e:	f04f 0201 	mov.w	r2, #1
    1e92:	601a      	str	r2, [r3, #0]
    SCCB_DELAY();
    1e94:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    1e98:	f000 f87a 	bl	1f90 <LPLD_SCCB_Delay>
 * SCCBݣڲ
 */
static void LPLD_SCCB_SendByte(uint8 data) 
{
  uint8 i=8;
  while(i--)
    1e9c:	7bfb      	ldrb	r3, [r7, #15]
    1e9e:	2b00      	cmp	r3, #0
    1ea0:	bf0c      	ite	eq
    1ea2:	2300      	moveq	r3, #0
    1ea4:	2301      	movne	r3, #1
    1ea6:	b2db      	uxtb	r3, r3
    1ea8:	7bfa      	ldrb	r2, [r7, #15]
    1eaa:	f102 32ff 	add.w	r2, r2, #4294967295
    1eae:	73fa      	strb	r2, [r7, #15]
    1eb0:	2b00      	cmp	r3, #0
    1eb2:	d1c2      	bne.n	1e3a <LPLD_SCCB_SendByte+0x12>
    data<<=1;
    SCCB_DELAY();
    SCCB_SCL=1;
    SCCB_DELAY();
  }
  SCCB_SCL=0;
    1eb4:	f04f 0368 	mov.w	r3, #104	; 0x68
    1eb8:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1ebc:	f04f 0200 	mov.w	r2, #0
    1ec0:	601a      	str	r2, [r3, #0]
}
    1ec2:	f107 0710 	add.w	r7, r7, #16
    1ec6:	46bd      	mov	sp, r7
    1ec8:	bd80      	pop	{r7, pc}
    1eca:	bf00      	nop

00001ecc <LPLD_SCCB_ReceiveByte>:
/*
 * LPLD_SCCB_SendByte
 * SCCBݣڲ
 */
static uint8 LPLD_SCCB_ReceiveByte(void)  
{ 
    1ecc:	b580      	push	{r7, lr}
    1ece:	b082      	sub	sp, #8
    1ed0:	af00      	add	r7, sp, #0
  uint8 i=8;
    1ed2:	f04f 0308 	mov.w	r3, #8
    1ed6:	71fb      	strb	r3, [r7, #7]
  uint8 ReceiveByte=0;
    1ed8:	f04f 0300 	mov.w	r3, #0
    1edc:	71bb      	strb	r3, [r7, #6]
  
  SCCB_SDA_O=1;	
    1ede:	f04f 0364 	mov.w	r3, #100	; 0x64
    1ee2:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1ee6:	f04f 0201 	mov.w	r2, #1
    1eea:	601a      	str	r2, [r3, #0]
  SCCB_DELAY();
    1eec:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    1ef0:	f000 f84e 	bl	1f90 <LPLD_SCCB_Delay>
  
  SCCB_SDA_IN();	
    1ef4:	f44f 7339 	mov.w	r3, #740	; 0x2e4
    1ef8:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1efc:	f04f 0200 	mov.w	r2, #0
    1f00:	601a      	str	r2, [r3, #0]
  
  while(i--)
    1f02:	e024      	b.n	1f4e <LPLD_SCCB_ReceiveByte+0x82>
  {
    ReceiveByte<<=1;      
    1f04:	79bb      	ldrb	r3, [r7, #6]
    1f06:	ea4f 0343 	mov.w	r3, r3, lsl #1
    1f0a:	71bb      	strb	r3, [r7, #6]
    SCCB_SCL=0;
    1f0c:	f04f 0368 	mov.w	r3, #104	; 0x68
    1f10:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1f14:	f04f 0200 	mov.w	r2, #0
    1f18:	601a      	str	r2, [r3, #0]
    SCCB_DELAY();
    1f1a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    1f1e:	f000 f837 	bl	1f90 <LPLD_SCCB_Delay>
    
    SCCB_SCL=1;
    1f22:	f04f 0368 	mov.w	r3, #104	; 0x68
    1f26:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1f2a:	f04f 0201 	mov.w	r2, #1
    1f2e:	601a      	str	r2, [r3, #0]
    SCCB_DELAY();	
    1f30:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    1f34:	f000 f82c 	bl	1f90 <LPLD_SCCB_Delay>
    
    if(SCCB_SDA_I)
    1f38:	f44f 7319 	mov.w	r3, #612	; 0x264
    1f3c:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1f40:	681b      	ldr	r3, [r3, #0]
    1f42:	2b00      	cmp	r3, #0
    1f44:	d003      	beq.n	1f4e <LPLD_SCCB_ReceiveByte+0x82>
    {
      ReceiveByte|=0x01;
    1f46:	79bb      	ldrb	r3, [r7, #6]
    1f48:	f043 0301 	orr.w	r3, r3, #1
    1f4c:	71bb      	strb	r3, [r7, #6]
  SCCB_SDA_O=1;	
  SCCB_DELAY();
  
  SCCB_SDA_IN();	
  
  while(i--)
    1f4e:	79fb      	ldrb	r3, [r7, #7]
    1f50:	2b00      	cmp	r3, #0
    1f52:	bf0c      	ite	eq
    1f54:	2300      	moveq	r3, #0
    1f56:	2301      	movne	r3, #1
    1f58:	b2db      	uxtb	r3, r3
    1f5a:	79fa      	ldrb	r2, [r7, #7]
    1f5c:	f102 32ff 	add.w	r2, r2, #4294967295
    1f60:	71fa      	strb	r2, [r7, #7]
    1f62:	2b00      	cmp	r3, #0
    1f64:	d1ce      	bne.n	1f04 <LPLD_SCCB_ReceiveByte+0x38>
    {
      ReceiveByte|=0x01;
    }
    
  }
  SCCB_SDA_OUT();
    1f66:	f44f 7339 	mov.w	r3, #740	; 0x2e4
    1f6a:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1f6e:	f04f 0201 	mov.w	r2, #1
    1f72:	601a      	str	r2, [r3, #0]
  SCCB_SCL=0;
    1f74:	f04f 0368 	mov.w	r3, #104	; 0x68
    1f78:	f2c4 33fe 	movt	r3, #17406	; 0x43fe
    1f7c:	f04f 0200 	mov.w	r2, #0
    1f80:	601a      	str	r2, [r3, #0]
  
  return ReceiveByte;
    1f82:	79bb      	ldrb	r3, [r7, #6]
}
    1f84:	4618      	mov	r0, r3
    1f86:	f107 0708 	add.w	r7, r7, #8
    1f8a:	46bd      	mov	sp, r7
    1f8c:	bd80      	pop	{r7, pc}
    1f8e:	bf00      	nop

00001f90 <LPLD_SCCB_Delay>:
/*
 * LPLD_SCCB_SendByte
 * SCCBʱڲ
 */
static void LPLD_SCCB_Delay(uint16 i)
{	
    1f90:	b480      	push	{r7}
    1f92:	b083      	sub	sp, #12
    1f94:	af00      	add	r7, sp, #0
    1f96:	4603      	mov	r3, r0
    1f98:	80fb      	strh	r3, [r7, #6]
  while(i) 
    1f9a:	e003      	b.n	1fa4 <LPLD_SCCB_Delay+0x14>
    i--; 
    1f9c:	88fb      	ldrh	r3, [r7, #6]
    1f9e:	f103 33ff 	add.w	r3, r3, #4294967295
    1fa2:	80fb      	strh	r3, [r7, #6]
 * LPLD_SCCB_SendByte
 * SCCBʱڲ
 */
static void LPLD_SCCB_Delay(uint16 i)
{	
  while(i) 
    1fa4:	88fb      	ldrh	r3, [r7, #6]
    1fa6:	2b00      	cmp	r3, #0
    1fa8:	d1f8      	bne.n	1f9c <LPLD_SCCB_Delay+0xc>
    i--; 
}
    1faa:	f107 070c 	add.w	r7, r7, #12
    1fae:	46bd      	mov	sp, r7
    1fb0:	bc80      	pop	{r7}
    1fb2:	4770      	bx	lr

00001fb4 <LPLD_ADC_Init>:
 * 输出:
 *    0--配置错误
 *    1--配置成功
 */
uint8 LPLD_ADC_Init(ADC_InitTypeDef adc_init_structure)
{
    1fb4:	b084      	sub	sp, #16
    1fb6:	b580      	push	{r7, lr}
    1fb8:	b086      	sub	sp, #24
    1fba:	af00      	add	r7, sp, #0
    1fbc:	f107 0c20 	add.w	ip, r7, #32
    1fc0:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  uint8 i;
  ADC_MemMapPtr adcx = adc_init_structure.ADC_Adcx;
    1fc4:	6a3b      	ldr	r3, [r7, #32]
    1fc6:	613b      	str	r3, [r7, #16]
  uint8 diff = adc_init_structure.ADC_DiffMode;
    1fc8:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
    1fcc:	73fb      	strb	r3, [r7, #15]
  uint8 mode = adc_init_structure.ADC_BitMode;
    1fce:	f897 3025 	ldrb.w	r3, [r7, #37]	; 0x25
    1fd2:	73bb      	strb	r3, [r7, #14]
  uint8 time = adc_init_structure.ADC_SampleTimeCfg;
    1fd4:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
    1fd8:	737b      	strb	r3, [r7, #13]
  uint8 ltime = adc_init_structure.ADC_LongSampleTimeSel;
    1fda:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
    1fde:	733b      	strb	r3, [r7, #12]
  uint8 avg = adc_init_structure.ADC_HwAvgSel;
    1fe0:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
    1fe4:	72fb      	strb	r3, [r7, #11]
  uint8 muxab = adc_init_structure.ADC_MuxSel;
    1fe6:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
    1fea:	72bb      	strb	r3, [r7, #10]
  uint8 pga = adc_init_structure.ADC_PgaGain;
    1fec:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
    1ff0:	727b      	strb	r3, [r7, #9]
  uint8 hwtrg = adc_init_structure.ADC_HwTrgCfg;
    1ff2:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    1ff6:	723b      	strb	r3, [r7, #8]
  ADC_ISR_CALLBACK isr_func = adc_init_structure.ADC_Isr;
    1ff8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    1ffa:	607b      	str	r3, [r7, #4]
 
  //配置ADC时钟 //这里貌似只配置了两个还要另行配置其他的几个
  if(adcx == ADC0)
    1ffc:	693a      	ldr	r2, [r7, #16]
    1ffe:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    2002:	f2c4 0303 	movt	r3, #16387	; 0x4003
    2006:	429a      	cmp	r2, r3
    2008:	d117      	bne.n	203a <LPLD_ADC_Init+0x86>
  {
    i=0;
    200a:	f04f 0300 	mov.w	r3, #0
    200e:	75fb      	strb	r3, [r7, #23]
    SIM_SCGC6 |= SIM_SCGC6_ADC0_MASK;   // 开启ADC0时钟
    2010:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    2014:	f2c4 0304 	movt	r3, #16388	; 0x4004
    2018:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    201c:	f2c4 0204 	movt	r2, #16388	; 0x4004
    2020:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    2024:	f102 021c 	add.w	r2, r2, #28
    2028:	6812      	ldr	r2, [r2, #0]
    202a:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
    202e:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    2032:	f103 031c 	add.w	r3, r3, #28
    2036:	601a      	str	r2, [r3, #0]
    2038:	e021      	b.n	207e <LPLD_ADC_Init+0xca>
  }
  else if(adcx == ADC1)
    203a:	693a      	ldr	r2, [r7, #16]
    203c:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    2040:	f2c4 030b 	movt	r3, #16395	; 0x400b
    2044:	429a      	cmp	r2, r3
    2046:	d117      	bne.n	2078 <LPLD_ADC_Init+0xc4>
  {
    i=1;
    2048:	f04f 0301 	mov.w	r3, #1
    204c:	75fb      	strb	r3, [r7, #23]
    SIM_SCGC3 |= SIM_SCGC3_ADC1_MASK;   // 开启ADC1时钟
    204e:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    2052:	f2c4 0304 	movt	r3, #16388	; 0x4004
    2056:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    205a:	f2c4 0204 	movt	r2, #16388	; 0x4004
    205e:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    2062:	f102 0210 	add.w	r2, r2, #16
    2066:	6812      	ldr	r2, [r2, #0]
    2068:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
    206c:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    2070:	f103 0310 	add.w	r3, r3, #16
    2074:	601a      	str	r2, [r3, #0]
    2076:	e002      	b.n	207e <LPLD_ADC_Init+0xca>
  }
  else 
  {
    return 0;
    2078:	f04f 0300 	mov.w	r3, #0
    207c:	e078      	b.n	2170 <LPLD_ADC_Init+0x1bc>
  }

  if(adc_init_structure.ADC_CalEnable == TRUE)
    207e:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
    2082:	2b01      	cmp	r3, #1
    2084:	d102      	bne.n	208c <LPLD_ADC_Init+0xd8>
    LPLD_ADC_Cal(adcx);  //进行ADC校准
    2086:	6938      	ldr	r0, [r7, #16]
    2088:	f000 fb36 	bl	26f8 <LPLD_ADC_Cal>
  
  //设置ADCCFG1寄存器
  adcx->CFG1  &=   (~ADC_CFG1_ADLPC_MASK);         // 重新为正常使用进行配置
    208c:	693b      	ldr	r3, [r7, #16]
    208e:	689b      	ldr	r3, [r3, #8]
    2090:	f023 0280 	bic.w	r2, r3, #128	; 0x80
    2094:	693b      	ldr	r3, [r7, #16]
    2096:	609a      	str	r2, [r3, #8]
  adcx->CFG1  |=    ADC_CFG1_ADIV(ADIV_1)          // ADC输入时钟分频为 1
    2098:	693b      	ldr	r3, [r7, #16]
    209a:	689a      	ldr	r2, [r3, #8]
                  | (time)                           // 设置长短时间采样模式
                  | ADC_CFG1_ADICLK(ADICLK_BUS_2)  // ADC输入时钟源为 BusClk
    209c:	7b7b      	ldrb	r3, [r7, #13]
    209e:	f043 0301 	orr.w	r3, r3, #1
    20a2:	b2db      	uxtb	r3, r3
    20a4:	4619      	mov	r1, r3
                  | ADC_CFG1_MODE(mode);           //设置ADC转换精度
    20a6:	7bbb      	ldrb	r3, [r7, #14]
    20a8:	ea4f 0383 	mov.w	r3, r3, lsl #2
    20ac:	f003 030c 	and.w	r3, r3, #12
    20b0:	430b      	orrs	r3, r1
  if(adc_init_structure.ADC_CalEnable == TRUE)
    LPLD_ADC_Cal(adcx);  //进行ADC校准
  
  //设置ADCCFG1寄存器
  adcx->CFG1  &=   (~ADC_CFG1_ADLPC_MASK);         // 重新为正常使用进行配置
  adcx->CFG1  |=    ADC_CFG1_ADIV(ADIV_1)          // ADC输入时钟分频为 1
    20b2:	431a      	orrs	r2, r3
    20b4:	693b      	ldr	r3, [r7, #16]
    20b6:	609a      	str	r2, [r3, #8]
                  | (time)                           // 设置长短时间采样模式
                  | ADC_CFG1_ADICLK(ADICLK_BUS_2)  // ADC输入时钟源为 BusClk
                  | ADC_CFG1_MODE(mode);           //设置ADC转换精度

  //设置ADCCFG2寄存器
  adcx->CFG2 &=  (~ADC_CFG2_ADACKEN_MASK);   //禁用异步时钟输出
    20b8:	693b      	ldr	r3, [r7, #16]
    20ba:	68db      	ldr	r3, [r3, #12]
    20bc:	f023 0208 	bic.w	r2, r3, #8
    20c0:	693b      	ldr	r3, [r7, #16]
    20c2:	60da      	str	r2, [r3, #12]
  adcx->CFG2 |=    (muxab)                      // ADC复用选择
    20c4:	693b      	ldr	r3, [r7, #16]
    20c6:	68da      	ldr	r2, [r3, #12]
                 | (ADC_CFG2_ADHSC_MASK)        // 高速转换
                 | ADC_CFG2_ADLSTS(ltime);    // 长采样时间时钟周期选择
    20c8:	7abb      	ldrb	r3, [r7, #10]
    20ca:	f043 0304 	orr.w	r3, r3, #4
    20ce:	b2db      	uxtb	r3, r3
    20d0:	4619      	mov	r1, r3
    20d2:	7b3b      	ldrb	r3, [r7, #12]
    20d4:	f003 0303 	and.w	r3, r3, #3
    20d8:	430b      	orrs	r3, r1
                  | ADC_CFG1_ADICLK(ADICLK_BUS_2)  // ADC输入时钟源为 BusClk
                  | ADC_CFG1_MODE(mode);           //设置ADC转换精度

  //设置ADCCFG2寄存器
  adcx->CFG2 &=  (~ADC_CFG2_ADACKEN_MASK);   //禁用异步时钟输出
  adcx->CFG2 |=    (muxab)                      // ADC复用选择
    20da:	431a      	orrs	r2, r3
    20dc:	693b      	ldr	r3, [r7, #16]
    20de:	60da      	str	r2, [r3, #12]
                 | (ADC_CFG2_ADHSC_MASK)        // 高速转换
                 | ADC_CFG2_ADLSTS(ltime);    // 长采样时间时钟周期选择
                                              // 总采样周期见K60技术文档 page:840
  //用于设定阈值
  adcx->CV1  = 0x1234u ; 
    20e0:	693b      	ldr	r3, [r7, #16]
    20e2:	f241 2234 	movw	r2, #4660	; 0x1234
    20e6:	619a      	str	r2, [r3, #24]
  adcx->CV2  = 0x5678u ;
    20e8:	693b      	ldr	r3, [r7, #16]
    20ea:	f245 6278 	movw	r2, #22136	; 0x5678
    20ee:	61da      	str	r2, [r3, #28]
 
  adcx->SC2  &= ((~ADC_SC2_ACFE_MASK)     //关闭比较功能 
    20f0:	693b      	ldr	r3, [r7, #16]
    20f2:	6a1b      	ldr	r3, [r3, #32]
    20f4:	f023 0224 	bic.w	r2, r3, #36	; 0x24
    20f8:	693b      	ldr	r3, [r7, #16]
    20fa:	621a      	str	r2, [r3, #32]
                 & (~ADC_SC2_DMAEN_MASK)); //关闭DMA
  adcx->SC2  |=  (hwtrg & ADC_SC2_ADTRG_MASK) //设置触发方式
    20fc:	693b      	ldr	r3, [r7, #16]
    20fe:	6a1a      	ldr	r2, [r3, #32]
    2100:	7a3b      	ldrb	r3, [r7, #8]
    2102:	f003 0340 	and.w	r3, r3, #64	; 0x40
    2106:	4313      	orrs	r3, r2
    2108:	f043 0218 	orr.w	r2, r3, #24
    210c:	693b      	ldr	r3, [r7, #16]
    210e:	621a      	str	r2, [r3, #32]
                 |  ADC_SC2_ACREN_MASK          //使能范围比较
                 |  ADC_SC2_ACFGT_MASK          //使能大于比较功能
                 |  ADC_SC2_REFSEL(REFSEL_EXT); //选择外部参考源VREFH和VREFL
  
  if(adc_init_structure.ADC_DmaEnable == TRUE) 
    2110:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    2114:	2b01      	cmp	r3, #1
    2116:	d105      	bne.n	2124 <LPLD_ADC_Init+0x170>
    adcx->SC2  |= ADC_SC2_DMAEN_MASK;           //使能DMA
    2118:	693b      	ldr	r3, [r7, #16]
    211a:	6a1b      	ldr	r3, [r3, #32]
    211c:	f043 0204 	orr.w	r2, r3, #4
    2120:	693b      	ldr	r3, [r7, #16]
    2122:	621a      	str	r2, [r3, #32]

  adcx->SC3  &=  (~ADC_SC3_CAL_MASK)          //关闭校准
    2124:	693b      	ldr	r3, [r7, #16]
    2126:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    2128:	f023 0288 	bic.w	r2, r3, #136	; 0x88
    212c:	693b      	ldr	r3, [r7, #16]
    212e:	625a      	str	r2, [r3, #36]	; 0x24
                 & (~ADC_SC3_ADCO_MASK);         //选择一次转换
  adcx->SC3  |=  avg;                        //硬件平均
    2130:	693b      	ldr	r3, [r7, #16]
    2132:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    2134:	7afb      	ldrb	r3, [r7, #11]
    2136:	431a      	orrs	r2, r3
    2138:	693b      	ldr	r3, [r7, #16]
    213a:	625a      	str	r2, [r3, #36]	; 0x24
  
  adcx->PGA  = pga<<ADC_PGA_PGAG_SHIFT; 
    213c:	7a7b      	ldrb	r3, [r7, #9]
    213e:	ea4f 4303 	mov.w	r3, r3, lsl #16
    2142:	461a      	mov	r2, r3
    2144:	693b      	ldr	r3, [r7, #16]
    2146:	651a      	str	r2, [r3, #80]	; 0x50
  
  //校准完毕后再重新初始化ADC寄存器
  //adcx->SC1[0] = ADC_SC1_ADCH(AD31);    //复位SC1
  adcx->SC1[hwtrg & 0x01] = diff;         //设置单端、差分输入
    2148:	7a3b      	ldrb	r3, [r7, #8]
    214a:	f003 0201 	and.w	r2, r3, #1
    214e:	7bf9      	ldrb	r1, [r7, #15]
    2150:	693b      	ldr	r3, [r7, #16]
    2152:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  
  if(isr_func!= NULL)
    2156:	687b      	ldr	r3, [r7, #4]
    2158:	2b00      	cmp	r3, #0
    215a:	d007      	beq.n	216c <LPLD_ADC_Init+0x1b8>
  {
    ADC_ISR[i] = isr_func;
    215c:	7dfa      	ldrb	r2, [r7, #23]
    215e:	f241 53fc 	movw	r3, #5628	; 0x15fc
    2162:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    2166:	6879      	ldr	r1, [r7, #4]
    2168:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  }
  
  return 1;
    216c:	f04f 0301 	mov.w	r3, #1
}
    2170:	4618      	mov	r0, r3
    2172:	f107 0718 	add.w	r7, r7, #24
    2176:	46bd      	mov	sp, r7
    2178:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    217c:	b004      	add	sp, #16
    217e:	4770      	bx	lr

00002180 <LPLD_ADC_Deinit>:
 * 输出:
 *    0--配置错误
 *    1--配置成功
 */
uint8 LPLD_ADC_Deinit(ADC_InitTypeDef adc_init_structure)
{
    2180:	b084      	sub	sp, #16
    2182:	b480      	push	{r7}
    2184:	b083      	sub	sp, #12
    2186:	af00      	add	r7, sp, #0
    2188:	f107 0c10 	add.w	ip, r7, #16
    218c:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  ADC_MemMapPtr adcx = adc_init_structure.ADC_Adcx;
    2190:	693b      	ldr	r3, [r7, #16]
    2192:	607b      	str	r3, [r7, #4]
  uint8 hwtrg = adc_init_structure.ADC_HwTrgCfg;
    2194:	7f3b      	ldrb	r3, [r7, #28]
    2196:	70fb      	strb	r3, [r7, #3]
  
  adcx->SC1[hwtrg & 0x01] = ADC_SC1_ADCH(AD31);    //复位SC1
    2198:	78fb      	ldrb	r3, [r7, #3]
    219a:	f003 0201 	and.w	r2, r3, #1
    219e:	687b      	ldr	r3, [r7, #4]
    21a0:	f04f 011f 	mov.w	r1, #31
    21a4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  
  //配置ADC时钟
  if(adcx == ADC0)
    21a8:	687a      	ldr	r2, [r7, #4]
    21aa:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    21ae:	f2c4 0303 	movt	r3, #16387	; 0x4003
    21b2:	429a      	cmp	r2, r3
    21b4:	d114      	bne.n	21e0 <LPLD_ADC_Deinit+0x60>
  {
    SIM_SCGC6 &= ~(SIM_SCGC6_ADC0_MASK);   // 关闭ADC0时钟
    21b6:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    21ba:	f2c4 0304 	movt	r3, #16388	; 0x4004
    21be:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    21c2:	f2c4 0204 	movt	r2, #16388	; 0x4004
    21c6:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    21ca:	f102 021c 	add.w	r2, r2, #28
    21ce:	6812      	ldr	r2, [r2, #0]
    21d0:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
    21d4:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    21d8:	f103 031c 	add.w	r3, r3, #28
    21dc:	601a      	str	r2, [r3, #0]
    21de:	e01e      	b.n	221e <LPLD_ADC_Deinit+0x9e>
  }
  else if(adcx == ADC1)
    21e0:	687a      	ldr	r2, [r7, #4]
    21e2:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    21e6:	f2c4 030b 	movt	r3, #16395	; 0x400b
    21ea:	429a      	cmp	r2, r3
    21ec:	d114      	bne.n	2218 <LPLD_ADC_Deinit+0x98>
  {
    SIM_SCGC3 &= ~(SIM_SCGC3_ADC1_MASK);   // 关闭ADC1时钟
    21ee:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    21f2:	f2c4 0304 	movt	r3, #16388	; 0x4004
    21f6:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    21fa:	f2c4 0204 	movt	r2, #16388	; 0x4004
    21fe:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    2202:	f102 0210 	add.w	r2, r2, #16
    2206:	6812      	ldr	r2, [r2, #0]
    2208:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
    220c:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    2210:	f103 0310 	add.w	r3, r3, #16
    2214:	601a      	str	r2, [r3, #0]
    2216:	e002      	b.n	221e <LPLD_ADC_Deinit+0x9e>
  }
  else 
  {
    return 0;
    2218:	f04f 0300 	mov.w	r3, #0
    221c:	e001      	b.n	2222 <LPLD_ADC_Deinit+0xa2>
  }
  
  return 1;
    221e:	f04f 0301 	mov.w	r3, #1
}
    2222:	4618      	mov	r0, r3
    2224:	f107 070c 	add.w	r7, r7, #12
    2228:	46bd      	mov	sp, r7
    222a:	bc80      	pop	{r7}
    222c:	b004      	add	sp, #16
    222e:	4770      	bx	lr

00002230 <LPLD_ADC_Get>:
 * 输出:
 *    AD通道转换值(右对齐)，若为差分转换结果，则为二进制补码格式(需强制转换为int16)
 *
 */
uint16 LPLD_ADC_Get(ADC_MemMapPtr adcx, AdcChnEnum_Type chn)
{
    2230:	b480      	push	{r7}
    2232:	b083      	sub	sp, #12
    2234:	af00      	add	r7, sp, #0
    2236:	6078      	str	r0, [r7, #4]
    2238:	460b      	mov	r3, r1
    223a:	70fb      	strb	r3, [r7, #3]
  adcx->SC1[0] &= ~(ADC_SC1_AIEN_MASK);
    223c:	687b      	ldr	r3, [r7, #4]
    223e:	681b      	ldr	r3, [r3, #0]
    2240:	f023 0240 	bic.w	r2, r3, #64	; 0x40
    2244:	687b      	ldr	r3, [r7, #4]
    2246:	601a      	str	r2, [r3, #0]
  adcx->SC1[0] &= ~(ADC_SC1_ADCH_MASK);
    2248:	687b      	ldr	r3, [r7, #4]
    224a:	681b      	ldr	r3, [r3, #0]
    224c:	f023 021f 	bic.w	r2, r3, #31
    2250:	687b      	ldr	r3, [r7, #4]
    2252:	601a      	str	r2, [r3, #0]
  adcx->SC1[0] |= ADC_SC1_ADCH(chn);
    2254:	687b      	ldr	r3, [r7, #4]
    2256:	681a      	ldr	r2, [r3, #0]
    2258:	78fb      	ldrb	r3, [r7, #3]
    225a:	f003 031f 	and.w	r3, r3, #31
    225e:	431a      	orrs	r2, r3
    2260:	687b      	ldr	r3, [r7, #4]
    2262:	601a      	str	r2, [r3, #0]
  while((adcx->SC1[0]&ADC_SC1_COCO_MASK) == 0); //等待转换完成  
    2264:	bf00      	nop
    2266:	687b      	ldr	r3, [r7, #4]
    2268:	681b      	ldr	r3, [r3, #0]
    226a:	f003 0380 	and.w	r3, r3, #128	; 0x80
    226e:	2b00      	cmp	r3, #0
    2270:	d0f9      	beq.n	2266 <LPLD_ADC_Get+0x36>
  return adcx->R[0];
    2272:	687b      	ldr	r3, [r7, #4]
    2274:	691b      	ldr	r3, [r3, #16]
    2276:	b29b      	uxth	r3, r3
}
    2278:	4618      	mov	r0, r3
    227a:	f107 070c 	add.w	r7, r7, #12
    227e:	46bd      	mov	sp, r7
    2280:	bc80      	pop	{r7}
    2282:	4770      	bx	lr

00002284 <LPLD_ADC_EnableConversion>:
 * 输出:
 *    无
 *
 */
void LPLD_ADC_EnableConversion(ADC_MemMapPtr adcx, AdcChnEnum_Type chn, uint8 ab, boolean irq)
{
    2284:	b480      	push	{r7}
    2286:	b083      	sub	sp, #12
    2288:	af00      	add	r7, sp, #0
    228a:	6078      	str	r0, [r7, #4]
    228c:	70f9      	strb	r1, [r7, #3]
    228e:	70ba      	strb	r2, [r7, #2]
    2290:	707b      	strb	r3, [r7, #1]
  if(irq == TRUE)
    2292:	787b      	ldrb	r3, [r7, #1]
    2294:	2b01      	cmp	r3, #1
    2296:	d109      	bne.n	22ac <LPLD_ADC_EnableConversion+0x28>
  {
    adcx->SC1[ab] |= (ADC_SC1_AIEN_MASK);
    2298:	78ba      	ldrb	r2, [r7, #2]
    229a:	78b9      	ldrb	r1, [r7, #2]
    229c:	687b      	ldr	r3, [r7, #4]
    229e:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    22a2:	f043 0140 	orr.w	r1, r3, #64	; 0x40
    22a6:	687b      	ldr	r3, [r7, #4]
    22a8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  }
  adcx->SC1[ab] &= ~(ADC_SC1_ADCH_MASK);
    22ac:	78ba      	ldrb	r2, [r7, #2]
    22ae:	78b9      	ldrb	r1, [r7, #2]
    22b0:	687b      	ldr	r3, [r7, #4]
    22b2:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    22b6:	f023 011f 	bic.w	r1, r3, #31
    22ba:	687b      	ldr	r3, [r7, #4]
    22bc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  adcx->SC1[ab] |= ADC_SC1_ADCH(chn);
    22c0:	78ba      	ldrb	r2, [r7, #2]
    22c2:	78b9      	ldrb	r1, [r7, #2]
    22c4:	687b      	ldr	r3, [r7, #4]
    22c6:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
    22ca:	78fb      	ldrb	r3, [r7, #3]
    22cc:	f003 031f 	and.w	r3, r3, #31
    22d0:	4319      	orrs	r1, r3
    22d2:	687b      	ldr	r3, [r7, #4]
    22d4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    22d8:	f107 070c 	add.w	r7, r7, #12
    22dc:	46bd      	mov	sp, r7
    22de:	bc80      	pop	{r7}
    22e0:	4770      	bx	lr
    22e2:	bf00      	nop

000022e4 <LPLD_ADC_GetResult>:
 * 输出:
 *    AD通道转换值(右对齐)，若为差分转换结果，则为二进制补码格式(需强制转换为int16)
 *
 */
uint16 LPLD_ADC_GetResult(ADC_MemMapPtr adcx, uint8 ab)
{
    22e4:	b480      	push	{r7}
    22e6:	b083      	sub	sp, #12
    22e8:	af00      	add	r7, sp, #0
    22ea:	6078      	str	r0, [r7, #4]
    22ec:	460b      	mov	r3, r1
    22ee:	70fb      	strb	r3, [r7, #3]
  //参数检查
  return adcx->R[ab];
    22f0:	78fa      	ldrb	r2, [r7, #3]
    22f2:	687b      	ldr	r3, [r7, #4]
    22f4:	f102 0204 	add.w	r2, r2, #4
    22f8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    22fc:	b29b      	uxth	r3, r3
}
    22fe:	4618      	mov	r0, r3
    2300:	f107 070c 	add.w	r7, r7, #12
    2304:	46bd      	mov	sp, r7
    2306:	bc80      	pop	{r7}
    2308:	4770      	bx	lr
    230a:	bf00      	nop

0000230c <LPLD_ADC_GetSC1nCOCO>:
*    0--SC1A寄存器COCO位置1
*    1--SC1B寄存器COCO位置1
 *
 */
uint8 LPLD_ADC_GetSC1nCOCO(ADC_MemMapPtr adcx)
{
    230c:	b480      	push	{r7}
    230e:	b083      	sub	sp, #12
    2310:	af00      	add	r7, sp, #0
    2312:	6078      	str	r0, [r7, #4]
  if(adcx->SC1[0] & ADC_SC1_COCO_MASK)
    2314:	687b      	ldr	r3, [r7, #4]
    2316:	681b      	ldr	r3, [r3, #0]
    2318:	f003 0380 	and.w	r3, r3, #128	; 0x80
    231c:	2b00      	cmp	r3, #0
    231e:	d002      	beq.n	2326 <LPLD_ADC_GetSC1nCOCO+0x1a>
    return 0;
    2320:	f04f 0300 	mov.w	r3, #0
    2324:	e00a      	b.n	233c <LPLD_ADC_GetSC1nCOCO+0x30>
  if(adcx->SC1[1] & ADC_SC1_COCO_MASK)
    2326:	687b      	ldr	r3, [r7, #4]
    2328:	685b      	ldr	r3, [r3, #4]
    232a:	f003 0380 	and.w	r3, r3, #128	; 0x80
    232e:	2b00      	cmp	r3, #0
    2330:	d002      	beq.n	2338 <LPLD_ADC_GetSC1nCOCO+0x2c>
    return 1;
    2332:	f04f 0301 	mov.w	r3, #1
    2336:	e001      	b.n	233c <LPLD_ADC_GetSC1nCOCO+0x30>
  return -1;
    2338:	f04f 03ff 	mov.w	r3, #255	; 0xff
}
    233c:	4618      	mov	r0, r3
    233e:	f107 070c 	add.w	r7, r7, #12
    2342:	46bd      	mov	sp, r7
    2344:	bc80      	pop	{r7}
    2346:	4770      	bx	lr

00002348 <LPLD_ADC_EnableIrq>:
 *    0--配置错误
 *    1--配置成功
 *
 */
uint8 LPLD_ADC_EnableIrq(ADC_InitTypeDef adc_init_structure)
{
    2348:	b084      	sub	sp, #16
    234a:	b580      	push	{r7, lr}
    234c:	b082      	sub	sp, #8
    234e:	af00      	add	r7, sp, #0
    2350:	f107 0c10 	add.w	ip, r7, #16
    2354:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  ADC_MemMapPtr adcx = adc_init_structure.ADC_Adcx;
    2358:	693b      	ldr	r3, [r7, #16]
    235a:	607b      	str	r3, [r7, #4]
  
  if(adcx == ADC0)
    235c:	687a      	ldr	r2, [r7, #4]
    235e:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    2362:	f2c4 0303 	movt	r3, #16387	; 0x4003
    2366:	429a      	cmp	r2, r3
    2368:	d104      	bne.n	2374 <LPLD_ADC_EnableIrq+0x2c>
    enable_irq(INT_ADC0 - 16);
    236a:	f04f 0039 	mov.w	r0, #57	; 0x39
    236e:	f7fe fbcf 	bl	b10 <enable_irq>
    2372:	e00e      	b.n	2392 <LPLD_ADC_EnableIrq+0x4a>
  else if(adcx == ADC1)
    2374:	687a      	ldr	r2, [r7, #4]
    2376:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    237a:	f2c4 030b 	movt	r3, #16395	; 0x400b
    237e:	429a      	cmp	r2, r3
    2380:	d104      	bne.n	238c <LPLD_ADC_EnableIrq+0x44>
    enable_irq (INT_ADC1 - 16);
    2382:	f04f 003a 	mov.w	r0, #58	; 0x3a
    2386:	f7fe fbc3 	bl	b10 <enable_irq>
    238a:	e002      	b.n	2392 <LPLD_ADC_EnableIrq+0x4a>
  else
    return 0;
    238c:	f04f 0300 	mov.w	r3, #0
    2390:	e001      	b.n	2396 <LPLD_ADC_EnableIrq+0x4e>
  return 1;
    2392:	f04f 0301 	mov.w	r3, #1
}
    2396:	4618      	mov	r0, r3
    2398:	f107 0708 	add.w	r7, r7, #8
    239c:	46bd      	mov	sp, r7
    239e:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    23a2:	b004      	add	sp, #16
    23a4:	4770      	bx	lr
    23a6:	bf00      	nop

000023a8 <LPLD_ADC_DisableIrq>:
 *    0--配置错误
 *    1--配置成功
 *
 */
uint8 LPLD_ADC_DisableIrq(ADC_InitTypeDef adc_init_structure)
{
    23a8:	b084      	sub	sp, #16
    23aa:	b580      	push	{r7, lr}
    23ac:	b082      	sub	sp, #8
    23ae:	af00      	add	r7, sp, #0
    23b0:	f107 0c10 	add.w	ip, r7, #16
    23b4:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  ADC_MemMapPtr adcx = adc_init_structure.ADC_Adcx;
    23b8:	693b      	ldr	r3, [r7, #16]
    23ba:	607b      	str	r3, [r7, #4]
  
  if(adcx == ADC0)
    23bc:	687a      	ldr	r2, [r7, #4]
    23be:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    23c2:	f2c4 0303 	movt	r3, #16387	; 0x4003
    23c6:	429a      	cmp	r2, r3
    23c8:	d104      	bne.n	23d4 <LPLD_ADC_DisableIrq+0x2c>
      disable_irq(INT_ADC0 - 16);
    23ca:	f04f 0039 	mov.w	r0, #57	; 0x39
    23ce:	f7fe fc63 	bl	c98 <disable_irq>
    23d2:	e00e      	b.n	23f2 <LPLD_ADC_DisableIrq+0x4a>
  else if(adcx == ADC1)
    23d4:	687a      	ldr	r2, [r7, #4]
    23d6:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    23da:	f2c4 030b 	movt	r3, #16395	; 0x400b
    23de:	429a      	cmp	r2, r3
    23e0:	d104      	bne.n	23ec <LPLD_ADC_DisableIrq+0x44>
      disable_irq(INT_ADC1 - 16);
    23e2:	f04f 003a 	mov.w	r0, #58	; 0x3a
    23e6:	f7fe fc57 	bl	c98 <disable_irq>
    23ea:	e002      	b.n	23f2 <LPLD_ADC_DisableIrq+0x4a>
  else
    return 0;
    23ec:	f04f 0300 	mov.w	r3, #0
    23f0:	e001      	b.n	23f6 <LPLD_ADC_DisableIrq+0x4e>

  return 1;
    23f2:	f04f 0301 	mov.w	r3, #1
}
    23f6:	4618      	mov	r0, r3
    23f8:	f107 0708 	add.w	r7, r7, #8
    23fc:	46bd      	mov	sp, r7
    23fe:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    2402:	b004      	add	sp, #16
    2404:	4770      	bx	lr
    2406:	bf00      	nop

00002408 <LPLD_ADC_Chn_Enable>:
 *    0--配置错误
 *    1--配置成功
 *
 */
uint8 LPLD_ADC_Chn_Enable(ADC_MemMapPtr adcx, AdcChnEnum_Type chn)
{
    2408:	b480      	push	{r7}
    240a:	b085      	sub	sp, #20
    240c:	af00      	add	r7, sp, #0
    240e:	6078      	str	r0, [r7, #4]
    2410:	460b      	mov	r3, r1
    2412:	70fb      	strb	r3, [r7, #3]
  //判断复用引脚是a或b
  uint8 mux = (adcx->CFG2 & ADC_CFG2_MUXSEL_MASK)>>ADC_CFG2_MUXSEL_SHIFT;
    2414:	687b      	ldr	r3, [r7, #4]
    2416:	68db      	ldr	r3, [r3, #12]
    2418:	f003 0310 	and.w	r3, r3, #16
    241c:	ea4f 1313 	mov.w	r3, r3, lsr #4
    2420:	73fb      	strb	r3, [r7, #15]
    
  if(chn > AD30)
    2422:	78fb      	ldrb	r3, [r7, #3]
    2424:	2b1e      	cmp	r3, #30
    2426:	d902      	bls.n	242e <LPLD_ADC_Chn_Enable+0x26>
    return 0;
    2428:	f04f 0300 	mov.w	r3, #0
    242c:	e15d      	b.n	26ea <LPLD_ADC_Chn_Enable+0x2e2>
  
  //不同的通道对应不同的引脚，因此需要判断并配置
  if(adcx == ADC0)
    242e:	687a      	ldr	r2, [r7, #4]
    2430:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    2434:	f2c4 0303 	movt	r3, #16387	; 0x4003
    2438:	429a      	cmp	r2, r3
    243a:	f040 80ad 	bne.w	2598 <LPLD_ADC_Chn_Enable+0x190>
  {
    switch(chn)
    243e:	78fb      	ldrb	r3, [r7, #3]
    2440:	2b1e      	cmp	r3, #30
    2442:	f200 80a6 	bhi.w	2592 <LPLD_ADC_Chn_Enable+0x18a>
    2446:	a201      	add	r2, pc, #4	; (adr r2, 244c <LPLD_ADC_Chn_Enable+0x44>)
    2448:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    244c:	000026d5 	ldrdeq	r2, [r0], -r5
    2450:	000026d5 	ldrdeq	r2, [r0], -r5
    2454:	000026d5 	ldrdeq	r2, [r0], -r5
    2458:	000026d5 	ldrdeq	r2, [r0], -r5
    245c:	000024c9 	andeq	r2, r0, r9, asr #9
    2460:	000024e1 	andeq	r2, r0, r1, ror #9
    2464:	000024f9 	strdeq	r2, [r0], -r9
    2468:	000024f9 	strdeq	r2, [r0], -r9
    246c:	00002519 	andeq	r2, r0, r9, lsl r5
    2470:	00002519 	andeq	r2, r0, r9, lsl r5
    2474:	00002531 	andeq	r2, r0, r1, lsr r5
    2478:	00002531 	andeq	r2, r0, r1, lsr r5
    247c:	00002549 	andeq	r2, r0, r9, asr #10
    2480:	00002549 	andeq	r2, r0, r9, asr #10
    2484:	00002561 	andeq	r2, r0, r1, ror #10
    2488:	00002561 	andeq	r2, r0, r1, ror #10
    248c:	000026d5 	ldrdeq	r2, [r0], -r5
    2490:	00002579 	andeq	r2, r0, r9, ror r5
    2494:	00002579 	andeq	r2, r0, r9, ror r5
    2498:	000026d5 	ldrdeq	r2, [r0], -r5
    249c:	000026d5 	ldrdeq	r2, [r0], -r5
    24a0:	00002593 	muleq	r0, r3, r5
    24a4:	00002593 	muleq	r0, r3, r5
    24a8:	000026d5 	ldrdeq	r2, [r0], -r5
    24ac:	00002593 	muleq	r0, r3, r5
    24b0:	00002593 	muleq	r0, r3, r5
    24b4:	000026d5 	ldrdeq	r2, [r0], -r5
    24b8:	000026d5 	ldrdeq	r2, [r0], -r5
    24bc:	00002593 	muleq	r0, r3, r5
    24c0:	000026d5 	ldrdeq	r2, [r0], -r5
    24c4:	000026d5 	ldrdeq	r2, [r0], -r5
      case DAD1:   //ADC0_DP1 -- PGA2_DP
      case DAD2:   //PGA0_DP
      case DAD3:   //ADC0_DP3 -- PGA1_DP
        break;
      case AD4:   //ADC0_SE4b -- PTC2     
        if(mux == 1)    //b
    24c8:	7bfb      	ldrb	r3, [r7, #15]
    24ca:	2b01      	cmp	r3, #1
    24cc:	f040 8104 	bne.w	26d8 <LPLD_ADC_Chn_Enable+0x2d0>
          PORTC->PCR[2] =  PORT_PCR_MUX(0);
    24d0:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    24d4:	f2c4 0304 	movt	r3, #16388	; 0x4004
    24d8:	f04f 0200 	mov.w	r2, #0
    24dc:	609a      	str	r2, [r3, #8]
        break;
    24de:	e0fb      	b.n	26d8 <LPLD_ADC_Chn_Enable+0x2d0>
      case AD5:   //ADC0_SE5b -- PTD1     
        if(mux == 1)    //b
    24e0:	7bfb      	ldrb	r3, [r7, #15]
    24e2:	2b01      	cmp	r3, #1
    24e4:	f040 80fa 	bne.w	26dc <LPLD_ADC_Chn_Enable+0x2d4>
          PORTD->PCR[1] =  PORT_PCR_MUX(0);
    24e8:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    24ec:	f2c4 0304 	movt	r3, #16388	; 0x4004
    24f0:	f04f 0200 	mov.w	r2, #0
    24f4:	605a      	str	r2, [r3, #4]
        break;
    24f6:	e0f1      	b.n	26dc <LPLD_ADC_Chn_Enable+0x2d4>
      case AD6:   //ADC0_SE6b -- PTD5
      case AD7:   //ADC0_SE7b -- PTD6     
        if(mux == 1)    //b
    24f8:	7bfb      	ldrb	r3, [r7, #15]
    24fa:	2b01      	cmp	r3, #1
    24fc:	f040 80f0 	bne.w	26e0 <LPLD_ADC_Chn_Enable+0x2d8>
          PORTD->PCR[chn-1] =  PORT_PCR_MUX(0);
    2500:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    2504:	f2c4 0304 	movt	r3, #16388	; 0x4004
    2508:	78fa      	ldrb	r2, [r7, #3]
    250a:	f102 32ff 	add.w	r2, r2, #4294967295
    250e:	f04f 0100 	mov.w	r1, #0
    2512:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        break;
    2516:	e0e3      	b.n	26e0 <LPLD_ADC_Chn_Enable+0x2d8>
      case AD8:  //ADC0_SE8 -- PTB0
      case AD9:  //ADC0_SE9 -- PTB1
        PORTB->PCR[chn-8] =  PORT_PCR_MUX(0);
    2518:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    251c:	f2c4 0304 	movt	r3, #16388	; 0x4004
    2520:	78fa      	ldrb	r2, [r7, #3]
    2522:	f1a2 0208 	sub.w	r2, r2, #8
    2526:	f04f 0100 	mov.w	r1, #0
    252a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        break;
    252e:	e0da      	b.n	26e6 <LPLD_ADC_Chn_Enable+0x2de>
      case AD10:  //ADC0_SE10 -- PTA7
      case AD11:  //ADC0_SE11 -- PTA8
        PORTA->PCR[chn-3] =  PORT_PCR_MUX(0);
    2530:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    2534:	f2c4 0304 	movt	r3, #16388	; 0x4004
    2538:	78fa      	ldrb	r2, [r7, #3]
    253a:	f1a2 0203 	sub.w	r2, r2, #3
    253e:	f04f 0100 	mov.w	r1, #0
    2542:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        break;
    2546:	e0ce      	b.n	26e6 <LPLD_ADC_Chn_Enable+0x2de>
      case AD12:  //ADC0_SE12 -- PTB2
      case AD13:  //ADC0_SE13 -- PTB3
        PORTB->PCR[chn-10] =  PORT_PCR_MUX(0);
    2548:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    254c:	f2c4 0304 	movt	r3, #16388	; 0x4004
    2550:	78fa      	ldrb	r2, [r7, #3]
    2552:	f1a2 020a 	sub.w	r2, r2, #10
    2556:	f04f 0100 	mov.w	r1, #0
    255a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        break;
    255e:	e0c2      	b.n	26e6 <LPLD_ADC_Chn_Enable+0x2de>
      case AD14:  //ADC0_SE14 -- PTC0
      case AD15:  //ADC0_SE15 -- PTC1
        PORTC->PCR[chn-14] =  PORT_PCR_MUX(0);
    2560:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    2564:	f2c4 0304 	movt	r3, #16388	; 0x4004
    2568:	78fa      	ldrb	r2, [r7, #3]
    256a:	f1a2 020e 	sub.w	r2, r2, #14
    256e:	f04f 0100 	mov.w	r1, #0
    2572:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        break;
    2576:	e0b6      	b.n	26e6 <LPLD_ADC_Chn_Enable+0x2de>
      case AD16:   //ADC0_SE16
        break;
      case AD17:   //ADC0_SE17 -- PTE24
      case AD18:   //ADC0_SE18 -- PTE25
        PORTE->PCR[chn+7] =  PORT_PCR_MUX(0);
    2578:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    257c:	f2c4 0304 	movt	r3, #16388	; 0x4004
    2580:	78fa      	ldrb	r2, [r7, #3]
    2582:	f102 0207 	add.w	r2, r2, #7
    2586:	f04f 0100 	mov.w	r1, #0
    258a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        break;
    258e:	bf00      	nop
    2590:	e0a9      	b.n	26e6 <LPLD_ADC_Chn_Enable+0x2de>
      case AD27:   //Bandgap (S.E)
      case AD29:   //VREFH (S.E)
      case AD30:   //VREFL
        break;
      default:
        return 0;  
    2592:	f04f 0300 	mov.w	r3, #0
    2596:	e0a8      	b.n	26ea <LPLD_ADC_Chn_Enable+0x2e2>
    }
  }
  else if(adcx == ADC1)
    2598:	687a      	ldr	r2, [r7, #4]
    259a:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    259e:	f2c4 030b 	movt	r3, #16395	; 0x400b
    25a2:	429a      	cmp	r2, r3
    25a4:	f040 8093 	bne.w	26ce <LPLD_ADC_Chn_Enable+0x2c6>
  {
    switch(chn)
    25a8:	78fb      	ldrb	r3, [r7, #3]
    25aa:	2b1e      	cmp	r3, #30
    25ac:	f200 808c 	bhi.w	26c8 <LPLD_ADC_Chn_Enable+0x2c0>
    25b0:	a201      	add	r2, pc, #4	; (adr r2, 25b8 <LPLD_ADC_Chn_Enable+0x1b0>)
    25b2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    25b6:	bf00      	nop
    25b8:	000026e5 	andeq	r2, r0, r5, ror #13
    25bc:	000026e5 	andeq	r2, r0, r5, ror #13
    25c0:	000026e5 	andeq	r2, r0, r5, ror #13
    25c4:	000026e5 	andeq	r2, r0, r5, ror #13
    25c8:	00002635 	andeq	r2, r0, r5, lsr r6
    25cc:	00002635 	andeq	r2, r0, r5, lsr r6
    25d0:	00002635 	andeq	r2, r0, r5, lsr r6
    25d4:	00002635 	andeq	r2, r0, r5, lsr r6
    25d8:	0000266b 	andeq	r2, r0, fp, ror #12
    25dc:	0000266b 	andeq	r2, r0, fp, ror #12
    25e0:	00002683 	andeq	r2, r0, r3, lsl #13
    25e4:	00002683 	andeq	r2, r0, r3, lsl #13
    25e8:	00002683 	andeq	r2, r0, r3, lsl #13
    25ec:	00002683 	andeq	r2, r0, r3, lsl #13
    25f0:	0000269b 	muleq	r0, fp, r6
    25f4:	0000269b 	muleq	r0, fp, r6
    25f8:	000026e5 	andeq	r2, r0, r5, ror #13
    25fc:	000026b3 			; <UNDEFINED> instruction: 0x000026b3
    2600:	000026e5 	andeq	r2, r0, r5, ror #13
    2604:	000026e5 	andeq	r2, r0, r5, ror #13
    2608:	000026e5 	andeq	r2, r0, r5, ror #13
    260c:	000026c9 	andeq	r2, r0, r9, asr #13
    2610:	000026c9 	andeq	r2, r0, r9, asr #13
    2614:	000026e5 	andeq	r2, r0, r5, ror #13
    2618:	000026c9 	andeq	r2, r0, r9, asr #13
    261c:	000026c9 	andeq	r2, r0, r9, asr #13
    2620:	000026e5 	andeq	r2, r0, r5, ror #13
    2624:	000026e5 	andeq	r2, r0, r5, ror #13
    2628:	000026c9 	andeq	r2, r0, r9, asr #13
    262c:	000026e5 	andeq	r2, r0, r5, ror #13
    2630:	000026e5 	andeq	r2, r0, r5, ror #13
        break;
      case AD4:   //ADC1_SE4a -- PTE0     //ADC1_SE4b -- PTC8
      case AD5:   //ADC1_SE5a -- PTE1     //ADC1_SE5b -- PTC9
      case AD6:   //ADC1_SE6a -- PTE2     //ADC1_SE6b -- PTC10
      case AD7:   //ADC1_SE7a -- PTE3     //ADC1_SE7b -- PTC11
        if(mux == 0)    //a
    2634:	7bfb      	ldrb	r3, [r7, #15]
    2636:	2b00      	cmp	r3, #0
    2638:	d10b      	bne.n	2652 <LPLD_ADC_Chn_Enable+0x24a>
          PORTE->PCR[chn-4] =  PORT_PCR_MUX(0);
    263a:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    263e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    2642:	78fa      	ldrb	r2, [r7, #3]
    2644:	f1a2 0204 	sub.w	r2, r2, #4
    2648:	f04f 0100 	mov.w	r1, #0
    264c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        else            //b
          PORTC->PCR[chn+4] =  PORT_PCR_MUX(0);
        break;
    2650:	e049      	b.n	26e6 <LPLD_ADC_Chn_Enable+0x2de>
      case AD6:   //ADC1_SE6a -- PTE2     //ADC1_SE6b -- PTC10
      case AD7:   //ADC1_SE7a -- PTE3     //ADC1_SE7b -- PTC11
        if(mux == 0)    //a
          PORTE->PCR[chn-4] =  PORT_PCR_MUX(0);
        else            //b
          PORTC->PCR[chn+4] =  PORT_PCR_MUX(0);
    2652:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    2656:	f2c4 0304 	movt	r3, #16388	; 0x4004
    265a:	78fa      	ldrb	r2, [r7, #3]
    265c:	f102 0204 	add.w	r2, r2, #4
    2660:	f04f 0100 	mov.w	r1, #0
    2664:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        break;
    2668:	e03d      	b.n	26e6 <LPLD_ADC_Chn_Enable+0x2de>
      case AD8:  //ADC1_SE8 -- PTB0
      case AD9:  //ADC1_SE9 -- PTB1
        PORTB->PCR[chn-8] =  PORT_PCR_MUX(0);
    266a:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    266e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    2672:	78fa      	ldrb	r2, [r7, #3]
    2674:	f1a2 0208 	sub.w	r2, r2, #8
    2678:	f04f 0100 	mov.w	r1, #0
    267c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        break;
    2680:	e031      	b.n	26e6 <LPLD_ADC_Chn_Enable+0x2de>
      case AD10:  //ADC1_SE10 -- PTB4
      case AD11:  //ADC1_SE11 -- PTB5
      case AD12:  //ADC1_SE12 -- PTB6
      case AD13:  //ADC1_SE13 -- PTB7
        PORTB->PCR[chn-6] =  PORT_PCR_MUX(0);
    2682:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    2686:	f2c4 0304 	movt	r3, #16388	; 0x4004
    268a:	78fa      	ldrb	r2, [r7, #3]
    268c:	f1a2 0206 	sub.w	r2, r2, #6
    2690:	f04f 0100 	mov.w	r1, #0
    2694:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        break;
    2698:	e025      	b.n	26e6 <LPLD_ADC_Chn_Enable+0x2de>
      case AD14:  //ADC1_SE14 -- PTB10
      case AD15:  //ADC1_SE15 -- PTB11
        PORTB->PCR[chn-4] =  PORT_PCR_MUX(0);
    269a:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    269e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    26a2:	78fa      	ldrb	r2, [r7, #3]
    26a4:	f1a2 0204 	sub.w	r2, r2, #4
    26a8:	f04f 0100 	mov.w	r1, #0
    26ac:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        break;
    26b0:	e019      	b.n	26e6 <LPLD_ADC_Chn_Enable+0x2de>
      case AD16:   //ADC1_SE16
        break;
      case AD17:  //ADC1_SE17 -- PTA17
        PORTA->PCR[chn] =  PORT_PCR_MUX(0);
    26b2:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    26b6:	f2c4 0304 	movt	r3, #16388	; 0x4004
    26ba:	78fa      	ldrb	r2, [r7, #3]
    26bc:	f04f 0100 	mov.w	r1, #0
    26c0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        break;
    26c4:	bf00      	nop
    26c6:	e00e      	b.n	26e6 <LPLD_ADC_Chn_Enable+0x2de>
      case AD27:   //Bandgap (S.E)
      case AD29:   //VREFH (S.E)
      case AD30:   //VREFL
        break;
      default:
        return 0;  
    26c8:	f04f 0300 	mov.w	r3, #0
    26cc:	e00d      	b.n	26ea <LPLD_ADC_Chn_Enable+0x2e2>
    }
  }
  else
  {
    return 0;
    26ce:	f04f 0300 	mov.w	r3, #0
    26d2:	e00a      	b.n	26ea <LPLD_ADC_Chn_Enable+0x2e2>
    {
      case DAD0:   //ADC0_DP0 -- PGA0_DP
      case DAD1:   //ADC0_DP1 -- PGA2_DP
      case DAD2:   //PGA0_DP
      case DAD3:   //ADC0_DP3 -- PGA1_DP
        break;
    26d4:	bf00      	nop
    26d6:	e006      	b.n	26e6 <LPLD_ADC_Chn_Enable+0x2de>
      case AD4:   //ADC0_SE4b -- PTC2     
        if(mux == 1)    //b
          PORTC->PCR[2] =  PORT_PCR_MUX(0);
        break;
    26d8:	bf00      	nop
    26da:	e004      	b.n	26e6 <LPLD_ADC_Chn_Enable+0x2de>
      case AD5:   //ADC0_SE5b -- PTD1     
        if(mux == 1)    //b
          PORTD->PCR[1] =  PORT_PCR_MUX(0);
        break;
    26dc:	bf00      	nop
    26de:	e002      	b.n	26e6 <LPLD_ADC_Chn_Enable+0x2de>
      case AD6:   //ADC0_SE6b -- PTD5
      case AD7:   //ADC0_SE7b -- PTD6     
        if(mux == 1)    //b
          PORTD->PCR[chn-1] =  PORT_PCR_MUX(0);
        break;
    26e0:	bf00      	nop
    26e2:	e000      	b.n	26e6 <LPLD_ADC_Chn_Enable+0x2de>
    {
      case DAD0:   //ADC1_DP0 -- PGA1_DP
      case DAD1:   //ADC1_DP1 -- PGA3_DP
      case DAD2:   //PGA1_DP 
      case DAD3:   //ADC1_DP3 -- PGA0_DP
        break;
    26e4:	bf00      	nop
  else
  {
    return 0;
  }
  
  return 1;
    26e6:	f04f 0301 	mov.w	r3, #1
}
    26ea:	4618      	mov	r0, r3
    26ec:	f107 0714 	add.w	r7, r7, #20
    26f0:	46bd      	mov	sp, r7
    26f2:	bc80      	pop	{r7}
    26f4:	4770      	bx	lr
    26f6:	bf00      	nop

000026f8 <LPLD_ADC_Cal>:
 * 输出:
 *    0--配置错误
 *    1--配置成功
 */
static uint8 LPLD_ADC_Cal(ADC_MemMapPtr adcx)
{
    26f8:	b480      	push	{r7}
    26fa:	b085      	sub	sp, #20
    26fc:	af00      	add	r7, sp, #0
    26fe:	6078      	str	r0, [r7, #4]
  //32次硬件平均、ADCK不超过4MHz
  //参考高=Vdda、正常功耗模式
  //可忽略的配置：
  //输入通道、转换模式连续功能、比较功能、精度、差分单端
  //设置ADCCFG1寄存器
  adcx->CFG1  &= (~ADC_CFG1_ADLPC_MASK);          // 正常功耗配置
    2700:	687b      	ldr	r3, [r7, #4]
    2702:	689b      	ldr	r3, [r3, #8]
    2704:	f023 0280 	bic.w	r2, r3, #128	; 0x80
    2708:	687b      	ldr	r3, [r7, #4]
    270a:	609a      	str	r2, [r3, #8]
  adcx->CFG1  |=  ADC_CFG1_ADIV(ADIV_8)          // ADC输入时钟分频为8
    270c:	687b      	ldr	r3, [r7, #4]
    270e:	689b      	ldr	r3, [r3, #8]
    2710:	f043 0271 	orr.w	r2, r3, #113	; 0x71
    2714:	687b      	ldr	r3, [r7, #4]
    2716:	609a      	str	r2, [r3, #8]
                  | ADC_CFG1_ADLSMP_MASK           // 设置长时间采样模式
                  | ADC_CFG1_ADICLK(ADICLK_BUS_2); // ADC输入时钟源为 BusClk/2

  adcx->CFG2  &= (~ADC_CFG2_ADACKEN_MASK);
    2718:	687b      	ldr	r3, [r7, #4]
    271a:	68db      	ldr	r3, [r3, #12]
    271c:	f023 0208 	bic.w	r2, r3, #8
    2720:	687b      	ldr	r3, [r7, #4]
    2722:	60da      	str	r2, [r3, #12]
  adcx->CFG1  |=  ADC_CFG2_ADHSC_MASK         // 高速转换
    2724:	687b      	ldr	r3, [r7, #4]
    2726:	689b      	ldr	r3, [r3, #8]
    2728:	f043 0204 	orr.w	r2, r3, #4
    272c:	687b      	ldr	r3, [r7, #4]
    272e:	609a      	str	r2, [r3, #8]
                 | ADC_CFG2_ADLSTS(LSAMTIME_20EX); // 长采样时间时钟周期选择 额外20个时钟周期，共24个ADCK周期
                                               // 总采样周期见K60技术文档 page:840
  //用于设定阈值
  adcx->CV1  = 0x1234u ; 
    2730:	687b      	ldr	r3, [r7, #4]
    2732:	f241 2234 	movw	r2, #4660	; 0x1234
    2736:	619a      	str	r2, [r3, #24]
  adcx->CV2  = 0x5678u ;
    2738:	687b      	ldr	r3, [r7, #4]
    273a:	f245 6278 	movw	r2, #22136	; 0x5678
    273e:	61da      	str	r2, [r3, #28]
  
  adcx->SC2 &=  (~ADC_SC2_ADTRG_MASK);        //使能软件触发作为校准
    2740:	687b      	ldr	r3, [r7, #4]
    2742:	6a1b      	ldr	r3, [r3, #32]
    2744:	f023 0240 	bic.w	r2, r3, #64	; 0x40
    2748:	687b      	ldr	r3, [r7, #4]
    274a:	621a      	str	r2, [r3, #32]
  adcx->SC2 |=  ADC_SC2_REFSEL(REFSEL_EXT);  //选择外部参考源VREFH和VREFL
    274c:	687b      	ldr	r3, [r7, #4]
    274e:	6a1a      	ldr	r2, [r3, #32]
    2750:	687b      	ldr	r3, [r7, #4]
    2752:	621a      	str	r2, [r3, #32]
    
  adcx->SC3 &= ( ~ADC_SC3_ADCO_MASK & ~ADC_SC3_AVGS_MASK );  //设置单次转换，清除平均标志
    2754:	687b      	ldr	r3, [r7, #4]
    2756:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    2758:	f023 020b 	bic.w	r2, r3, #11
    275c:	687b      	ldr	r3, [r7, #4]
    275e:	625a      	str	r2, [r3, #36]	; 0x24
  adcx->SC3 |= ( ADC_SC3_AVGE_MASK | ADC_SC3_AVGS(HW_32AVG) );//打开平均标志，设置到最大采样平准
    2760:	687b      	ldr	r3, [r7, #4]
    2762:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    2764:	f043 0207 	orr.w	r2, r3, #7
    2768:	687b      	ldr	r3, [r7, #4]
    276a:	625a      	str	r2, [r3, #36]	; 0x24
  
  adcx->SC3 |= ADC_SC3_CAL_MASK ;                            //开始校准
    276c:	687b      	ldr	r3, [r7, #4]
    276e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    2770:	f043 0280 	orr.w	r2, r3, #128	; 0x80
    2774:	687b      	ldr	r3, [r7, #4]
    2776:	625a      	str	r2, [r3, #36]	; 0x24
  
  while((adcx->SC1[0] & ADC_SC1_COCO_MASK)== 0x00 );         //等待校准完成
    2778:	bf00      	nop
    277a:	687b      	ldr	r3, [r7, #4]
    277c:	681b      	ldr	r3, [r3, #0]
    277e:	f003 0380 	and.w	r3, r3, #128	; 0x80
    2782:	2b00      	cmp	r3, #0
    2784:	d0f9      	beq.n	277a <LPLD_ADC_Cal+0x82>
  	
  if ((adcx->SC3& ADC_SC3_CALF_MASK) == ADC_SC3_CALF_MASK )
    2786:	687b      	ldr	r3, [r7, #4]
    2788:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    278a:	f003 0340 	and.w	r3, r3, #64	; 0x40
    278e:	2b00      	cmp	r3, #0
    2790:	d002      	beq.n	2798 <LPLD_ADC_Cal+0xa0>
  {  
   return 0;    //检查到校准错误，返回错误
    2792:	f04f 0300 	mov.w	r3, #0
    2796:	e069      	b.n	286c <LPLD_ADC_Cal+0x174>
  }
  // Calculate plus-side calibration
  cal_var  = 0x00;
    2798:	f04f 0300 	mov.w	r3, #0
    279c:	81fb      	strh	r3, [r7, #14]
  cal_var  = adcx->CLP0;       
    279e:	687b      	ldr	r3, [r7, #4]
    27a0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    27a2:	81fb      	strh	r3, [r7, #14]
  cal_var += adcx->CLP1;      
    27a4:	687b      	ldr	r3, [r7, #4]
    27a6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    27a8:	b29a      	uxth	r2, r3
    27aa:	89fb      	ldrh	r3, [r7, #14]
    27ac:	18d3      	adds	r3, r2, r3
    27ae:	81fb      	strh	r3, [r7, #14]
  cal_var += adcx->CLP2;      
    27b0:	687b      	ldr	r3, [r7, #4]
    27b2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    27b4:	b29a      	uxth	r2, r3
    27b6:	89fb      	ldrh	r3, [r7, #14]
    27b8:	18d3      	adds	r3, r2, r3
    27ba:	81fb      	strh	r3, [r7, #14]
  cal_var += adcx->CLP3;      
    27bc:	687b      	ldr	r3, [r7, #4]
    27be:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    27c0:	b29a      	uxth	r2, r3
    27c2:	89fb      	ldrh	r3, [r7, #14]
    27c4:	18d3      	adds	r3, r2, r3
    27c6:	81fb      	strh	r3, [r7, #14]
  cal_var += adcx->CLP4;      
    27c8:	687b      	ldr	r3, [r7, #4]
    27ca:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    27cc:	b29a      	uxth	r2, r3
    27ce:	89fb      	ldrh	r3, [r7, #14]
    27d0:	18d3      	adds	r3, r2, r3
    27d2:	81fb      	strh	r3, [r7, #14]
  cal_var += adcx->CLPS;      
    27d4:	687b      	ldr	r3, [r7, #4]
    27d6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    27d8:	b29a      	uxth	r2, r3
    27da:	89fb      	ldrh	r3, [r7, #14]
    27dc:	18d3      	adds	r3, r2, r3
    27de:	81fb      	strh	r3, [r7, #14]
  cal_var  = cal_var/2;
    27e0:	89fb      	ldrh	r3, [r7, #14]
    27e2:	ea4f 0353 	mov.w	r3, r3, lsr #1
    27e6:	81fb      	strh	r3, [r7, #14]
  cal_var |= 0x8000; // Set MSB
    27e8:	89fb      	ldrh	r3, [r7, #14]
    27ea:	ea6f 4343 	mvn.w	r3, r3, lsl #17
    27ee:	ea6f 4353 	mvn.w	r3, r3, lsr #17
    27f2:	81fb      	strh	r3, [r7, #14]
  
  adcx->PG = ADC_PG_PG(cal_var);
    27f4:	89fa      	ldrh	r2, [r7, #14]
    27f6:	687b      	ldr	r3, [r7, #4]
    27f8:	62da      	str	r2, [r3, #44]	; 0x2c

  // Calculate minus-side calibration
  cal_var = 0x00;
    27fa:	f04f 0300 	mov.w	r3, #0
    27fe:	81fb      	strh	r3, [r7, #14]
  cal_var =  adcx->CLM0; 
    2800:	687b      	ldr	r3, [r7, #4]
    2802:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    2804:	81fb      	strh	r3, [r7, #14]
  cal_var += adcx->CLM1;
    2806:	687b      	ldr	r3, [r7, #4]
    2808:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    280a:	b29a      	uxth	r2, r3
    280c:	89fb      	ldrh	r3, [r7, #14]
    280e:	18d3      	adds	r3, r2, r3
    2810:	81fb      	strh	r3, [r7, #14]
  cal_var += adcx->CLM2;
    2812:	687b      	ldr	r3, [r7, #4]
    2814:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    2816:	b29a      	uxth	r2, r3
    2818:	89fb      	ldrh	r3, [r7, #14]
    281a:	18d3      	adds	r3, r2, r3
    281c:	81fb      	strh	r3, [r7, #14]
  cal_var += adcx->CLM3;
    281e:	687b      	ldr	r3, [r7, #4]
    2820:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    2822:	b29a      	uxth	r2, r3
    2824:	89fb      	ldrh	r3, [r7, #14]
    2826:	18d3      	adds	r3, r2, r3
    2828:	81fb      	strh	r3, [r7, #14]
  cal_var += adcx->CLM4;
    282a:	687b      	ldr	r3, [r7, #4]
    282c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    282e:	b29a      	uxth	r2, r3
    2830:	89fb      	ldrh	r3, [r7, #14]
    2832:	18d3      	adds	r3, r2, r3
    2834:	81fb      	strh	r3, [r7, #14]
  cal_var += adcx->CLMS;
    2836:	687b      	ldr	r3, [r7, #4]
    2838:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    283a:	b29a      	uxth	r2, r3
    283c:	89fb      	ldrh	r3, [r7, #14]
    283e:	18d3      	adds	r3, r2, r3
    2840:	81fb      	strh	r3, [r7, #14]
  cal_var = cal_var/2;
    2842:	89fb      	ldrh	r3, [r7, #14]
    2844:	ea4f 0353 	mov.w	r3, r3, lsr #1
    2848:	81fb      	strh	r3, [r7, #14]
  cal_var |= 0x8000; // Set MSB
    284a:	89fb      	ldrh	r3, [r7, #14]
    284c:	ea6f 4343 	mvn.w	r3, r3, lsl #17
    2850:	ea6f 4353 	mvn.w	r3, r3, lsr #17
    2854:	81fb      	strh	r3, [r7, #14]

  adcx->MG   = ADC_MG_MG(cal_var); 
    2856:	89fa      	ldrh	r2, [r7, #14]
    2858:	687b      	ldr	r3, [r7, #4]
    285a:	631a      	str	r2, [r3, #48]	; 0x30
  adcx->SC3 &= ~ADC_SC3_CAL_MASK ; //清除校验标志
    285c:	687b      	ldr	r3, [r7, #4]
    285e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    2860:	f023 0280 	bic.w	r2, r3, #128	; 0x80
    2864:	687b      	ldr	r3, [r7, #4]
    2866:	625a      	str	r2, [r3, #36]	; 0x24
  
  return 1;
    2868:	f04f 0301 	mov.w	r3, #1
}
    286c:	4618      	mov	r0, r3
    286e:	f107 0714 	add.w	r7, r7, #20
    2872:	46bd      	mov	sp, r7
    2874:	bc80      	pop	{r7}
    2876:	4770      	bx	lr

00002878 <ADC0_IRQHandler>:
 * 与启动文件startup_K60.s中的中断向量表关联
 * 用户无需修改，程序自动进入对应通道中断函数
 */

void ADC0_IRQHandler(void)
{
    2878:	b580      	push	{r7, lr}
    287a:	af00      	add	r7, sp, #0
    ADC_ISR[0]();
    287c:	f241 53fc 	movw	r3, #5628	; 0x15fc
    2880:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    2884:	681b      	ldr	r3, [r3, #0]
    2886:	4798      	blx	r3
}
    2888:	bd80      	pop	{r7, pc}
    288a:	bf00      	nop

0000288c <ADC1_IRQHandler>:

void ADC1_IRQHandler(void)
{
    288c:	b580      	push	{r7, lr}
    288e:	af00      	add	r7, sp, #0
    ADC_ISR[1]();
    2890:	f241 53fc 	movw	r3, #5628	; 0x15fc
    2894:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    2898:	685b      	ldr	r3, [r3, #4]
    289a:	4798      	blx	r3
}
    289c:	bd80      	pop	{r7, pc}
    289e:	bf00      	nop

000028a0 <LPLD_DMA_Init>:
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_DMA_Init(DMA_InitTypeDef dma_init_struct)
{
    28a0:	b084      	sub	sp, #16
    28a2:	b480      	push	{r7}
    28a4:	b08b      	sub	sp, #44	; 0x2c
    28a6:	af00      	add	r7, sp, #0
    28a8:	f107 0c30 	add.w	ip, r7, #48	; 0x30
    28ac:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  uint8 chx = dma_init_struct.DMA_CHx;
    28b0:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
    28b4:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  uint8 req = dma_init_struct.DMA_Req;
    28b8:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
    28bc:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
  boolean periodic_trigg = dma_init_struct.DMA_PeriodicTriggerEnable;
    28c0:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
    28c4:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
  uint16 major_cnt = dma_init_struct.DMA_MajorLoopCnt;
    28c8:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
    28ca:	847b      	strh	r3, [r7, #34]	; 0x22
  uint32 minor_cnt = dma_init_struct.DMA_MinorByteCnt;
    28cc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    28ce:	61fb      	str	r3, [r7, #28]
  uint32 src_addr = dma_init_struct.DMA_SourceAddr;
    28d0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    28d2:	61bb      	str	r3, [r7, #24]
  uint8 src_dsize = dma_init_struct.DMA_SourceDataSize;
    28d4:	f897 3040 	ldrb.w	r3, [r7, #64]	; 0x40
    28d8:	75fb      	strb	r3, [r7, #23]
  int16 src_addroffset = dma_init_struct.DMA_SourceAddrOffset;
    28da:	f8b7 3042 	ldrh.w	r3, [r7, #66]	; 0x42
    28de:	82bb      	strh	r3, [r7, #20]
  int32 src_lastadj = dma_init_struct.DMA_LastSourceAddrAdj;
    28e0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    28e2:	613b      	str	r3, [r7, #16]
  uint32 dst_addr = dma_init_struct.DMA_DestAddr;
    28e4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    28e6:	60fb      	str	r3, [r7, #12]
  uint8 dst_dsize = dma_init_struct.DMA_DestDataSize;
    28e8:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
    28ec:	72fb      	strb	r3, [r7, #11]
  int16 dst_addroffset = dma_init_struct.DMA_DestAddrOffset;
    28ee:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
    28f2:	813b      	strh	r3, [r7, #8]
  int32 dst_lastadj = dma_init_struct.DMA_LastDestAddrAdj;
    28f4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    28f6:	607b      	str	r3, [r7, #4]
  boolean auto_disable = dma_init_struct.DMA_AutoDisableReq;
    28f8:	f897 3054 	ldrb.w	r3, [r7, #84]	; 0x54
    28fc:	70fb      	strb	r3, [r7, #3]
  //ASSERT( src_addr != NULL );      //Դַж
  //ASSERT( (src_dsize <= DMA_SRC_32BIT)||(src_dsize == DMA_SRC_16BYTE) );     //ԴݴСж
  //ASSERT( dst_addr != NULL );      //Ŀĵַж
  //ASSERT( (dst_dsize <= DMA_DST_32BIT)||(dst_dsize == DMA_DST_16BYTE) );     //ĿݴСж
 
  if (chx > DMA_CH15)
    28fe:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
    2902:	2b0f      	cmp	r3, #15
    2904:	d902      	bls.n	290c <LPLD_DMA_Init+0x6c>
    return 0;
    2906:	f04f 0300 	mov.w	r3, #0
    290a:	e220      	b.n	2d4e <LPLD_DMA_Init+0x4ae>
  if (req > DMA_MUX_63)
    290c:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
    2910:	2b3f      	cmp	r3, #63	; 0x3f
    2912:	d902      	bls.n	291a <LPLD_DMA_Init+0x7a>
    return 0;
    2914:	f04f 0300 	mov.w	r3, #0
    2918:	e219      	b.n	2d4e <LPLD_DMA_Init+0x4ae>
  if (major_cnt > 0x7FFF)
    291a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
    291c:	b21b      	sxth	r3, r3
    291e:	2b00      	cmp	r3, #0
    2920:	da02      	bge.n	2928 <LPLD_DMA_Init+0x88>
    return 0;
    2922:	f04f 0300 	mov.w	r3, #0
    2926:	e212      	b.n	2d4e <LPLD_DMA_Init+0x4ae>
  if (src_addr == 0)
    2928:	69bb      	ldr	r3, [r7, #24]
    292a:	2b00      	cmp	r3, #0
    292c:	d102      	bne.n	2934 <LPLD_DMA_Init+0x94>
    return 0;
    292e:	f04f 0300 	mov.w	r3, #0
    2932:	e20c      	b.n	2d4e <LPLD_DMA_Init+0x4ae>
  if ((src_dsize > DMA_SRC_32BIT) || (src_dsize != DMA_SRC_16BYTE))
    2934:	7dfb      	ldrb	r3, [r7, #23]
    2936:	2b02      	cmp	r3, #2
    2938:	d802      	bhi.n	2940 <LPLD_DMA_Init+0xa0>
    293a:	7dfb      	ldrb	r3, [r7, #23]
    293c:	2b04      	cmp	r3, #4
    293e:	d002      	beq.n	2946 <LPLD_DMA_Init+0xa6>
    return 0;
    2940:	f04f 0300 	mov.w	r3, #0
    2944:	e203      	b.n	2d4e <LPLD_DMA_Init+0x4ae>
  if (dst_addr == 0)
    2946:	68fb      	ldr	r3, [r7, #12]
    2948:	2b00      	cmp	r3, #0
    294a:	d102      	bne.n	2952 <LPLD_DMA_Init+0xb2>
    return 0;
    294c:	f04f 0300 	mov.w	r3, #0
    2950:	e1fd      	b.n	2d4e <LPLD_DMA_Init+0x4ae>
  if ((dst_dsize > DMA_DST_32BIT) || (dst_dsize != DMA_SRC_16BYTE))
    2952:	7afb      	ldrb	r3, [r7, #11]
    2954:	2b02      	cmp	r3, #2
    2956:	d802      	bhi.n	295e <LPLD_DMA_Init+0xbe>
    2958:	7afb      	ldrb	r3, [r7, #11]
    295a:	2b04      	cmp	r3, #4
    295c:	d002      	beq.n	2964 <LPLD_DMA_Init+0xc4>
    return 0;
    295e:	f04f 0300 	mov.w	r3, #0
    2962:	e1f4      	b.n	2d4e <LPLD_DMA_Init+0x4ae>

  SIM_SCGC7 |= SIM_SCGC7_DMA_MASK;     //DMAģʱ
    2964:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    2968:	f2c4 0304 	movt	r3, #16388	; 0x4004
    296c:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    2970:	f2c4 0204 	movt	r2, #16388	; 0x4004
    2974:	f502 5282 	add.w	r2, r2, #4160	; 0x1040
    2978:	6812      	ldr	r2, [r2, #0]
    297a:	f042 0202 	orr.w	r2, r2, #2
    297e:	f503 5382 	add.w	r3, r3, #4160	; 0x1040
    2982:	601a      	str	r2, [r3, #0]
  SIM_SCGC6 |= SIM_SCGC6_DMAMUX0_MASK;  //DMAͨ·ʱ   
    2984:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    2988:	f2c4 0304 	movt	r3, #16388	; 0x4004
    298c:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    2990:	f2c4 0204 	movt	r2, #16388	; 0x4004
    2994:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    2998:	f102 021c 	add.w	r2, r2, #28
    299c:	6812      	ldr	r2, [r2, #0]
    299e:	f042 0202 	orr.w	r2, r2, #2
    29a2:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    29a6:	f103 031c 	add.w	r3, r3, #28
    29aa:	601a      	str	r2, [r3, #0]
  
  //رͨxӲDMA 
  DMA0->ERQ &= ~(1<<chx);
    29ac:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    29b0:	f2c4 0300 	movt	r3, #16384	; 0x4000
    29b4:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    29b8:	f2c4 0200 	movt	r2, #16384	; 0x4000
    29bc:	68d1      	ldr	r1, [r2, #12]
    29be:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
    29c2:	f04f 0001 	mov.w	r0, #1
    29c6:	fa00 f202 	lsl.w	r2, r0, r2
    29ca:	ea6f 0202 	mvn.w	r2, r2
    29ce:	400a      	ands	r2, r1
    29d0:	60da      	str	r2, [r3, #12]
  
  //ѡ ͨx DMAԴ
  DMAMUX->CHCFG[chx] = DMAMUX_CHCFG_SOURCE(req);
    29d2:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    29d6:	f2c4 0302 	movt	r3, #16386	; 0x4002
    29da:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
    29de:	f897 1026 	ldrb.w	r1, [r7, #38]	; 0x26
    29e2:	f001 013f 	and.w	r1, r1, #63	; 0x3f
    29e6:	b2c9      	uxtb	r1, r1
    29e8:	5499      	strb	r1, [r3, r2]
  //Ƿʹڴ
  if(periodic_trigg == TRUE)
    29ea:	f897 3025 	ldrb.w	r3, [r7, #37]	; 0x25
    29ee:	2b01      	cmp	r3, #1
    29f0:	d112      	bne.n	2a18 <LPLD_DMA_Init+0x178>
  {
    DMAMUX->CHCFG[chx] |= DMAMUX_CHCFG_TRIG_MASK;
    29f2:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    29f6:	f2c4 0302 	movt	r3, #16386	; 0x4002
    29fa:	f897 1027 	ldrb.w	r1, [r7, #39]	; 0x27
    29fe:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    2a02:	f2c4 0202 	movt	r2, #16386	; 0x4002
    2a06:	f897 0027 	ldrb.w	r0, [r7, #39]	; 0x27
    2a0a:	5c12      	ldrb	r2, [r2, r0]
    2a0c:	b2d2      	uxtb	r2, r2
    2a0e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    2a12:	b2d2      	uxtb	r2, r2
    2a14:	545a      	strb	r2, [r3, r1]
    2a16:	e011      	b.n	2a3c <LPLD_DMA_Init+0x19c>
  }
  else
  {
    DMAMUX->CHCFG[chx] &= ~(DMAMUX_CHCFG_TRIG_MASK);
    2a18:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    2a1c:	f2c4 0302 	movt	r3, #16386	; 0x4002
    2a20:	f897 1027 	ldrb.w	r1, [r7, #39]	; 0x27
    2a24:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    2a28:	f2c4 0202 	movt	r2, #16386	; 0x4002
    2a2c:	f897 0027 	ldrb.w	r0, [r7, #39]	; 0x27
    2a30:	5c12      	ldrb	r2, [r2, r0]
    2a32:	b2d2      	uxtb	r2, r2
    2a34:	f022 0240 	bic.w	r2, r2, #64	; 0x40
    2a38:	b2d2      	uxtb	r2, r2
    2a3a:	545a      	strb	r2, [r3, r1]
  }
  
  
  //Դַ   
  DMA0->TCD[chx].SADDR = DMA_SADDR_SADDR(src_addr);
    2a3c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2a40:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2a44:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
    2a48:	f102 0280 	add.w	r2, r2, #128	; 0x80
    2a4c:	ea4f 1242 	mov.w	r2, r2, lsl #5
    2a50:	189b      	adds	r3, r3, r2
    2a52:	69ba      	ldr	r2, [r7, #24]
    2a54:	601a      	str	r2, [r3, #0]
  //ִԴַĲ֮ԴַĻ/ƫƵַ
  DMA0->TCD[chx].SOFF = DMA_SOFF_SOFF(src_addroffset);
    2a56:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2a5a:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2a5e:	f897 1027 	ldrb.w	r1, [r7, #39]	; 0x27
    2a62:	8aba      	ldrh	r2, [r7, #20]
    2a64:	f101 0180 	add.w	r1, r1, #128	; 0x80
    2a68:	ea4f 1141 	mov.w	r1, r1, lsl #5
    2a6c:	185b      	adds	r3, r3, r1
    2a6e:	809a      	strh	r2, [r3, #4]
  //ԴַĴС
  DMA0->TCD[chx].ATTR = 0 | DMA_ATTR_SSIZE(src_dsize);
    2a70:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2a74:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2a78:	f897 1027 	ldrb.w	r1, [r7, #39]	; 0x27
    2a7c:	7dfa      	ldrb	r2, [r7, #23]
    2a7e:	b292      	uxth	r2, r2
    2a80:	ea4f 2202 	mov.w	r2, r2, lsl #8
    2a84:	b292      	uxth	r2, r2
    2a86:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    2a8a:	b292      	uxth	r2, r2
    2a8c:	f101 0180 	add.w	r1, r1, #128	; 0x80
    2a90:	ea4f 1141 	mov.w	r1, r1, lsl #5
    2a94:	185b      	adds	r3, r3, r1
    2a96:	80da      	strh	r2, [r3, #6]
  //ļmajor iteration countﵽµԴַ
  DMA0->TCD[chx].SLAST = DMA_SLAST_SLAST(src_lastadj);
    2a98:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2a9c:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2aa0:	f897 1027 	ldrb.w	r1, [r7, #39]	; 0x27
    2aa4:	693a      	ldr	r2, [r7, #16]
    2aa6:	ea4f 1141 	mov.w	r1, r1, lsl #5
    2aaa:	185b      	adds	r3, r3, r1
    2aac:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    2ab0:	f103 0308 	add.w	r3, r3, #8
    2ab4:	605a      	str	r2, [r3, #4]
  
  //Ŀĵַ 
  DMA0->TCD[chx].DADDR = DMA_DADDR_DADDR(dst_addr);
    2ab6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2aba:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2abe:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
    2ac2:	ea4f 1242 	mov.w	r2, r2, lsl #5
    2ac6:	189b      	adds	r3, r3, r2
    2ac8:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    2acc:	f103 0310 	add.w	r3, r3, #16
    2ad0:	68fa      	ldr	r2, [r7, #12]
    2ad2:	601a      	str	r2, [r3, #0]
  //ִĿĵַĲ֮ĿĵַĻ/ƫƵַ
  DMA0->TCD[chx].DOFF = DMA_DOFF_DOFF(dst_addroffset);
    2ad4:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2ad8:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2adc:	f897 1027 	ldrb.w	r1, [r7, #39]	; 0x27
    2ae0:	893a      	ldrh	r2, [r7, #8]
    2ae2:	ea4f 1141 	mov.w	r1, r1, lsl #5
    2ae6:	185b      	adds	r3, r3, r1
    2ae8:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    2aec:	f103 0310 	add.w	r3, r3, #16
    2af0:	809a      	strh	r2, [r3, #4]
  //ĿĵַĴ
  DMA0->TCD[chx].ATTR |= DMA_ATTR_DSIZE(dst_dsize);
    2af2:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2af6:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2afa:	f897 1027 	ldrb.w	r1, [r7, #39]	; 0x27
    2afe:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    2b02:	f2c4 0200 	movt	r2, #16384	; 0x4000
    2b06:	f897 0027 	ldrb.w	r0, [r7, #39]	; 0x27
    2b0a:	f100 0080 	add.w	r0, r0, #128	; 0x80
    2b0e:	ea4f 1040 	mov.w	r0, r0, lsl #5
    2b12:	1812      	adds	r2, r2, r0
    2b14:	88d2      	ldrh	r2, [r2, #6]
    2b16:	b290      	uxth	r0, r2
    2b18:	7afa      	ldrb	r2, [r7, #11]
    2b1a:	b292      	uxth	r2, r2
    2b1c:	f002 0207 	and.w	r2, r2, #7
    2b20:	b292      	uxth	r2, r2
    2b22:	4302      	orrs	r2, r0
    2b24:	b292      	uxth	r2, r2
    2b26:	f101 0180 	add.w	r1, r1, #128	; 0x80
    2b2a:	ea4f 1141 	mov.w	r1, r1, lsl #5
    2b2e:	185b      	adds	r3, r3, r1
    2b30:	80da      	strh	r2, [r3, #6]
  //ļmajor iteration countﵽµĿĵַ
  DMA0->TCD[chx].DLAST_SGA = DMA_DLAST_SGA_DLASTSGA(dst_lastadj);
    2b32:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2b36:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2b3a:	f897 1027 	ldrb.w	r1, [r7, #39]	; 0x27
    2b3e:	687a      	ldr	r2, [r7, #4]
    2b40:	ea4f 1141 	mov.w	r1, r1, lsl #5
    2b44:	185b      	adds	r3, r3, r1
    2b46:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    2b4a:	f103 0318 	add.w	r3, r3, #24
    2b4e:	601a      	str	r2, [r3, #0]
  //ĬΪͨӹܣӴ˹
  if( 1 == 1)
  {
    //===============ȣѭ====================================
    //ѭ current major loop count
    DMA0->TCD[chx].CITER_ELINKNO = DMA_CITER_ELINKNO_CITER(major_cnt);
    2b50:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2b54:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2b58:	f897 1027 	ldrb.w	r1, [r7, #39]	; 0x27
    2b5c:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
    2b5e:	ea4f 4242 	mov.w	r2, r2, lsl #17
    2b62:	ea4f 4252 	mov.w	r2, r2, lsr #17
    2b66:	b292      	uxth	r2, r2
    2b68:	ea4f 1141 	mov.w	r1, r1, lsl #5
    2b6c:	185b      	adds	r3, r3, r1
    2b6e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    2b72:	f103 0310 	add.w	r3, r3, #16
    2b76:	80da      	strh	r2, [r3, #6]
    //ʼѭѭΪʱ򣬽װʼѭֵ
    DMA0->TCD[chx].BITER_ELINKNO = DMA_CITER_ELINKNO_CITER(major_cnt);
    2b78:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2b7c:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2b80:	f897 1027 	ldrb.w	r1, [r7, #39]	; 0x27
    2b84:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
    2b86:	ea4f 4242 	mov.w	r2, r2, lsl #17
    2b8a:	ea4f 4252 	mov.w	r2, r2, lsr #17
    2b8e:	b292      	uxth	r2, r2
    2b90:	ea4f 1141 	mov.w	r1, r1, lsl #5
    2b94:	185b      	adds	r3, r3, r1
    2b96:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    2b9a:	f103 0318 	add.w	r3, r3, #24
    2b9e:	80da      	strh	r2, [r3, #6]
  
  //ĬΪôѭַƫƹܣӴ˹
  if( 1 == 1)
  {
    //ѭһδֽڵĸ
    DMA0->TCD[chx].NBYTES_MLNO = DMA_NBYTES_MLNO_NBYTES(minor_cnt);
    2ba0:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2ba4:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2ba8:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
    2bac:	ea4f 1242 	mov.w	r2, r2, lsl #5
    2bb0:	189b      	adds	r3, r3, r2
    2bb2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    2bb6:	f103 0308 	add.w	r3, r3, #8
    2bba:	69fa      	ldr	r2, [r7, #28]
    2bbc:	601a      	str	r2, [r3, #0]
  }
  
  //TCDƼĴ     
  DMA0->TCD[chx].CSR = 0;
    2bbe:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2bc2:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2bc6:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
    2bca:	ea4f 1242 	mov.w	r2, r2, lsl #5
    2bce:	189b      	adds	r3, r3, r2
    2bd0:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    2bd4:	f103 0318 	add.w	r3, r3, #24
    2bd8:	f04f 0200 	mov.w	r2, #0
    2bdc:	809a      	strh	r2, [r3, #4]
  
  //eDMAж
  if((dma_init_struct.DMA_Isr != NULL) && 
    2bde:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    2be0:	2b00      	cmp	r3, #0
    2be2:	d02c      	beq.n	2c3e <LPLD_DMA_Init+0x39e>
     (dma_init_struct.DMA_MajorCompleteIntEnable == TRUE))
    2be4:	f897 3055 	ldrb.w	r3, [r7, #85]	; 0x55
  
  //TCDƼĴ     
  DMA0->TCD[chx].CSR = 0;
  
  //eDMAж
  if((dma_init_struct.DMA_Isr != NULL) && 
    2be8:	2b01      	cmp	r3, #1
    2bea:	d128      	bne.n	2c3e <LPLD_DMA_Init+0x39e>
     (dma_init_struct.DMA_MajorCompleteIntEnable == TRUE))
  {

       DMA0->TCD[chx].CSR |= DMA_CSR_INTMAJOR_MASK; //ʹDMA ѭ ж
    2bec:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2bf0:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2bf4:	f897 1027 	ldrb.w	r1, [r7, #39]	; 0x27
    2bf8:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    2bfc:	f2c4 0200 	movt	r2, #16384	; 0x4000
    2c00:	f897 0027 	ldrb.w	r0, [r7, #39]	; 0x27
    2c04:	ea4f 1040 	mov.w	r0, r0, lsl #5
    2c08:	1812      	adds	r2, r2, r0
    2c0a:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    2c0e:	f102 0218 	add.w	r2, r2, #24
    2c12:	8892      	ldrh	r2, [r2, #4]
    2c14:	b292      	uxth	r2, r2
    2c16:	f042 0202 	orr.w	r2, r2, #2
    2c1a:	b292      	uxth	r2, r2
    2c1c:	ea4f 1141 	mov.w	r1, r1, lsl #5
    2c20:	185b      	adds	r3, r3, r1
    2c22:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    2c26:	f103 0318 	add.w	r3, r3, #24
    2c2a:	809a      	strh	r2, [r3, #4]
       DMA_ISR[chx] = dma_init_struct.DMA_Isr;
    2c2c:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
    2c30:	6db9      	ldr	r1, [r7, #88]	; 0x58
    2c32:	f241 6304 	movw	r3, #5636	; 0x1604
    2c36:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    2c3a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  }
  if((dma_init_struct.DMA_Isr != NULL) && 
    2c3e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    2c40:	2b00      	cmp	r3, #0
    2c42:	d02c      	beq.n	2c9e <LPLD_DMA_Init+0x3fe>
     (dma_init_struct.DMA_MajorHalfCompleteIntEnable == TRUE))
    2c44:	f897 3056 	ldrb.w	r3, [r7, #86]	; 0x56
  {

       DMA0->TCD[chx].CSR |= DMA_CSR_INTMAJOR_MASK; //ʹDMA ѭ ж
       DMA_ISR[chx] = dma_init_struct.DMA_Isr;
  }
  if((dma_init_struct.DMA_Isr != NULL) && 
    2c48:	2b01      	cmp	r3, #1
    2c4a:	d128      	bne.n	2c9e <LPLD_DMA_Init+0x3fe>
     (dma_init_struct.DMA_MajorHalfCompleteIntEnable == TRUE))
  {

       DMA0->TCD[chx].CSR |= DMA_CSR_INTHALF_MASK; //ʹDMA ѭһ ж
    2c4c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2c50:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2c54:	f897 1027 	ldrb.w	r1, [r7, #39]	; 0x27
    2c58:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    2c5c:	f2c4 0200 	movt	r2, #16384	; 0x4000
    2c60:	f897 0027 	ldrb.w	r0, [r7, #39]	; 0x27
    2c64:	ea4f 1040 	mov.w	r0, r0, lsl #5
    2c68:	1812      	adds	r2, r2, r0
    2c6a:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    2c6e:	f102 0218 	add.w	r2, r2, #24
    2c72:	8892      	ldrh	r2, [r2, #4]
    2c74:	b292      	uxth	r2, r2
    2c76:	f042 0204 	orr.w	r2, r2, #4
    2c7a:	b292      	uxth	r2, r2
    2c7c:	ea4f 1141 	mov.w	r1, r1, lsl #5
    2c80:	185b      	adds	r3, r3, r1
    2c82:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    2c86:	f103 0318 	add.w	r3, r3, #24
    2c8a:	809a      	strh	r2, [r3, #4]
       DMA_ISR[chx] = dma_init_struct.DMA_Isr;
    2c8c:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
    2c90:	6db9      	ldr	r1, [r7, #88]	; 0x58
    2c92:	f241 6304 	movw	r3, #5636	; 0x1604
    2c96:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    2c9a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  }
    
  if(auto_disable == TRUE)
    2c9e:	78fb      	ldrb	r3, [r7, #3]
    2ca0:	2b01      	cmp	r3, #1
    2ca2:	d120      	bne.n	2ce6 <LPLD_DMA_Init+0x446>
  {
     DMA0->TCD[chx].CSR |= DMA_CSR_DREQ_MASK; //ѭԶرDMA 
    2ca4:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2ca8:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2cac:	f897 1027 	ldrb.w	r1, [r7, #39]	; 0x27
    2cb0:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    2cb4:	f2c4 0200 	movt	r2, #16384	; 0x4000
    2cb8:	f897 0027 	ldrb.w	r0, [r7, #39]	; 0x27
    2cbc:	ea4f 1040 	mov.w	r0, r0, lsl #5
    2cc0:	1812      	adds	r2, r2, r0
    2cc2:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    2cc6:	f102 0218 	add.w	r2, r2, #24
    2cca:	8892      	ldrh	r2, [r2, #4]
    2ccc:	b292      	uxth	r2, r2
    2cce:	f042 0208 	orr.w	r2, r2, #8
    2cd2:	b292      	uxth	r2, r2
    2cd4:	ea4f 1141 	mov.w	r1, r1, lsl #5
    2cd8:	185b      	adds	r3, r3, r1
    2cda:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    2cde:	f103 0318 	add.w	r3, r3, #24
    2ce2:	809a      	strh	r2, [r3, #4]
    2ce4:	e01f      	b.n	2d26 <LPLD_DMA_Init+0x486>
  }
  else
  {
     DMA0->TCD[chx].CSR &= ~(DMA_CSR_DREQ_MASK); //ѭ󣬲رDMA
    2ce6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2cea:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2cee:	f897 1027 	ldrb.w	r1, [r7, #39]	; 0x27
    2cf2:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    2cf6:	f2c4 0200 	movt	r2, #16384	; 0x4000
    2cfa:	f897 0027 	ldrb.w	r0, [r7, #39]	; 0x27
    2cfe:	ea4f 1040 	mov.w	r0, r0, lsl #5
    2d02:	1812      	adds	r2, r2, r0
    2d04:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    2d08:	f102 0218 	add.w	r2, r2, #24
    2d0c:	8892      	ldrh	r2, [r2, #4]
    2d0e:	b292      	uxth	r2, r2
    2d10:	f022 0208 	bic.w	r2, r2, #8
    2d14:	b292      	uxth	r2, r2
    2d16:	ea4f 1141 	mov.w	r1, r1, lsl #5
    2d1a:	185b      	adds	r3, r3, r1
    2d1c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    2d20:	f103 0318 	add.w	r3, r3, #24
    2d24:	809a      	strh	r2, [r3, #4]
  } 
 
  //DMAͨʹ
  DMAMUX->CHCFG[chx] |= DMAMUX_CHCFG_ENBL_MASK;
    2d26:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    2d2a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    2d2e:	f897 1027 	ldrb.w	r1, [r7, #39]	; 0x27
    2d32:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    2d36:	f2c4 0202 	movt	r2, #16386	; 0x4002
    2d3a:	f897 0027 	ldrb.w	r0, [r7, #39]	; 0x27
    2d3e:	5c12      	ldrb	r2, [r2, r0]
    2d40:	b2d2      	uxtb	r2, r2
    2d42:	f062 027f 	orn	r2, r2, #127	; 0x7f
    2d46:	b2d2      	uxtb	r2, r2
    2d48:	545a      	strb	r2, [r3, r1]
    
  return 1;
    2d4a:	f04f 0301 	mov.w	r3, #1
}
    2d4e:	4618      	mov	r0, r3
    2d50:	f107 072c 	add.w	r7, r7, #44	; 0x2c
    2d54:	46bd      	mov	sp, r7
    2d56:	bc80      	pop	{r7}
    2d58:	b004      	add	sp, #16
    2d5a:	4770      	bx	lr

00002d5c <LPLD_DMA_EnableIrq>:
 * :
 *    0--ʧ
 *    1--ɹ
 */
uint8 LPLD_DMA_EnableIrq(DMA_InitTypeDef dma_init_struct)
{
    2d5c:	b084      	sub	sp, #16
    2d5e:	b580      	push	{r7, lr}
    2d60:	af00      	add	r7, sp, #0
    2d62:	f107 0c08 	add.w	ip, r7, #8
    2d66:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  enable_irq(dma_init_struct.DMA_CHx + INT_DMA0_DMA16 - 16);  
    2d6a:	7a3b      	ldrb	r3, [r7, #8]
    2d6c:	4618      	mov	r0, r3
    2d6e:	f7fd fecf 	bl	b10 <enable_irq>
  return 1;
    2d72:	f04f 0301 	mov.w	r3, #1
}
    2d76:	4618      	mov	r0, r3
    2d78:	46bd      	mov	sp, r7
    2d7a:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    2d7e:	b004      	add	sp, #16
    2d80:	4770      	bx	lr
    2d82:	bf00      	nop

00002d84 <LPLD_DMA_DisableIrq>:
 * :
 *    0--ʧ
 *    1--ɹ
 */
uint8 LPLD_DMA_DisableIrq(DMA_InitTypeDef dma_init_struct)
{
    2d84:	b084      	sub	sp, #16
    2d86:	b580      	push	{r7, lr}
    2d88:	af00      	add	r7, sp, #0
    2d8a:	f107 0c08 	add.w	ip, r7, #8
    2d8e:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  disable_irq(dma_init_struct.DMA_CHx + INT_DMA0_DMA16 - 16);
    2d92:	7a3b      	ldrb	r3, [r7, #8]
    2d94:	4618      	mov	r0, r3
    2d96:	f7fd ff7f 	bl	c98 <disable_irq>
  return 1;
    2d9a:	f04f 0301 	mov.w	r3, #1
}
    2d9e:	4618      	mov	r0, r3
    2da0:	46bd      	mov	sp, r7
    2da2:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    2da6:	b004      	add	sp, #16
    2da8:	4770      	bx	lr
    2daa:	bf00      	nop

00002dac <LPLD_DMA_SoftwareStartService>:
 *
 * :
 *    
 */
void LPLD_DMA_SoftwareStartService(DMA_InitTypeDef dma_init_struct)
{
    2dac:	b084      	sub	sp, #16
    2dae:	b480      	push	{r7}
    2db0:	af00      	add	r7, sp, #0
    2db2:	f107 0c04 	add.w	ip, r7, #4
    2db6:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  DMA0->TCD[dma_init_struct.DMA_CHx].CSR |= DMA_CSR_START_MASK; 
    2dba:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2dbe:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2dc2:	793a      	ldrb	r2, [r7, #4]
    2dc4:	4611      	mov	r1, r2
    2dc6:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    2dca:	f2c4 0200 	movt	r2, #16384	; 0x4000
    2dce:	7938      	ldrb	r0, [r7, #4]
    2dd0:	ea4f 1040 	mov.w	r0, r0, lsl #5
    2dd4:	1812      	adds	r2, r2, r0
    2dd6:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    2dda:	f102 0218 	add.w	r2, r2, #24
    2dde:	8892      	ldrh	r2, [r2, #4]
    2de0:	b292      	uxth	r2, r2
    2de2:	f042 0201 	orr.w	r2, r2, #1
    2de6:	b292      	uxth	r2, r2
    2de8:	ea4f 1141 	mov.w	r1, r1, lsl #5
    2dec:	185b      	adds	r3, r3, r1
    2dee:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    2df2:	f103 0318 	add.w	r3, r3, #24
    2df6:	809a      	strh	r2, [r3, #4]
}
    2df8:	46bd      	mov	sp, r7
    2dfa:	bc80      	pop	{r7}
    2dfc:	b004      	add	sp, #16
    2dfe:	4770      	bx	lr

00002e00 <DMA0_IRQHandler>:
 * eDMAжϴ
 * ļstartup_K60.sеж
 * û޸ģԶӦͨжϺ
 */
void DMA0_IRQHandler(void)
{
    2e00:	b580      	push	{r7, lr}
    2e02:	af00      	add	r7, sp, #0
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[0]();
    2e04:	f241 6304 	movw	r3, #5636	; 0x1604
    2e08:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    2e0c:	681b      	ldr	r3, [r3, #0]
    2e0e:	4798      	blx	r3
  //жϱ־λ
  DMA0->INT |= 0x1u<<0;
    2e10:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2e14:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2e18:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    2e1c:	f2c4 0200 	movt	r2, #16384	; 0x4000
    2e20:	6a52      	ldr	r2, [r2, #36]	; 0x24
    2e22:	f042 0201 	orr.w	r2, r2, #1
    2e26:	625a      	str	r2, [r3, #36]	; 0x24
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2e28:	bd80      	pop	{r7, pc}
    2e2a:	bf00      	nop

00002e2c <DMA1_IRQHandler>:

void DMA1_IRQHandler(void)
{
    2e2c:	b580      	push	{r7, lr}
    2e2e:	af00      	add	r7, sp, #0
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[1]();
    2e30:	f241 6304 	movw	r3, #5636	; 0x1604
    2e34:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    2e38:	685b      	ldr	r3, [r3, #4]
    2e3a:	4798      	blx	r3
  //жϱ־λ
  DMA0->INT |= 0x1u<<1;
    2e3c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2e40:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2e44:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    2e48:	f2c4 0200 	movt	r2, #16384	; 0x4000
    2e4c:	6a52      	ldr	r2, [r2, #36]	; 0x24
    2e4e:	f042 0202 	orr.w	r2, r2, #2
    2e52:	625a      	str	r2, [r3, #36]	; 0x24
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2e54:	bd80      	pop	{r7, pc}
    2e56:	bf00      	nop

00002e58 <DMA2_IRQHandler>:

void DMA2_IRQHandler(void)
{
    2e58:	b580      	push	{r7, lr}
    2e5a:	af00      	add	r7, sp, #0
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[2]();
    2e5c:	f241 6304 	movw	r3, #5636	; 0x1604
    2e60:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    2e64:	689b      	ldr	r3, [r3, #8]
    2e66:	4798      	blx	r3
  //жϱ־λ
  DMA0->INT |= 0x1u<<2;
    2e68:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2e6c:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2e70:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    2e74:	f2c4 0200 	movt	r2, #16384	; 0x4000
    2e78:	6a52      	ldr	r2, [r2, #36]	; 0x24
    2e7a:	f042 0204 	orr.w	r2, r2, #4
    2e7e:	625a      	str	r2, [r3, #36]	; 0x24
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2e80:	bd80      	pop	{r7, pc}
    2e82:	bf00      	nop

00002e84 <DMA3_IRQHandler>:

void DMA3_IRQHandler(void)
{
    2e84:	b580      	push	{r7, lr}
    2e86:	af00      	add	r7, sp, #0
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[3]();
    2e88:	f241 6304 	movw	r3, #5636	; 0x1604
    2e8c:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    2e90:	68db      	ldr	r3, [r3, #12]
    2e92:	4798      	blx	r3
  //жϱ־λ
  DMA0->INT |= 0x1u<<3;
    2e94:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2e98:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2e9c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    2ea0:	f2c4 0200 	movt	r2, #16384	; 0x4000
    2ea4:	6a52      	ldr	r2, [r2, #36]	; 0x24
    2ea6:	f042 0208 	orr.w	r2, r2, #8
    2eaa:	625a      	str	r2, [r3, #36]	; 0x24
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2eac:	bd80      	pop	{r7, pc}
    2eae:	bf00      	nop

00002eb0 <DMA4_IRQHandler>:

void DMA4_IRQHandler(void)
{
    2eb0:	b580      	push	{r7, lr}
    2eb2:	af00      	add	r7, sp, #0
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[4]();
    2eb4:	f241 6304 	movw	r3, #5636	; 0x1604
    2eb8:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    2ebc:	691b      	ldr	r3, [r3, #16]
    2ebe:	4798      	blx	r3
  //жϱ־λ
  DMA0->INT |= 0x1u<<4;
    2ec0:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2ec4:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2ec8:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    2ecc:	f2c4 0200 	movt	r2, #16384	; 0x4000
    2ed0:	6a52      	ldr	r2, [r2, #36]	; 0x24
    2ed2:	f042 0210 	orr.w	r2, r2, #16
    2ed6:	625a      	str	r2, [r3, #36]	; 0x24
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2ed8:	bd80      	pop	{r7, pc}
    2eda:	bf00      	nop

00002edc <DMA5_IRQHandler>:

void DMA5_IRQHandler(void)
{
    2edc:	b580      	push	{r7, lr}
    2ede:	af00      	add	r7, sp, #0
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[5]();
    2ee0:	f241 6304 	movw	r3, #5636	; 0x1604
    2ee4:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    2ee8:	695b      	ldr	r3, [r3, #20]
    2eea:	4798      	blx	r3
  //жϱ־λ
  DMA0->INT |= 0x1u<<5;
    2eec:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2ef0:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2ef4:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    2ef8:	f2c4 0200 	movt	r2, #16384	; 0x4000
    2efc:	6a52      	ldr	r2, [r2, #36]	; 0x24
    2efe:	f042 0220 	orr.w	r2, r2, #32
    2f02:	625a      	str	r2, [r3, #36]	; 0x24
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2f04:	bd80      	pop	{r7, pc}
    2f06:	bf00      	nop

00002f08 <DMA6_IRQHandler>:

void DMA6_IRQHandler(void)
{
    2f08:	b580      	push	{r7, lr}
    2f0a:	af00      	add	r7, sp, #0
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[6]();
    2f0c:	f241 6304 	movw	r3, #5636	; 0x1604
    2f10:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    2f14:	699b      	ldr	r3, [r3, #24]
    2f16:	4798      	blx	r3
  //жϱ־λ
  DMA0->INT |= 0x1u<<6;
    2f18:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2f1c:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2f20:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    2f24:	f2c4 0200 	movt	r2, #16384	; 0x4000
    2f28:	6a52      	ldr	r2, [r2, #36]	; 0x24
    2f2a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    2f2e:	625a      	str	r2, [r3, #36]	; 0x24
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2f30:	bd80      	pop	{r7, pc}
    2f32:	bf00      	nop

00002f34 <DMA7_IRQHandler>:

void DMA7_IRQHandler(void)
{
    2f34:	b580      	push	{r7, lr}
    2f36:	af00      	add	r7, sp, #0
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[7]();
    2f38:	f241 6304 	movw	r3, #5636	; 0x1604
    2f3c:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    2f40:	69db      	ldr	r3, [r3, #28]
    2f42:	4798      	blx	r3
  //жϱ־λ
  DMA0->INT |= 0x1u<<7;
    2f44:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2f48:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2f4c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    2f50:	f2c4 0200 	movt	r2, #16384	; 0x4000
    2f54:	6a52      	ldr	r2, [r2, #36]	; 0x24
    2f56:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    2f5a:	625a      	str	r2, [r3, #36]	; 0x24
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2f5c:	bd80      	pop	{r7, pc}
    2f5e:	bf00      	nop

00002f60 <DMA8_IRQHandler>:

void DMA8_IRQHandler(void)
{
    2f60:	b580      	push	{r7, lr}
    2f62:	af00      	add	r7, sp, #0
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[8]();
    2f64:	f241 6304 	movw	r3, #5636	; 0x1604
    2f68:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    2f6c:	6a1b      	ldr	r3, [r3, #32]
    2f6e:	4798      	blx	r3
  //жϱ־λ
  DMA0->INT |= 0x1u<<8;
    2f70:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2f74:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2f78:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    2f7c:	f2c4 0200 	movt	r2, #16384	; 0x4000
    2f80:	6a52      	ldr	r2, [r2, #36]	; 0x24
    2f82:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    2f86:	625a      	str	r2, [r3, #36]	; 0x24
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2f88:	bd80      	pop	{r7, pc}
    2f8a:	bf00      	nop

00002f8c <DMA9_IRQHandler>:

void DMA9_IRQHandler(void)
{
    2f8c:	b580      	push	{r7, lr}
    2f8e:	af00      	add	r7, sp, #0
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[9]();
    2f90:	f241 6304 	movw	r3, #5636	; 0x1604
    2f94:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    2f98:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    2f9a:	4798      	blx	r3
  //жϱ־λ
  DMA0->INT |= 0x1u<<9;
    2f9c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2fa0:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2fa4:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    2fa8:	f2c4 0200 	movt	r2, #16384	; 0x4000
    2fac:	6a52      	ldr	r2, [r2, #36]	; 0x24
    2fae:	f442 7200 	orr.w	r2, r2, #512	; 0x200
    2fb2:	625a      	str	r2, [r3, #36]	; 0x24
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2fb4:	bd80      	pop	{r7, pc}
    2fb6:	bf00      	nop

00002fb8 <DMA10_IRQHandler>:

void DMA10_IRQHandler(void)
{
    2fb8:	b580      	push	{r7, lr}
    2fba:	af00      	add	r7, sp, #0
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[10]();
    2fbc:	f241 6304 	movw	r3, #5636	; 0x1604
    2fc0:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    2fc4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2fc6:	4798      	blx	r3
  //жϱ־λ
  DMA0->INT |= 0x1u<10;
    2fc8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2fcc:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2fd0:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    2fd4:	f2c4 0200 	movt	r2, #16384	; 0x4000
    2fd8:	6a52      	ldr	r2, [r2, #36]	; 0x24
    2fda:	f042 0201 	orr.w	r2, r2, #1
    2fde:	625a      	str	r2, [r3, #36]	; 0x24
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2fe0:	bd80      	pop	{r7, pc}
    2fe2:	bf00      	nop

00002fe4 <DMA11_IRQHandler>:

void DMA11_IRQHandler(void)
{
    2fe4:	b580      	push	{r7, lr}
    2fe6:	af00      	add	r7, sp, #0
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[11]();
    2fe8:	f241 6304 	movw	r3, #5636	; 0x1604
    2fec:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    2ff0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2ff2:	4798      	blx	r3
  //жϱ־λ
  DMA0->INT |= 0x1u<<11;
    2ff4:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    2ff8:	f2c4 0300 	movt	r3, #16384	; 0x4000
    2ffc:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    3000:	f2c4 0200 	movt	r2, #16384	; 0x4000
    3004:	6a52      	ldr	r2, [r2, #36]	; 0x24
    3006:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
    300a:	625a      	str	r2, [r3, #36]	; 0x24
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    300c:	bd80      	pop	{r7, pc}
    300e:	bf00      	nop

00003010 <DMA12_IRQHandler>:

void DMA12_IRQHandler(void)
{
    3010:	b580      	push	{r7, lr}
    3012:	af00      	add	r7, sp, #0
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[12]();
    3014:	f241 6304 	movw	r3, #5636	; 0x1604
    3018:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    301c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    301e:	4798      	blx	r3
  //жϱ־λ
  DMA0->INT |= 0x1u<<12;
    3020:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    3024:	f2c4 0300 	movt	r3, #16384	; 0x4000
    3028:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    302c:	f2c4 0200 	movt	r2, #16384	; 0x4000
    3030:	6a52      	ldr	r2, [r2, #36]	; 0x24
    3032:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
    3036:	625a      	str	r2, [r3, #36]	; 0x24
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    3038:	bd80      	pop	{r7, pc}
    303a:	bf00      	nop

0000303c <DMA13_IRQHandler>:

void DMA13_IRQHandler(void)
{
    303c:	b580      	push	{r7, lr}
    303e:	af00      	add	r7, sp, #0
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[13]();
    3040:	f241 6304 	movw	r3, #5636	; 0x1604
    3044:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    3048:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    304a:	4798      	blx	r3
  //жϱ־λ
  DMA0->INT |= 0x1u<<13;
    304c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    3050:	f2c4 0300 	movt	r3, #16384	; 0x4000
    3054:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    3058:	f2c4 0200 	movt	r2, #16384	; 0x4000
    305c:	6a52      	ldr	r2, [r2, #36]	; 0x24
    305e:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
    3062:	625a      	str	r2, [r3, #36]	; 0x24
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    3064:	bd80      	pop	{r7, pc}
    3066:	bf00      	nop

00003068 <DMA14_IRQHandler>:

void DMA14_IRQHandler(void)
{
    3068:	b580      	push	{r7, lr}
    306a:	af00      	add	r7, sp, #0
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[14]();
    306c:	f241 6304 	movw	r3, #5636	; 0x1604
    3070:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    3074:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    3076:	4798      	blx	r3
  //жϱ־λ
  DMA0->INT |= 0x1u<<14;
    3078:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    307c:	f2c4 0300 	movt	r3, #16384	; 0x4000
    3080:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    3084:	f2c4 0200 	movt	r2, #16384	; 0x4000
    3088:	6a52      	ldr	r2, [r2, #36]	; 0x24
    308a:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
    308e:	625a      	str	r2, [r3, #36]	; 0x24
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    3090:	bd80      	pop	{r7, pc}
    3092:	bf00      	nop

00003094 <DMA15_IRQHandler>:

void DMA15_IRQHandler(void)
{
    3094:	b580      	push	{r7, lr}
    3096:	af00      	add	r7, sp, #0
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[15]();
    3098:	f241 6304 	movw	r3, #5636	; 0x1604
    309c:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    30a0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    30a2:	4798      	blx	r3
  //жϱ־λ
  DMA0->INT |= 0x1u<<15;
    30a4:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    30a8:	f2c4 0300 	movt	r3, #16384	; 0x4000
    30ac:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    30b0:	f2c4 0200 	movt	r2, #16384	; 0x4000
    30b4:	6a52      	ldr	r2, [r2, #36]	; 0x24
    30b6:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
    30ba:	625a      	str	r2, [r3, #36]	; 0x24
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    30bc:	bd80      	pop	{r7, pc}
    30be:	bf00      	nop

000030c0 <LPLD_FTM_Init>:
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_FTM_Init(FTM_InitTypeDef ftm_init_structure)
{
    30c0:	b084      	sub	sp, #16
    30c2:	b580      	push	{r7, lr}
    30c4:	b086      	sub	sp, #24
    30c6:	af04      	add	r7, sp, #16
    30c8:	f107 0c10 	add.w	ip, r7, #16
    30cc:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  uint8 result, i;
  
  // ʹFTMʱģ
  if(ftm_init_structure.FTM_Ftmx == FTM0)
    30d0:	693a      	ldr	r2, [r7, #16]
    30d2:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    30d6:	f2c4 0303 	movt	r3, #16387	; 0x4003
    30da:	429a      	cmp	r2, r3
    30dc:	d117      	bne.n	310e <LPLD_FTM_Init+0x4e>
  {
    i=0; 
    30de:	f04f 0300 	mov.w	r3, #0
    30e2:	71bb      	strb	r3, [r7, #6]
    SIM_SCGC6 |= SIM_SCGC6_FTM0_MASK;
    30e4:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    30e8:	f2c4 0304 	movt	r3, #16388	; 0x4004
    30ec:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    30f0:	f2c4 0204 	movt	r2, #16388	; 0x4004
    30f4:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    30f8:	f102 021c 	add.w	r2, r2, #28
    30fc:	6812      	ldr	r2, [r2, #0]
    30fe:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
    3102:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    3106:	f103 031c 	add.w	r3, r3, #28
    310a:	601a      	str	r2, [r3, #0]
    310c:	e05f      	b.n	31ce <LPLD_FTM_Init+0x10e>
  }
  else if(ftm_init_structure.FTM_Ftmx == FTM1)
    310e:	693a      	ldr	r2, [r7, #16]
    3110:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    3114:	f2c4 0303 	movt	r3, #16387	; 0x4003
    3118:	429a      	cmp	r2, r3
    311a:	d117      	bne.n	314c <LPLD_FTM_Init+0x8c>
  {
    i=1;
    311c:	f04f 0301 	mov.w	r3, #1
    3120:	71bb      	strb	r3, [r7, #6]
    SIM_SCGC6 |= SIM_SCGC6_FTM1_MASK;
    3122:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    3126:	f2c4 0304 	movt	r3, #16388	; 0x4004
    312a:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    312e:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3132:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    3136:	f102 021c 	add.w	r2, r2, #28
    313a:	6812      	ldr	r2, [r2, #0]
    313c:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
    3140:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    3144:	f103 031c 	add.w	r3, r3, #28
    3148:	601a      	str	r2, [r3, #0]
    314a:	e040      	b.n	31ce <LPLD_FTM_Init+0x10e>
  }
  else if(ftm_init_structure.FTM_Ftmx == FTM2)
    314c:	693a      	ldr	r2, [r7, #16]
    314e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    3152:	f2c4 030b 	movt	r3, #16395	; 0x400b
    3156:	429a      	cmp	r2, r3
    3158:	d117      	bne.n	318a <LPLD_FTM_Init+0xca>
  {
    i=2;
    315a:	f04f 0302 	mov.w	r3, #2
    315e:	71bb      	strb	r3, [r7, #6]
    SIM_SCGC3 |= SIM_SCGC3_FTM2_MASK;
    3160:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    3164:	f2c4 0304 	movt	r3, #16388	; 0x4004
    3168:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    316c:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3170:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    3174:	f102 0210 	add.w	r2, r2, #16
    3178:	6812      	ldr	r2, [r2, #0]
    317a:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
    317e:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    3182:	f103 0310 	add.w	r3, r3, #16
    3186:	601a      	str	r2, [r3, #0]
    3188:	e021      	b.n	31ce <LPLD_FTM_Init+0x10e>
  }
  else if (ftm_init_structure.FTM_Ftmx == FTM3)
    318a:	693a      	ldr	r2, [r7, #16]
    318c:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    3190:	f2c4 030b 	movt	r3, #16395	; 0x400b
    3194:	429a      	cmp	r2, r3
    3196:	d117      	bne.n	31c8 <LPLD_FTM_Init+0x108>
  {
    i = 3;
    3198:	f04f 0303 	mov.w	r3, #3
    319c:	71bb      	strb	r3, [r7, #6]
    SIM_SCGC3 |= SIM_SCGC3_FTM3_MASK;
    319e:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    31a2:	f2c4 0304 	movt	r3, #16388	; 0x4004
    31a6:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    31aa:	f2c4 0204 	movt	r2, #16388	; 0x4004
    31ae:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    31b2:	f102 0210 	add.w	r2, r2, #16
    31b6:	6812      	ldr	r2, [r2, #0]
    31b8:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
    31bc:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    31c0:	f103 0310 	add.w	r3, r3, #16
    31c4:	601a      	str	r2, [r3, #0]
    31c6:	e002      	b.n	31ce <LPLD_FTM_Init+0x10e>
  }
  else
  {
    return 0;
    31c8:	f04f 0300 	mov.w	r3, #0
    31cc:	e067      	b.n	329e <LPLD_FTM_Init+0x1de>
  }
  
  if(ftm_init_structure.FTM_Mode & FTM_MODE_PWM)
    31ce:	7d3b      	ldrb	r3, [r7, #20]
    31d0:	f003 0301 	and.w	r3, r3, #1
    31d4:	2b00      	cmp	r3, #0
    31d6:	d00e      	beq.n	31f6 <LPLD_FTM_Init+0x136>
  {
    result = LPLD_FTM_PWM_Init(ftm_init_structure);
    31d8:	466b      	mov	r3, sp
    31da:	f107 0220 	add.w	r2, r7, #32
    31de:	ca07      	ldmia	r2, {r0, r1, r2}
    31e0:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    31e4:	f107 0c10 	add.w	ip, r7, #16
    31e8:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
    31ec:	f000 fbbe 	bl	396c <LPLD_FTM_PWM_Init>
    31f0:	4603      	mov	r3, r0
    31f2:	71fb      	strb	r3, [r7, #7]
    31f4:	e03a      	b.n	326c <LPLD_FTM_Init+0x1ac>
  }
  else if(ftm_init_structure.FTM_Mode & FTM_MODE_IC)
    31f6:	7d3b      	ldrb	r3, [r7, #20]
    31f8:	f003 0302 	and.w	r3, r3, #2
    31fc:	2b00      	cmp	r3, #0
    31fe:	d00e      	beq.n	321e <LPLD_FTM_Init+0x15e>
  {
    result = LPLD_FTM_IC_Init(ftm_init_structure);
    3200:	466b      	mov	r3, sp
    3202:	f107 0220 	add.w	r2, r7, #32
    3206:	ca07      	ldmia	r2, {r0, r1, r2}
    3208:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    320c:	f107 0c10 	add.w	ip, r7, #16
    3210:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
    3214:	f000 fc88 	bl	3b28 <LPLD_FTM_IC_Init>
    3218:	4603      	mov	r3, r0
    321a:	71fb      	strb	r3, [r7, #7]
    321c:	e026      	b.n	326c <LPLD_FTM_Init+0x1ac>
  }
  else if(ftm_init_structure.FTM_Mode & FTM_MODE_QD)
    321e:	7d3b      	ldrb	r3, [r7, #20]
    3220:	f003 0304 	and.w	r3, r3, #4
    3224:	2b00      	cmp	r3, #0
    3226:	d00e      	beq.n	3246 <LPLD_FTM_Init+0x186>
  {
    result = LPLD_FTM_QD_Init(ftm_init_structure);
    3228:	466b      	mov	r3, sp
    322a:	f107 0220 	add.w	r2, r7, #32
    322e:	ca07      	ldmia	r2, {r0, r1, r2}
    3230:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    3234:	f107 0c10 	add.w	ip, r7, #16
    3238:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
    323c:	f001 fcc4 	bl	4bc8 <LPLD_FTM_QD_Init>
    3240:	4603      	mov	r3, r0
    3242:	71fb      	strb	r3, [r7, #7]
    3244:	e012      	b.n	326c <LPLD_FTM_Init+0x1ac>
  }
  else if(ftm_init_structure.FTM_Mode & FTM_MODE_DEC)
    3246:	7d3b      	ldrb	r3, [r7, #20]
    3248:	f003 0308 	and.w	r3, r3, #8
    324c:	2b00      	cmp	r3, #0
    324e:	d00d      	beq.n	326c <LPLD_FTM_Init+0x1ac>
  {
    result = LPLD_FTM_DEC_Init(ftm_init_structure);
    3250:	466b      	mov	r3, sp
    3252:	f107 0220 	add.w	r2, r7, #32
    3256:	ca07      	ldmia	r2, {r0, r1, r2}
    3258:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    325c:	f107 0c10 	add.w	ip, r7, #16
    3260:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
    3264:	f001 fce8 	bl	4c38 <LPLD_FTM_DEC_Init>
    3268:	4603      	mov	r3, r0
    326a:	71fb      	strb	r3, [r7, #7]
  }
  
  if(result == 1)
    326c:	79fb      	ldrb	r3, [r7, #7]
    326e:	2b01      	cmp	r3, #1
    3270:	d114      	bne.n	329c <LPLD_FTM_Init+0x1dc>
  {    
    //жǷж
    if(ftm_init_structure.FTM_Isr!=NULL)
    3272:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3274:	2b00      	cmp	r3, #0
    3276:	d011      	beq.n	329c <LPLD_FTM_Init+0x1dc>
    {      
      FTM_ISR[i] = ftm_init_structure.FTM_Isr;
    3278:	79ba      	ldrb	r2, [r7, #6]
    327a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    327c:	f241 6344 	movw	r3, #5700	; 0x1644
    3280:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    3284:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      if(ftm_init_structure.FTM_ToiEnable == TRUE)
    3288:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
    328c:	2b01      	cmp	r3, #1
    328e:	d105      	bne.n	329c <LPLD_FTM_Init+0x1dc>
      {
        ftm_init_structure.FTM_Ftmx->SC |= FTM_SC_TOIE_MASK;
    3290:	693b      	ldr	r3, [r7, #16]
    3292:	693a      	ldr	r2, [r7, #16]
    3294:	6812      	ldr	r2, [r2, #0]
    3296:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    329a:	601a      	str	r2, [r3, #0]
      }
    }
  }
  
  return result;
    329c:	79fb      	ldrb	r3, [r7, #7]
}
    329e:	4618      	mov	r0, r3
    32a0:	f107 0708 	add.w	r7, r7, #8
    32a4:	46bd      	mov	sp, r7
    32a6:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    32aa:	b004      	add	sp, #16
    32ac:	4770      	bx	lr
    32ae:	bf00      	nop

000032b0 <LPLD_FTM_Deinit>:
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_FTM_Deinit(FTM_InitTypeDef ftm_init_structure)
{
    32b0:	b084      	sub	sp, #16
    32b2:	b580      	push	{r7, lr}
    32b4:	b084      	sub	sp, #16
    32b6:	af04      	add	r7, sp, #16
    32b8:	f107 0c08 	add.w	ip, r7, #8
    32bc:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  if(ftm_init_structure.FTM_Ftmx == FTM0)
    32c0:	68ba      	ldr	r2, [r7, #8]
    32c2:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    32c6:	f2c4 0303 	movt	r3, #16387	; 0x4003
    32ca:	429a      	cmp	r2, r3
    32cc:	d114      	bne.n	32f8 <LPLD_FTM_Deinit+0x48>
  {
    SIM_SCGC6 &= ~SIM_SCGC6_FTM0_MASK;
    32ce:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    32d2:	f2c4 0304 	movt	r3, #16388	; 0x4004
    32d6:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    32da:	f2c4 0204 	movt	r2, #16388	; 0x4004
    32de:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    32e2:	f102 021c 	add.w	r2, r2, #28
    32e6:	6812      	ldr	r2, [r2, #0]
    32e8:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
    32ec:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    32f0:	f103 031c 	add.w	r3, r3, #28
    32f4:	601a      	str	r2, [r3, #0]
    32f6:	e056      	b.n	33a6 <LPLD_FTM_Deinit+0xf6>
  }
  else if(ftm_init_structure.FTM_Ftmx == FTM1)
    32f8:	68ba      	ldr	r2, [r7, #8]
    32fa:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    32fe:	f2c4 0303 	movt	r3, #16387	; 0x4003
    3302:	429a      	cmp	r2, r3
    3304:	d114      	bne.n	3330 <LPLD_FTM_Deinit+0x80>
  {
    SIM_SCGC6 &= ~SIM_SCGC6_FTM1_MASK;
    3306:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    330a:	f2c4 0304 	movt	r3, #16388	; 0x4004
    330e:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    3312:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3316:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    331a:	f102 021c 	add.w	r2, r2, #28
    331e:	6812      	ldr	r2, [r2, #0]
    3320:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
    3324:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    3328:	f103 031c 	add.w	r3, r3, #28
    332c:	601a      	str	r2, [r3, #0]
    332e:	e03a      	b.n	33a6 <LPLD_FTM_Deinit+0xf6>
  }
  else if(ftm_init_structure.FTM_Ftmx == FTM2)
    3330:	68ba      	ldr	r2, [r7, #8]
    3332:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    3336:	f2c4 030b 	movt	r3, #16395	; 0x400b
    333a:	429a      	cmp	r2, r3
    333c:	d114      	bne.n	3368 <LPLD_FTM_Deinit+0xb8>
  {
    SIM_SCGC3 &= ~SIM_SCGC3_FTM2_MASK;
    333e:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    3342:	f2c4 0304 	movt	r3, #16388	; 0x4004
    3346:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    334a:	f2c4 0204 	movt	r2, #16388	; 0x4004
    334e:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    3352:	f102 0210 	add.w	r2, r2, #16
    3356:	6812      	ldr	r2, [r2, #0]
    3358:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
    335c:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    3360:	f103 0310 	add.w	r3, r3, #16
    3364:	601a      	str	r2, [r3, #0]
    3366:	e01e      	b.n	33a6 <LPLD_FTM_Deinit+0xf6>
  }
  else if (ftm_init_structure.FTM_Ftmx == FTM3)
    3368:	68ba      	ldr	r2, [r7, #8]
    336a:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    336e:	f2c4 030b 	movt	r3, #16395	; 0x400b
    3372:	429a      	cmp	r2, r3
    3374:	d114      	bne.n	33a0 <LPLD_FTM_Deinit+0xf0>
  {
      SIM_SCGC3 &= ~SIM_SCGC3_FTM3_MASK;
    3376:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    337a:	f2c4 0304 	movt	r3, #16388	; 0x4004
    337e:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    3382:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3386:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    338a:	f102 0210 	add.w	r2, r2, #16
    338e:	6812      	ldr	r2, [r2, #0]
    3390:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
    3394:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    3398:	f103 0310 	add.w	r3, r3, #16
    339c:	601a      	str	r2, [r3, #0]
    339e:	e002      	b.n	33a6 <LPLD_FTM_Deinit+0xf6>
  }
  else
  {
    return 0;
    33a0:	f04f 0300 	mov.w	r3, #0
    33a4:	e00c      	b.n	33c0 <LPLD_FTM_Deinit+0x110>
  }
  
  return LPLD_FTM_DisableIrq(ftm_init_structure);
    33a6:	466b      	mov	r3, sp
    33a8:	f107 0218 	add.w	r2, r7, #24
    33ac:	ca07      	ldmia	r2, {r0, r1, r2}
    33ae:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    33b2:	f107 0c08 	add.w	ip, r7, #8
    33b6:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
    33ba:	f000 fa41 	bl	3840 <LPLD_FTM_DisableIrq>
    33be:	4603      	mov	r3, r0
}
    33c0:	4618      	mov	r0, r3
    33c2:	46bd      	mov	sp, r7
    33c4:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    33c8:	b004      	add	sp, #16
    33ca:	4770      	bx	lr

000033cc <LPLD_FTM_PWM_Enable>:
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_FTM_PWM_Enable(FTM_MemMapPtr  ftmx, FtmChnEnum_Type chn, uint32 duty, PortPinsEnum_Type pin, uint8 align)
{
    33cc:	b580      	push	{r7, lr}
    33ce:	b086      	sub	sp, #24
    33d0:	af00      	add	r7, sp, #0
    33d2:	60f8      	str	r0, [r7, #12]
    33d4:	607a      	str	r2, [r7, #4]
    33d6:	460a      	mov	r2, r1
    33d8:	72fa      	strb	r2, [r7, #11]
    33da:	72bb      	strb	r3, [r7, #10]
  uint32 cv;
  vuint32 mod;
 
  if (duty > 10000)
    33dc:	687a      	ldr	r2, [r7, #4]
    33de:	f242 7310 	movw	r3, #10000	; 0x2710
    33e2:	429a      	cmp	r2, r3
    33e4:	d902      	bls.n	33ec <LPLD_FTM_PWM_Enable+0x20>
    return 0;
    33e6:	f04f 0300 	mov.w	r3, #0
    33ea:	e03d      	b.n	3468 <LPLD_FTM_PWM_Enable+0x9c>
  //
  //ASSERT( duty <= 10000 );                  //жռձ
  
  if(!LPLD_FTM_PinInit(ftmx, chn, pin))
    33ec:	7afa      	ldrb	r2, [r7, #11]
    33ee:	7abb      	ldrb	r3, [r7, #10]
    33f0:	68f8      	ldr	r0, [r7, #12]
    33f2:	4611      	mov	r1, r2
    33f4:	461a      	mov	r2, r3
    33f6:	f000 fc1d 	bl	3c34 <LPLD_FTM_PinInit>
    33fa:	4603      	mov	r3, r0
    33fc:	2b00      	cmp	r3, #0
    33fe:	d102      	bne.n	3406 <LPLD_FTM_PWM_Enable+0x3a>
    return 0;
    3400:	f04f 0300 	mov.w	r3, #0
    3404:	e030      	b.n	3468 <LPLD_FTM_PWM_Enable+0x9c>
  
  //Ҷ룬100%-ռձ
  if(align == ALIGN_RIGHT)
    3406:	f897 3020 	ldrb.w	r3, [r7, #32]
    340a:	2b24      	cmp	r3, #36	; 0x24
    340c:	d105      	bne.n	341a <LPLD_FTM_PWM_Enable+0x4e>
  {
    duty = 10000 - duty;
    340e:	687b      	ldr	r3, [r7, #4]
    3410:	f5c3 531c 	rsb	r3, r3, #9984	; 0x2700
    3414:	f103 0310 	add.w	r3, r3, #16
    3418:	607b      	str	r3, [r7, #4]
  }
  
  //ռձ = (CnV-CNTIN)/(MOD-CNTIN+1)
  mod = ftmx->MOD;
    341a:	68fb      	ldr	r3, [r7, #12]
    341c:	689b      	ldr	r3, [r3, #8]
    341e:	613b      	str	r3, [r7, #16]
  cv = (duty*(mod-0+1)+0)/10000;
    3420:	693b      	ldr	r3, [r7, #16]
    3422:	f103 0301 	add.w	r3, r3, #1
    3426:	687a      	ldr	r2, [r7, #4]
    3428:	fb02 f203 	mul.w	r2, r2, r3
    342c:	f241 7359 	movw	r3, #5977	; 0x1759
    3430:	f2cd 13b7 	movt	r3, #53687	; 0xd1b7
    3434:	fba3 1302 	umull	r1, r3, r3, r2
    3438:	ea4f 3353 	mov.w	r3, r3, lsr #13
    343c:	617b      	str	r3, [r7, #20]
  
  // FTMͨƼĴ 
  // ͨģʽ MSB:MSA-1X, ͨԵѡ  ELSB:ELSA-10
  // ͨģʽ MSB:MSA-1X, ͨԵѡ Ҷ ELSB:ELSA-X1
  ftmx->CONTROLS[chn].CnSC = align;
    343e:	7afb      	ldrb	r3, [r7, #11]
    3440:	f897 2020 	ldrb.w	r2, [r7, #32]
    3444:	68f9      	ldr	r1, [r7, #12]
    3446:	f103 0301 	add.w	r3, r3, #1
    344a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    344e:	18cb      	adds	r3, r1, r3
    3450:	605a      	str	r2, [r3, #4]
  // FTMֵͨ
  ftmx->CONTROLS[chn].CnV  = cv;
    3452:	7afb      	ldrb	r3, [r7, #11]
    3454:	68fa      	ldr	r2, [r7, #12]
    3456:	f103 0301 	add.w	r3, r3, #1
    345a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    345e:	18d3      	adds	r3, r2, r3
    3460:	697a      	ldr	r2, [r7, #20]
    3462:	609a      	str	r2, [r3, #8]
  
  return 1;
    3464:	f04f 0301 	mov.w	r3, #1
}
    3468:	4618      	mov	r0, r3
    346a:	f107 0718 	add.w	r7, r7, #24
    346e:	46bd      	mov	sp, r7
    3470:	bd80      	pop	{r7, pc}
    3472:	bf00      	nop

00003474 <LPLD_FTM_PWM_ChangeDuty>:
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_FTM_PWM_ChangeDuty(FTM_MemMapPtr  ftmx, FtmChnEnum_Type chn, uint32 duty)
{
    3474:	b480      	push	{r7}
    3476:	b087      	sub	sp, #28
    3478:	af00      	add	r7, sp, #0
    347a:	60f8      	str	r0, [r7, #12]
    347c:	460b      	mov	r3, r1
    347e:	607a      	str	r2, [r7, #4]
    3480:	72fb      	strb	r3, [r7, #11]
  uint32 cv;
  vuint32 mod;
  
  if (duty > 10000)
    3482:	687a      	ldr	r2, [r7, #4]
    3484:	f242 7310 	movw	r3, #10000	; 0x2710
    3488:	429a      	cmp	r2, r3
    348a:	d902      	bls.n	3492 <LPLD_FTM_PWM_ChangeDuty+0x1e>
    return 0;
    348c:	f04f 0300 	mov.w	r3, #0
    3490:	e02e      	b.n	34f0 <LPLD_FTM_PWM_ChangeDuty+0x7c>
  //
  //ASSERT( duty <= 10000 );                  //жռձ
    
  //Ҷ룬100%-ռձ
  if(ftmx->CONTROLS[chn].CnSC & FTM_CnSC_ELSA_MASK)
    3492:	7afb      	ldrb	r3, [r7, #11]
    3494:	68fa      	ldr	r2, [r7, #12]
    3496:	f103 0301 	add.w	r3, r3, #1
    349a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    349e:	18d3      	adds	r3, r2, r3
    34a0:	685b      	ldr	r3, [r3, #4]
    34a2:	f003 0304 	and.w	r3, r3, #4
    34a6:	2b00      	cmp	r3, #0
    34a8:	d005      	beq.n	34b6 <LPLD_FTM_PWM_ChangeDuty+0x42>
  {
    duty = 10000 - duty;
    34aa:	687b      	ldr	r3, [r7, #4]
    34ac:	f5c3 531c 	rsb	r3, r3, #9984	; 0x2700
    34b0:	f103 0310 	add.w	r3, r3, #16
    34b4:	607b      	str	r3, [r7, #4]
  }
  
  //ռձ = (CnV-CNTIN)/(MOD-CNTIN+1)
  mod = ftmx->MOD;
    34b6:	68fb      	ldr	r3, [r7, #12]
    34b8:	689b      	ldr	r3, [r3, #8]
    34ba:	613b      	str	r3, [r7, #16]
  cv = (duty*(mod-0+1)+0)/10000;
    34bc:	693b      	ldr	r3, [r7, #16]
    34be:	f103 0301 	add.w	r3, r3, #1
    34c2:	687a      	ldr	r2, [r7, #4]
    34c4:	fb02 f203 	mul.w	r2, r2, r3
    34c8:	f241 7359 	movw	r3, #5977	; 0x1759
    34cc:	f2cd 13b7 	movt	r3, #53687	; 0xd1b7
    34d0:	fba3 1302 	umull	r1, r3, r3, r2
    34d4:	ea4f 3353 	mov.w	r3, r3, lsr #13
    34d8:	617b      	str	r3, [r7, #20]
 
  // FTMֵͨ
  ftmx->CONTROLS[chn].CnV = cv;
    34da:	7afb      	ldrb	r3, [r7, #11]
    34dc:	68fa      	ldr	r2, [r7, #12]
    34de:	f103 0301 	add.w	r3, r3, #1
    34e2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    34e6:	18d3      	adds	r3, r2, r3
    34e8:	697a      	ldr	r2, [r7, #20]
    34ea:	609a      	str	r2, [r3, #8]
  
  return 1;
    34ec:	f04f 0301 	mov.w	r3, #1
}
    34f0:	4618      	mov	r0, r3
    34f2:	f107 071c 	add.w	r7, r7, #28
    34f6:	46bd      	mov	sp, r7
    34f8:	bc80      	pop	{r7}
    34fa:	4770      	bx	lr

000034fc <LPLD_FTM_DisableChn>:
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_FTM_DisableChn(FTM_MemMapPtr  ftmx, FtmChnEnum_Type chn)
{
    34fc:	b580      	push	{r7, lr}
    34fe:	b082      	sub	sp, #8
    3500:	af00      	add	r7, sp, #0
    3502:	6078      	str	r0, [r7, #4]
    3504:	460b      	mov	r3, r1
    3506:	70fb      	strb	r3, [r7, #3]
  LPLD_FTM_PinDeinit(ftmx, chn);
    3508:	78fb      	ldrb	r3, [r7, #3]
    350a:	6878      	ldr	r0, [r7, #4]
    350c:	4619      	mov	r1, r3
    350e:	f001 f82f 	bl	4570 <LPLD_FTM_PinDeinit>
  ftmx->CONTROLS[chn].CnSC = 0;
    3512:	78fb      	ldrb	r3, [r7, #3]
    3514:	687a      	ldr	r2, [r7, #4]
    3516:	f103 0301 	add.w	r3, r3, #1
    351a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    351e:	18d3      	adds	r3, r2, r3
    3520:	f04f 0200 	mov.w	r2, #0
    3524:	605a      	str	r2, [r3, #4]
  ftmx->CONTROLS[chn].CnV  = 0;
    3526:	78fb      	ldrb	r3, [r7, #3]
    3528:	687a      	ldr	r2, [r7, #4]
    352a:	f103 0301 	add.w	r3, r3, #1
    352e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    3532:	18d3      	adds	r3, r2, r3
    3534:	f04f 0200 	mov.w	r2, #0
    3538:	609a      	str	r2, [r3, #8]
  
  return 1;
    353a:	f04f 0301 	mov.w	r3, #1
}
    353e:	4618      	mov	r0, r3
    3540:	f107 0708 	add.w	r7, r7, #8
    3544:	46bd      	mov	sp, r7
    3546:	bd80      	pop	{r7, pc}

00003548 <LPLD_FTM_IC_Enable>:
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_FTM_IC_Enable(FTM_MemMapPtr  ftmx, FtmChnEnum_Type chn, PortPinsEnum_Type pin, uint8 capture_edge)
{
    3548:	b580      	push	{r7, lr}
    354a:	b082      	sub	sp, #8
    354c:	af00      	add	r7, sp, #0
    354e:	6078      	str	r0, [r7, #4]
    3550:	70f9      	strb	r1, [r7, #3]
    3552:	70ba      	strb	r2, [r7, #2]
    3554:	707b      	strb	r3, [r7, #1]
  if(!LPLD_FTM_PinInit(ftmx, chn, pin))
    3556:	78fa      	ldrb	r2, [r7, #3]
    3558:	78bb      	ldrb	r3, [r7, #2]
    355a:	6878      	ldr	r0, [r7, #4]
    355c:	4611      	mov	r1, r2
    355e:	461a      	mov	r2, r3
    3560:	f000 fb68 	bl	3c34 <LPLD_FTM_PinInit>
    3564:	4603      	mov	r3, r0
    3566:	2b00      	cmp	r3, #0
    3568:	d102      	bne.n	3570 <LPLD_FTM_IC_Enable+0x28>
    return 0;
    356a:	f04f 0300 	mov.w	r3, #0
    356e:	e077      	b.n	3660 <LPLD_FTM_IC_Enable+0x118>
  
  ftmx->CONTROLS[chn].CnSC = 0x00;
    3570:	78fb      	ldrb	r3, [r7, #3]
    3572:	687a      	ldr	r2, [r7, #4]
    3574:	f103 0301 	add.w	r3, r3, #1
    3578:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    357c:	18d3      	adds	r3, r2, r3
    357e:	f04f 0200 	mov.w	r2, #0
    3582:	605a      	str	r2, [r3, #4]
  
  ftmx->CONTROLS[chn].CnSC |= capture_edge;        
    3584:	78f8      	ldrb	r0, [r7, #3]
    3586:	78fb      	ldrb	r3, [r7, #3]
    3588:	687a      	ldr	r2, [r7, #4]
    358a:	f103 0301 	add.w	r3, r3, #1
    358e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    3592:	18d3      	adds	r3, r2, r3
    3594:	685a      	ldr	r2, [r3, #4]
    3596:	787b      	ldrb	r3, [r7, #1]
    3598:	431a      	orrs	r2, r3
    359a:	6879      	ldr	r1, [r7, #4]
    359c:	f100 0301 	add.w	r3, r0, #1
    35a0:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    35a4:	18cb      	adds	r3, r1, r3
    35a6:	605a      	str	r2, [r3, #4]
  
  ftmx->CONTROLS[chn].CnSC &= (~FTM_CnSC_CHF_MASK);
    35a8:	78f8      	ldrb	r0, [r7, #3]
    35aa:	78fb      	ldrb	r3, [r7, #3]
    35ac:	687a      	ldr	r2, [r7, #4]
    35ae:	f103 0301 	add.w	r3, r3, #1
    35b2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    35b6:	18d3      	adds	r3, r2, r3
    35b8:	685b      	ldr	r3, [r3, #4]
    35ba:	f023 0280 	bic.w	r2, r3, #128	; 0x80
    35be:	6879      	ldr	r1, [r7, #4]
    35c0:	f100 0301 	add.w	r3, r0, #1
    35c4:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    35c8:	18cb      	adds	r3, r1, r3
    35ca:	605a      	str	r2, [r3, #4]
  ftmx->CONTROLS[chn].CnSC |= FTM_CnSC_CHIE_MASK;         //ʹͨж
    35cc:	78f8      	ldrb	r0, [r7, #3]
    35ce:	78fb      	ldrb	r3, [r7, #3]
    35d0:	687a      	ldr	r2, [r7, #4]
    35d2:	f103 0301 	add.w	r3, r3, #1
    35d6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    35da:	18d3      	adds	r3, r2, r3
    35dc:	685b      	ldr	r3, [r3, #4]
    35de:	f043 0240 	orr.w	r2, r3, #64	; 0x40
    35e2:	6879      	ldr	r1, [r7, #4]
    35e4:	f100 0301 	add.w	r3, r0, #1
    35e8:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    35ec:	18cb      	adds	r3, r1, r3
    35ee:	605a      	str	r2, [r3, #4]
  
  ftmx->CONTROLS[chn].CnSC &= (~FTM_CnSC_MSB_MASK);
    35f0:	78f8      	ldrb	r0, [r7, #3]
    35f2:	78fb      	ldrb	r3, [r7, #3]
    35f4:	687a      	ldr	r2, [r7, #4]
    35f6:	f103 0301 	add.w	r3, r3, #1
    35fa:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    35fe:	18d3      	adds	r3, r2, r3
    3600:	685b      	ldr	r3, [r3, #4]
    3602:	f023 0220 	bic.w	r2, r3, #32
    3606:	6879      	ldr	r1, [r7, #4]
    3608:	f100 0301 	add.w	r3, r0, #1
    360c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    3610:	18cb      	adds	r3, r1, r3
    3612:	605a      	str	r2, [r3, #4]
  ftmx->CONTROLS[chn].CnSC &= (~FTM_CnSC_MSA_MASK);       //óInput captureģʽ
    3614:	78f8      	ldrb	r0, [r7, #3]
    3616:	78fb      	ldrb	r3, [r7, #3]
    3618:	687a      	ldr	r2, [r7, #4]
    361a:	f103 0301 	add.w	r3, r3, #1
    361e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    3622:	18d3      	adds	r3, r2, r3
    3624:	685b      	ldr	r3, [r3, #4]
    3626:	f023 0210 	bic.w	r2, r3, #16
    362a:	6879      	ldr	r1, [r7, #4]
    362c:	f100 0301 	add.w	r3, r0, #1
    3630:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    3634:	18cb      	adds	r3, r1, r3
    3636:	605a      	str	r2, [r3, #4]
  
  ftmx->CONTROLS[chn].CnSC &= (~FTM_CnSC_DMA_MASK);       //رDMA
    3638:	78f8      	ldrb	r0, [r7, #3]
    363a:	78fb      	ldrb	r3, [r7, #3]
    363c:	687a      	ldr	r2, [r7, #4]
    363e:	f103 0301 	add.w	r3, r3, #1
    3642:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    3646:	18d3      	adds	r3, r2, r3
    3648:	685b      	ldr	r3, [r3, #4]
    364a:	f023 0201 	bic.w	r2, r3, #1
    364e:	6879      	ldr	r1, [r7, #4]
    3650:	f100 0301 	add.w	r3, r0, #1
    3654:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    3658:	18cb      	adds	r3, r1, r3
    365a:	605a      	str	r2, [r3, #4]
  
  return 1;
    365c:	f04f 0301 	mov.w	r3, #1
}
    3660:	4618      	mov	r0, r3
    3662:	f107 0708 	add.w	r7, r7, #8
    3666:	46bd      	mov	sp, r7
    3668:	bd80      	pop	{r7, pc}
    366a:	bf00      	nop

0000366c <LPLD_FTM_IsTOF>:
 * :
 *    TRUEFALSE
 *
 */
boolean LPLD_FTM_IsTOF(FTM_MemMapPtr  ftmx)
{
    366c:	b480      	push	{r7}
    366e:	b083      	sub	sp, #12
    3670:	af00      	add	r7, sp, #0
    3672:	6078      	str	r0, [r7, #4]
  return (boolean)((ftmx->SC & FTM_SC_TOF_MASK)>>FTM_SC_TOF_SHIFT);
    3674:	687b      	ldr	r3, [r7, #4]
    3676:	681b      	ldr	r3, [r3, #0]
    3678:	f003 0380 	and.w	r3, r3, #128	; 0x80
    367c:	ea4f 13d3 	mov.w	r3, r3, lsr #7
    3680:	b2db      	uxtb	r3, r3
}
    3682:	4618      	mov	r0, r3
    3684:	f107 070c 	add.w	r7, r7, #12
    3688:	46bd      	mov	sp, r7
    368a:	bc80      	pop	{r7}
    368c:	4770      	bx	lr
    368e:	bf00      	nop

00003690 <LPLD_FTM_ClearTOF>:
 * :
 *    
 *
 */
void LPLD_FTM_ClearTOF(FTM_MemMapPtr  ftmx)
{
    3690:	b480      	push	{r7}
    3692:	b083      	sub	sp, #12
    3694:	af00      	add	r7, sp, #0
    3696:	6078      	str	r0, [r7, #4]
  ftmx->SC = ftmx->SC & ~FTM_SC_TOF_MASK;
    3698:	687b      	ldr	r3, [r7, #4]
    369a:	681b      	ldr	r3, [r3, #0]
    369c:	f023 0280 	bic.w	r2, r3, #128	; 0x80
    36a0:	687b      	ldr	r3, [r7, #4]
    36a2:	601a      	str	r2, [r3, #0]
}
    36a4:	f107 070c 	add.w	r7, r7, #12
    36a8:	46bd      	mov	sp, r7
    36aa:	bc80      	pop	{r7}
    36ac:	4770      	bx	lr
    36ae:	bf00      	nop

000036b0 <LPLD_FTM_IsCHnF>:
 * :
 *    TRUEFALSE
 *
 */
boolean LPLD_FTM_IsCHnF(FTM_MemMapPtr  ftmx, FtmChnEnum_Type chn)
{
    36b0:	b480      	push	{r7}
    36b2:	b083      	sub	sp, #12
    36b4:	af00      	add	r7, sp, #0
    36b6:	6078      	str	r0, [r7, #4]
    36b8:	460b      	mov	r3, r1
    36ba:	70fb      	strb	r3, [r7, #3]
  return (boolean)((ftmx->CONTROLS[chn].CnSC & FTM_CnSC_CHF_MASK)>>FTM_CnSC_CHF_SHIFT);
    36bc:	78fb      	ldrb	r3, [r7, #3]
    36be:	687a      	ldr	r2, [r7, #4]
    36c0:	f103 0301 	add.w	r3, r3, #1
    36c4:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    36c8:	18d3      	adds	r3, r2, r3
    36ca:	685b      	ldr	r3, [r3, #4]
    36cc:	f003 0380 	and.w	r3, r3, #128	; 0x80
    36d0:	ea4f 13d3 	mov.w	r3, r3, lsr #7
    36d4:	b2db      	uxtb	r3, r3
}
    36d6:	4618      	mov	r0, r3
    36d8:	f107 070c 	add.w	r7, r7, #12
    36dc:	46bd      	mov	sp, r7
    36de:	bc80      	pop	{r7}
    36e0:	4770      	bx	lr
    36e2:	bf00      	nop

000036e4 <LPLD_FTM_ClearCHnF>:
 * :
 *    
 *
 */
void LPLD_FTM_ClearCHnF(FTM_MemMapPtr  ftmx, FtmChnEnum_Type chn)
{
    36e4:	b480      	push	{r7}
    36e6:	b083      	sub	sp, #12
    36e8:	af00      	add	r7, sp, #0
    36ea:	6078      	str	r0, [r7, #4]
    36ec:	460b      	mov	r3, r1
    36ee:	70fb      	strb	r3, [r7, #3]
  ftmx->CONTROLS[chn].CnSC = ftmx->CONTROLS[chn].CnSC & ~FTM_CnSC_CHF_MASK;
    36f0:	78f8      	ldrb	r0, [r7, #3]
    36f2:	78fb      	ldrb	r3, [r7, #3]
    36f4:	687a      	ldr	r2, [r7, #4]
    36f6:	f103 0301 	add.w	r3, r3, #1
    36fa:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    36fe:	18d3      	adds	r3, r2, r3
    3700:	685b      	ldr	r3, [r3, #4]
    3702:	f023 0280 	bic.w	r2, r3, #128	; 0x80
    3706:	6879      	ldr	r1, [r7, #4]
    3708:	f100 0301 	add.w	r3, r0, #1
    370c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    3710:	18cb      	adds	r3, r1, r3
    3712:	605a      	str	r2, [r3, #4]
}
    3714:	f107 070c 	add.w	r7, r7, #12
    3718:	46bd      	mov	sp, r7
    371a:	bc80      	pop	{r7}
    371c:	4770      	bx	lr
    371e:	bf00      	nop

00003720 <LPLD_FTM_GetChVal>:
 * :
 *    0x1~0xFFFF
 *
 */
uint16 LPLD_FTM_GetChVal(FTM_MemMapPtr  ftmx, FtmChnEnum_Type chn)
{
    3720:	b480      	push	{r7}
    3722:	b083      	sub	sp, #12
    3724:	af00      	add	r7, sp, #0
    3726:	6078      	str	r0, [r7, #4]
    3728:	460b      	mov	r3, r1
    372a:	70fb      	strb	r3, [r7, #3]
  return ftmx->CONTROLS[chn].CnV;    //ȡӦͨ񵽵FTMֵ
    372c:	78fb      	ldrb	r3, [r7, #3]
    372e:	687a      	ldr	r2, [r7, #4]
    3730:	f103 0301 	add.w	r3, r3, #1
    3734:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    3738:	18d3      	adds	r3, r2, r3
    373a:	689b      	ldr	r3, [r3, #8]
    373c:	b29b      	uxth	r3, r3
}
    373e:	4618      	mov	r0, r3
    3740:	f107 070c 	add.w	r7, r7, #12
    3744:	46bd      	mov	sp, r7
    3746:	bc80      	pop	{r7}
    3748:	4770      	bx	lr
    374a:	bf00      	nop

0000374c <LPLD_FTM_GetClkDiv>:
 * :
 *    1248163264128
 *
 */
uint8 LPLD_FTM_GetClkDiv(FTM_MemMapPtr  ftmx)
{
    374c:	b480      	push	{r7}
    374e:	b083      	sub	sp, #12
    3750:	af00      	add	r7, sp, #0
    3752:	6078      	str	r0, [r7, #4]
  return 1u<<((ftmx->SC & FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT);    //ʱӷƵϵ
    3754:	687b      	ldr	r3, [r7, #4]
    3756:	681b      	ldr	r3, [r3, #0]
    3758:	f003 0307 	and.w	r3, r3, #7
    375c:	f04f 0201 	mov.w	r2, #1
    3760:	fa02 f303 	lsl.w	r3, r2, r3
    3764:	b2db      	uxtb	r3, r3
}
    3766:	4618      	mov	r0, r3
    3768:	f107 070c 	add.w	r7, r7, #12
    376c:	46bd      	mov	sp, r7
    376e:	bc80      	pop	{r7}
    3770:	4770      	bx	lr
    3772:	bf00      	nop

00003774 <LPLD_FTM_GetCounter>:
 * :
 *    
 *
 */
uint16 LPLD_FTM_GetCounter(FTM_MemMapPtr  ftmx)
{
    3774:	b480      	push	{r7}
    3776:	b083      	sub	sp, #12
    3778:	af00      	add	r7, sp, #0
    377a:	6078      	str	r0, [r7, #4]
  return ftmx->CNT;        //ȡFTMxֵ
    377c:	687b      	ldr	r3, [r7, #4]
    377e:	685b      	ldr	r3, [r3, #4]
    3780:	b29b      	uxth	r3, r3
}
    3782:	4618      	mov	r0, r3
    3784:	f107 070c 	add.w	r7, r7, #12
    3788:	46bd      	mov	sp, r7
    378a:	bc80      	pop	{r7}
    378c:	4770      	bx	lr
    378e:	bf00      	nop

00003790 <LPLD_FTM_ClearCounter>:
 * :
 *    
 *
 */
void LPLD_FTM_ClearCounter(FTM_MemMapPtr  ftmx)
{
    3790:	b480      	push	{r7}
    3792:	b083      	sub	sp, #12
    3794:	af00      	add	r7, sp, #0
    3796:	6078      	str	r0, [r7, #4]
  ftmx->CNT = 0;        //FTMxֵ
    3798:	687b      	ldr	r3, [r7, #4]
    379a:	f04f 0200 	mov.w	r2, #0
    379e:	605a      	str	r2, [r3, #4]
}
    37a0:	f107 070c 	add.w	r7, r7, #12
    37a4:	46bd      	mov	sp, r7
    37a6:	bc80      	pop	{r7}
    37a8:	4770      	bx	lr
    37aa:	bf00      	nop

000037ac <LPLD_FTM_EnableIrq>:
 *    0--ô
 *    1--óɹ
 *
 */
uint8 LPLD_FTM_EnableIrq(FTM_InitTypeDef ftm_init_structure)
{
    37ac:	b084      	sub	sp, #16
    37ae:	b580      	push	{r7, lr}
    37b0:	b082      	sub	sp, #8
    37b2:	af00      	add	r7, sp, #0
    37b4:	f107 0c10 	add.w	ip, r7, #16
    37b8:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  uint8 i;
  FTM_MemMapPtr  ftmx = ftm_init_structure.FTM_Ftmx;
    37bc:	693b      	ldr	r3, [r7, #16]
    37be:	603b      	str	r3, [r7, #0]
  
  if(ftmx == FTM0)
    37c0:	683a      	ldr	r2, [r7, #0]
    37c2:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    37c6:	f2c4 0303 	movt	r3, #16387	; 0x4003
    37ca:	429a      	cmp	r2, r3
    37cc:	d103      	bne.n	37d6 <LPLD_FTM_EnableIrq+0x2a>
    i=0;
    37ce:	f04f 0300 	mov.w	r3, #0
    37d2:	71fb      	strb	r3, [r7, #7]
    37d4:	e023      	b.n	381e <LPLD_FTM_EnableIrq+0x72>
  else if(ftmx == FTM1)
    37d6:	683a      	ldr	r2, [r7, #0]
    37d8:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    37dc:	f2c4 0303 	movt	r3, #16387	; 0x4003
    37e0:	429a      	cmp	r2, r3
    37e2:	d103      	bne.n	37ec <LPLD_FTM_EnableIrq+0x40>
    i=1;
    37e4:	f04f 0301 	mov.w	r3, #1
    37e8:	71fb      	strb	r3, [r7, #7]
    37ea:	e018      	b.n	381e <LPLD_FTM_EnableIrq+0x72>
  else if(ftmx == FTM2)
    37ec:	683a      	ldr	r2, [r7, #0]
    37ee:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    37f2:	f2c4 030b 	movt	r3, #16395	; 0x400b
    37f6:	429a      	cmp	r2, r3
    37f8:	d103      	bne.n	3802 <LPLD_FTM_EnableIrq+0x56>
    i=2;
    37fa:	f04f 0302 	mov.w	r3, #2
    37fe:	71fb      	strb	r3, [r7, #7]
    3800:	e00d      	b.n	381e <LPLD_FTM_EnableIrq+0x72>
  else if (ftmx == FTM3)
    3802:	683a      	ldr	r2, [r7, #0]
    3804:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    3808:	f2c4 030b 	movt	r3, #16395	; 0x400b
    380c:	429a      	cmp	r2, r3
    380e:	d103      	bne.n	3818 <LPLD_FTM_EnableIrq+0x6c>
    i = 3;
    3810:	f04f 0303 	mov.w	r3, #3
    3814:	71fb      	strb	r3, [r7, #7]
    3816:	e002      	b.n	381e <LPLD_FTM_EnableIrq+0x72>
  else
    return 0;
    3818:	f04f 0300 	mov.w	r3, #0
    381c:	e007      	b.n	382e <LPLD_FTM_EnableIrq+0x82>

  enable_irq(62 + i);
    381e:	79fb      	ldrb	r3, [r7, #7]
    3820:	f103 033e 	add.w	r3, r3, #62	; 0x3e
    3824:	4618      	mov	r0, r3
    3826:	f7fd f973 	bl	b10 <enable_irq>
  
  return 1;
    382a:	f04f 0301 	mov.w	r3, #1
}
    382e:	4618      	mov	r0, r3
    3830:	f107 0708 	add.w	r7, r7, #8
    3834:	46bd      	mov	sp, r7
    3836:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    383a:	b004      	add	sp, #16
    383c:	4770      	bx	lr
    383e:	bf00      	nop

00003840 <LPLD_FTM_DisableIrq>:
 *    0--ô
 *    1--óɹ
 *
 */
uint8 LPLD_FTM_DisableIrq(FTM_InitTypeDef ftm_init_structure)
{
    3840:	b084      	sub	sp, #16
    3842:	b580      	push	{r7, lr}
    3844:	b082      	sub	sp, #8
    3846:	af00      	add	r7, sp, #0
    3848:	f107 0c10 	add.w	ip, r7, #16
    384c:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  uint8 i;
  FTM_MemMapPtr  ftmx = ftm_init_structure.FTM_Ftmx;
    3850:	693b      	ldr	r3, [r7, #16]
    3852:	603b      	str	r3, [r7, #0]
  
  if(ftmx == FTM0)
    3854:	683a      	ldr	r2, [r7, #0]
    3856:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    385a:	f2c4 0303 	movt	r3, #16387	; 0x4003
    385e:	429a      	cmp	r2, r3
    3860:	d103      	bne.n	386a <LPLD_FTM_DisableIrq+0x2a>
    i=0;
    3862:	f04f 0300 	mov.w	r3, #0
    3866:	71fb      	strb	r3, [r7, #7]
    3868:	e023      	b.n	38b2 <LPLD_FTM_DisableIrq+0x72>
  else if(ftmx == FTM1)
    386a:	683a      	ldr	r2, [r7, #0]
    386c:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    3870:	f2c4 0303 	movt	r3, #16387	; 0x4003
    3874:	429a      	cmp	r2, r3
    3876:	d103      	bne.n	3880 <LPLD_FTM_DisableIrq+0x40>
    i=1;
    3878:	f04f 0301 	mov.w	r3, #1
    387c:	71fb      	strb	r3, [r7, #7]
    387e:	e018      	b.n	38b2 <LPLD_FTM_DisableIrq+0x72>
  else if(ftmx == FTM2)
    3880:	683a      	ldr	r2, [r7, #0]
    3882:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    3886:	f2c4 030b 	movt	r3, #16395	; 0x400b
    388a:	429a      	cmp	r2, r3
    388c:	d103      	bne.n	3896 <LPLD_FTM_DisableIrq+0x56>
    i=2;
    388e:	f04f 0302 	mov.w	r3, #2
    3892:	71fb      	strb	r3, [r7, #7]
    3894:	e00d      	b.n	38b2 <LPLD_FTM_DisableIrq+0x72>
  else if (ftmx == FTM3)
    3896:	683a      	ldr	r2, [r7, #0]
    3898:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    389c:	f2c4 030b 	movt	r3, #16395	; 0x400b
    38a0:	429a      	cmp	r2, r3
    38a2:	d103      	bne.n	38ac <LPLD_FTM_DisableIrq+0x6c>
      i = 3;
    38a4:	f04f 0303 	mov.w	r3, #3
    38a8:	71fb      	strb	r3, [r7, #7]
    38aa:	e002      	b.n	38b2 <LPLD_FTM_DisableIrq+0x72>
  else
    return 0;
    38ac:	f04f 0300 	mov.w	r3, #0
    38b0:	e007      	b.n	38c2 <LPLD_FTM_DisableIrq+0x82>

  disable_irq(62 + i);
    38b2:	79fb      	ldrb	r3, [r7, #7]
    38b4:	f103 033e 	add.w	r3, r3, #62	; 0x3e
    38b8:	4618      	mov	r0, r3
    38ba:	f7fd f9ed 	bl	c98 <disable_irq>
  
  return 1;
    38be:	f04f 0301 	mov.w	r3, #1
}
    38c2:	4618      	mov	r0, r3
    38c4:	f107 0708 	add.w	r7, r7, #8
    38c8:	46bd      	mov	sp, r7
    38ca:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    38ce:	b004      	add	sp, #16
    38d0:	4770      	bx	lr
    38d2:	bf00      	nop

000038d4 <LPLD_FTM_QD_Enable>:
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_FTM_QD_Enable(FTM_MemMapPtr  ftmx, PortPinsEnum_Type pha, PortPinsEnum_Type phb)
{
    38d4:	b580      	push	{r7, lr}
    38d6:	b082      	sub	sp, #8
    38d8:	af00      	add	r7, sp, #0
    38da:	6078      	str	r0, [r7, #4]
    38dc:	4613      	mov	r3, r2
    38de:	460a      	mov	r2, r1
    38e0:	70fa      	strb	r2, [r7, #3]
    38e2:	70bb      	strb	r3, [r7, #2]
  if(!LPLD_FTM_PinInit(ftmx, FTM_PhA, pha))
    38e4:	78fb      	ldrb	r3, [r7, #3]
    38e6:	6878      	ldr	r0, [r7, #4]
    38e8:	f04f 0108 	mov.w	r1, #8
    38ec:	461a      	mov	r2, r3
    38ee:	f000 f9a1 	bl	3c34 <LPLD_FTM_PinInit>
    38f2:	4603      	mov	r3, r0
    38f4:	2b00      	cmp	r3, #0
    38f6:	d102      	bne.n	38fe <LPLD_FTM_QD_Enable+0x2a>
    return 0;
    38f8:	f04f 0300 	mov.w	r3, #0
    38fc:	e00e      	b.n	391c <LPLD_FTM_QD_Enable+0x48>
  if(!LPLD_FTM_PinInit(ftmx, FTM_PhB, phb))
    38fe:	78bb      	ldrb	r3, [r7, #2]
    3900:	6878      	ldr	r0, [r7, #4]
    3902:	f04f 0109 	mov.w	r1, #9
    3906:	461a      	mov	r2, r3
    3908:	f000 f994 	bl	3c34 <LPLD_FTM_PinInit>
    390c:	4603      	mov	r3, r0
    390e:	2b00      	cmp	r3, #0
    3910:	d102      	bne.n	3918 <LPLD_FTM_QD_Enable+0x44>
    return 0;
    3912:	f04f 0300 	mov.w	r3, #0
    3916:	e001      	b.n	391c <LPLD_FTM_QD_Enable+0x48>
  
  return 1;
    3918:	f04f 0301 	mov.w	r3, #1
}
    391c:	4618      	mov	r0, r3
    391e:	f107 0708 	add.w	r7, r7, #8
    3922:	46bd      	mov	sp, r7
    3924:	bd80      	pop	{r7, pc}
    3926:	bf00      	nop

00003928 <LPLD_FTM_QD_Disable>:
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_FTM_QD_Disable(FTM_MemMapPtr  ftmx)
{
    3928:	b580      	push	{r7, lr}
    392a:	b082      	sub	sp, #8
    392c:	af00      	add	r7, sp, #0
    392e:	6078      	str	r0, [r7, #4]
  if(!LPLD_FTM_PinDeinit(ftmx, FTM_PhA))
    3930:	6878      	ldr	r0, [r7, #4]
    3932:	f04f 0108 	mov.w	r1, #8
    3936:	f000 fe1b 	bl	4570 <LPLD_FTM_PinDeinit>
    393a:	4603      	mov	r3, r0
    393c:	2b00      	cmp	r3, #0
    393e:	d102      	bne.n	3946 <LPLD_FTM_QD_Disable+0x1e>
    return 0;
    3940:	f04f 0300 	mov.w	r3, #0
    3944:	e00c      	b.n	3960 <LPLD_FTM_QD_Disable+0x38>
  if(!LPLD_FTM_PinDeinit(ftmx, FTM_PhB))
    3946:	6878      	ldr	r0, [r7, #4]
    3948:	f04f 0109 	mov.w	r1, #9
    394c:	f000 fe10 	bl	4570 <LPLD_FTM_PinDeinit>
    3950:	4603      	mov	r3, r0
    3952:	2b00      	cmp	r3, #0
    3954:	d102      	bne.n	395c <LPLD_FTM_QD_Disable+0x34>
    return 0;
    3956:	f04f 0300 	mov.w	r3, #0
    395a:	e001      	b.n	3960 <LPLD_FTM_QD_Disable+0x38>
  
  return 1;
    395c:	f04f 0301 	mov.w	r3, #1
}
    3960:	4618      	mov	r0, r3
    3962:	f107 0708 	add.w	r7, r7, #8
    3966:	46bd      	mov	sp, r7
    3968:	bd80      	pop	{r7, pc}
    396a:	bf00      	nop

0000396c <LPLD_FTM_PWM_Init>:
/*
 * LPLD_FTM_PWM_Init
 * FTMģPWMģʽʼڲ
 */
static uint8 LPLD_FTM_PWM_Init(FTM_InitTypeDef ftm_init_structure)
{
    396c:	b084      	sub	sp, #16
    396e:	b480      	push	{r7}
    3970:	b089      	sub	sp, #36	; 0x24
    3972:	af00      	add	r7, sp, #0
    3974:	f107 0c28 	add.w	ip, r7, #40	; 0x28
    3978:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  uint32 bus_clk_hz;
  uint32 mod, mod2;
  uint8 ps;
  uint32 freq = ftm_init_structure.FTM_PwmFreq;
    397c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    397e:	617b      	str	r3, [r7, #20]
  uint32 dt_en = ftm_init_structure.FTM_PwmDeadtimeCfg;
    3980:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    3982:	613b      	str	r3, [r7, #16]
  uint8 dt_div = ftm_init_structure.FTM_PwmDeadtimeDiv;
    3984:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
    3988:	73fb      	strb	r3, [r7, #15]
  uint8 dt_val = ftm_init_structure.FTM_PwmDeadtimeVal;
    398a:	f897 3039 	ldrb.w	r3, [r7, #57]	; 0x39
    398e:	73bb      	strb	r3, [r7, #14]
  FTM_MemMapPtr ftmx = ftm_init_structure.FTM_Ftmx;
    3990:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3992:	60bb      	str	r3, [r7, #8]
  
  //
  //ASSERT( freq );                  //жƵ
  //ASSERT( dt_val<=63 );            //жֵ
  if (dt_val > 63)
    3994:	7bbb      	ldrb	r3, [r7, #14]
    3996:	2b3f      	cmp	r3, #63	; 0x3f
    3998:	d902      	bls.n	39a0 <LPLD_FTM_PWM_Init+0x34>
    return 0;
    399a:	f04f 0300 	mov.w	r3, #0
    399e:	e0bb      	b.n	3b18 <LPLD_FTM_PWM_Init+0x1ac>
  
  bus_clk_hz = g_bus_clock;
    39a0:	f240 036c 	movw	r3, #108	; 0x6c
    39a4:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    39a8:	681b      	ldr	r3, [r3, #0]
    39aa:	607b      	str	r3, [r7, #4]
  
  if(freq>bus_clk_hz) return 0;
    39ac:	697a      	ldr	r2, [r7, #20]
    39ae:	687b      	ldr	r3, [r7, #4]
    39b0:	429a      	cmp	r2, r3
    39b2:	d902      	bls.n	39ba <LPLD_FTM_PWM_Init+0x4e>
    39b4:	f04f 0300 	mov.w	r3, #0
    39b8:	e0ae      	b.n	3b18 <LPLD_FTM_PWM_Init+0x1ac>
 //δдıȽȤ... 
  if((mod=bus_clk_hz/(freq*128)) < 0xFFFFu)
    39ba:	697b      	ldr	r3, [r7, #20]
    39bc:	ea4f 13c3 	mov.w	r3, r3, lsl #7
    39c0:	687a      	ldr	r2, [r7, #4]
    39c2:	fbb2 f3f3 	udiv	r3, r2, r3
    39c6:	603b      	str	r3, [r7, #0]
    39c8:	683a      	ldr	r2, [r7, #0]
    39ca:	f64f 73fe 	movw	r3, #65534	; 0xfffe
    39ce:	429a      	cmp	r2, r3
    39d0:	d87a      	bhi.n	3ac8 <LPLD_FTM_PWM_Init+0x15c>
  {
    ps = 7;
    39d2:	f04f 0307 	mov.w	r3, #7
    39d6:	76fb      	strb	r3, [r7, #27]
    mod2=mod;
    39d8:	683b      	ldr	r3, [r7, #0]
    39da:	61fb      	str	r3, [r7, #28]
    if((mod=bus_clk_hz/(freq*64)) < 0xFFFFu)
    39dc:	697b      	ldr	r3, [r7, #20]
    39de:	ea4f 1383 	mov.w	r3, r3, lsl #6
    39e2:	687a      	ldr	r2, [r7, #4]
    39e4:	fbb2 f3f3 	udiv	r3, r2, r3
    39e8:	603b      	str	r3, [r7, #0]
    39ea:	683a      	ldr	r2, [r7, #0]
    39ec:	f64f 73fe 	movw	r3, #65534	; 0xfffe
    39f0:	429a      	cmp	r2, r3
    39f2:	d86c      	bhi.n	3ace <LPLD_FTM_PWM_Init+0x162>
    {
      ps = 6;  
    39f4:	f04f 0306 	mov.w	r3, #6
    39f8:	76fb      	strb	r3, [r7, #27]
      mod2=mod;  
    39fa:	683b      	ldr	r3, [r7, #0]
    39fc:	61fb      	str	r3, [r7, #28]
      if((mod=bus_clk_hz/(freq*32)) < 0xFFFFu)
    39fe:	697b      	ldr	r3, [r7, #20]
    3a00:	ea4f 1343 	mov.w	r3, r3, lsl #5
    3a04:	687a      	ldr	r2, [r7, #4]
    3a06:	fbb2 f3f3 	udiv	r3, r2, r3
    3a0a:	603b      	str	r3, [r7, #0]
    3a0c:	683a      	ldr	r2, [r7, #0]
    3a0e:	f64f 73fe 	movw	r3, #65534	; 0xfffe
    3a12:	429a      	cmp	r2, r3
    3a14:	d85b      	bhi.n	3ace <LPLD_FTM_PWM_Init+0x162>
      {
        ps = 5;  
    3a16:	f04f 0305 	mov.w	r3, #5
    3a1a:	76fb      	strb	r3, [r7, #27]
        mod2=mod;
    3a1c:	683b      	ldr	r3, [r7, #0]
    3a1e:	61fb      	str	r3, [r7, #28]
        if((mod=bus_clk_hz/(freq*16)) < 0xFFFFu)
    3a20:	697b      	ldr	r3, [r7, #20]
    3a22:	ea4f 1303 	mov.w	r3, r3, lsl #4
    3a26:	687a      	ldr	r2, [r7, #4]
    3a28:	fbb2 f3f3 	udiv	r3, r2, r3
    3a2c:	603b      	str	r3, [r7, #0]
    3a2e:	683a      	ldr	r2, [r7, #0]
    3a30:	f64f 73fe 	movw	r3, #65534	; 0xfffe
    3a34:	429a      	cmp	r2, r3
    3a36:	d84a      	bhi.n	3ace <LPLD_FTM_PWM_Init+0x162>
        {
          ps = 4;  
    3a38:	f04f 0304 	mov.w	r3, #4
    3a3c:	76fb      	strb	r3, [r7, #27]
          mod2=mod;   
    3a3e:	683b      	ldr	r3, [r7, #0]
    3a40:	61fb      	str	r3, [r7, #28]
          if((mod=bus_clk_hz/(freq*8)) < 0xFFFFu)
    3a42:	697b      	ldr	r3, [r7, #20]
    3a44:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    3a48:	687a      	ldr	r2, [r7, #4]
    3a4a:	fbb2 f3f3 	udiv	r3, r2, r3
    3a4e:	603b      	str	r3, [r7, #0]
    3a50:	683a      	ldr	r2, [r7, #0]
    3a52:	f64f 73fe 	movw	r3, #65534	; 0xfffe
    3a56:	429a      	cmp	r2, r3
    3a58:	d839      	bhi.n	3ace <LPLD_FTM_PWM_Init+0x162>
          {
            ps = 3;
    3a5a:	f04f 0303 	mov.w	r3, #3
    3a5e:	76fb      	strb	r3, [r7, #27]
            mod2=mod;
    3a60:	683b      	ldr	r3, [r7, #0]
    3a62:	61fb      	str	r3, [r7, #28]
            if((mod=bus_clk_hz/(freq*4)) < 0xFFFFu)
    3a64:	697b      	ldr	r3, [r7, #20]
    3a66:	ea4f 0383 	mov.w	r3, r3, lsl #2
    3a6a:	687a      	ldr	r2, [r7, #4]
    3a6c:	fbb2 f3f3 	udiv	r3, r2, r3
    3a70:	603b      	str	r3, [r7, #0]
    3a72:	683a      	ldr	r2, [r7, #0]
    3a74:	f64f 73fe 	movw	r3, #65534	; 0xfffe
    3a78:	429a      	cmp	r2, r3
    3a7a:	d828      	bhi.n	3ace <LPLD_FTM_PWM_Init+0x162>
            {
              ps = 2;
    3a7c:	f04f 0302 	mov.w	r3, #2
    3a80:	76fb      	strb	r3, [r7, #27]
              mod2=mod;
    3a82:	683b      	ldr	r3, [r7, #0]
    3a84:	61fb      	str	r3, [r7, #28]
              if((mod=bus_clk_hz/(freq*2)) < 0xFFFFu)
    3a86:	697b      	ldr	r3, [r7, #20]
    3a88:	ea4f 0343 	mov.w	r3, r3, lsl #1
    3a8c:	687a      	ldr	r2, [r7, #4]
    3a8e:	fbb2 f3f3 	udiv	r3, r2, r3
    3a92:	603b      	str	r3, [r7, #0]
    3a94:	683a      	ldr	r2, [r7, #0]
    3a96:	f64f 73fe 	movw	r3, #65534	; 0xfffe
    3a9a:	429a      	cmp	r2, r3
    3a9c:	d817      	bhi.n	3ace <LPLD_FTM_PWM_Init+0x162>
              {
                ps = 1;
    3a9e:	f04f 0301 	mov.w	r3, #1
    3aa2:	76fb      	strb	r3, [r7, #27]
                mod2=mod;
    3aa4:	683b      	ldr	r3, [r7, #0]
    3aa6:	61fb      	str	r3, [r7, #28]
                if((mod=bus_clk_hz/(freq*1)) < 0xFFFFu)
    3aa8:	687a      	ldr	r2, [r7, #4]
    3aaa:	697b      	ldr	r3, [r7, #20]
    3aac:	fbb2 f3f3 	udiv	r3, r2, r3
    3ab0:	603b      	str	r3, [r7, #0]
    3ab2:	683a      	ldr	r2, [r7, #0]
    3ab4:	f64f 73fe 	movw	r3, #65534	; 0xfffe
    3ab8:	429a      	cmp	r2, r3
    3aba:	d808      	bhi.n	3ace <LPLD_FTM_PWM_Init+0x162>
                {
                  ps = 0;
    3abc:	f04f 0300 	mov.w	r3, #0
    3ac0:	76fb      	strb	r3, [r7, #27]
                  mod2=mod;
    3ac2:	683b      	ldr	r3, [r7, #0]
    3ac4:	61fb      	str	r3, [r7, #28]
    3ac6:	e002      	b.n	3ace <LPLD_FTM_PWM_Init+0x162>
      }
    }
  }
  else
  {
    return 0;
    3ac8:	f04f 0300 	mov.w	r3, #0
    3acc:	e024      	b.n	3b18 <LPLD_FTM_PWM_Init+0x1ac>
  }
  
  ftmx->SC = 0;
    3ace:	68bb      	ldr	r3, [r7, #8]
    3ad0:	f04f 0200 	mov.w	r2, #0
    3ad4:	601a      	str	r2, [r3, #0]
  
  // PWMڼռձ
  //    PWM = (MOD-CNTIN+1)*FTMʱ :
  // FTMʼֵ
  ftmx->CNT = 0;
    3ad6:	68bb      	ldr	r3, [r7, #8]
    3ad8:	f04f 0200 	mov.w	r2, #0
    3adc:	605a      	str	r2, [r3, #4]
  ftmx->CNTIN = 0;
    3ade:	68bb      	ldr	r3, [r7, #8]
    3ae0:	f04f 0200 	mov.w	r2, #0
    3ae4:	64da      	str	r2, [r3, #76]	; 0x4c
  // FTMMODֵ
  ftmx->MOD = mod2;
    3ae6:	68bb      	ldr	r3, [r7, #8]
    3ae8:	69fa      	ldr	r2, [r7, #28]
    3aea:	609a      	str	r2, [r3, #8]
  
  ftmx->DEADTIME = FTM_DEADTIME_DTPS(dt_div) | FTM_DEADTIME_DTVAL(dt_val);
    3aec:	7bfb      	ldrb	r3, [r7, #15]
    3aee:	ea4f 1383 	mov.w	r3, r3, lsl #6
    3af2:	b2da      	uxtb	r2, r3
    3af4:	7bbb      	ldrb	r3, [r7, #14]
    3af6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    3afa:	431a      	orrs	r2, r3
    3afc:	68bb      	ldr	r3, [r7, #8]
    3afe:	669a      	str	r2, [r3, #104]	; 0x68
  ftmx->COMBINE = dt_en;        //ʹ
    3b00:	68bb      	ldr	r3, [r7, #8]
    3b02:	693a      	ldr	r2, [r7, #16]
    3b04:	665a      	str	r2, [r3, #100]	; 0x64
  
  // FTMƼĴ
  // ж, Ӽģʽ, ʱԴ:System clockBus Clk, Ƶϵ:8
  // SysClk = 50MHz, SC_PS=3, FTM Clk = 50MHz/2^3 = 6.25MHz
  ftmx->SC = FTM_SC_CLKS(1)|FTM_SC_PS(ps);
    3b06:	7efb      	ldrb	r3, [r7, #27]
    3b08:	f003 0307 	and.w	r3, r3, #7
    3b0c:	f043 0208 	orr.w	r2, r3, #8
    3b10:	68bb      	ldr	r3, [r7, #8]
    3b12:	601a      	str	r2, [r3, #0]
  
  return 1;
    3b14:	f04f 0301 	mov.w	r3, #1
}
    3b18:	4618      	mov	r0, r3
    3b1a:	f107 0724 	add.w	r7, r7, #36	; 0x24
    3b1e:	46bd      	mov	sp, r7
    3b20:	bc80      	pop	{r7}
    3b22:	b004      	add	sp, #16
    3b24:	4770      	bx	lr
    3b26:	bf00      	nop

00003b28 <LPLD_FTM_IC_Init>:
/*
 * LPLD_FTM_IC_Init
 * FTMģ벶ģʽʼڲ
 */
static uint8 LPLD_FTM_IC_Init(FTM_InitTypeDef ftm_init_structure)
{
    3b28:	b084      	sub	sp, #16
    3b2a:	b480      	push	{r7}
    3b2c:	b085      	sub	sp, #20
    3b2e:	af00      	add	r7, sp, #0
    3b30:	f107 0c18 	add.w	ip, r7, #24
    3b34:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  uint8 i;
  uint8 ps = ftm_init_structure.FTM_ClkDiv;
    3b38:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
    3b3c:	73bb      	strb	r3, [r7, #14]
  FTM_ISR_CALLBACK isr_func = ftm_init_structure.FTM_Isr;
    3b3e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    3b40:	60bb      	str	r3, [r7, #8]
  FTM_MemMapPtr  ftmx = ftm_init_structure.FTM_Ftmx;
    3b42:	69bb      	ldr	r3, [r7, #24]
    3b44:	607b      	str	r3, [r7, #4]
  
  //
  //ASSERT( ps <= 7);             //ʱӷƵϵ
  
  if (ps > 7)
    3b46:	7bbb      	ldrb	r3, [r7, #14]
    3b48:	2b07      	cmp	r3, #7
    3b4a:	d902      	bls.n	3b52 <LPLD_FTM_IC_Init+0x2a>
    return 0;
    3b4c:	f04f 0300 	mov.w	r3, #0
    3b50:	e069      	b.n	3c26 <LPLD_FTM_IC_Init+0xfe>
  ftmx->CONF=FTM_CONF_BDMMODE(0x3);
    3b52:	687b      	ldr	r3, [r7, #4]
    3b54:	f04f 02c0 	mov.w	r2, #192	; 0xc0
    3b58:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  
  ftmx->SC = 0;
    3b5c:	687b      	ldr	r3, [r7, #4]
    3b5e:	f04f 0200 	mov.w	r2, #0
    3b62:	601a      	str	r2, [r3, #0]
  
  ftmx->CNT = 0;
    3b64:	687b      	ldr	r3, [r7, #4]
    3b66:	f04f 0200 	mov.w	r2, #0
    3b6a:	605a      	str	r2, [r3, #4]
  ftmx->CNTIN = 0;
    3b6c:	687b      	ldr	r3, [r7, #4]
    3b6e:	f04f 0200 	mov.w	r2, #0
    3b72:	64da      	str	r2, [r3, #76]	; 0x4c
  ftmx->MOD = 0;                           
    3b74:	687b      	ldr	r3, [r7, #4]
    3b76:	f04f 0200 	mov.w	r2, #0
    3b7a:	609a      	str	r2, [r3, #8]
  ftmx->QDCTRL = (~FTM_QDCTRL_QUADEN_MASK); //ر
    3b7c:	687b      	ldr	r3, [r7, #4]
    3b7e:	f06f 0201 	mvn.w	r2, #1
    3b82:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  ftmx->FILTER = 0x00;                      //ع
    3b86:	687b      	ldr	r3, [r7, #4]
    3b88:	f04f 0200 	mov.w	r2, #0
    3b8c:	679a      	str	r2, [r3, #120]	; 0x78
  
  // FTMƼĴ
  // FTM CounteróFree Counter
  // ж, Ӽģʽ, ʱԴ:System clockBus Clk, Ƶϵ:PS
  // SysClk = 50MHz, SC_PS=3, FTM Clk = 50MHz/2^3 = 6.25MHz
  ftmx->SC |= FTM_SC_CLKS(1)|FTM_SC_PS(ps);
    3b8e:	687b      	ldr	r3, [r7, #4]
    3b90:	681a      	ldr	r2, [r3, #0]
    3b92:	7bbb      	ldrb	r3, [r7, #14]
    3b94:	f003 0307 	and.w	r3, r3, #7
    3b98:	4313      	orrs	r3, r2
    3b9a:	f043 0208 	orr.w	r2, r3, #8
    3b9e:	687b      	ldr	r3, [r7, #4]
    3ba0:	601a      	str	r2, [r3, #0]
  //ftmx->SC |= FTM_SC_TOIE_MASK;             //ʹܼж
  ftmx->SC &= (~FTM_SC_CPWMS_MASK);         //FTMӼ
    3ba2:	687b      	ldr	r3, [r7, #4]
    3ba4:	681b      	ldr	r3, [r3, #0]
    3ba6:	f023 0220 	bic.w	r2, r3, #32
    3baa:	687b      	ldr	r3, [r7, #4]
    3bac:	601a      	str	r2, [r3, #0]

  //жϺڵַж
  if(isr_func!=NULL)
    3bae:	68bb      	ldr	r3, [r7, #8]
    3bb0:	2b00      	cmp	r3, #0
    3bb2:	d036      	beq.n	3c22 <LPLD_FTM_IC_Init+0xfa>
  {
    if(ftmx == FTM0)
    3bb4:	687a      	ldr	r2, [r7, #4]
    3bb6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    3bba:	f2c4 0303 	movt	r3, #16387	; 0x4003
    3bbe:	429a      	cmp	r2, r3
    3bc0:	d103      	bne.n	3bca <LPLD_FTM_IC_Init+0xa2>
      i=0;
    3bc2:	f04f 0300 	mov.w	r3, #0
    3bc6:	73fb      	strb	r3, [r7, #15]
    3bc8:	e023      	b.n	3c12 <LPLD_FTM_IC_Init+0xea>
    else if(ftmx == FTM1)
    3bca:	687a      	ldr	r2, [r7, #4]
    3bcc:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    3bd0:	f2c4 0303 	movt	r3, #16387	; 0x4003
    3bd4:	429a      	cmp	r2, r3
    3bd6:	d103      	bne.n	3be0 <LPLD_FTM_IC_Init+0xb8>
      i=1;
    3bd8:	f04f 0301 	mov.w	r3, #1
    3bdc:	73fb      	strb	r3, [r7, #15]
    3bde:	e018      	b.n	3c12 <LPLD_FTM_IC_Init+0xea>
    else if(ftmx == FTM2)
    3be0:	687a      	ldr	r2, [r7, #4]
    3be2:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    3be6:	f2c4 030b 	movt	r3, #16395	; 0x400b
    3bea:	429a      	cmp	r2, r3
    3bec:	d103      	bne.n	3bf6 <LPLD_FTM_IC_Init+0xce>
      i=2;
    3bee:	f04f 0302 	mov.w	r3, #2
    3bf2:	73fb      	strb	r3, [r7, #15]
    3bf4:	e00d      	b.n	3c12 <LPLD_FTM_IC_Init+0xea>
    else if (ftmx == FTM3)
    3bf6:	687a      	ldr	r2, [r7, #4]
    3bf8:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    3bfc:	f2c4 030b 	movt	r3, #16395	; 0x400b
    3c00:	429a      	cmp	r2, r3
    3c02:	d103      	bne.n	3c0c <LPLD_FTM_IC_Init+0xe4>
        i = 3;
    3c04:	f04f 0303 	mov.w	r3, #3
    3c08:	73fb      	strb	r3, [r7, #15]
    3c0a:	e002      	b.n	3c12 <LPLD_FTM_IC_Init+0xea>
    else
      return 0;
    3c0c:	f04f 0300 	mov.w	r3, #0
    3c10:	e009      	b.n	3c26 <LPLD_FTM_IC_Init+0xfe>
    FTM_ISR[i] = isr_func;
    3c12:	7bfa      	ldrb	r2, [r7, #15]
    3c14:	f241 6344 	movw	r3, #5700	; 0x1644
    3c18:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    3c1c:	68b9      	ldr	r1, [r7, #8]
    3c1e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  }

  return 1;
    3c22:	f04f 0301 	mov.w	r3, #1
}
    3c26:	4618      	mov	r0, r3
    3c28:	f107 0714 	add.w	r7, r7, #20
    3c2c:	46bd      	mov	sp, r7
    3c2e:	bc80      	pop	{r7}
    3c30:	b004      	add	sp, #16
    3c32:	4770      	bx	lr

00003c34 <LPLD_FTM_PinInit>:
/*
 * LPLD_FTM_PinInit
 * ʼͨnָŵFTMùܣڲ
 */
static uint8 LPLD_FTM_PinInit(FTM_MemMapPtr  ftmx, FtmChnEnum_Type chn, PortPinsEnum_Type pin)
{ 
    3c34:	b480      	push	{r7}
    3c36:	b083      	sub	sp, #12
    3c38:	af00      	add	r7, sp, #0
    3c3a:	6078      	str	r0, [r7, #4]
    3c3c:	4613      	mov	r3, r2
    3c3e:	460a      	mov	r2, r1
    3c40:	70fa      	strb	r2, [r7, #3]
    3c42:	70bb      	strb	r3, [r7, #2]
  //ftmxʹӦpinftm
  if(ftmx == FTM0)
    3c44:	687a      	ldr	r2, [r7, #4]
    3c46:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    3c4a:	f2c4 0303 	movt	r3, #16387	; 0x4003
    3c4e:	429a      	cmp	r2, r3
    3c50:	f040 815b 	bne.w	3f0a <LPLD_FTM_PinInit+0x2d6>
  {
    switch(chn)
    3c54:	78fb      	ldrb	r3, [r7, #3]
    3c56:	2b07      	cmp	r3, #7
    3c58:	f200 8154 	bhi.w	3f04 <LPLD_FTM_PinInit+0x2d0>
    3c5c:	a201      	add	r2, pc, #4	; (adr r2, 3c64 <LPLD_FTM_PinInit+0x30>)
    3c5e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    3c62:	bf00      	nop
    3c64:	00003c85 	andeq	r3, r0, r5, lsl #25
    3c68:	00003cd9 	ldrdeq	r3, [r0], -r9
    3c6c:	00003d2d 	andeq	r3, r0, sp, lsr #26
    3c70:	00003d7d 	andeq	r3, r0, sp, ror sp
    3c74:	00003dcb 	andeq	r3, r0, fp, asr #27
    3c78:	00003e19 	andeq	r3, r0, r9, lsl lr
    3c7c:	00003e67 	andeq	r3, r0, r7, ror #28
    3c80:	00003eb5 			; <UNDEFINED> instruction: 0x00003eb5
    {
    case FTM_Ch0:
      if(pin == PTA3)
    3c84:	78bb      	ldrb	r3, [r7, #2]
    3c86:	2b03      	cmp	r3, #3
    3c88:	d10f      	bne.n	3caa <LPLD_FTM_PinInit+0x76>
        PORTA->PCR[3] = (PORTA->PCR[3] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
    3c8a:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    3c8e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    3c92:	f44f 4210 	mov.w	r2, #36864	; 0x9000
    3c96:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3c9a:	68d2      	ldr	r2, [r2, #12]
    3c9c:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    3ca0:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    3ca4:	60da      	str	r2, [r3, #12]
      else if(pin == PTC1)
        PORTC->PCR[1] = (PORTC->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
      break;
    3ca6:	f000 bc5a 	b.w	455e <LPLD_FTM_PinInit+0x92a>
    switch(chn)
    {
    case FTM_Ch0:
      if(pin == PTA3)
        PORTA->PCR[3] = (PORTA->PCR[3] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTC1)
    3caa:	78bb      	ldrb	r3, [r7, #2]
    3cac:	2b3d      	cmp	r3, #61	; 0x3d
    3cae:	d10f      	bne.n	3cd0 <LPLD_FTM_PinInit+0x9c>
        PORTC->PCR[1] = (PORTC->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    3cb0:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    3cb4:	f2c4 0304 	movt	r3, #16388	; 0x4004
    3cb8:	f44f 4230 	mov.w	r2, #45056	; 0xb000
    3cbc:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3cc0:	6852      	ldr	r2, [r2, #4]
    3cc2:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    3cc6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    3cca:	605a      	str	r2, [r3, #4]
      else
        return 0;
      break;
    3ccc:	f000 bc47 	b.w	455e <LPLD_FTM_PinInit+0x92a>
      if(pin == PTA3)
        PORTA->PCR[3] = (PORTA->PCR[3] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTC1)
        PORTC->PCR[1] = (PORTC->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
    3cd0:	f04f 0300 	mov.w	r3, #0
    3cd4:	f000 bc45 	b.w	4562 <LPLD_FTM_PinInit+0x92e>
      break;
    case FTM_Ch1:
      if(pin == PTA4)
    3cd8:	78bb      	ldrb	r3, [r7, #2]
    3cda:	2b04      	cmp	r3, #4
    3cdc:	d10f      	bne.n	3cfe <LPLD_FTM_PinInit+0xca>
        PORTA->PCR[4] = (PORTA->PCR[4] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
    3cde:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    3ce2:	f2c4 0304 	movt	r3, #16388	; 0x4004
    3ce6:	f44f 4210 	mov.w	r2, #36864	; 0x9000
    3cea:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3cee:	6912      	ldr	r2, [r2, #16]
    3cf0:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    3cf4:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    3cf8:	611a      	str	r2, [r3, #16]
      else if(pin == PTC2)
        PORTC->PCR[2] = (PORTC->PCR[2] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
      break;
    3cfa:	f000 bc30 	b.w	455e <LPLD_FTM_PinInit+0x92a>
        return 0;
      break;
    case FTM_Ch1:
      if(pin == PTA4)
        PORTA->PCR[4] = (PORTA->PCR[4] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTC2)
    3cfe:	78bb      	ldrb	r3, [r7, #2]
    3d00:	2b3e      	cmp	r3, #62	; 0x3e
    3d02:	d10f      	bne.n	3d24 <LPLD_FTM_PinInit+0xf0>
        PORTC->PCR[2] = (PORTC->PCR[2] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    3d04:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    3d08:	f2c4 0304 	movt	r3, #16388	; 0x4004
    3d0c:	f44f 4230 	mov.w	r2, #45056	; 0xb000
    3d10:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3d14:	6892      	ldr	r2, [r2, #8]
    3d16:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    3d1a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    3d1e:	609a      	str	r2, [r3, #8]
      else
        return 0;
      break;
    3d20:	f000 bc1d 	b.w	455e <LPLD_FTM_PinInit+0x92a>
      if(pin == PTA4)
        PORTA->PCR[4] = (PORTA->PCR[4] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTC2)
        PORTC->PCR[2] = (PORTC->PCR[2] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
    3d24:	f04f 0300 	mov.w	r3, #0
    3d28:	f000 bc1b 	b.w	4562 <LPLD_FTM_PinInit+0x92e>
      break;
    case FTM_Ch2:
      if(pin == PTA5)
    3d2c:	78bb      	ldrb	r3, [r7, #2]
    3d2e:	2b05      	cmp	r3, #5
    3d30:	d10f      	bne.n	3d52 <LPLD_FTM_PinInit+0x11e>
        PORTA->PCR[5] = (PORTA->PCR[5] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
    3d32:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    3d36:	f2c4 0304 	movt	r3, #16388	; 0x4004
    3d3a:	f44f 4210 	mov.w	r2, #36864	; 0x9000
    3d3e:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3d42:	6952      	ldr	r2, [r2, #20]
    3d44:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    3d48:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    3d4c:	615a      	str	r2, [r3, #20]
      else if(pin == PTC3)
        PORTC->PCR[3] = (PORTC->PCR[3] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
      break;
    3d4e:	f000 bc06 	b.w	455e <LPLD_FTM_PinInit+0x92a>
        return 0;
      break;
    case FTM_Ch2:
      if(pin == PTA5)
        PORTA->PCR[5] = (PORTA->PCR[5] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTC3)
    3d52:	78bb      	ldrb	r3, [r7, #2]
    3d54:	2b3f      	cmp	r3, #63	; 0x3f
    3d56:	d10e      	bne.n	3d76 <LPLD_FTM_PinInit+0x142>
        PORTC->PCR[3] = (PORTC->PCR[3] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    3d58:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    3d5c:	f2c4 0304 	movt	r3, #16388	; 0x4004
    3d60:	f44f 4230 	mov.w	r2, #45056	; 0xb000
    3d64:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3d68:	68d2      	ldr	r2, [r2, #12]
    3d6a:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    3d6e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    3d72:	60da      	str	r2, [r3, #12]
      else
        return 0;
      break;
    3d74:	e3f3      	b.n	455e <LPLD_FTM_PinInit+0x92a>
      if(pin == PTA5)
        PORTA->PCR[5] = (PORTA->PCR[5] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTC3)
        PORTC->PCR[3] = (PORTC->PCR[3] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
    3d76:	f04f 0300 	mov.w	r3, #0
    3d7a:	e3f2      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
      break;
    case FTM_Ch3:
      if(pin == PTA6)
    3d7c:	78bb      	ldrb	r3, [r7, #2]
    3d7e:	2b06      	cmp	r3, #6
    3d80:	d10e      	bne.n	3da0 <LPLD_FTM_PinInit+0x16c>
        PORTA->PCR[6] = (PORTA->PCR[6] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
    3d82:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    3d86:	f2c4 0304 	movt	r3, #16388	; 0x4004
    3d8a:	f44f 4210 	mov.w	r2, #36864	; 0x9000
    3d8e:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3d92:	6992      	ldr	r2, [r2, #24]
    3d94:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    3d98:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    3d9c:	619a      	str	r2, [r3, #24]
      else if(pin == PTC4)
        PORTC->PCR[4] = (PORTC->PCR[4] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
      break;
    3d9e:	e3de      	b.n	455e <LPLD_FTM_PinInit+0x92a>
        return 0;
      break;
    case FTM_Ch3:
      if(pin == PTA6)
        PORTA->PCR[6] = (PORTA->PCR[6] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTC4)
    3da0:	78bb      	ldrb	r3, [r7, #2]
    3da2:	2b40      	cmp	r3, #64	; 0x40
    3da4:	d10e      	bne.n	3dc4 <LPLD_FTM_PinInit+0x190>
        PORTC->PCR[4] = (PORTC->PCR[4] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    3da6:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    3daa:	f2c4 0304 	movt	r3, #16388	; 0x4004
    3dae:	f44f 4230 	mov.w	r2, #45056	; 0xb000
    3db2:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3db6:	6912      	ldr	r2, [r2, #16]
    3db8:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    3dbc:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    3dc0:	611a      	str	r2, [r3, #16]
      else
        return 0;
      break;
    3dc2:	e3cc      	b.n	455e <LPLD_FTM_PinInit+0x92a>
      if(pin == PTA6)
        PORTA->PCR[6] = (PORTA->PCR[6] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTC4)
        PORTC->PCR[4] = (PORTC->PCR[4] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
    3dc4:	f04f 0300 	mov.w	r3, #0
    3dc8:	e3cb      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
      break;
    case FTM_Ch4:
      if(pin == PTA7)
    3dca:	78bb      	ldrb	r3, [r7, #2]
    3dcc:	2b07      	cmp	r3, #7
    3dce:	d10e      	bne.n	3dee <LPLD_FTM_PinInit+0x1ba>
        PORTA->PCR[7] = (PORTA->PCR[7] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
    3dd0:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    3dd4:	f2c4 0304 	movt	r3, #16388	; 0x4004
    3dd8:	f44f 4210 	mov.w	r2, #36864	; 0x9000
    3ddc:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3de0:	69d2      	ldr	r2, [r2, #28]
    3de2:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    3de6:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    3dea:	61da      	str	r2, [r3, #28]
      else if(pin == PTD4)
        PORTD->PCR[4] = (PORTD->PCR[4] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
      break;
    3dec:	e3b7      	b.n	455e <LPLD_FTM_PinInit+0x92a>
        return 0;
      break;
    case FTM_Ch4:
      if(pin == PTA7)
        PORTA->PCR[7] = (PORTA->PCR[7] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTD4)
    3dee:	78bb      	ldrb	r3, [r7, #2]
    3df0:	2b60      	cmp	r3, #96	; 0x60
    3df2:	d10e      	bne.n	3e12 <LPLD_FTM_PinInit+0x1de>
        PORTD->PCR[4] = (PORTD->PCR[4] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    3df4:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    3df8:	f2c4 0304 	movt	r3, #16388	; 0x4004
    3dfc:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    3e00:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3e04:	6912      	ldr	r2, [r2, #16]
    3e06:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    3e0a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    3e0e:	611a      	str	r2, [r3, #16]
      else
        return 0;
      break;
    3e10:	e3a5      	b.n	455e <LPLD_FTM_PinInit+0x92a>
      if(pin == PTA7)
        PORTA->PCR[7] = (PORTA->PCR[7] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTD4)
        PORTD->PCR[4] = (PORTD->PCR[4] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
    3e12:	f04f 0300 	mov.w	r3, #0
    3e16:	e3a4      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
      break;
    case FTM_Ch5:
      if(pin == PTA0)
    3e18:	78bb      	ldrb	r3, [r7, #2]
    3e1a:	2b00      	cmp	r3, #0
    3e1c:	d10e      	bne.n	3e3c <LPLD_FTM_PinInit+0x208>
        PORTA->PCR[0] = (PORTA->PCR[0] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
    3e1e:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    3e22:	f2c4 0304 	movt	r3, #16388	; 0x4004
    3e26:	f44f 4210 	mov.w	r2, #36864	; 0x9000
    3e2a:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3e2e:	6812      	ldr	r2, [r2, #0]
    3e30:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    3e34:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    3e38:	601a      	str	r2, [r3, #0]
      else if(pin == PTD5)
        PORTD->PCR[5] = (PORTD->PCR[5] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
      break;
    3e3a:	e390      	b.n	455e <LPLD_FTM_PinInit+0x92a>
        return 0;
      break;
    case FTM_Ch5:
      if(pin == PTA0)
        PORTA->PCR[0] = (PORTA->PCR[0] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTD5)
    3e3c:	78bb      	ldrb	r3, [r7, #2]
    3e3e:	2b61      	cmp	r3, #97	; 0x61
    3e40:	d10e      	bne.n	3e60 <LPLD_FTM_PinInit+0x22c>
        PORTD->PCR[5] = (PORTD->PCR[5] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    3e42:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    3e46:	f2c4 0304 	movt	r3, #16388	; 0x4004
    3e4a:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    3e4e:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3e52:	6952      	ldr	r2, [r2, #20]
    3e54:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    3e58:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    3e5c:	615a      	str	r2, [r3, #20]
      else
        return 0;
      break;
    3e5e:	e37e      	b.n	455e <LPLD_FTM_PinInit+0x92a>
      if(pin == PTA0)
        PORTA->PCR[0] = (PORTA->PCR[0] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTD5)
        PORTD->PCR[5] = (PORTD->PCR[5] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
    3e60:	f04f 0300 	mov.w	r3, #0
    3e64:	e37d      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
      break;
    case FTM_Ch6:
      if(pin == PTA1)
    3e66:	78bb      	ldrb	r3, [r7, #2]
    3e68:	2b01      	cmp	r3, #1
    3e6a:	d10e      	bne.n	3e8a <LPLD_FTM_PinInit+0x256>
        PORTA->PCR[1] = (PORTA->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
    3e6c:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    3e70:	f2c4 0304 	movt	r3, #16388	; 0x4004
    3e74:	f44f 4210 	mov.w	r2, #36864	; 0x9000
    3e78:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3e7c:	6852      	ldr	r2, [r2, #4]
    3e7e:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    3e82:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    3e86:	605a      	str	r2, [r3, #4]
      else if(pin == PTD6)
        PORTD->PCR[6] = (PORTD->PCR[6] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
      break;
    3e88:	e369      	b.n	455e <LPLD_FTM_PinInit+0x92a>
        return 0;
      break;
    case FTM_Ch6:
      if(pin == PTA1)
        PORTA->PCR[1] = (PORTA->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTD6)
    3e8a:	78bb      	ldrb	r3, [r7, #2]
    3e8c:	2b62      	cmp	r3, #98	; 0x62
    3e8e:	d10e      	bne.n	3eae <LPLD_FTM_PinInit+0x27a>
        PORTD->PCR[6] = (PORTD->PCR[6] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    3e90:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    3e94:	f2c4 0304 	movt	r3, #16388	; 0x4004
    3e98:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    3e9c:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3ea0:	6992      	ldr	r2, [r2, #24]
    3ea2:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    3ea6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    3eaa:	619a      	str	r2, [r3, #24]
      else
        return 0;
      break;
    3eac:	e357      	b.n	455e <LPLD_FTM_PinInit+0x92a>
      if(pin == PTA1)
        PORTA->PCR[1] = (PORTA->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTD6)
        PORTD->PCR[6] = (PORTD->PCR[6] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
    3eae:	f04f 0300 	mov.w	r3, #0
    3eb2:	e356      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
      break;
    case FTM_Ch7:
      if(pin == PTA2)
    3eb4:	78bb      	ldrb	r3, [r7, #2]
    3eb6:	2b02      	cmp	r3, #2
    3eb8:	d10e      	bne.n	3ed8 <LPLD_FTM_PinInit+0x2a4>
        PORTA->PCR[2] = (PORTA->PCR[2] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
    3eba:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    3ebe:	f2c4 0304 	movt	r3, #16388	; 0x4004
    3ec2:	f44f 4210 	mov.w	r2, #36864	; 0x9000
    3ec6:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3eca:	6892      	ldr	r2, [r2, #8]
    3ecc:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    3ed0:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    3ed4:	609a      	str	r2, [r3, #8]
      else if(pin == PTD7)
        PORTD->PCR[7] = (PORTD->PCR[7] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
      break;
    3ed6:	e342      	b.n	455e <LPLD_FTM_PinInit+0x92a>
        return 0;
      break;
    case FTM_Ch7:
      if(pin == PTA2)
        PORTA->PCR[2] = (PORTA->PCR[2] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTD7)
    3ed8:	78bb      	ldrb	r3, [r7, #2]
    3eda:	2b63      	cmp	r3, #99	; 0x63
    3edc:	d10f      	bne.n	3efe <LPLD_FTM_PinInit+0x2ca>
        PORTD->PCR[7] = (PORTD->PCR[7] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    3ede:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    3ee2:	f2c4 0304 	movt	r3, #16388	; 0x4004
    3ee6:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    3eea:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3eee:	69d2      	ldr	r2, [r2, #28]
    3ef0:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    3ef4:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    3ef8:	61da      	str	r2, [r3, #28]
      else
        return 0;
      break;
    3efa:	bf00      	nop
    3efc:	e32f      	b.n	455e <LPLD_FTM_PinInit+0x92a>
      if(pin == PTA2)
        PORTA->PCR[2] = (PORTA->PCR[2] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTD7)
        PORTD->PCR[7] = (PORTD->PCR[7] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
    3efe:	f04f 0300 	mov.w	r3, #0
    3f02:	e32e      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
      break;
    default:
      return 0;     
    3f04:	f04f 0300 	mov.w	r3, #0
    3f08:	e32b      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
    }
  }
  else if(ftmx == FTM1)
    3f0a:	687a      	ldr	r2, [r7, #4]
    3f0c:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    3f10:	f2c4 0303 	movt	r3, #16387	; 0x4003
    3f14:	429a      	cmp	r2, r3
    3f16:	f040 80ff 	bne.w	4118 <LPLD_FTM_PinInit+0x4e4>
  {
    switch(chn)
    3f1a:	78fb      	ldrb	r3, [r7, #3]
    3f1c:	2b09      	cmp	r3, #9
    3f1e:	f200 80f8 	bhi.w	4112 <LPLD_FTM_PinInit+0x4de>
    3f22:	a201      	add	r2, pc, #4	; (adr r2, 3f28 <LPLD_FTM_PinInit+0x2f4>)
    3f24:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    3f28:	00003f51 	andeq	r3, r0, r1, asr pc
    3f2c:	00003fc3 	andeq	r3, r0, r3, asr #31
    3f30:	00004113 	andeq	r4, r0, r3, lsl r1
    3f34:	00004113 	andeq	r4, r0, r3, lsl r1
    3f38:	00004113 	andeq	r4, r0, r3, lsl r1
    3f3c:	00004113 	andeq	r4, r0, r3, lsl r1
    3f40:	00004113 	andeq	r4, r0, r3, lsl r1
    3f44:	00004113 	andeq	r4, r0, r3, lsl r1
    3f48:	00004035 	andeq	r4, r0, r5, lsr r0
    3f4c:	000040a5 	andeq	r4, r0, r5, lsr #1
    {
    case FTM_Ch0:
      if(pin == PTA8)
    3f50:	78bb      	ldrb	r3, [r7, #2]
    3f52:	2b08      	cmp	r3, #8
    3f54:	d10e      	bne.n	3f74 <LPLD_FTM_PinInit+0x340>
        PORTA->PCR[8] = (PORTA->PCR[8] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
    3f56:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    3f5a:	f2c4 0304 	movt	r3, #16388	; 0x4004
    3f5e:	f44f 4210 	mov.w	r2, #36864	; 0x9000
    3f62:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3f66:	6a12      	ldr	r2, [r2, #32]
    3f68:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    3f6c:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    3f70:	621a      	str	r2, [r3, #32]
        PORTA->PCR[12] = (PORTA->PCR[12] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
      else if(pin == PTB0)
        PORTB->PCR[0] = (PORTB->PCR[0] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
      else
        return 0;
      break;
    3f72:	e2f4      	b.n	455e <LPLD_FTM_PinInit+0x92a>
    switch(chn)
    {
    case FTM_Ch0:
      if(pin == PTA8)
        PORTA->PCR[8] = (PORTA->PCR[8] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTA12)
    3f74:	78bb      	ldrb	r3, [r7, #2]
    3f76:	2b0c      	cmp	r3, #12
    3f78:	d10e      	bne.n	3f98 <LPLD_FTM_PinInit+0x364>
        PORTA->PCR[12] = (PORTA->PCR[12] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
    3f7a:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    3f7e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    3f82:	f44f 4210 	mov.w	r2, #36864	; 0x9000
    3f86:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3f8a:	6b12      	ldr	r2, [r2, #48]	; 0x30
    3f8c:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    3f90:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    3f94:	631a      	str	r2, [r3, #48]	; 0x30
      else if(pin == PTB0)
        PORTB->PCR[0] = (PORTB->PCR[0] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
      else
        return 0;
      break;
    3f96:	e2e2      	b.n	455e <LPLD_FTM_PinInit+0x92a>
    case FTM_Ch0:
      if(pin == PTA8)
        PORTA->PCR[8] = (PORTA->PCR[8] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTA12)
        PORTA->PCR[12] = (PORTA->PCR[12] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
      else if(pin == PTB0)
    3f98:	78bb      	ldrb	r3, [r7, #2]
    3f9a:	2b20      	cmp	r3, #32
    3f9c:	d10e      	bne.n	3fbc <LPLD_FTM_PinInit+0x388>
        PORTB->PCR[0] = (PORTB->PCR[0] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
    3f9e:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    3fa2:	f2c4 0304 	movt	r3, #16388	; 0x4004
    3fa6:	f44f 4220 	mov.w	r2, #40960	; 0xa000
    3faa:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3fae:	6812      	ldr	r2, [r2, #0]
    3fb0:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    3fb4:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    3fb8:	601a      	str	r2, [r3, #0]
      else
        return 0;
      break;
    3fba:	e2d0      	b.n	455e <LPLD_FTM_PinInit+0x92a>
      else if(pin == PTA12)
        PORTA->PCR[12] = (PORTA->PCR[12] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
      else if(pin == PTB0)
        PORTB->PCR[0] = (PORTB->PCR[0] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
      else
        return 0;
    3fbc:	f04f 0300 	mov.w	r3, #0
    3fc0:	e2cf      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
      break;
    case FTM_Ch1:
      if(pin == PTA9)
    3fc2:	78bb      	ldrb	r3, [r7, #2]
    3fc4:	2b09      	cmp	r3, #9
    3fc6:	d10e      	bne.n	3fe6 <LPLD_FTM_PinInit+0x3b2>
        PORTA->PCR[9] = (PORTA->PCR[9] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
    3fc8:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    3fcc:	f2c4 0304 	movt	r3, #16388	; 0x4004
    3fd0:	f44f 4210 	mov.w	r2, #36864	; 0x9000
    3fd4:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3fd8:	6a52      	ldr	r2, [r2, #36]	; 0x24
    3fda:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    3fde:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    3fe2:	625a      	str	r2, [r3, #36]	; 0x24
        PORTA->PCR[13] = (PORTA->PCR[13] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
      else if(pin == PTB1)
        PORTB->PCR[1] = (PORTB->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
      else
        return 0;
      break;
    3fe4:	e2bb      	b.n	455e <LPLD_FTM_PinInit+0x92a>
        return 0;
      break;
    case FTM_Ch1:
      if(pin == PTA9)
        PORTA->PCR[9] = (PORTA->PCR[9] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTA13)
    3fe6:	78bb      	ldrb	r3, [r7, #2]
    3fe8:	2b0d      	cmp	r3, #13
    3fea:	d10e      	bne.n	400a <LPLD_FTM_PinInit+0x3d6>
        PORTA->PCR[13] = (PORTA->PCR[13] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
    3fec:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    3ff0:	f2c4 0304 	movt	r3, #16388	; 0x4004
    3ff4:	f44f 4210 	mov.w	r2, #36864	; 0x9000
    3ff8:	f2c4 0204 	movt	r2, #16388	; 0x4004
    3ffc:	6b52      	ldr	r2, [r2, #52]	; 0x34
    3ffe:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    4002:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    4006:	635a      	str	r2, [r3, #52]	; 0x34
      else if(pin == PTB1)
        PORTB->PCR[1] = (PORTB->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
      else
        return 0;
      break;
    4008:	e2a9      	b.n	455e <LPLD_FTM_PinInit+0x92a>
    case FTM_Ch1:
      if(pin == PTA9)
        PORTA->PCR[9] = (PORTA->PCR[9] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTA13)
        PORTA->PCR[13] = (PORTA->PCR[13] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
      else if(pin == PTB1)
    400a:	78bb      	ldrb	r3, [r7, #2]
    400c:	2b21      	cmp	r3, #33	; 0x21
    400e:	d10e      	bne.n	402e <LPLD_FTM_PinInit+0x3fa>
        PORTB->PCR[1] = (PORTB->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
    4010:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    4014:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4018:	f44f 4220 	mov.w	r2, #40960	; 0xa000
    401c:	f2c4 0204 	movt	r2, #16388	; 0x4004
    4020:	6852      	ldr	r2, [r2, #4]
    4022:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    4026:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    402a:	605a      	str	r2, [r3, #4]
      else
        return 0;
      break;
    402c:	e297      	b.n	455e <LPLD_FTM_PinInit+0x92a>
      else if(pin == PTA13)
        PORTA->PCR[13] = (PORTA->PCR[13] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
      else if(pin == PTB1)
        PORTB->PCR[1] = (PORTB->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
      else
        return 0;
    402e:	f04f 0300 	mov.w	r3, #0
    4032:	e296      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
      break;
    case FTM_PhA:
      if(pin == PTA8)
    4034:	78bb      	ldrb	r3, [r7, #2]
    4036:	2b08      	cmp	r3, #8
    4038:	d10e      	bne.n	4058 <LPLD_FTM_PinInit+0x424>
        PORTA->PCR[8] = (PORTA->PCR[8] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6); 
    403a:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    403e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4042:	f44f 4210 	mov.w	r2, #36864	; 0x9000
    4046:	f2c4 0204 	movt	r2, #16388	; 0x4004
    404a:	6a12      	ldr	r2, [r2, #32]
    404c:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    4050:	f442 62c0 	orr.w	r2, r2, #1536	; 0x600
    4054:	621a      	str	r2, [r3, #32]
        PORTA->PCR[12] = (PORTA->PCR[12] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(7);
      else if(pin == PTB0)
        PORTB->PCR[0] = (PORTB->PCR[0] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
      else
        return 0;
      break;
    4056:	e282      	b.n	455e <LPLD_FTM_PinInit+0x92a>
        return 0;
      break;
    case FTM_PhA:
      if(pin == PTA8)
        PORTA->PCR[8] = (PORTA->PCR[8] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6); 
      else if(pin == PTA12)
    4058:	78bb      	ldrb	r3, [r7, #2]
    405a:	2b0c      	cmp	r3, #12
    405c:	d10c      	bne.n	4078 <LPLD_FTM_PinInit+0x444>
        PORTA->PCR[12] = (PORTA->PCR[12] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(7);
    405e:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4062:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4066:	f44f 4210 	mov.w	r2, #36864	; 0x9000
    406a:	f2c4 0204 	movt	r2, #16388	; 0x4004
    406e:	6b12      	ldr	r2, [r2, #48]	; 0x30
    4070:	f442 62e0 	orr.w	r2, r2, #1792	; 0x700
    4074:	631a      	str	r2, [r3, #48]	; 0x30
      else if(pin == PTB0)
        PORTB->PCR[0] = (PORTB->PCR[0] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
      else
        return 0;
      break;
    4076:	e272      	b.n	455e <LPLD_FTM_PinInit+0x92a>
    case FTM_PhA:
      if(pin == PTA8)
        PORTA->PCR[8] = (PORTA->PCR[8] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6); 
      else if(pin == PTA12)
        PORTA->PCR[12] = (PORTA->PCR[12] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(7);
      else if(pin == PTB0)
    4078:	78bb      	ldrb	r3, [r7, #2]
    407a:	2b20      	cmp	r3, #32
    407c:	d10f      	bne.n	409e <LPLD_FTM_PinInit+0x46a>
        PORTB->PCR[0] = (PORTB->PCR[0] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
    407e:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    4082:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4086:	f44f 4220 	mov.w	r2, #40960	; 0xa000
    408a:	f2c4 0204 	movt	r2, #16388	; 0x4004
    408e:	6812      	ldr	r2, [r2, #0]
    4090:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    4094:	f442 62c0 	orr.w	r2, r2, #1536	; 0x600
    4098:	601a      	str	r2, [r3, #0]
      else
        return 0;
      break;
    409a:	bf00      	nop
    409c:	e25f      	b.n	455e <LPLD_FTM_PinInit+0x92a>
      else if(pin == PTA12)
        PORTA->PCR[12] = (PORTA->PCR[12] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(7);
      else if(pin == PTB0)
        PORTB->PCR[0] = (PORTB->PCR[0] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
      else
        return 0;
    409e:	f04f 0300 	mov.w	r3, #0
    40a2:	e25e      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
      break;
    case FTM_PhB:
      if(pin == PTA9)
    40a4:	78bb      	ldrb	r3, [r7, #2]
    40a6:	2b09      	cmp	r3, #9
    40a8:	d10e      	bne.n	40c8 <LPLD_FTM_PinInit+0x494>
        PORTA->PCR[9] = (PORTA->PCR[9] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6); 
    40aa:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    40ae:	f2c4 0304 	movt	r3, #16388	; 0x4004
    40b2:	f44f 4210 	mov.w	r2, #36864	; 0x9000
    40b6:	f2c4 0204 	movt	r2, #16388	; 0x4004
    40ba:	6a52      	ldr	r2, [r2, #36]	; 0x24
    40bc:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    40c0:	f442 62c0 	orr.w	r2, r2, #1536	; 0x600
    40c4:	625a      	str	r2, [r3, #36]	; 0x24
    40c6:	e024      	b.n	4112 <LPLD_FTM_PinInit+0x4de>
      else if(pin == PTA13)
    40c8:	78bb      	ldrb	r3, [r7, #2]
    40ca:	2b0d      	cmp	r3, #13
    40cc:	d10c      	bne.n	40e8 <LPLD_FTM_PinInit+0x4b4>
        PORTA->PCR[13] = (PORTA->PCR[13] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(7);
    40ce:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    40d2:	f2c4 0304 	movt	r3, #16388	; 0x4004
    40d6:	f44f 4210 	mov.w	r2, #36864	; 0x9000
    40da:	f2c4 0204 	movt	r2, #16388	; 0x4004
    40de:	6b52      	ldr	r2, [r2, #52]	; 0x34
    40e0:	f442 62e0 	orr.w	r2, r2, #1792	; 0x700
    40e4:	635a      	str	r2, [r3, #52]	; 0x34
    40e6:	e014      	b.n	4112 <LPLD_FTM_PinInit+0x4de>
      else if(pin == PTB1)
    40e8:	78bb      	ldrb	r3, [r7, #2]
    40ea:	2b21      	cmp	r3, #33	; 0x21
    40ec:	d10e      	bne.n	410c <LPLD_FTM_PinInit+0x4d8>
        PORTB->PCR[1] = (PORTB->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
    40ee:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    40f2:	f2c4 0304 	movt	r3, #16388	; 0x4004
    40f6:	f44f 4220 	mov.w	r2, #40960	; 0xa000
    40fa:	f2c4 0204 	movt	r2, #16388	; 0x4004
    40fe:	6852      	ldr	r2, [r2, #4]
    4100:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    4104:	f442 62c0 	orr.w	r2, r2, #1536	; 0x600
    4108:	605a      	str	r2, [r3, #4]
    410a:	e002      	b.n	4112 <LPLD_FTM_PinInit+0x4de>
      else
        return 0;
    410c:	f04f 0300 	mov.w	r3, #0
    4110:	e227      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
    default:
      return 0;   
    4112:	f04f 0300 	mov.w	r3, #0
    4116:	e224      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
    }
  }
  else if(ftmx == FTM2)
    4118:	687a      	ldr	r2, [r7, #4]
    411a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    411e:	f2c4 030b 	movt	r3, #16395	; 0x400b
    4122:	429a      	cmp	r2, r3
    4124:	f040 80bc 	bne.w	42a0 <LPLD_FTM_PinInit+0x66c>
  {
    switch(chn)
    4128:	78fb      	ldrb	r3, [r7, #3]
    412a:	2b09      	cmp	r3, #9
    412c:	f200 80b5 	bhi.w	429a <LPLD_FTM_PinInit+0x666>
    4130:	a201      	add	r2, pc, #4	; (adr r2, 4138 <LPLD_FTM_PinInit+0x504>)
    4132:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    4136:	bf00      	nop
    4138:	00004161 	andeq	r4, r0, r1, ror #2
    413c:	000041af 	andeq	r4, r0, pc, lsr #3
    4140:	0000429b 	muleq	r0, fp, r2
    4144:	0000429b 	muleq	r0, fp, r2
    4148:	0000429b 	muleq	r0, fp, r2
    414c:	0000429b 	muleq	r0, fp, r2
    4150:	0000429b 	muleq	r0, fp, r2
    4154:	0000429b 	muleq	r0, fp, r2
    4158:	000041fd 	strdeq	r4, [r0], -sp
    415c:	0000424b 	andeq	r4, r0, fp, asr #4
    {
    case FTM_Ch0:
      if(pin == PTA10)
    4160:	78bb      	ldrb	r3, [r7, #2]
    4162:	2b0a      	cmp	r3, #10
    4164:	d10e      	bne.n	4184 <LPLD_FTM_PinInit+0x550>
        PORTA->PCR[10] = (PORTA->PCR[10] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
    4166:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    416a:	f2c4 0304 	movt	r3, #16388	; 0x4004
    416e:	f44f 4210 	mov.w	r2, #36864	; 0x9000
    4172:	f2c4 0204 	movt	r2, #16388	; 0x4004
    4176:	6a92      	ldr	r2, [r2, #40]	; 0x28
    4178:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    417c:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    4180:	629a      	str	r2, [r3, #40]	; 0x28
      else if(pin == PTB18)
        PORTB->PCR[18] = (PORTB->PCR[18] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
      else
        return 0;
      break;
    4182:	e1ec      	b.n	455e <LPLD_FTM_PinInit+0x92a>
    switch(chn)
    {
    case FTM_Ch0:
      if(pin == PTA10)
        PORTA->PCR[10] = (PORTA->PCR[10] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTB18)
    4184:	78bb      	ldrb	r3, [r7, #2]
    4186:	2b32      	cmp	r3, #50	; 0x32
    4188:	d10e      	bne.n	41a8 <LPLD_FTM_PinInit+0x574>
        PORTB->PCR[18] = (PORTB->PCR[18] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
    418a:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    418e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4192:	f44f 4220 	mov.w	r2, #40960	; 0xa000
    4196:	f2c4 0204 	movt	r2, #16388	; 0x4004
    419a:	6c92      	ldr	r2, [r2, #72]	; 0x48
    419c:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    41a0:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    41a4:	649a      	str	r2, [r3, #72]	; 0x48
      else
        return 0;
      break;
    41a6:	e1da      	b.n	455e <LPLD_FTM_PinInit+0x92a>
      if(pin == PTA10)
        PORTA->PCR[10] = (PORTA->PCR[10] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTB18)
        PORTB->PCR[18] = (PORTB->PCR[18] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
      else
        return 0;
    41a8:	f04f 0300 	mov.w	r3, #0
    41ac:	e1d9      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
      break;
    case FTM_Ch1:
      if(pin == PTA11)
    41ae:	78bb      	ldrb	r3, [r7, #2]
    41b0:	2b0b      	cmp	r3, #11
    41b2:	d10e      	bne.n	41d2 <LPLD_FTM_PinInit+0x59e>
        PORTA->PCR[11] = (PORTA->PCR[11] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
    41b4:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    41b8:	f2c4 0304 	movt	r3, #16388	; 0x4004
    41bc:	f44f 4210 	mov.w	r2, #36864	; 0x9000
    41c0:	f2c4 0204 	movt	r2, #16388	; 0x4004
    41c4:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    41c6:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    41ca:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    41ce:	62da      	str	r2, [r3, #44]	; 0x2c
      else if(pin == PTB19)
        PORTB->PCR[19] = (PORTB->PCR[19] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
      else
        return 0;
      break;
    41d0:	e1c5      	b.n	455e <LPLD_FTM_PinInit+0x92a>
        return 0;
      break;
    case FTM_Ch1:
      if(pin == PTA11)
        PORTA->PCR[11] = (PORTA->PCR[11] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTB19)
    41d2:	78bb      	ldrb	r3, [r7, #2]
    41d4:	2b33      	cmp	r3, #51	; 0x33
    41d6:	d10e      	bne.n	41f6 <LPLD_FTM_PinInit+0x5c2>
        PORTB->PCR[19] = (PORTB->PCR[19] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
    41d8:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    41dc:	f2c4 0304 	movt	r3, #16388	; 0x4004
    41e0:	f44f 4220 	mov.w	r2, #40960	; 0xa000
    41e4:	f2c4 0204 	movt	r2, #16388	; 0x4004
    41e8:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
    41ea:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    41ee:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    41f2:	64da      	str	r2, [r3, #76]	; 0x4c
      else
        return 0;
      break;
    41f4:	e1b3      	b.n	455e <LPLD_FTM_PinInit+0x92a>
      if(pin == PTA11)
        PORTA->PCR[11] = (PORTA->PCR[11] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTB19)
        PORTB->PCR[19] = (PORTB->PCR[19] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
      else
        return 0;
    41f6:	f04f 0300 	mov.w	r3, #0
    41fa:	e1b2      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
      break;
    case FTM_PhA:
      if(pin == PTA10)
    41fc:	78bb      	ldrb	r3, [r7, #2]
    41fe:	2b0a      	cmp	r3, #10
    4200:	d10e      	bne.n	4220 <LPLD_FTM_PinInit+0x5ec>
        PORTA->PCR[10] = (PORTA->PCR[10] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6); 
    4202:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4206:	f2c4 0304 	movt	r3, #16388	; 0x4004
    420a:	f44f 4210 	mov.w	r2, #36864	; 0x9000
    420e:	f2c4 0204 	movt	r2, #16388	; 0x4004
    4212:	6a92      	ldr	r2, [r2, #40]	; 0x28
    4214:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    4218:	f442 62c0 	orr.w	r2, r2, #1536	; 0x600
    421c:	629a      	str	r2, [r3, #40]	; 0x28
      else if(pin == PTB18)
        PORTB->PCR[18] = (PORTB->PCR[18] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
      else
        return 0;
      break;
    421e:	e19e      	b.n	455e <LPLD_FTM_PinInit+0x92a>
        return 0;
      break;
    case FTM_PhA:
      if(pin == PTA10)
        PORTA->PCR[10] = (PORTA->PCR[10] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6); 
      else if(pin == PTB18)
    4220:	78bb      	ldrb	r3, [r7, #2]
    4222:	2b32      	cmp	r3, #50	; 0x32
    4224:	d10e      	bne.n	4244 <LPLD_FTM_PinInit+0x610>
        PORTB->PCR[18] = (PORTB->PCR[18] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
    4226:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    422a:	f2c4 0304 	movt	r3, #16388	; 0x4004
    422e:	f44f 4220 	mov.w	r2, #40960	; 0xa000
    4232:	f2c4 0204 	movt	r2, #16388	; 0x4004
    4236:	6c92      	ldr	r2, [r2, #72]	; 0x48
    4238:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    423c:	f442 62c0 	orr.w	r2, r2, #1536	; 0x600
    4240:	649a      	str	r2, [r3, #72]	; 0x48
      else
        return 0;
      break;
    4242:	e18c      	b.n	455e <LPLD_FTM_PinInit+0x92a>
      if(pin == PTA10)
        PORTA->PCR[10] = (PORTA->PCR[10] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6); 
      else if(pin == PTB18)
        PORTB->PCR[18] = (PORTB->PCR[18] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
      else
        return 0;
    4244:	f04f 0300 	mov.w	r3, #0
    4248:	e18b      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
      break;
    case FTM_PhB:
      if(pin == PTA11)
    424a:	78bb      	ldrb	r3, [r7, #2]
    424c:	2b0b      	cmp	r3, #11
    424e:	d10e      	bne.n	426e <LPLD_FTM_PinInit+0x63a>
        PORTA->PCR[11] = (PORTA->PCR[11] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6); 
    4250:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4254:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4258:	f44f 4210 	mov.w	r2, #36864	; 0x9000
    425c:	f2c4 0204 	movt	r2, #16388	; 0x4004
    4260:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    4262:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    4266:	f442 62c0 	orr.w	r2, r2, #1536	; 0x600
    426a:	62da      	str	r2, [r3, #44]	; 0x2c
      else if(pin == PTB19)
        PORTB->PCR[19] = (PORTB->PCR[19] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
      else
        return 0;
      break;
    426c:	e177      	b.n	455e <LPLD_FTM_PinInit+0x92a>
        return 0;
      break;
    case FTM_PhB:
      if(pin == PTA11)
        PORTA->PCR[11] = (PORTA->PCR[11] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6); 
      else if(pin == PTB19)
    426e:	78bb      	ldrb	r3, [r7, #2]
    4270:	2b33      	cmp	r3, #51	; 0x33
    4272:	d10f      	bne.n	4294 <LPLD_FTM_PinInit+0x660>
        PORTB->PCR[19] = (PORTB->PCR[19] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
    4274:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    4278:	f2c4 0304 	movt	r3, #16388	; 0x4004
    427c:	f44f 4220 	mov.w	r2, #40960	; 0xa000
    4280:	f2c4 0204 	movt	r2, #16388	; 0x4004
    4284:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
    4286:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    428a:	f442 62c0 	orr.w	r2, r2, #1536	; 0x600
    428e:	64da      	str	r2, [r3, #76]	; 0x4c
      else
        return 0;
      break;
    4290:	bf00      	nop
    4292:	e164      	b.n	455e <LPLD_FTM_PinInit+0x92a>
      if(pin == PTA11)
        PORTA->PCR[11] = (PORTA->PCR[11] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6); 
      else if(pin == PTB19)
        PORTB->PCR[19] = (PORTB->PCR[19] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
      else
        return 0;
    4294:	f04f 0300 	mov.w	r3, #0
    4298:	e163      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
      break;
    default:
      return 0;   
    429a:	f04f 0300 	mov.w	r3, #0
    429e:	e160      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
    }
  }
  else if (ftmx == FTM3)
    42a0:	687a      	ldr	r2, [r7, #4]
    42a2:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    42a6:	f2c4 030b 	movt	r3, #16395	; 0x400b
    42aa:	429a      	cmp	r2, r3
    42ac:	f040 8154 	bne.w	4558 <LPLD_FTM_PinInit+0x924>
  {
      switch(chn)
    42b0:	78fb      	ldrb	r3, [r7, #3]
    42b2:	2b07      	cmp	r3, #7
    42b4:	f200 814d 	bhi.w	4552 <LPLD_FTM_PinInit+0x91e>
    42b8:	a201      	add	r2, pc, #4	; (adr r2, 42c0 <LPLD_FTM_PinInit+0x68c>)
    42ba:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    42be:	bf00      	nop
    42c0:	000042e1 	andeq	r4, r0, r1, ror #5
    42c4:	0000432f 	andeq	r4, r0, pc, lsr #6
    42c8:	0000437d 	andeq	r4, r0, sp, ror r3
    42cc:	000043cb 	andeq	r4, r0, fp, asr #7
    42d0:	00004419 	andeq	r4, r0, r9, lsl r4
    42d4:	00004467 	andeq	r4, r0, r7, ror #8
    42d8:	000044b5 			; <UNDEFINED> instruction: 0x000044b5
    42dc:	00004503 	andeq	r4, r0, r3, lsl #10
      {
          case FTM_Ch0:
              if (pin == PTE5)
    42e0:	78bb      	ldrb	r3, [r7, #2]
    42e2:	2b81      	cmp	r3, #129	; 0x81
    42e4:	d10e      	bne.n	4304 <LPLD_FTM_PinInit+0x6d0>
                  PORTE->PCR[5] = (PORTE->PCR[5] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
    42e6:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    42ea:	f2c4 0304 	movt	r3, #16388	; 0x4004
    42ee:	f44f 4250 	mov.w	r2, #53248	; 0xd000
    42f2:	f2c4 0204 	movt	r2, #16388	; 0x4004
    42f6:	6952      	ldr	r2, [r2, #20]
    42f8:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    42fc:	f442 62c0 	orr.w	r2, r2, #1536	; 0x600
    4300:	615a      	str	r2, [r3, #20]
              else if (pin == PTD0)
                  PORTD->PCR[0] = (PORTD->PCR[0] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
              else
                  return 0;
              break;
    4302:	e12c      	b.n	455e <LPLD_FTM_PinInit+0x92a>
      switch(chn)
      {
          case FTM_Ch0:
              if (pin == PTE5)
                  PORTE->PCR[5] = (PORTE->PCR[5] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
              else if (pin == PTD0)
    4304:	78bb      	ldrb	r3, [r7, #2]
    4306:	2b5c      	cmp	r3, #92	; 0x5c
    4308:	d10e      	bne.n	4328 <LPLD_FTM_PinInit+0x6f4>
                  PORTD->PCR[0] = (PORTD->PCR[0] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    430a:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    430e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4312:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    4316:	f2c4 0204 	movt	r2, #16388	; 0x4004
    431a:	6812      	ldr	r2, [r2, #0]
    431c:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    4320:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    4324:	601a      	str	r2, [r3, #0]
              else
                  return 0;
              break;
    4326:	e11a      	b.n	455e <LPLD_FTM_PinInit+0x92a>
              if (pin == PTE5)
                  PORTE->PCR[5] = (PORTE->PCR[5] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
              else if (pin == PTD0)
                  PORTD->PCR[0] = (PORTD->PCR[0] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
              else
                  return 0;
    4328:	f04f 0300 	mov.w	r3, #0
    432c:	e119      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
              break;
          case FTM_Ch1:
              if (pin == PTE6)
    432e:	78bb      	ldrb	r3, [r7, #2]
    4330:	2b82      	cmp	r3, #130	; 0x82
    4332:	d10e      	bne.n	4352 <LPLD_FTM_PinInit+0x71e>
                  PORTE->PCR[6] = (PORTE->PCR[6] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
    4334:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    4338:	f2c4 0304 	movt	r3, #16388	; 0x4004
    433c:	f44f 4250 	mov.w	r2, #53248	; 0xd000
    4340:	f2c4 0204 	movt	r2, #16388	; 0x4004
    4344:	6992      	ldr	r2, [r2, #24]
    4346:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    434a:	f442 62c0 	orr.w	r2, r2, #1536	; 0x600
    434e:	619a      	str	r2, [r3, #24]
              else if (pin == PTD1)
                  PORTD->PCR[1] = (PORTD->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
              else 
                  return 0;
              break;
    4350:	e105      	b.n	455e <LPLD_FTM_PinInit+0x92a>
                  return 0;
              break;
          case FTM_Ch1:
              if (pin == PTE6)
                  PORTE->PCR[6] = (PORTE->PCR[6] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
              else if (pin == PTD1)
    4352:	78bb      	ldrb	r3, [r7, #2]
    4354:	2b5d      	cmp	r3, #93	; 0x5d
    4356:	d10e      	bne.n	4376 <LPLD_FTM_PinInit+0x742>
                  PORTD->PCR[1] = (PORTD->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    4358:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    435c:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4360:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    4364:	f2c4 0204 	movt	r2, #16388	; 0x4004
    4368:	6852      	ldr	r2, [r2, #4]
    436a:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    436e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    4372:	605a      	str	r2, [r3, #4]
              else 
                  return 0;
              break;
    4374:	e0f3      	b.n	455e <LPLD_FTM_PinInit+0x92a>
              if (pin == PTE6)
                  PORTE->PCR[6] = (PORTE->PCR[6] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
              else if (pin == PTD1)
                  PORTD->PCR[1] = (PORTD->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
              else 
                  return 0;
    4376:	f04f 0300 	mov.w	r3, #0
    437a:	e0f2      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
              break;
          case FTM_Ch2:
              if (pin == PTE7)
    437c:	78bb      	ldrb	r3, [r7, #2]
    437e:	2b83      	cmp	r3, #131	; 0x83
    4380:	d10e      	bne.n	43a0 <LPLD_FTM_PinInit+0x76c>
                  PORTE->PCR[7] = (PORTE->PCR[7] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
    4382:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    4386:	f2c4 0304 	movt	r3, #16388	; 0x4004
    438a:	f44f 4250 	mov.w	r2, #53248	; 0xd000
    438e:	f2c4 0204 	movt	r2, #16388	; 0x4004
    4392:	69d2      	ldr	r2, [r2, #28]
    4394:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    4398:	f442 62c0 	orr.w	r2, r2, #1536	; 0x600
    439c:	61da      	str	r2, [r3, #28]
              else if (pin == PTD2)
                  PORTD->PCR[2] = (PORTD->PCR[2] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
              else 
                  return 0;
              break;
    439e:	e0de      	b.n	455e <LPLD_FTM_PinInit+0x92a>
                  return 0;
              break;
          case FTM_Ch2:
              if (pin == PTE7)
                  PORTE->PCR[7] = (PORTE->PCR[7] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
              else if (pin == PTD2)
    43a0:	78bb      	ldrb	r3, [r7, #2]
    43a2:	2b5e      	cmp	r3, #94	; 0x5e
    43a4:	d10e      	bne.n	43c4 <LPLD_FTM_PinInit+0x790>
                  PORTD->PCR[2] = (PORTD->PCR[2] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    43a6:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    43aa:	f2c4 0304 	movt	r3, #16388	; 0x4004
    43ae:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    43b2:	f2c4 0204 	movt	r2, #16388	; 0x4004
    43b6:	6892      	ldr	r2, [r2, #8]
    43b8:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    43bc:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    43c0:	609a      	str	r2, [r3, #8]
              else 
                  return 0;
              break;
    43c2:	e0cc      	b.n	455e <LPLD_FTM_PinInit+0x92a>
              if (pin == PTE7)
                  PORTE->PCR[7] = (PORTE->PCR[7] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
              else if (pin == PTD2)
                  PORTD->PCR[2] = (PORTD->PCR[2] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
              else 
                  return 0;
    43c4:	f04f 0300 	mov.w	r3, #0
    43c8:	e0cb      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
              break;
          case FTM_Ch3:
              if (pin == PTE8)
    43ca:	78bb      	ldrb	r3, [r7, #2]
    43cc:	2b84      	cmp	r3, #132	; 0x84
    43ce:	d10e      	bne.n	43ee <LPLD_FTM_PinInit+0x7ba>
                  PORTE->PCR[8] = (PORTE->PCR[8] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
    43d0:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    43d4:	f2c4 0304 	movt	r3, #16388	; 0x4004
    43d8:	f44f 4250 	mov.w	r2, #53248	; 0xd000
    43dc:	f2c4 0204 	movt	r2, #16388	; 0x4004
    43e0:	6a12      	ldr	r2, [r2, #32]
    43e2:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    43e6:	f442 62c0 	orr.w	r2, r2, #1536	; 0x600
    43ea:	621a      	str	r2, [r3, #32]
              else if (pin == PTD3)
                  PORTD->PCR[3] = (PORTD->PCR[3] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
              else 
                  return 0;
              break;
    43ec:	e0b7      	b.n	455e <LPLD_FTM_PinInit+0x92a>
                  return 0;
              break;
          case FTM_Ch3:
              if (pin == PTE8)
                  PORTE->PCR[8] = (PORTE->PCR[8] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
              else if (pin == PTD3)
    43ee:	78bb      	ldrb	r3, [r7, #2]
    43f0:	2b5f      	cmp	r3, #95	; 0x5f
    43f2:	d10e      	bne.n	4412 <LPLD_FTM_PinInit+0x7de>
                  PORTD->PCR[3] = (PORTD->PCR[3] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    43f4:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    43f8:	f2c4 0304 	movt	r3, #16388	; 0x4004
    43fc:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    4400:	f2c4 0204 	movt	r2, #16388	; 0x4004
    4404:	68d2      	ldr	r2, [r2, #12]
    4406:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    440a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    440e:	60da      	str	r2, [r3, #12]
              else 
                  return 0;
              break;
    4410:	e0a5      	b.n	455e <LPLD_FTM_PinInit+0x92a>
              if (pin == PTE8)
                  PORTE->PCR[8] = (PORTE->PCR[8] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
              else if (pin == PTD3)
                  PORTD->PCR[3] = (PORTD->PCR[3] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
              else 
                  return 0;
    4412:	f04f 0300 	mov.w	r3, #0
    4416:	e0a4      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
              break;
          case FTM_Ch4:
              if (pin == PTE9)
    4418:	78bb      	ldrb	r3, [r7, #2]
    441a:	2b85      	cmp	r3, #133	; 0x85
    441c:	d10e      	bne.n	443c <LPLD_FTM_PinInit+0x808>
                  PORTE->PCR[9] = (PORTE->PCR[9] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
    441e:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    4422:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4426:	f44f 4250 	mov.w	r2, #53248	; 0xd000
    442a:	f2c4 0204 	movt	r2, #16388	; 0x4004
    442e:	6a52      	ldr	r2, [r2, #36]	; 0x24
    4430:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    4434:	f442 62c0 	orr.w	r2, r2, #1536	; 0x600
    4438:	625a      	str	r2, [r3, #36]	; 0x24
              else if (pin == PTD4)
                  PORTD->PCR[4] = (PORTD->PCR[4] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
              else
                  return 0;
              break;
    443a:	e090      	b.n	455e <LPLD_FTM_PinInit+0x92a>
                  return 0;
              break;
          case FTM_Ch4:
              if (pin == PTE9)
                  PORTE->PCR[9] = (PORTE->PCR[9] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
              else if (pin == PTD4)
    443c:	78bb      	ldrb	r3, [r7, #2]
    443e:	2b60      	cmp	r3, #96	; 0x60
    4440:	d10e      	bne.n	4460 <LPLD_FTM_PinInit+0x82c>
                  PORTD->PCR[4] = (PORTD->PCR[4] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    4442:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    4446:	f2c4 0304 	movt	r3, #16388	; 0x4004
    444a:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    444e:	f2c4 0204 	movt	r2, #16388	; 0x4004
    4452:	6912      	ldr	r2, [r2, #16]
    4454:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    4458:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    445c:	611a      	str	r2, [r3, #16]
              else
                  return 0;
              break;
    445e:	e07e      	b.n	455e <LPLD_FTM_PinInit+0x92a>
              if (pin == PTE9)
                  PORTE->PCR[9] = (PORTE->PCR[9] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
              else if (pin == PTD4)
                  PORTD->PCR[4] = (PORTD->PCR[4] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
              else
                  return 0;
    4460:	f04f 0300 	mov.w	r3, #0
    4464:	e07d      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
              break;
          case FTM_Ch5:
              if (pin == PTE10)
    4466:	78bb      	ldrb	r3, [r7, #2]
    4468:	2b86      	cmp	r3, #134	; 0x86
    446a:	d10e      	bne.n	448a <LPLD_FTM_PinInit+0x856>
                  PORTE->PCR[10] = (PORTE->PCR[10] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
    446c:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    4470:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4474:	f44f 4250 	mov.w	r2, #53248	; 0xd000
    4478:	f2c4 0204 	movt	r2, #16388	; 0x4004
    447c:	6a92      	ldr	r2, [r2, #40]	; 0x28
    447e:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    4482:	f442 62c0 	orr.w	r2, r2, #1536	; 0x600
    4486:	629a      	str	r2, [r3, #40]	; 0x28
              else if (pin == PTD5)
                  PORTD->PCR[5] = (PORTD->PCR[5] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
              else
                  return 0;
              break;
    4488:	e069      	b.n	455e <LPLD_FTM_PinInit+0x92a>
                  return 0;
              break;
          case FTM_Ch5:
              if (pin == PTE10)
                  PORTE->PCR[10] = (PORTE->PCR[10] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
              else if (pin == PTD5)
    448a:	78bb      	ldrb	r3, [r7, #2]
    448c:	2b61      	cmp	r3, #97	; 0x61
    448e:	d10e      	bne.n	44ae <LPLD_FTM_PinInit+0x87a>
                  PORTD->PCR[5] = (PORTD->PCR[5] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    4490:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    4494:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4498:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    449c:	f2c4 0204 	movt	r2, #16388	; 0x4004
    44a0:	6952      	ldr	r2, [r2, #20]
    44a2:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    44a6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    44aa:	615a      	str	r2, [r3, #20]
              else
                  return 0;
              break;
    44ac:	e057      	b.n	455e <LPLD_FTM_PinInit+0x92a>
              if (pin == PTE10)
                  PORTE->PCR[10] = (PORTE->PCR[10] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
              else if (pin == PTD5)
                  PORTD->PCR[5] = (PORTD->PCR[5] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
              else
                  return 0;
    44ae:	f04f 0300 	mov.w	r3, #0
    44b2:	e056      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
              break;
          case FTM_Ch6:
              if (pin == PTE11)
    44b4:	78bb      	ldrb	r3, [r7, #2]
    44b6:	2b87      	cmp	r3, #135	; 0x87
    44b8:	d10e      	bne.n	44d8 <LPLD_FTM_PinInit+0x8a4>
                  PORTE->PCR[11] = (PORTE->PCR[11] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
    44ba:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    44be:	f2c4 0304 	movt	r3, #16388	; 0x4004
    44c2:	f44f 4250 	mov.w	r2, #53248	; 0xd000
    44c6:	f2c4 0204 	movt	r2, #16388	; 0x4004
    44ca:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    44cc:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    44d0:	f442 62c0 	orr.w	r2, r2, #1536	; 0x600
    44d4:	62da      	str	r2, [r3, #44]	; 0x2c
              else if (pin == PTD6)
                  PORTD->PCR[6] = (PORTD->PCR[6] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
              else
                  return 0;
              break;
    44d6:	e042      	b.n	455e <LPLD_FTM_PinInit+0x92a>
                  return 0;
              break;
          case FTM_Ch6:
              if (pin == PTE11)
                  PORTE->PCR[11] = (PORTE->PCR[11] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
              else if (pin == PTD6)
    44d8:	78bb      	ldrb	r3, [r7, #2]
    44da:	2b62      	cmp	r3, #98	; 0x62
    44dc:	d10e      	bne.n	44fc <LPLD_FTM_PinInit+0x8c8>
                  PORTD->PCR[6] = (PORTD->PCR[6] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    44de:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    44e2:	f2c4 0304 	movt	r3, #16388	; 0x4004
    44e6:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    44ea:	f2c4 0204 	movt	r2, #16388	; 0x4004
    44ee:	6992      	ldr	r2, [r2, #24]
    44f0:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    44f4:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    44f8:	619a      	str	r2, [r3, #24]
              else
                  return 0;
              break;
    44fa:	e030      	b.n	455e <LPLD_FTM_PinInit+0x92a>
              if (pin == PTE11)
                  PORTE->PCR[11] = (PORTE->PCR[11] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
              else if (pin == PTD6)
                  PORTD->PCR[6] = (PORTD->PCR[6] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
              else
                  return 0;
    44fc:	f04f 0300 	mov.w	r3, #0
    4500:	e02f      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
              break;
          case FTM_Ch7:
              if (pin == PTE12)
    4502:	78bb      	ldrb	r3, [r7, #2]
    4504:	2b88      	cmp	r3, #136	; 0x88
    4506:	d10e      	bne.n	4526 <LPLD_FTM_PinInit+0x8f2>
                  PORTE->PCR[12] = (PORTE->PCR[12] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
    4508:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    450c:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4510:	f44f 4250 	mov.w	r2, #53248	; 0xd000
    4514:	f2c4 0204 	movt	r2, #16388	; 0x4004
    4518:	6b12      	ldr	r2, [r2, #48]	; 0x30
    451a:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    451e:	f442 62c0 	orr.w	r2, r2, #1536	; 0x600
    4522:	631a      	str	r2, [r3, #48]	; 0x30
              else if (pin == PTD7)
                  PORTD->PCR[7] = (PORTD->PCR[7] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
              else
                 return 0;
              break;
    4524:	e01b      	b.n	455e <LPLD_FTM_PinInit+0x92a>
                  return 0;
              break;
          case FTM_Ch7:
              if (pin == PTE12)
                  PORTE->PCR[12] = (PORTE->PCR[12] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
              else if (pin == PTD7)
    4526:	78bb      	ldrb	r3, [r7, #2]
    4528:	2b63      	cmp	r3, #99	; 0x63
    452a:	d10f      	bne.n	454c <LPLD_FTM_PinInit+0x918>
                  PORTD->PCR[7] = (PORTD->PCR[7] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    452c:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    4530:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4534:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    4538:	f2c4 0204 	movt	r2, #16388	; 0x4004
    453c:	69d2      	ldr	r2, [r2, #28]
    453e:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
    4542:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    4546:	61da      	str	r2, [r3, #28]
              else
                 return 0;
              break;
    4548:	bf00      	nop
    454a:	e008      	b.n	455e <LPLD_FTM_PinInit+0x92a>
              if (pin == PTE12)
                  PORTE->PCR[12] = (PORTE->PCR[12] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
              else if (pin == PTD7)
                  PORTD->PCR[7] = (PORTD->PCR[7] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
              else
                 return 0;
    454c:	f04f 0300 	mov.w	r3, #0
    4550:	e007      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
              break;
          default:
              return 0;
    4552:	f04f 0300 	mov.w	r3, #0
    4556:	e004      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
      }
  }
  else
  {
    return 0;
    4558:	f04f 0300 	mov.w	r3, #0
    455c:	e001      	b.n	4562 <LPLD_FTM_PinInit+0x92e>
  }
  return 1;
    455e:	f04f 0301 	mov.w	r3, #1
}
    4562:	4618      	mov	r0, r3
    4564:	f107 070c 	add.w	r7, r7, #12
    4568:	46bd      	mov	sp, r7
    456a:	bc80      	pop	{r7}
    456c:	4770      	bx	lr
    456e:	bf00      	nop

00004570 <LPLD_FTM_PinDeinit>:
/*
 * LPLD_FTM_PinInit
 * ʼͨnָŵFTMùܣڲ
 */
static uint8 LPLD_FTM_PinDeinit(FTM_MemMapPtr ftmx, FtmChnEnum_Type chn)
{
    4570:	b480      	push	{r7}
    4572:	b083      	sub	sp, #12
    4574:	af00      	add	r7, sp, #0
    4576:	6078      	str	r0, [r7, #4]
    4578:	460b      	mov	r3, r1
    457a:	70fb      	strb	r3, [r7, #3]
  //ftmxӦpinftmܣظĬϹ
  if(ftmx == FTM0)
    457c:	687a      	ldr	r2, [r7, #4]
    457e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    4582:	f2c4 0303 	movt	r3, #16387	; 0x4003
    4586:	429a      	cmp	r2, r3
    4588:	f040 813c 	bne.w	4804 <LPLD_FTM_PinDeinit+0x294>
  {
    switch(chn)
    458c:	78fb      	ldrb	r3, [r7, #3]
    458e:	2b07      	cmp	r3, #7
    4590:	f200 8135 	bhi.w	47fe <LPLD_FTM_PinDeinit+0x28e>
    4594:	a201      	add	r2, pc, #4	; (adr r2, 459c <LPLD_FTM_PinDeinit+0x2c>)
    4596:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    459a:	bf00      	nop
    459c:	000045bd 			; <UNDEFINED> instruction: 0x000045bd
    45a0:	00004605 	andeq	r4, r0, r5, lsl #12
    45a4:	0000464d 	andeq	r4, r0, sp, asr #12
    45a8:	00004695 	muleq	r0, r5, r6
    45ac:	000046dd 	ldrdeq	r4, [r0], -sp
    45b0:	00004725 	andeq	r4, r0, r5, lsr #14
    45b4:	0000476d 	andeq	r4, r0, sp, ror #14
    45b8:	000047b5 			; <UNDEFINED> instruction: 0x000047b5
    {
    case FTM_Ch0:
      if((PORTA->PCR[3]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    45bc:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    45c0:	f2c4 0304 	movt	r3, #16388	; 0x4004
    45c4:	68db      	ldr	r3, [r3, #12]
    45c6:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    45ca:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    45ce:	d106      	bne.n	45de <LPLD_FTM_PinDeinit+0x6e>
        PORTA->PCR[3] = PORT_PCR_MUX(0); 
    45d0:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    45d4:	f2c4 0304 	movt	r3, #16388	; 0x4004
    45d8:	f04f 0200 	mov.w	r2, #0
    45dc:	60da      	str	r2, [r3, #12]
      if((PORTC->PCR[1]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
    45de:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    45e2:	f2c4 0304 	movt	r3, #16388	; 0x4004
    45e6:	685b      	ldr	r3, [r3, #4]
    45e8:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    45ec:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    45f0:	f040 82c3 	bne.w	4b7a <LPLD_FTM_PinDeinit+0x60a>
        PORTC->PCR[1] = PORT_PCR_MUX(0);
    45f4:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    45f8:	f2c4 0304 	movt	r3, #16388	; 0x4004
    45fc:	f04f 0200 	mov.w	r2, #0
    4600:	605a      	str	r2, [r3, #4]
      break;
    4602:	e2ba      	b.n	4b7a <LPLD_FTM_PinDeinit+0x60a>
    case FTM_Ch1:
      if((PORTA->PCR[4]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    4604:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4608:	f2c4 0304 	movt	r3, #16388	; 0x4004
    460c:	691b      	ldr	r3, [r3, #16]
    460e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    4612:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    4616:	d106      	bne.n	4626 <LPLD_FTM_PinDeinit+0xb6>
        PORTA->PCR[4] = PORT_PCR_MUX(0); 
    4618:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    461c:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4620:	f04f 0200 	mov.w	r2, #0
    4624:	611a      	str	r2, [r3, #16]
      if((PORTC->PCR[2]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
    4626:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    462a:	f2c4 0304 	movt	r3, #16388	; 0x4004
    462e:	689b      	ldr	r3, [r3, #8]
    4630:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    4634:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    4638:	f040 82a1 	bne.w	4b7e <LPLD_FTM_PinDeinit+0x60e>
        PORTC->PCR[2] = PORT_PCR_MUX(0);
    463c:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    4640:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4644:	f04f 0200 	mov.w	r2, #0
    4648:	609a      	str	r2, [r3, #8]
      break;
    464a:	e298      	b.n	4b7e <LPLD_FTM_PinDeinit+0x60e>
    case FTM_Ch2:
      if((PORTA->PCR[5]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    464c:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4650:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4654:	695b      	ldr	r3, [r3, #20]
    4656:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    465a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    465e:	d106      	bne.n	466e <LPLD_FTM_PinDeinit+0xfe>
        PORTA->PCR[5] = PORT_PCR_MUX(0); 
    4660:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4664:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4668:	f04f 0200 	mov.w	r2, #0
    466c:	615a      	str	r2, [r3, #20]
      if((PORTC->PCR[3]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
    466e:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    4672:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4676:	68db      	ldr	r3, [r3, #12]
    4678:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    467c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    4680:	f040 827f 	bne.w	4b82 <LPLD_FTM_PinDeinit+0x612>
        PORTC->PCR[3] = PORT_PCR_MUX(0);
    4684:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    4688:	f2c4 0304 	movt	r3, #16388	; 0x4004
    468c:	f04f 0200 	mov.w	r2, #0
    4690:	60da      	str	r2, [r3, #12]
      break;
    4692:	e276      	b.n	4b82 <LPLD_FTM_PinDeinit+0x612>
    case FTM_Ch3:
      if((PORTA->PCR[6]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    4694:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4698:	f2c4 0304 	movt	r3, #16388	; 0x4004
    469c:	699b      	ldr	r3, [r3, #24]
    469e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    46a2:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    46a6:	d106      	bne.n	46b6 <LPLD_FTM_PinDeinit+0x146>
        PORTA->PCR[6] = PORT_PCR_MUX(0); 
    46a8:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    46ac:	f2c4 0304 	movt	r3, #16388	; 0x4004
    46b0:	f04f 0200 	mov.w	r2, #0
    46b4:	619a      	str	r2, [r3, #24]
      if((PORTC->PCR[4]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
    46b6:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    46ba:	f2c4 0304 	movt	r3, #16388	; 0x4004
    46be:	691b      	ldr	r3, [r3, #16]
    46c0:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    46c4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    46c8:	f040 825d 	bne.w	4b86 <LPLD_FTM_PinDeinit+0x616>
        PORTC->PCR[4] = PORT_PCR_MUX(0);
    46cc:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    46d0:	f2c4 0304 	movt	r3, #16388	; 0x4004
    46d4:	f04f 0200 	mov.w	r2, #0
    46d8:	611a      	str	r2, [r3, #16]
      break;
    46da:	e254      	b.n	4b86 <LPLD_FTM_PinDeinit+0x616>
    case FTM_Ch4:
      if((PORTA->PCR[7]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    46dc:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    46e0:	f2c4 0304 	movt	r3, #16388	; 0x4004
    46e4:	69db      	ldr	r3, [r3, #28]
    46e6:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    46ea:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    46ee:	d106      	bne.n	46fe <LPLD_FTM_PinDeinit+0x18e>
        PORTA->PCR[7] = PORT_PCR_MUX(0); 
    46f0:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    46f4:	f2c4 0304 	movt	r3, #16388	; 0x4004
    46f8:	f04f 0200 	mov.w	r2, #0
    46fc:	61da      	str	r2, [r3, #28]
      if((PORTD->PCR[4]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
    46fe:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    4702:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4706:	691b      	ldr	r3, [r3, #16]
    4708:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    470c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    4710:	f040 823b 	bne.w	4b8a <LPLD_FTM_PinDeinit+0x61a>
        PORTD->PCR[4] = PORT_PCR_MUX(0);
    4714:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    4718:	f2c4 0304 	movt	r3, #16388	; 0x4004
    471c:	f04f 0200 	mov.w	r2, #0
    4720:	611a      	str	r2, [r3, #16]
      break;
    4722:	e232      	b.n	4b8a <LPLD_FTM_PinDeinit+0x61a>
    case FTM_Ch5:
      if((PORTA->PCR[0]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    4724:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4728:	f2c4 0304 	movt	r3, #16388	; 0x4004
    472c:	681b      	ldr	r3, [r3, #0]
    472e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    4732:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    4736:	d106      	bne.n	4746 <LPLD_FTM_PinDeinit+0x1d6>
        PORTA->PCR[0] = PORT_PCR_MUX(0); 
    4738:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    473c:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4740:	f04f 0200 	mov.w	r2, #0
    4744:	601a      	str	r2, [r3, #0]
      if((PORTD->PCR[5]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
    4746:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    474a:	f2c4 0304 	movt	r3, #16388	; 0x4004
    474e:	695b      	ldr	r3, [r3, #20]
    4750:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    4754:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    4758:	f040 8219 	bne.w	4b8e <LPLD_FTM_PinDeinit+0x61e>
        PORTD->PCR[5] = PORT_PCR_MUX(0);
    475c:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    4760:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4764:	f04f 0200 	mov.w	r2, #0
    4768:	615a      	str	r2, [r3, #20]
      break;
    476a:	e210      	b.n	4b8e <LPLD_FTM_PinDeinit+0x61e>
    case FTM_Ch6:
      if((PORTA->PCR[1]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    476c:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4770:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4774:	685b      	ldr	r3, [r3, #4]
    4776:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    477a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    477e:	d106      	bne.n	478e <LPLD_FTM_PinDeinit+0x21e>
        PORTA->PCR[1] = PORT_PCR_MUX(0); 
    4780:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4784:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4788:	f04f 0200 	mov.w	r2, #0
    478c:	605a      	str	r2, [r3, #4]
      if((PORTD->PCR[6]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
    478e:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    4792:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4796:	699b      	ldr	r3, [r3, #24]
    4798:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    479c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    47a0:	f040 81f7 	bne.w	4b92 <LPLD_FTM_PinDeinit+0x622>
        PORTD->PCR[6] = PORT_PCR_MUX(0);
    47a4:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    47a8:	f2c4 0304 	movt	r3, #16388	; 0x4004
    47ac:	f04f 0200 	mov.w	r2, #0
    47b0:	619a      	str	r2, [r3, #24]
      break;
    47b2:	e1ee      	b.n	4b92 <LPLD_FTM_PinDeinit+0x622>
    case FTM_Ch7:
      if((PORTA->PCR[2]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    47b4:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    47b8:	f2c4 0304 	movt	r3, #16388	; 0x4004
    47bc:	689b      	ldr	r3, [r3, #8]
    47be:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    47c2:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    47c6:	d106      	bne.n	47d6 <LPLD_FTM_PinDeinit+0x266>
        PORTA->PCR[2] = PORT_PCR_MUX(0); 
    47c8:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    47cc:	f2c4 0304 	movt	r3, #16388	; 0x4004
    47d0:	f04f 0200 	mov.w	r2, #0
    47d4:	609a      	str	r2, [r3, #8]
      if((PORTD->PCR[7]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
    47d6:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    47da:	f2c4 0304 	movt	r3, #16388	; 0x4004
    47de:	69db      	ldr	r3, [r3, #28]
    47e0:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    47e4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    47e8:	f040 81d5 	bne.w	4b96 <LPLD_FTM_PinDeinit+0x626>
        PORTD->PCR[7] = PORT_PCR_MUX(0);      
    47ec:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    47f0:	f2c4 0304 	movt	r3, #16388	; 0x4004
    47f4:	f04f 0200 	mov.w	r2, #0
    47f8:	61da      	str	r2, [r3, #28]
      break;
    47fa:	bf00      	nop
    47fc:	e1cb      	b.n	4b96 <LPLD_FTM_PinDeinit+0x626>
    default:
      return 0;     
    47fe:	f04f 0300 	mov.w	r3, #0
    4802:	e1db      	b.n	4bbc <LPLD_FTM_PinDeinit+0x64c>
    }
  }
  else if(ftmx == FTM1)
    4804:	687a      	ldr	r2, [r7, #4]
    4806:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    480a:	f2c4 0303 	movt	r3, #16387	; 0x4003
    480e:	429a      	cmp	r2, r3
    4810:	f040 80f4 	bne.w	49fc <LPLD_FTM_PinDeinit+0x48c>
  {
    switch(chn)
    4814:	78fb      	ldrb	r3, [r7, #3]
    4816:	2b09      	cmp	r3, #9
    4818:	f200 80ed 	bhi.w	49f6 <LPLD_FTM_PinDeinit+0x486>
    481c:	a201      	add	r2, pc, #4	; (adr r2, 4824 <LPLD_FTM_PinDeinit+0x2b4>)
    481e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    4822:	bf00      	nop
    4824:	0000484d 	andeq	r4, r0, sp, asr #16
    4828:	000048b7 			; <UNDEFINED> instruction: 0x000048b7
    482c:	000049f7 	strdeq	r4, [r0], -r7
    4830:	000049f7 	strdeq	r4, [r0], -r7
    4834:	000049f7 	strdeq	r4, [r0], -r7
    4838:	000049f7 	strdeq	r4, [r0], -r7
    483c:	000049f7 	strdeq	r4, [r0], -r7
    4840:	000049f7 	strdeq	r4, [r0], -r7
    4844:	00004921 	andeq	r4, r0, r1, lsr #18
    4848:	0000498b 	andeq	r4, r0, fp, lsl #19
    {
    case FTM_Ch0:
      if((PORTA->PCR[8]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    484c:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4850:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4854:	6a1b      	ldr	r3, [r3, #32]
    4856:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    485a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    485e:	d106      	bne.n	486e <LPLD_FTM_PinDeinit+0x2fe>
        PORTA->PCR[8] = PORT_PCR_MUX(0); 
    4860:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4864:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4868:	f04f 0200 	mov.w	r2, #0
    486c:	621a      	str	r2, [r3, #32]
      if((PORTA->PCR[12]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    486e:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4872:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4876:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    4878:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    487c:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    4880:	d106      	bne.n	4890 <LPLD_FTM_PinDeinit+0x320>
        PORTA->PCR[12] = PORT_PCR_MUX(0);
    4882:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4886:	f2c4 0304 	movt	r3, #16388	; 0x4004
    488a:	f04f 0200 	mov.w	r2, #0
    488e:	631a      	str	r2, [r3, #48]	; 0x30
      if((PORTB->PCR[0]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    4890:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    4894:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4898:	681b      	ldr	r3, [r3, #0]
    489a:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    489e:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    48a2:	f040 817a 	bne.w	4b9a <LPLD_FTM_PinDeinit+0x62a>
        PORTB->PCR[0] = PORT_PCR_MUX(0);
    48a6:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    48aa:	f2c4 0304 	movt	r3, #16388	; 0x4004
    48ae:	f04f 0200 	mov.w	r2, #0
    48b2:	601a      	str	r2, [r3, #0]
      break;
    48b4:	e171      	b.n	4b9a <LPLD_FTM_PinDeinit+0x62a>
    case FTM_Ch1:
      if((PORTA->PCR[9]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    48b6:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    48ba:	f2c4 0304 	movt	r3, #16388	; 0x4004
    48be:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    48c0:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    48c4:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    48c8:	d106      	bne.n	48d8 <LPLD_FTM_PinDeinit+0x368>
        PORTA->PCR[9] = PORT_PCR_MUX(0); 
    48ca:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    48ce:	f2c4 0304 	movt	r3, #16388	; 0x4004
    48d2:	f04f 0200 	mov.w	r2, #0
    48d6:	625a      	str	r2, [r3, #36]	; 0x24
      if((PORTA->PCR[13]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    48d8:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    48dc:	f2c4 0304 	movt	r3, #16388	; 0x4004
    48e0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    48e2:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    48e6:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    48ea:	d106      	bne.n	48fa <LPLD_FTM_PinDeinit+0x38a>
        PORTA->PCR[13] = PORT_PCR_MUX(0);
    48ec:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    48f0:	f2c4 0304 	movt	r3, #16388	; 0x4004
    48f4:	f04f 0200 	mov.w	r2, #0
    48f8:	635a      	str	r2, [r3, #52]	; 0x34
      if((PORTB->PCR[1]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    48fa:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    48fe:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4902:	685b      	ldr	r3, [r3, #4]
    4904:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    4908:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    490c:	f040 8147 	bne.w	4b9e <LPLD_FTM_PinDeinit+0x62e>
        PORTB->PCR[1] = PORT_PCR_MUX(0);
    4910:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    4914:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4918:	f04f 0200 	mov.w	r2, #0
    491c:	605a      	str	r2, [r3, #4]
      break;
    491e:	e13e      	b.n	4b9e <LPLD_FTM_PinDeinit+0x62e>
    case FTM_PhA:
      if((PORTA->PCR[8]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
    4920:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4924:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4928:	6a1b      	ldr	r3, [r3, #32]
    492a:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    492e:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
    4932:	d106      	bne.n	4942 <LPLD_FTM_PinDeinit+0x3d2>
        PORTA->PCR[8] = PORT_PCR_MUX(0); 
    4934:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4938:	f2c4 0304 	movt	r3, #16388	; 0x4004
    493c:	f04f 0200 	mov.w	r2, #0
    4940:	621a      	str	r2, [r3, #32]
      if((PORTA->PCR[12]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(7))
    4942:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4946:	f2c4 0304 	movt	r3, #16388	; 0x4004
    494a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    494c:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    4950:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
    4954:	d106      	bne.n	4964 <LPLD_FTM_PinDeinit+0x3f4>
        PORTA->PCR[12] = PORT_PCR_MUX(0);
    4956:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    495a:	f2c4 0304 	movt	r3, #16388	; 0x4004
    495e:	f04f 0200 	mov.w	r2, #0
    4962:	631a      	str	r2, [r3, #48]	; 0x30
      if((PORTB->PCR[0]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
    4964:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    4968:	f2c4 0304 	movt	r3, #16388	; 0x4004
    496c:	681b      	ldr	r3, [r3, #0]
    496e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    4972:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
    4976:	f040 8114 	bne.w	4ba2 <LPLD_FTM_PinDeinit+0x632>
        PORTB->PCR[0] = PORT_PCR_MUX(0);
    497a:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    497e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4982:	f04f 0200 	mov.w	r2, #0
    4986:	601a      	str	r2, [r3, #0]
      break;
    4988:	e10b      	b.n	4ba2 <LPLD_FTM_PinDeinit+0x632>
    case FTM_PhB:
      if((PORTA->PCR[9]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
    498a:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    498e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4992:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    4994:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    4998:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
    499c:	d106      	bne.n	49ac <LPLD_FTM_PinDeinit+0x43c>
        PORTA->PCR[9] = PORT_PCR_MUX(0); 
    499e:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    49a2:	f2c4 0304 	movt	r3, #16388	; 0x4004
    49a6:	f04f 0200 	mov.w	r2, #0
    49aa:	625a      	str	r2, [r3, #36]	; 0x24
      if((PORTA->PCR[13]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(7))
    49ac:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    49b0:	f2c4 0304 	movt	r3, #16388	; 0x4004
    49b4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    49b6:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    49ba:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
    49be:	d106      	bne.n	49ce <LPLD_FTM_PinDeinit+0x45e>
        PORTA->PCR[13] = PORT_PCR_MUX(0);
    49c0:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    49c4:	f2c4 0304 	movt	r3, #16388	; 0x4004
    49c8:	f04f 0200 	mov.w	r2, #0
    49cc:	635a      	str	r2, [r3, #52]	; 0x34
      if((PORTB->PCR[1]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
    49ce:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    49d2:	f2c4 0304 	movt	r3, #16388	; 0x4004
    49d6:	685b      	ldr	r3, [r3, #4]
    49d8:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    49dc:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
    49e0:	f040 80e1 	bne.w	4ba6 <LPLD_FTM_PinDeinit+0x636>
        PORTB->PCR[1] = PORT_PCR_MUX(0);
    49e4:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    49e8:	f2c4 0304 	movt	r3, #16388	; 0x4004
    49ec:	f04f 0200 	mov.w	r2, #0
    49f0:	605a      	str	r2, [r3, #4]
      break;
    49f2:	bf00      	nop
    49f4:	e0d7      	b.n	4ba6 <LPLD_FTM_PinDeinit+0x636>
    default:
      return 0;   
    49f6:	f04f 0300 	mov.w	r3, #0
    49fa:	e0df      	b.n	4bbc <LPLD_FTM_PinDeinit+0x64c>
    }
  }
  else if(ftmx == FTM2)
    49fc:	687a      	ldr	r2, [r7, #4]
    49fe:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    4a02:	f2c4 030b 	movt	r3, #16395	; 0x400b
    4a06:	429a      	cmp	r2, r3
    4a08:	f040 80ad 	bne.w	4b66 <LPLD_FTM_PinDeinit+0x5f6>
  {
    switch(chn)
    4a0c:	78fb      	ldrb	r3, [r7, #3]
    4a0e:	2b09      	cmp	r3, #9
    4a10:	f200 80a6 	bhi.w	4b60 <LPLD_FTM_PinDeinit+0x5f0>
    4a14:	a201      	add	r2, pc, #4	; (adr r2, 4a1c <LPLD_FTM_PinDeinit+0x4ac>)
    4a16:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    4a1a:	bf00      	nop
    4a1c:	00004a45 	andeq	r4, r0, r5, asr #20
    4a20:	00004a8d 	andeq	r4, r0, sp, lsl #21
    4a24:	00004b61 	andeq	r4, r0, r1, ror #22
    4a28:	00004b61 	andeq	r4, r0, r1, ror #22
    4a2c:	00004b61 	andeq	r4, r0, r1, ror #22
    4a30:	00004b61 	andeq	r4, r0, r1, ror #22
    4a34:	00004b61 	andeq	r4, r0, r1, ror #22
    4a38:	00004b61 	andeq	r4, r0, r1, ror #22
    4a3c:	00004ad3 	ldrdeq	r4, [r0], -r3
    4a40:	00004b19 	andeq	r4, r0, r9, lsl fp
    {
    case FTM_Ch0:
      if((PORTA->PCR[10]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    4a44:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4a48:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4a4c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4a4e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    4a52:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    4a56:	d106      	bne.n	4a66 <LPLD_FTM_PinDeinit+0x4f6>
        PORTA->PCR[10] = PORT_PCR_MUX(0); 
    4a58:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4a5c:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4a60:	f04f 0200 	mov.w	r2, #0
    4a64:	629a      	str	r2, [r3, #40]	; 0x28
      if((PORTB->PCR[18]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    4a66:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    4a6a:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4a6e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    4a70:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    4a74:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    4a78:	f040 8097 	bne.w	4baa <LPLD_FTM_PinDeinit+0x63a>
        PORTB->PCR[18] = PORT_PCR_MUX(0);
    4a7c:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    4a80:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4a84:	f04f 0200 	mov.w	r2, #0
    4a88:	649a      	str	r2, [r3, #72]	; 0x48
      break;
    4a8a:	e08e      	b.n	4baa <LPLD_FTM_PinDeinit+0x63a>
    case FTM_Ch1:
      if((PORTA->PCR[11]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    4a8c:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4a90:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4a94:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    4a96:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    4a9a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    4a9e:	d106      	bne.n	4aae <LPLD_FTM_PinDeinit+0x53e>
        PORTA->PCR[11] = PORT_PCR_MUX(0); 
    4aa0:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4aa4:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4aa8:	f04f 0200 	mov.w	r2, #0
    4aac:	62da      	str	r2, [r3, #44]	; 0x2c
      if((PORTB->PCR[19]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    4aae:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    4ab2:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4ab6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    4ab8:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    4abc:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    4ac0:	d175      	bne.n	4bae <LPLD_FTM_PinDeinit+0x63e>
        PORTB->PCR[19] = PORT_PCR_MUX(0);
    4ac2:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    4ac6:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4aca:	f04f 0200 	mov.w	r2, #0
    4ace:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
    4ad0:	e06d      	b.n	4bae <LPLD_FTM_PinDeinit+0x63e>
    case FTM_PhA:
      if((PORTA->PCR[10]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
    4ad2:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4ad6:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4ada:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4adc:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    4ae0:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
    4ae4:	d106      	bne.n	4af4 <LPLD_FTM_PinDeinit+0x584>
        PORTA->PCR[10] = PORT_PCR_MUX(0); 
    4ae6:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4aea:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4aee:	f04f 0200 	mov.w	r2, #0
    4af2:	629a      	str	r2, [r3, #40]	; 0x28
      if((PORTB->PCR[18]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
    4af4:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    4af8:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4afc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    4afe:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    4b02:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
    4b06:	d154      	bne.n	4bb2 <LPLD_FTM_PinDeinit+0x642>
        PORTB->PCR[18] = PORT_PCR_MUX(0);
    4b08:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    4b0c:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4b10:	f04f 0200 	mov.w	r2, #0
    4b14:	649a      	str	r2, [r3, #72]	; 0x48
      break;
    4b16:	e04c      	b.n	4bb2 <LPLD_FTM_PinDeinit+0x642>
    case FTM_PhB:
      if((PORTA->PCR[11]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
    4b18:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4b1c:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4b20:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    4b22:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    4b26:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
    4b2a:	d106      	bne.n	4b3a <LPLD_FTM_PinDeinit+0x5ca>
        PORTA->PCR[11] = PORT_PCR_MUX(0); 
    4b2c:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4b30:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4b34:	f04f 0200 	mov.w	r2, #0
    4b38:	62da      	str	r2, [r3, #44]	; 0x2c
      if((PORTB->PCR[19]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
    4b3a:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    4b3e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4b42:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    4b44:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    4b48:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
    4b4c:	d133      	bne.n	4bb6 <LPLD_FTM_PinDeinit+0x646>
        PORTB->PCR[19] = PORT_PCR_MUX(0);
    4b4e:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    4b52:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4b56:	f04f 0200 	mov.w	r2, #0
    4b5a:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
    4b5c:	bf00      	nop
    4b5e:	e02a      	b.n	4bb6 <LPLD_FTM_PinDeinit+0x646>
    default:
      return 0;   
    4b60:	f04f 0300 	mov.w	r3, #0
    4b64:	e02a      	b.n	4bbc <LPLD_FTM_PinDeinit+0x64c>
    }
  }
  else if (ftmx == FTM3)
    4b66:	687a      	ldr	r2, [r7, #4]
    4b68:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4b6c:	f2c4 030b 	movt	r3, #16395	; 0x400b
    4b70:	429a      	cmp	r2, r3
    4b72:	d121      	bne.n	4bb8 <LPLD_FTM_PinDeinit+0x648>
      switch (chn)
      {
        case FTM_Ch0:
            if 
      }*/
    return 0;
    4b74:	f04f 0300 	mov.w	r3, #0
    4b78:	e020      	b.n	4bbc <LPLD_FTM_PinDeinit+0x64c>
    case FTM_Ch0:
      if((PORTA->PCR[3]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTA->PCR[3] = PORT_PCR_MUX(0); 
      if((PORTC->PCR[1]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
        PORTC->PCR[1] = PORT_PCR_MUX(0);
      break;
    4b7a:	bf00      	nop
    4b7c:	e01c      	b.n	4bb8 <LPLD_FTM_PinDeinit+0x648>
    case FTM_Ch1:
      if((PORTA->PCR[4]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTA->PCR[4] = PORT_PCR_MUX(0); 
      if((PORTC->PCR[2]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
        PORTC->PCR[2] = PORT_PCR_MUX(0);
      break;
    4b7e:	bf00      	nop
    4b80:	e01a      	b.n	4bb8 <LPLD_FTM_PinDeinit+0x648>
    case FTM_Ch2:
      if((PORTA->PCR[5]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTA->PCR[5] = PORT_PCR_MUX(0); 
      if((PORTC->PCR[3]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
        PORTC->PCR[3] = PORT_PCR_MUX(0);
      break;
    4b82:	bf00      	nop
    4b84:	e018      	b.n	4bb8 <LPLD_FTM_PinDeinit+0x648>
    case FTM_Ch3:
      if((PORTA->PCR[6]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTA->PCR[6] = PORT_PCR_MUX(0); 
      if((PORTC->PCR[4]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
        PORTC->PCR[4] = PORT_PCR_MUX(0);
      break;
    4b86:	bf00      	nop
    4b88:	e016      	b.n	4bb8 <LPLD_FTM_PinDeinit+0x648>
    case FTM_Ch4:
      if((PORTA->PCR[7]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTA->PCR[7] = PORT_PCR_MUX(0); 
      if((PORTD->PCR[4]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
        PORTD->PCR[4] = PORT_PCR_MUX(0);
      break;
    4b8a:	bf00      	nop
    4b8c:	e014      	b.n	4bb8 <LPLD_FTM_PinDeinit+0x648>
    case FTM_Ch5:
      if((PORTA->PCR[0]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTA->PCR[0] = PORT_PCR_MUX(0); 
      if((PORTD->PCR[5]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
        PORTD->PCR[5] = PORT_PCR_MUX(0);
      break;
    4b8e:	bf00      	nop
    4b90:	e012      	b.n	4bb8 <LPLD_FTM_PinDeinit+0x648>
    case FTM_Ch6:
      if((PORTA->PCR[1]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTA->PCR[1] = PORT_PCR_MUX(0); 
      if((PORTD->PCR[6]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
        PORTD->PCR[6] = PORT_PCR_MUX(0);
      break;
    4b92:	bf00      	nop
    4b94:	e010      	b.n	4bb8 <LPLD_FTM_PinDeinit+0x648>
    case FTM_Ch7:
      if((PORTA->PCR[2]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTA->PCR[2] = PORT_PCR_MUX(0); 
      if((PORTD->PCR[7]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
        PORTD->PCR[7] = PORT_PCR_MUX(0);      
      break;
    4b96:	bf00      	nop
    4b98:	e00e      	b.n	4bb8 <LPLD_FTM_PinDeinit+0x648>
        PORTA->PCR[8] = PORT_PCR_MUX(0); 
      if((PORTA->PCR[12]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTA->PCR[12] = PORT_PCR_MUX(0);
      if((PORTB->PCR[0]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTB->PCR[0] = PORT_PCR_MUX(0);
      break;
    4b9a:	bf00      	nop
    4b9c:	e00c      	b.n	4bb8 <LPLD_FTM_PinDeinit+0x648>
        PORTA->PCR[9] = PORT_PCR_MUX(0); 
      if((PORTA->PCR[13]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTA->PCR[13] = PORT_PCR_MUX(0);
      if((PORTB->PCR[1]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTB->PCR[1] = PORT_PCR_MUX(0);
      break;
    4b9e:	bf00      	nop
    4ba0:	e00a      	b.n	4bb8 <LPLD_FTM_PinDeinit+0x648>
        PORTA->PCR[8] = PORT_PCR_MUX(0); 
      if((PORTA->PCR[12]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(7))
        PORTA->PCR[12] = PORT_PCR_MUX(0);
      if((PORTB->PCR[0]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
        PORTB->PCR[0] = PORT_PCR_MUX(0);
      break;
    4ba2:	bf00      	nop
    4ba4:	e008      	b.n	4bb8 <LPLD_FTM_PinDeinit+0x648>
        PORTA->PCR[9] = PORT_PCR_MUX(0); 
      if((PORTA->PCR[13]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(7))
        PORTA->PCR[13] = PORT_PCR_MUX(0);
      if((PORTB->PCR[1]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
        PORTB->PCR[1] = PORT_PCR_MUX(0);
      break;
    4ba6:	bf00      	nop
    4ba8:	e006      	b.n	4bb8 <LPLD_FTM_PinDeinit+0x648>
    case FTM_Ch0:
      if((PORTA->PCR[10]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTA->PCR[10] = PORT_PCR_MUX(0); 
      if((PORTB->PCR[18]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTB->PCR[18] = PORT_PCR_MUX(0);
      break;
    4baa:	bf00      	nop
    4bac:	e004      	b.n	4bb8 <LPLD_FTM_PinDeinit+0x648>
    case FTM_Ch1:
      if((PORTA->PCR[11]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTA->PCR[11] = PORT_PCR_MUX(0); 
      if((PORTB->PCR[19]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTB->PCR[19] = PORT_PCR_MUX(0);
      break;
    4bae:	bf00      	nop
    4bb0:	e002      	b.n	4bb8 <LPLD_FTM_PinDeinit+0x648>
    case FTM_PhA:
      if((PORTA->PCR[10]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
        PORTA->PCR[10] = PORT_PCR_MUX(0); 
      if((PORTB->PCR[18]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
        PORTB->PCR[18] = PORT_PCR_MUX(0);
      break;
    4bb2:	bf00      	nop
    4bb4:	e000      	b.n	4bb8 <LPLD_FTM_PinDeinit+0x648>
    case FTM_PhB:
      if((PORTA->PCR[11]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
        PORTA->PCR[11] = PORT_PCR_MUX(0); 
      if((PORTB->PCR[19]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
        PORTB->PCR[19] = PORT_PCR_MUX(0);
      break;
    4bb6:	bf00      	nop
        case FTM_Ch0:
            if 
      }*/
    return 0;
  }
  return 1;
    4bb8:	f04f 0301 	mov.w	r3, #1
}
    4bbc:	4618      	mov	r0, r3
    4bbe:	f107 070c 	add.w	r7, r7, #12
    4bc2:	46bd      	mov	sp, r7
    4bc4:	bc80      	pop	{r7}
    4bc6:	4770      	bx	lr

00004bc8 <LPLD_FTM_QD_Init>:
/*
 * LPLD_FTM_QD_Init
 * FTMģģʽʼڲ
 */
static uint8 LPLD_FTM_QD_Init(FTM_InitTypeDef ftm_init_structure)
{
    4bc8:	b084      	sub	sp, #16
    4bca:	b480      	push	{r7}
    4bcc:	b083      	sub	sp, #12
    4bce:	af00      	add	r7, sp, #0
    4bd0:	f107 0c10 	add.w	ip, r7, #16
    4bd4:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  uint8 mode = ftm_init_structure.FTM_QdMode;
    4bd8:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
    4bdc:	71fb      	strb	r3, [r7, #7]
  FTM_MemMapPtr ftmx = ftm_init_structure.FTM_Ftmx;
    4bde:	693b      	ldr	r3, [r7, #16]
    4be0:	603b      	str	r3, [r7, #0]
 
  ftmx->MODE |= FTM_MODE_FTMEN_MASK;    //FTM2EN=1   
    4be2:	683b      	ldr	r3, [r7, #0]
    4be4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    4be6:	f043 0201 	orr.w	r2, r3, #1
    4bea:	683b      	ldr	r3, [r7, #0]
    4bec:	655a      	str	r2, [r3, #84]	; 0x54
  
  ftmx->CNTIN = 0;//FTM0ʼֵΪ0  
    4bee:	683b      	ldr	r3, [r7, #0]
    4bf0:	f04f 0200 	mov.w	r2, #0
    4bf4:	64da      	str	r2, [r3, #76]	; 0x4c
  ftmx->CNT=0;  
    4bf6:	683b      	ldr	r3, [r7, #0]
    4bf8:	f04f 0200 	mov.w	r2, #0
    4bfc:	605a      	str	r2, [r3, #4]
  ftmx->MOD = 0xFFFF;//ֵ  
    4bfe:	683b      	ldr	r3, [r7, #0]
    4c00:	f64f 72ff 	movw	r2, #65535	; 0xffff
    4c04:	609a      	str	r2, [r3, #8]
  
  ftmx->QDCTRL |= mode;     //ģʽѡ
    4c06:	683b      	ldr	r3, [r7, #0]
    4c08:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
    4c0c:	79fb      	ldrb	r3, [r7, #7]
    4c0e:	431a      	orrs	r2, r3
    4c10:	683b      	ldr	r3, [r7, #0]
    4c12:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  ftmx->QDCTRL |= FTM_QDCTRL_QUADEN_MASK;       //ʹģʽ 
    4c16:	683b      	ldr	r3, [r7, #0]
    4c18:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    4c1c:	f043 0201 	orr.w	r2, r3, #1
    4c20:	683b      	ldr	r3, [r7, #0]
    4c22:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  return 1;
    4c26:	f04f 0301 	mov.w	r3, #1
}
    4c2a:	4618      	mov	r0, r3
    4c2c:	f107 070c 	add.w	r7, r7, #12
    4c30:	46bd      	mov	sp, r7
    4c32:	bc80      	pop	{r7}
    4c34:	b004      	add	sp, #16
    4c36:	4770      	bx	lr

00004c38 <LPLD_FTM_DEC_Init>:

static uint8 LPLD_FTM_DEC_Init(FTM_InitTypeDef ftm_init_structure)
{
    4c38:	b084      	sub	sp, #16
    4c3a:	b480      	push	{r7}
    4c3c:	af00      	add	r7, sp, #0
    4c3e:	f107 0c04 	add.w	ip, r7, #4
    4c42:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  
  return 0;
    4c46:	f04f 0300 	mov.w	r3, #0
}
    4c4a:	4618      	mov	r0, r3
    4c4c:	46bd      	mov	sp, r7
    4c4e:	bc80      	pop	{r7}
    4c50:	b004      	add	sp, #16
    4c52:	4770      	bx	lr

00004c54 <FTM0_IRQHandler>:
 * FTM0--FTM1жϴ
 * ļstartup_K60.sеж
 * û޸ģԶӦͨжϺ
 */
void FTM0_IRQHandler(void)
{
    4c54:	b580      	push	{r7, lr}
    4c56:	af00      	add	r7, sp, #0
  OS_ENTER_CRITICAL(); //֪ϵͳʱѾжϷӺ
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif
  
  FTM_ISR[0]();
    4c58:	f241 6344 	movw	r3, #5700	; 0x1644
    4c5c:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    4c60:	681b      	ldr	r3, [r3, #0]
    4c62:	4798      	blx	r3
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    4c64:	bd80      	pop	{r7, pc}
    4c66:	bf00      	nop

00004c68 <FTM1_IRQHandler>:

void FTM1_IRQHandler(void)
{
    4c68:	b580      	push	{r7, lr}
    4c6a:	af00      	add	r7, sp, #0
  OS_ENTER_CRITICAL(); //֪ϵͳʱѾжϷӺ
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif
  
  FTM_ISR[1]();
    4c6c:	f241 6344 	movw	r3, #5700	; 0x1644
    4c70:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    4c74:	685b      	ldr	r3, [r3, #4]
    4c76:	4798      	blx	r3
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    4c78:	bd80      	pop	{r7, pc}
    4c7a:	bf00      	nop

00004c7c <FTM2_IRQHandler>:

void FTM2_IRQHandler(void)
{
    4c7c:	b580      	push	{r7, lr}
    4c7e:	af00      	add	r7, sp, #0
  OS_ENTER_CRITICAL(); //֪ϵͳʱѾжϷӺ
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif
  
  FTM_ISR[2]();
    4c80:	f241 6344 	movw	r3, #5700	; 0x1644
    4c84:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    4c88:	689b      	ldr	r3, [r3, #8]
    4c8a:	4798      	blx	r3
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    4c8c:	bd80      	pop	{r7, pc}
    4c8e:	bf00      	nop

00004c90 <LPLD_GPIO_Init>:
 * \param gpio_init_structure
* \return 0--配置失败
 *         1--配置成功
 */
int8 LPLD_GPIO_Init(GPIO_InitTypeDef gpio_init_structure)
{
    4c90:	b084      	sub	sp, #16
    4c92:	b480      	push	{r7}
    4c94:	b087      	sub	sp, #28
    4c96:	af00      	add	r7, sp, #0
    4c98:	f107 0c20 	add.w	ip, r7, #32
    4c9c:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
    uint8 i;

    PORT_MemMapPtr portx;
    uint32 pcr = PORT_PCR_MUX(1)
                |gpio_init_structure.GPIO_PinControl;
    4ca0:	6abb      	ldr	r3, [r7, #40]	; 0x28
int8 LPLD_GPIO_Init(GPIO_InitTypeDef gpio_init_structure)
{
    uint8 i;

    PORT_MemMapPtr portx;
    uint32 pcr = PORT_PCR_MUX(1)
    4ca2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    4ca6:	60fb      	str	r3, [r7, #12]
                |gpio_init_structure.GPIO_PinControl;
    GPIO_MemMapPtr ptx = gpio_init_structure.GPIO_PTx;
    4ca8:	6a3b      	ldr	r3, [r7, #32]
    4caa:	60bb      	str	r3, [r7, #8]
    uint32 pins = gpio_init_structure.GPIO_Pins;
    4cac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    4cae:	607b      	str	r3, [r7, #4]
    uint8 dir = gpio_init_structure.GPIO_Dir;
    4cb0:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    4cb4:	70fb      	strb	r3, [r7, #3]
    uint8 output = gpio_init_structure.GPIO_Output;
    4cb6:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    4cba:	70bb      	strb	r3, [r7, #2]
    //GPIO_ISR_CALLBACK isr_func = gpio_init_structure.GPIO_Isr;
    

    if  (ptx == PTA)
    4cbc:	68ba      	ldr	r2, [r7, #8]
    4cbe:	f44f 4370 	mov.w	r3, #61440	; 0xf000
    4cc2:	f2c4 030f 	movt	r3, #16399	; 0x400f
    4cc6:	429a      	cmp	r2, r3
    4cc8:	d105      	bne.n	4cd6 <LPLD_GPIO_Init+0x46>
        portx = PORTA_BASE_PTR;
    4cca:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4cce:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4cd2:	613b      	str	r3, [r7, #16]
    4cd4:	e043      	b.n	4d5e <LPLD_GPIO_Init+0xce>
    else if (ptx == PTB)
    4cd6:	68ba      	ldr	r2, [r7, #8]
    4cd8:	f24f 0340 	movw	r3, #61504	; 0xf040
    4cdc:	f2c4 030f 	movt	r3, #16399	; 0x400f
    4ce0:	429a      	cmp	r2, r3
    4ce2:	d105      	bne.n	4cf0 <LPLD_GPIO_Init+0x60>
        portx = PORTB_BASE_PTR;
    4ce4:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    4ce8:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4cec:	613b      	str	r3, [r7, #16]
    4cee:	e036      	b.n	4d5e <LPLD_GPIO_Init+0xce>
    else if (ptx == PTC)
    4cf0:	68ba      	ldr	r2, [r7, #8]
    4cf2:	f24f 0380 	movw	r3, #61568	; 0xf080
    4cf6:	f2c4 030f 	movt	r3, #16399	; 0x400f
    4cfa:	429a      	cmp	r2, r3
    4cfc:	d105      	bne.n	4d0a <LPLD_GPIO_Init+0x7a>
        portx = PORTC_BASE_PTR;
    4cfe:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    4d02:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4d06:	613b      	str	r3, [r7, #16]
    4d08:	e029      	b.n	4d5e <LPLD_GPIO_Init+0xce>
    else if (ptx == PTD)
    4d0a:	68ba      	ldr	r2, [r7, #8]
    4d0c:	f24f 03c0 	movw	r3, #61632	; 0xf0c0
    4d10:	f2c4 030f 	movt	r3, #16399	; 0x400f
    4d14:	429a      	cmp	r2, r3
    4d16:	d105      	bne.n	4d24 <LPLD_GPIO_Init+0x94>
        portx = PORTD_BASE_PTR;
    4d18:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    4d1c:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4d20:	613b      	str	r3, [r7, #16]
    4d22:	e01c      	b.n	4d5e <LPLD_GPIO_Init+0xce>
    else if (ptx == PTE)
    4d24:	68ba      	ldr	r2, [r7, #8]
    4d26:	f44f 4371 	mov.w	r3, #61696	; 0xf100
    4d2a:	f2c4 030f 	movt	r3, #16399	; 0x400f
    4d2e:	429a      	cmp	r2, r3
    4d30:	d105      	bne.n	4d3e <LPLD_GPIO_Init+0xae>
        portx = PORTE_BASE_PTR;
    4d32:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    4d36:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4d3a:	613b      	str	r3, [r7, #16]
    4d3c:	e00f      	b.n	4d5e <LPLD_GPIO_Init+0xce>
    else if (ptx == PTF)
    4d3e:	68ba      	ldr	r2, [r7, #8]
    4d40:	f24f 1340 	movw	r3, #61760	; 0xf140
    4d44:	f2c4 030f 	movt	r3, #16399	; 0x400f
    4d48:	429a      	cmp	r2, r3
    4d4a:	d105      	bne.n	4d58 <LPLD_GPIO_Init+0xc8>
        portx = PORTF_BASE_PTR;
    4d4c:	f44f 4360 	mov.w	r3, #57344	; 0xe000
    4d50:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4d54:	613b      	str	r3, [r7, #16]
    4d56:	e002      	b.n	4d5e <LPLD_GPIO_Init+0xce>
    else
        return 0;
    4d58:	f04f 0300 	mov.w	r3, #0
    4d5c:	e03b      	b.n	4dd6 <LPLD_GPIO_Init+0x146>
    
    if (dir == DIR_OUTPUT)
    4d5e:	78fb      	ldrb	r3, [r7, #3]
    4d60:	2b01      	cmp	r3, #1
    4d62:	d116      	bne.n	4d92 <LPLD_GPIO_Init+0x102>
    {
        ptx->PDDR |= pins;
    4d64:	68bb      	ldr	r3, [r7, #8]
    4d66:	695a      	ldr	r2, [r3, #20]
    4d68:	687b      	ldr	r3, [r7, #4]
    4d6a:	431a      	orrs	r2, r3
    4d6c:	68bb      	ldr	r3, [r7, #8]
    4d6e:	615a      	str	r2, [r3, #20]
        if (output == OUTPUT_H)
    4d70:	78bb      	ldrb	r3, [r7, #2]
    4d72:	2b01      	cmp	r3, #1
    4d74:	d106      	bne.n	4d84 <LPLD_GPIO_Init+0xf4>
            ptx->PSOR |= pins;
    4d76:	68bb      	ldr	r3, [r7, #8]
    4d78:	685a      	ldr	r2, [r3, #4]
    4d7a:	687b      	ldr	r3, [r7, #4]
    4d7c:	431a      	orrs	r2, r3
    4d7e:	68bb      	ldr	r3, [r7, #8]
    4d80:	605a      	str	r2, [r3, #4]
    4d82:	e00e      	b.n	4da2 <LPLD_GPIO_Init+0x112>
        else
            ptx->PCOR |= pins;
    4d84:	68bb      	ldr	r3, [r7, #8]
    4d86:	689a      	ldr	r2, [r3, #8]
    4d88:	687b      	ldr	r3, [r7, #4]
    4d8a:	431a      	orrs	r2, r3
    4d8c:	68bb      	ldr	r3, [r7, #8]
    4d8e:	609a      	str	r2, [r3, #8]
    4d90:	e007      	b.n	4da2 <LPLD_GPIO_Init+0x112>
    }
    else
    {
        ptx->PDDR &= ~(pins);
    4d92:	68bb      	ldr	r3, [r7, #8]
    4d94:	695a      	ldr	r2, [r3, #20]
    4d96:	687b      	ldr	r3, [r7, #4]
    4d98:	ea6f 0303 	mvn.w	r3, r3
    4d9c:	401a      	ands	r2, r3
    4d9e:	68bb      	ldr	r3, [r7, #8]
    4da0:	615a      	str	r2, [r3, #20]
    }
    //配置所选引脚的控制寄存器
    for (i =0; i < 32; i++)
    4da2:	f04f 0300 	mov.w	r3, #0
    4da6:	75fb      	strb	r3, [r7, #23]
    4da8:	e010      	b.n	4dcc <LPLD_GPIO_Init+0x13c>
    {
        if (pins&(1ul<<i))
    4daa:	7dfb      	ldrb	r3, [r7, #23]
    4dac:	687a      	ldr	r2, [r7, #4]
    4dae:	fa22 f303 	lsr.w	r3, r2, r3
    4db2:	f003 0301 	and.w	r3, r3, #1
    4db6:	2b00      	cmp	r3, #0
    4db8:	d004      	beq.n	4dc4 <LPLD_GPIO_Init+0x134>
            portx->PCR[i] = pcr;
    4dba:	7dfa      	ldrb	r2, [r7, #23]
    4dbc:	693b      	ldr	r3, [r7, #16]
    4dbe:	68f9      	ldr	r1, [r7, #12]
    4dc0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    else
    {
        ptx->PDDR &= ~(pins);
    }
    //配置所选引脚的控制寄存器
    for (i =0; i < 32; i++)
    4dc4:	7dfb      	ldrb	r3, [r7, #23]
    4dc6:	f103 0301 	add.w	r3, r3, #1
    4dca:	75fb      	strb	r3, [r7, #23]
    4dcc:	7dfb      	ldrb	r3, [r7, #23]
    4dce:	2b1f      	cmp	r3, #31
    4dd0:	d9eb      	bls.n	4daa <LPLD_GPIO_Init+0x11a>
    {
        if (pins&(1ul<<i))
            portx->PCR[i] = pcr;
    }

    return 1;
    4dd2:	f04f 0301 	mov.w	r3, #1
    4dd6:	b25b      	sxtb	r3, r3

}
    4dd8:	4618      	mov	r0, r3
    4dda:	f107 071c 	add.w	r7, r7, #28
    4dde:	46bd      	mov	sp, r7
    4de0:	bc80      	pop	{r7}
    4de2:	b004      	add	sp, #16
    4de4:	4770      	bx	lr
    4de6:	bf00      	nop

00004de8 <LPLD_GPIO_EnableIrq>:
 *    0--配置错误
 *    1--配置成功
 *
 */
uint8 LPLD_GPIO_EnableIrq(GPIO_InitTypeDef gpio_init_structure)
{
    4de8:	b084      	sub	sp, #16
    4dea:	b580      	push	{r7, lr}
    4dec:	b082      	sub	sp, #8
    4dee:	af00      	add	r7, sp, #0
    4df0:	f107 0c10 	add.w	ip, r7, #16
    4df4:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
    GPIO_MemMapPtr ptx = gpio_init_structure.GPIO_PTx;
    4df8:	693b      	ldr	r3, [r7, #16]
    4dfa:	607b      	str	r3, [r7, #4]
    GPIO_ISR_CALLBACK isr_func = gpio_init_structure.GPIO_Isr;
    4dfc:	6a3b      	ldr	r3, [r7, #32]
    4dfe:	603b      	str	r3, [r7, #0]
    
    if (isr_func == NULL)
    4e00:	683b      	ldr	r3, [r7, #0]
    4e02:	2b00      	cmp	r3, #0
    4e04:	d102      	bne.n	4e0c <LPLD_GPIO_EnableIrq+0x24>
        return 0;
    4e06:	f04f 0300 	mov.w	r3, #0
    4e0a:	e05e      	b.n	4eca <LPLD_GPIO_EnableIrq+0xe2>
    if (ptx == PTA)
    4e0c:	687a      	ldr	r2, [r7, #4]
    4e0e:	f44f 4370 	mov.w	r3, #61440	; 0xf000
    4e12:	f2c4 030f 	movt	r3, #16399	; 0x400f
    4e16:	429a      	cmp	r2, r3
    4e18:	d10a      	bne.n	4e30 <LPLD_GPIO_EnableIrq+0x48>
    {
        GPIO_ISR[0] = isr_func;
    4e1a:	f241 6350 	movw	r3, #5712	; 0x1650
    4e1e:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    4e22:	683a      	ldr	r2, [r7, #0]
    4e24:	601a      	str	r2, [r3, #0]
        enable_irq(87);
    4e26:	f04f 0057 	mov.w	r0, #87	; 0x57
    4e2a:	f7fb fe71 	bl	b10 <enable_irq>
    4e2e:	e04a      	b.n	4ec6 <LPLD_GPIO_EnableIrq+0xde>
    }
    else if (ptx == PTB)
    4e30:	687a      	ldr	r2, [r7, #4]
    4e32:	f24f 0340 	movw	r3, #61504	; 0xf040
    4e36:	f2c4 030f 	movt	r3, #16399	; 0x400f
    4e3a:	429a      	cmp	r2, r3
    4e3c:	d10a      	bne.n	4e54 <LPLD_GPIO_EnableIrq+0x6c>
    {
        enable_irq(88);
    4e3e:	f04f 0058 	mov.w	r0, #88	; 0x58
    4e42:	f7fb fe65 	bl	b10 <enable_irq>
        GPIO_ISR[1] = isr_func;
    4e46:	f241 6350 	movw	r3, #5712	; 0x1650
    4e4a:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    4e4e:	683a      	ldr	r2, [r7, #0]
    4e50:	605a      	str	r2, [r3, #4]
    4e52:	e038      	b.n	4ec6 <LPLD_GPIO_EnableIrq+0xde>
    }
    else if (ptx == PTC)
    4e54:	687a      	ldr	r2, [r7, #4]
    4e56:	f24f 0380 	movw	r3, #61568	; 0xf080
    4e5a:	f2c4 030f 	movt	r3, #16399	; 0x400f
    4e5e:	429a      	cmp	r2, r3
    4e60:	d10a      	bne.n	4e78 <LPLD_GPIO_EnableIrq+0x90>
    {
        enable_irq(89);
    4e62:	f04f 0059 	mov.w	r0, #89	; 0x59
    4e66:	f7fb fe53 	bl	b10 <enable_irq>
        GPIO_ISR[2] = isr_func;
    4e6a:	f241 6350 	movw	r3, #5712	; 0x1650
    4e6e:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    4e72:	683a      	ldr	r2, [r7, #0]
    4e74:	609a      	str	r2, [r3, #8]
    4e76:	e026      	b.n	4ec6 <LPLD_GPIO_EnableIrq+0xde>
    }
    else if (ptx == PTD)
    4e78:	687a      	ldr	r2, [r7, #4]
    4e7a:	f24f 03c0 	movw	r3, #61632	; 0xf0c0
    4e7e:	f2c4 030f 	movt	r3, #16399	; 0x400f
    4e82:	429a      	cmp	r2, r3
    4e84:	d10a      	bne.n	4e9c <LPLD_GPIO_EnableIrq+0xb4>
    {
        enable_irq(90);
    4e86:	f04f 005a 	mov.w	r0, #90	; 0x5a
    4e8a:	f7fb fe41 	bl	b10 <enable_irq>
        GPIO_ISR[3] = isr_func;
    4e8e:	f241 6350 	movw	r3, #5712	; 0x1650
    4e92:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    4e96:	683a      	ldr	r2, [r7, #0]
    4e98:	60da      	str	r2, [r3, #12]
    4e9a:	e014      	b.n	4ec6 <LPLD_GPIO_EnableIrq+0xde>
    }
    else if (ptx == PTE)
    4e9c:	687a      	ldr	r2, [r7, #4]
    4e9e:	f44f 4371 	mov.w	r3, #61696	; 0xf100
    4ea2:	f2c4 030f 	movt	r3, #16399	; 0x400f
    4ea6:	429a      	cmp	r2, r3
    4ea8:	d10a      	bne.n	4ec0 <LPLD_GPIO_EnableIrq+0xd8>
    {
        enable_irq(91);
    4eaa:	f04f 005b 	mov.w	r0, #91	; 0x5b
    4eae:	f7fb fe2f 	bl	b10 <enable_irq>
        GPIO_ISR[4] = isr_func;
    4eb2:	f241 6350 	movw	r3, #5712	; 0x1650
    4eb6:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    4eba:	683a      	ldr	r2, [r7, #0]
    4ebc:	611a      	str	r2, [r3, #16]
    4ebe:	e002      	b.n	4ec6 <LPLD_GPIO_EnableIrq+0xde>
    }
    else
        return 0;
    4ec0:	f04f 0300 	mov.w	r3, #0
    4ec4:	e001      	b.n	4eca <LPLD_GPIO_EnableIrq+0xe2>
    return 1;
    4ec6:	f04f 0301 	mov.w	r3, #1
}
    4eca:	4618      	mov	r0, r3
    4ecc:	f107 0708 	add.w	r7, r7, #8
    4ed0:	46bd      	mov	sp, r7
    4ed2:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    4ed6:	b004      	add	sp, #16
    4ed8:	4770      	bx	lr
    4eda:	bf00      	nop

00004edc <LPLD_GPIO_DisableIrq>:
 *    0--配置错误
 *    1--配置成功
 *
 */
uint8 LPLD_GPIO_DisableIrq(GPIO_InitTypeDef gpio_init_structure)
{
    4edc:	b084      	sub	sp, #16
    4ede:	b480      	push	{r7}
    4ee0:	b085      	sub	sp, #20
    4ee2:	af00      	add	r7, sp, #0
    4ee4:	f107 0c18 	add.w	ip, r7, #24
    4ee8:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
    uint8 i;
    GPIO_MemMapPtr ptx = gpio_init_structure.GPIO_PTx;
    4eec:	69bb      	ldr	r3, [r7, #24]
    4eee:	607b      	str	r3, [r7, #4]
    PORT_MemMapPtr portx;
    uint32 pins = gpio_init_structure.GPIO_Pins;
    4ef0:	69fb      	ldr	r3, [r7, #28]
    4ef2:	603b      	str	r3, [r7, #0]
 
    if  (ptx == PTA)
    4ef4:	687a      	ldr	r2, [r7, #4]
    4ef6:	f44f 4370 	mov.w	r3, #61440	; 0xf000
    4efa:	f2c4 030f 	movt	r3, #16399	; 0x400f
    4efe:	429a      	cmp	r2, r3
    4f00:	d105      	bne.n	4f0e <LPLD_GPIO_DisableIrq+0x32>
        portx = PORTA_BASE_PTR;
    4f02:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    4f06:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4f0a:	60bb      	str	r3, [r7, #8]
    4f0c:	e043      	b.n	4f96 <LPLD_GPIO_DisableIrq+0xba>
    else if (ptx == PTB)
    4f0e:	687a      	ldr	r2, [r7, #4]
    4f10:	f24f 0340 	movw	r3, #61504	; 0xf040
    4f14:	f2c4 030f 	movt	r3, #16399	; 0x400f
    4f18:	429a      	cmp	r2, r3
    4f1a:	d105      	bne.n	4f28 <LPLD_GPIO_DisableIrq+0x4c>
        portx = PORTB_BASE_PTR;
    4f1c:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    4f20:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4f24:	60bb      	str	r3, [r7, #8]
    4f26:	e036      	b.n	4f96 <LPLD_GPIO_DisableIrq+0xba>
    else if (ptx == PTC)
    4f28:	687a      	ldr	r2, [r7, #4]
    4f2a:	f24f 0380 	movw	r3, #61568	; 0xf080
    4f2e:	f2c4 030f 	movt	r3, #16399	; 0x400f
    4f32:	429a      	cmp	r2, r3
    4f34:	d105      	bne.n	4f42 <LPLD_GPIO_DisableIrq+0x66>
        portx = PORTC_BASE_PTR;
    4f36:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    4f3a:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4f3e:	60bb      	str	r3, [r7, #8]
    4f40:	e029      	b.n	4f96 <LPLD_GPIO_DisableIrq+0xba>
    else if (ptx == PTD)
    4f42:	687a      	ldr	r2, [r7, #4]
    4f44:	f24f 03c0 	movw	r3, #61632	; 0xf0c0
    4f48:	f2c4 030f 	movt	r3, #16399	; 0x400f
    4f4c:	429a      	cmp	r2, r3
    4f4e:	d105      	bne.n	4f5c <LPLD_GPIO_DisableIrq+0x80>
        portx = PORTD_BASE_PTR;
    4f50:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    4f54:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4f58:	60bb      	str	r3, [r7, #8]
    4f5a:	e01c      	b.n	4f96 <LPLD_GPIO_DisableIrq+0xba>
    else if (ptx == PTE)
    4f5c:	687a      	ldr	r2, [r7, #4]
    4f5e:	f44f 4371 	mov.w	r3, #61696	; 0xf100
    4f62:	f2c4 030f 	movt	r3, #16399	; 0x400f
    4f66:	429a      	cmp	r2, r3
    4f68:	d105      	bne.n	4f76 <LPLD_GPIO_DisableIrq+0x9a>
        portx = PORTE_BASE_PTR;
    4f6a:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    4f6e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4f72:	60bb      	str	r3, [r7, #8]
    4f74:	e00f      	b.n	4f96 <LPLD_GPIO_DisableIrq+0xba>
    else if (ptx == PTF)
    4f76:	687a      	ldr	r2, [r7, #4]
    4f78:	f24f 1340 	movw	r3, #61760	; 0xf140
    4f7c:	f2c4 030f 	movt	r3, #16399	; 0x400f
    4f80:	429a      	cmp	r2, r3
    4f82:	d105      	bne.n	4f90 <LPLD_GPIO_DisableIrq+0xb4>
        portx = PORTF_BASE_PTR;
    4f84:	f44f 4360 	mov.w	r3, #57344	; 0xe000
    4f88:	f2c4 0304 	movt	r3, #16388	; 0x4004
    4f8c:	60bb      	str	r3, [r7, #8]
    4f8e:	e002      	b.n	4f96 <LPLD_GPIO_DisableIrq+0xba>
    else
        return 0;
    4f90:	f04f 0300 	mov.w	r3, #0
    4f94:	e01e      	b.n	4fd4 <LPLD_GPIO_DisableIrq+0xf8>
    //配置所选引脚的控制寄存器
    for (i =0; i < 32; i++)
    4f96:	f04f 0300 	mov.w	r3, #0
    4f9a:	73fb      	strb	r3, [r7, #15]
    4f9c:	e015      	b.n	4fca <LPLD_GPIO_DisableIrq+0xee>
    {
        if (pins&(1ul<<i))
    4f9e:	7bfb      	ldrb	r3, [r7, #15]
    4fa0:	683a      	ldr	r2, [r7, #0]
    4fa2:	fa22 f303 	lsr.w	r3, r2, r3
    4fa6:	f003 0301 	and.w	r3, r3, #1
    4faa:	2b00      	cmp	r3, #0
    4fac:	d009      	beq.n	4fc2 <LPLD_GPIO_DisableIrq+0xe6>
            portx->PCR[i] &= ~(PORT_PCR_IRQC_MASK);
    4fae:	7bfa      	ldrb	r2, [r7, #15]
    4fb0:	7bf9      	ldrb	r1, [r7, #15]
    4fb2:	68bb      	ldr	r3, [r7, #8]
    4fb4:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    4fb8:	f423 2170 	bic.w	r1, r3, #983040	; 0xf0000
    4fbc:	68bb      	ldr	r3, [r7, #8]
    4fbe:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    else if (ptx == PTF)
        portx = PORTF_BASE_PTR;
    else
        return 0;
    //配置所选引脚的控制寄存器
    for (i =0; i < 32; i++)
    4fc2:	7bfb      	ldrb	r3, [r7, #15]
    4fc4:	f103 0301 	add.w	r3, r3, #1
    4fc8:	73fb      	strb	r3, [r7, #15]
    4fca:	7bfb      	ldrb	r3, [r7, #15]
    4fcc:	2b1f      	cmp	r3, #31
    4fce:	d9e6      	bls.n	4f9e <LPLD_GPIO_DisableIrq+0xc2>
    {
        if (pins&(1ul<<i))
            portx->PCR[i] &= ~(PORT_PCR_IRQC_MASK);
    }
    return 1;
    4fd0:	f04f 0301 	mov.w	r3, #1
}
    4fd4:	4618      	mov	r0, r3
    4fd6:	f107 0714 	add.w	r7, r7, #20
    4fda:	46bd      	mov	sp, r7
    4fdc:	bc80      	pop	{r7}
    4fde:	b004      	add	sp, #16
    4fe0:	4770      	bx	lr
    4fe2:	bf00      	nop

00004fe4 <LPLD_GPIO_Output>:
 * /param ptx   --
 *        data32 --
 * /return 无
 */
void LPLD_GPIO_Output(GPIO_MemMapPtr ptx, uint32 data32)
{
    4fe4:	b480      	push	{r7}
    4fe6:	b083      	sub	sp, #12
    4fe8:	af00      	add	r7, sp, #0
    4fea:	6078      	str	r0, [r7, #4]
    4fec:	6039      	str	r1, [r7, #0]
    ptx->PDOR |= data32;
    4fee:	687b      	ldr	r3, [r7, #4]
    4ff0:	681a      	ldr	r2, [r3, #0]
    4ff2:	683b      	ldr	r3, [r7, #0]
    4ff4:	431a      	orrs	r2, r3
    4ff6:	687b      	ldr	r3, [r7, #4]
    4ff8:	601a      	str	r2, [r3, #0]
}
    4ffa:	f107 070c 	add.w	r7, r7, #12
    4ffe:	46bd      	mov	sp, r7
    5000:	bc80      	pop	{r7}
    5002:	4770      	bx	lr

00005004 <LPLD_GPIO_Output_b>:

void LPLD_GPIO_Output_b (GPIO_MemMapPtr ptx, uint8 lsb_num, uint8 data1)
{
    5004:	b480      	push	{r7}
    5006:	b083      	sub	sp, #12
    5008:	af00      	add	r7, sp, #0
    500a:	6078      	str	r0, [r7, #4]
    500c:	4613      	mov	r3, r2
    500e:	460a      	mov	r2, r1
    5010:	70fa      	strb	r2, [r7, #3]
    5012:	70bb      	strb	r3, [r7, #2]
    ptx->PDOR = (ptx -> PDOR & ~(0x01L << lsb_num)) | ((uint32) data1 << lsb_num);
    5014:	687b      	ldr	r3, [r7, #4]
    5016:	681a      	ldr	r2, [r3, #0]
    5018:	78fb      	ldrb	r3, [r7, #3]
    501a:	f04f 0101 	mov.w	r1, #1
    501e:	fa01 f303 	lsl.w	r3, r1, r3
    5022:	ea6f 0303 	mvn.w	r3, r3
    5026:	401a      	ands	r2, r3
    5028:	78b9      	ldrb	r1, [r7, #2]
    502a:	78fb      	ldrb	r3, [r7, #3]
    502c:	fa01 f303 	lsl.w	r3, r1, r3
    5030:	431a      	orrs	r2, r3
    5032:	687b      	ldr	r3, [r7, #4]
    5034:	601a      	str	r2, [r3, #0]
}
    5036:	f107 070c 	add.w	r7, r7, #12
    503a:	46bd      	mov	sp, r7
    503c:	bc80      	pop	{r7}
    503e:	4770      	bx	lr

00005040 <LPLD_GPIO_Toggle>:
 * /param ptx --
 *        data32 --
 * /return 无
 */
void LPLD_GPIO_Toggle(GPIO_MemMapPtr ptx, uint32 data32)
{
    5040:	b480      	push	{r7}
    5042:	b083      	sub	sp, #12
    5044:	af00      	add	r7, sp, #0
    5046:	6078      	str	r0, [r7, #4]
    5048:	6039      	str	r1, [r7, #0]
    ptx->PTOR |= data32;
    504a:	687b      	ldr	r3, [r7, #4]
    504c:	68da      	ldr	r2, [r3, #12]
    504e:	683b      	ldr	r3, [r7, #0]
    5050:	431a      	orrs	r2, r3
    5052:	687b      	ldr	r3, [r7, #4]
    5054:	60da      	str	r2, [r3, #12]
}
    5056:	f107 070c 	add.w	r7, r7, #12
    505a:	46bd      	mov	sp, r7
    505c:	bc80      	pop	{r7}
    505e:	4770      	bx	lr

00005060 <LPLD_GPIO_Toggle_b>:

void LPLD_GPIO_Toggle_b(GPIO_MemMapPtr ptx, uint8 lsb_num)
{
    5060:	b480      	push	{r7}
    5062:	b083      	sub	sp, #12
    5064:	af00      	add	r7, sp, #0
    5066:	6078      	str	r0, [r7, #4]
    5068:	460b      	mov	r3, r1
    506a:	70fb      	strb	r3, [r7, #3]
    ptx -> PTOR |= 0x01L << lsb_num;
    506c:	687b      	ldr	r3, [r7, #4]
    506e:	68da      	ldr	r2, [r3, #12]
    5070:	78fb      	ldrb	r3, [r7, #3]
    5072:	f04f 0101 	mov.w	r1, #1
    5076:	fa01 f303 	lsl.w	r3, r1, r3
    507a:	431a      	orrs	r2, r3
    507c:	687b      	ldr	r3, [r7, #4]
    507e:	60da      	str	r2, [r3, #12]
}
    5080:	f107 070c 	add.w	r7, r7, #12
    5084:	46bd      	mov	sp, r7
    5086:	bc80      	pop	{r7}
    5088:	4770      	bx	lr
    508a:	bf00      	nop

0000508c <LPLD_GPIO_Input>:
 * /brief 读取GPIO端口0~31的数据
 * /param ptx --
 * /return 取得的32为数据
 */
uint32 LPLD_GPIO_Input(GPIO_MemMapPtr ptx)
{
    508c:	b480      	push	{r7}
    508e:	b085      	sub	sp, #20
    5090:	af00      	add	r7, sp, #0
    5092:	6078      	str	r0, [r7, #4]
    uint32 tmp;
    tmp = ptx->PDIR;
    5094:	687b      	ldr	r3, [r7, #4]
    5096:	691b      	ldr	r3, [r3, #16]
    5098:	60fb      	str	r3, [r7, #12]
    return (tmp);
    509a:	68fb      	ldr	r3, [r7, #12]
}
    509c:	4618      	mov	r0, r3
    509e:	f107 0714 	add.w	r7, r7, #20
    50a2:	46bd      	mov	sp, r7
    50a4:	bc80      	pop	{r7}
    50a6:	4770      	bx	lr

000050a8 <LPLD_GPIO_Input_b>:

uint8 LPLD_GPIO_Input_b (GPIO_MemMapPtr ptx, uint8 lsb_num)
{
    50a8:	b480      	push	{r7}
    50aa:	b083      	sub	sp, #12
    50ac:	af00      	add	r7, sp, #0
    50ae:	6078      	str	r0, [r7, #4]
    50b0:	460b      	mov	r3, r1
    50b2:	70fb      	strb	r3, [r7, #3]
    return (uint8) ((ptx -> PDIR >> lsb_num) & 0x01L);
    50b4:	687b      	ldr	r3, [r7, #4]
    50b6:	691a      	ldr	r2, [r3, #16]
    50b8:	78fb      	ldrb	r3, [r7, #3]
    50ba:	fa22 f303 	lsr.w	r3, r2, r3
    50be:	b2db      	uxtb	r3, r3
    50c0:	f003 0301 	and.w	r3, r3, #1
    50c4:	b2db      	uxtb	r3, r3
}
    50c6:	4618      	mov	r0, r3
    50c8:	f107 070c 	add.w	r7, r7, #12
    50cc:	46bd      	mov	sp, r7
    50ce:	bc80      	pop	{r7}
    50d0:	4770      	bx	lr
    50d2:	bf00      	nop

000050d4 <PORTA_IRQHandler>:

/*
 * PORTA-PORTE中断处理函数
 */
void PORTA_IRQHandler (void)
{
    50d4:	b580      	push	{r7, lr}
    50d6:	af00      	add	r7, sp, #0
    GPIO_ISR[0]();
    50d8:	f241 6350 	movw	r3, #5712	; 0x1650
    50dc:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    50e0:	681b      	ldr	r3, [r3, #0]
    50e2:	4798      	blx	r3
    PORTA_ISFR = 0xFFFFFFFF;
    50e4:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    50e8:	f2c4 0304 	movt	r3, #16388	; 0x4004
    50ec:	f04f 32ff 	mov.w	r2, #4294967295
    50f0:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
}
    50f4:	bd80      	pop	{r7, pc}
    50f6:	bf00      	nop

000050f8 <PORTB_IRQHandler>:
void PORTB_IRQHandler (void)
{
    50f8:	b580      	push	{r7, lr}
    50fa:	af00      	add	r7, sp, #0
    GPIO_ISR[1]();
    50fc:	f241 6350 	movw	r3, #5712	; 0x1650
    5100:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    5104:	685b      	ldr	r3, [r3, #4]
    5106:	4798      	blx	r3
    PORTB_ISFR = 0xFFFFFFFF;
    5108:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    510c:	f2c4 0304 	movt	r3, #16388	; 0x4004
    5110:	f04f 32ff 	mov.w	r2, #4294967295
    5114:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
}
    5118:	bd80      	pop	{r7, pc}
    511a:	bf00      	nop

0000511c <PORTC_IRQHandler>:
void PORTC_IRQHandler (void)
{
    511c:	b580      	push	{r7, lr}
    511e:	af00      	add	r7, sp, #0
    GPIO_ISR[2]();
    5120:	f241 6350 	movw	r3, #5712	; 0x1650
    5124:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    5128:	689b      	ldr	r3, [r3, #8]
    512a:	4798      	blx	r3
    PORTC_ISFR = 0xFFFFFFFF;
    512c:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    5130:	f2c4 0304 	movt	r3, #16388	; 0x4004
    5134:	f04f 32ff 	mov.w	r2, #4294967295
    5138:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
}
    513c:	bd80      	pop	{r7, pc}
    513e:	bf00      	nop

00005140 <PORTD_IRQHandler>:

void PORTD_IRQHandler (void)
{
    5140:	b580      	push	{r7, lr}
    5142:	af00      	add	r7, sp, #0
    GPIO_ISR[3]();
    5144:	f241 6350 	movw	r3, #5712	; 0x1650
    5148:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    514c:	68db      	ldr	r3, [r3, #12]
    514e:	4798      	blx	r3
    PORTD_ISFR = 0xFFFFFFFF;
    5150:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    5154:	f2c4 0304 	movt	r3, #16388	; 0x4004
    5158:	f04f 32ff 	mov.w	r2, #4294967295
    515c:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
}
    5160:	bd80      	pop	{r7, pc}
    5162:	bf00      	nop

00005164 <PORTE_IRQHandler>:

void PORTE_IRQHandler (void)
{
    5164:	b580      	push	{r7, lr}
    5166:	af00      	add	r7, sp, #0
    GPIO_ISR[4]();
    5168:	f241 6350 	movw	r3, #5712	; 0x1650
    516c:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    5170:	691b      	ldr	r3, [r3, #16]
    5172:	4798      	blx	r3
    PORTE_ISFR = 0xFFFFFFFF;
    5174:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    5178:	f2c4 0304 	movt	r3, #16388	; 0x4004
    517c:	f04f 32ff 	mov.w	r2, #4294967295
    5180:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
}
    5184:	bd80      	pop	{r7, pc}
    5186:	bf00      	nop

00005188 <LPLD_LPTMR_Init>:
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_LPTMR_Init(LPTMR_InitTypeDef lptmr_init_structure)
{
    5188:	b480      	push	{r7}
    518a:	b089      	sub	sp, #36	; 0x24
    518c:	af00      	add	r7, sp, #0
    518e:	f107 0304 	add.w	r3, r7, #4
    5192:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  uint8  mode = lptmr_init_structure.LPTMR_Mode; 
    5196:	793b      	ldrb	r3, [r7, #4]
    5198:	77fb      	strb	r3, [r7, #31]
  uint16 period_ms = lptmr_init_structure.LPTMR_PeriodMs;
    519a:	88fb      	ldrh	r3, [r7, #6]
    519c:	83bb      	strh	r3, [r7, #28]
  uint8  pluseacc_input = lptmr_init_structure.LPTMR_PluseAccInput;
    519e:	7a3b      	ldrb	r3, [r7, #8]
    51a0:	76fb      	strb	r3, [r7, #27]
  LPTMR_ISR_CALLBACK isr_func = lptmr_init_structure.LPTMR_Isr;
    51a2:	68fb      	ldr	r3, [r7, #12]
    51a4:	617b      	str	r3, [r7, #20]

//  ASSERT(mode <= LPTMR_MODE_PLACC );
 // ASSERT(pluseacc_input <= LPTMR_ALT2 );
    if (mode > LPTMR_MODE_PLACC)
    51a6:	7ffb      	ldrb	r3, [r7, #31]
    51a8:	2b01      	cmp	r3, #1
    51aa:	d902      	bls.n	51b2 <LPLD_LPTMR_Init+0x2a>
        return 0;
    51ac:	f04f 0300 	mov.w	r3, #0
    51b0:	e0b4      	b.n	531c <LPLD_LPTMR_Init+0x194>
    if (pluseacc_input > LPTMR_ALT2)
    51b2:	7efb      	ldrb	r3, [r7, #27]
    51b4:	2b02      	cmp	r3, #2
    51b6:	d902      	bls.n	51be <LPLD_LPTMR_Init+0x36>
        return 0;
    51b8:	f04f 0300 	mov.w	r3, #0
    51bc:	e0ae      	b.n	531c <LPLD_LPTMR_Init+0x194>
  //ʹOSCERCLK
  OSC0_CR |= OSC_CR_ERCLKEN_MASK;
    51be:	f44f 43a0 	mov.w	r3, #20480	; 0x5000
    51c2:	f2c4 0306 	movt	r3, #16390	; 0x4006
    51c6:	f44f 42a0 	mov.w	r2, #20480	; 0x5000
    51ca:	f2c4 0206 	movt	r2, #16390	; 0x4006
    51ce:	7812      	ldrb	r2, [r2, #0]
    51d0:	b2d2      	uxtb	r2, r2
    51d2:	f062 027f 	orn	r2, r2, #127	; 0x7f
    51d6:	b2d2      	uxtb	r2, r2
    51d8:	701a      	strb	r2, [r3, #0]
  //ʼLPTMRʱ
  SIM_SCGC5|=SIM_SCGC5_LPTIMER_MASK;  
    51da:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    51de:	f2c4 0304 	movt	r3, #16388	; 0x4004
    51e2:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    51e6:	f2c4 0204 	movt	r2, #16388	; 0x4004
    51ea:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    51ee:	f102 0218 	add.w	r2, r2, #24
    51f2:	6812      	ldr	r2, [r2, #0]
    51f4:	f042 0201 	orr.w	r2, r2, #1
    51f8:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    51fc:	f103 0318 	add.w	r3, r3, #24
    5200:	601a      	str	r2, [r3, #0]
   
  //ռĴ
  LPTMR0_CSR = 0x00;                   
    5202:	f04f 0300 	mov.w	r3, #0
    5206:	f2c4 0304 	movt	r3, #16388	; 0x4004
    520a:	f04f 0200 	mov.w	r2, #0
    520e:	601a      	str	r2, [r3, #0]
  LPTMR0_PSR = 0x00;
    5210:	f04f 0300 	mov.w	r3, #0
    5214:	f2c4 0304 	movt	r3, #16388	; 0x4004
    5218:	f04f 0200 	mov.w	r2, #0
    521c:	605a      	str	r2, [r3, #4]
  LPTMR0_CMR = 0x00;
    521e:	f04f 0300 	mov.w	r3, #0
    5222:	f2c4 0304 	movt	r3, #16388	; 0x4004
    5226:	f04f 0200 	mov.w	r2, #0
    522a:	609a      	str	r2, [r3, #8]
   
  if(mode == LPTMR_MODE_TIMER)          // óɵ͹Ķʱ
    522c:	7ffb      	ldrb	r3, [r7, #31]
    522e:	2b00      	cmp	r3, #0
    5230:	d10d      	bne.n	524e <LPLD_LPTMR_Init+0xc6>
    // LPO 1Khz
    //ñȽϵֵ
    //ʹڲʱ ƵϵPrescaleΪ 2^(X+1)
    //ʱһ=ʱԴ(Clk_Src)/ ԤƵֵ(Prescale)
    //ʱĶʱֵ=õıȽֵ(compare_value)/ʱһ
    LPTMR0_CMR = LPTMR_CMR_COMPARE(period_ms);                 //ñȽֵ
    5232:	f04f 0300 	mov.w	r3, #0
    5236:	f2c4 0304 	movt	r3, #16388	; 0x4004
    523a:	8bba      	ldrh	r2, [r7, #28]
    523c:	609a      	str	r2, [r3, #8]
    //LPTMR0_PSR = LPTMR_PSR_PCS(0x1)|LPTMR_PSR_PBYP_MASK;       //LPOʱ·ʹ
    LPTMR0_PSR = (0 | LPTMR_PSR_PCS(3)
    523e:	f04f 0300 	mov.w	r3, #0
    5242:	f2c4 0304 	movt	r3, #16388	; 0x4004
    5246:	f04f 0223 	mov.w	r2, #35	; 0x23
    524a:	605a      	str	r2, [r3, #4]
    524c:	e040      	b.n	52d0 <LPLD_LPTMR_Init+0x148>
                    | LPTMR_PSR_PRESCALE(4)
                 );
        
  }
  else if(mode == LPTMR_MODE_PLACC)             //ó岶ģʽ
    524e:	7ffb      	ldrb	r3, [r7, #31]
    5250:	2b01      	cmp	r3, #1
    5252:	d13d      	bne.n	52d0 <LPLD_LPTMR_Init+0x148>
  {
    
    if(pluseacc_input == LPTMR_ALT1)            //PTA19
    5254:	7efb      	ldrb	r3, [r7, #27]
    5256:	2b01      	cmp	r3, #1
    5258:	d107      	bne.n	526a <LPLD_LPTMR_Init+0xe2>
    {
      PORTA->PCR[19] = PORT_PCR_MUX(0x6);       //PTA19Ϊۼ
    525a:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    525e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    5262:	f44f 62c0 	mov.w	r2, #1536	; 0x600
    5266:	64da      	str	r2, [r3, #76]	; 0x4c
    5268:	e009      	b.n	527e <LPLD_LPTMR_Init+0xf6>
    }
    else if(pluseacc_input == LPTMR_ALT2)       //PTC5
    526a:	7efb      	ldrb	r3, [r7, #27]
    526c:	2b02      	cmp	r3, #2
    526e:	d106      	bne.n	527e <LPLD_LPTMR_Init+0xf6>
    {
      PORTC->PCR[5] = PORT_PCR_MUX(0x4);        //PTC5Ϊۼ  
    5270:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    5274:	f2c4 0304 	movt	r3, #16388	; 0x4004
    5278:	f44f 6280 	mov.w	r2, #1024	; 0x400
    527c:	615a      	str	r2, [r3, #20]
    }

    //õڲʱ޹
    //ⲿźΪʱ
     LPTMR0_PSR = (0 | LPTMR_PSR_PCS(3)
    527e:	f04f 0300 	mov.w	r3, #0
    5282:	f2c4 0304 	movt	r3, #16388	; 0x4004
    5286:	f04f 0223 	mov.w	r2, #35	; 0x23
    528a:	605a      	str	r2, [r3, #4]
                    | LPTMR_PSR_PRESCALE(4)
                 );
  //LPTMR0_PSR = LPTMR_PSR_PCS(0x1)|LPTMR_PSR_PBYP_MASK; 
    LPTMR0_CSR = LPTMR_CSR_TPS(pluseacc_input);
    528c:	f04f 0300 	mov.w	r3, #0
    5290:	f2c4 0304 	movt	r3, #16388	; 0x4004
    5294:	7efa      	ldrb	r2, [r7, #27]
    5296:	ea4f 1202 	mov.w	r2, r2, lsl #4
    529a:	f002 0230 	and.w	r2, r2, #48	; 0x30
    529e:	601a      	str	r2, [r3, #0]
    LPTMR0_CSR |= LPTMR_CSR_TMS_MASK; //ģʽ
    52a0:	f04f 0300 	mov.w	r3, #0
    52a4:	f2c4 0304 	movt	r3, #16388	; 0x4004
    52a8:	f04f 0200 	mov.w	r2, #0
    52ac:	f2c4 0204 	movt	r2, #16388	; 0x4004
    52b0:	6812      	ldr	r2, [r2, #0]
    52b2:	f042 0202 	orr.w	r2, r2, #2
    52b6:	601a      	str	r2, [r3, #0]
    LPTMR0_CSR |= LPTMR_CSR_TFC_MASK; //ɼģʽ
    52b8:	f04f 0300 	mov.w	r3, #0
    52bc:	f2c4 0304 	movt	r3, #16388	; 0x4004
    52c0:	f04f 0200 	mov.w	r2, #0
    52c4:	f2c4 0204 	movt	r2, #16388	; 0x4004
    52c8:	6812      	ldr	r2, [r2, #0]
    52ca:	f042 0204 	orr.w	r2, r2, #4
    52ce:	601a      	str	r2, [r3, #0]
  }
  
  if(lptmr_init_structure.LPTMR_IntEnable == TRUE && isr_func != NULL)
    52d0:	7a7b      	ldrb	r3, [r7, #9]
    52d2:	2b01      	cmp	r3, #1
    52d4:	d114      	bne.n	5300 <LPLD_LPTMR_Init+0x178>
    52d6:	697b      	ldr	r3, [r7, #20]
    52d8:	2b00      	cmp	r3, #0
    52da:	d011      	beq.n	5300 <LPLD_LPTMR_Init+0x178>
  {
    LPTMR_ISR[0] = isr_func;
    52dc:	f241 6364 	movw	r3, #5732	; 0x1664
    52e0:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    52e4:	697a      	ldr	r2, [r7, #20]
    52e6:	601a      	str	r2, [r3, #0]
    LPTMR0_CSR |= LPTMR_CSR_TIE_MASK;
    52e8:	f04f 0300 	mov.w	r3, #0
    52ec:	f2c4 0304 	movt	r3, #16388	; 0x4004
    52f0:	f04f 0200 	mov.w	r2, #0
    52f4:	f2c4 0204 	movt	r2, #16388	; 0x4004
    52f8:	6812      	ldr	r2, [r2, #0]
    52fa:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    52fe:	601a      	str	r2, [r3, #0]
  }

  LPTMR0_CSR |= LPTMR_CSR_TEN_MASK; //LPTMR
    5300:	f04f 0300 	mov.w	r3, #0
    5304:	f2c4 0304 	movt	r3, #16388	; 0x4004
    5308:	f04f 0200 	mov.w	r2, #0
    530c:	f2c4 0204 	movt	r2, #16388	; 0x4004
    5310:	6812      	ldr	r2, [r2, #0]
    5312:	f042 0201 	orr.w	r2, r2, #1
    5316:	601a      	str	r2, [r3, #0]
  return 1;
    5318:	f04f 0301 	mov.w	r3, #1
}
    531c:	4618      	mov	r0, r3
    531e:	f107 0724 	add.w	r7, r7, #36	; 0x24
    5322:	46bd      	mov	sp, r7
    5324:	bc80      	pop	{r7}
    5326:	4770      	bx	lr

00005328 <LPLD_LPTMR_Deinit>:
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_LPTMR_Deinit(void)
{
    5328:	b580      	push	{r7, lr}
    532a:	af00      	add	r7, sp, #0
  //CSRĴ
  LPTMR0_CSR=0x00;  
    532c:	f04f 0300 	mov.w	r3, #0
    5330:	f2c4 0304 	movt	r3, #16388	; 0x4004
    5334:	f04f 0200 	mov.w	r2, #0
    5338:	601a      	str	r2, [r3, #0]
  //PSRĴ
  LPTMR0_PSR=0x00;
    533a:	f04f 0300 	mov.w	r3, #0
    533e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    5342:	f04f 0200 	mov.w	r2, #0
    5346:	605a      	str	r2, [r3, #4]
  //CMRĴ
  LPTMR0_CMR=0x00;
    5348:	f04f 0300 	mov.w	r3, #0
    534c:	f2c4 0304 	movt	r3, #16388	; 0x4004
    5350:	f04f 0200 	mov.w	r2, #0
    5354:	609a      	str	r2, [r3, #8]
  //ֹLPTimerж
  disable_irq(INT_LPTimer - 16);
    5356:	f04f 0055 	mov.w	r0, #85	; 0x55
    535a:	f7fb fc9d 	bl	c98 <disable_irq>
  
   //رLPTMRʱ
  SIM_SCGC5 &= ~(SIM_SCGC5_LPTIMER_MASK);  
    535e:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    5362:	f2c4 0304 	movt	r3, #16388	; 0x4004
    5366:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    536a:	f2c4 0204 	movt	r2, #16388	; 0x4004
    536e:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    5372:	f102 0218 	add.w	r2, r2, #24
    5376:	6812      	ldr	r2, [r2, #0]
    5378:	f022 0201 	bic.w	r2, r2, #1
    537c:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    5380:	f103 0318 	add.w	r3, r3, #24
    5384:	601a      	str	r2, [r3, #0]
  
  return 1;
    5386:	f04f 0301 	mov.w	r3, #1
}
    538a:	4618      	mov	r0, r3
    538c:	bd80      	pop	{r7, pc}
    538e:	bf00      	nop

00005390 <LPLD_LPTMR_ResetCounter>:
 *      
 *  :
 *      
 */
void LPLD_LPTMR_ResetCounter(void)
{
    5390:	b480      	push	{r7}
    5392:	af00      	add	r7, sp, #0
  LPTMR0_CSR&=(~LPTMR_CSR_TEN_MASK);       //Reset LPTMR0 Counter
    5394:	f04f 0300 	mov.w	r3, #0
    5398:	f2c4 0304 	movt	r3, #16388	; 0x4004
    539c:	f04f 0200 	mov.w	r2, #0
    53a0:	f2c4 0204 	movt	r2, #16388	; 0x4004
    53a4:	6812      	ldr	r2, [r2, #0]
    53a6:	f022 0201 	bic.w	r2, r2, #1
    53aa:	601a      	str	r2, [r3, #0]
}
    53ac:	46bd      	mov	sp, r7
    53ae:	bc80      	pop	{r7}
    53b0:	4770      	bx	lr
    53b2:	bf00      	nop

000053b4 <LPLD_LPTMR_EnableIrq>:
 *    0--ô
 *    1--óɹ
 *
 */
uint8 LPLD_LPTMR_EnableIrq(void)
{
    53b4:	b580      	push	{r7, lr}
    53b6:	af00      	add	r7, sp, #0
  enable_irq(INT_LPTimer - 16);
    53b8:	f04f 0055 	mov.w	r0, #85	; 0x55
    53bc:	f7fb fba8 	bl	b10 <enable_irq>
  return 1;
    53c0:	f04f 0301 	mov.w	r3, #1
}
    53c4:	4618      	mov	r0, r3
    53c6:	bd80      	pop	{r7, pc}

000053c8 <LPLD_LPTMR_DisableIrq>:
 *    0--ô
 *    1--óɹ
 *
 */
uint8 LPLD_LPTMR_DisableIrq(void)
{
    53c8:	b580      	push	{r7, lr}
    53ca:	af00      	add	r7, sp, #0
  disable_irq(INT_LPTimer - 16); 
    53cc:	f04f 0055 	mov.w	r0, #85	; 0x55
    53d0:	f7fb fc62 	bl	c98 <disable_irq>
  return 1;
    53d4:	f04f 0301 	mov.w	r3, #1
}
    53d8:	4618      	mov	r0, r3
    53da:	bd80      	pop	{r7, pc}

000053dc <LPLD_LPTMR_GetPulseAcc>:
 *      
 *  :
 *      ۼֵ
 */
uint16 LPLD_LPTMR_GetPulseAcc(void)
{
    53dc:	b480      	push	{r7}
    53de:	af00      	add	r7, sp, #0
    LPTMR0_CNR = 0;
    53e0:	f04f 0300 	mov.w	r3, #0
    53e4:	f2c4 0304 	movt	r3, #16388	; 0x4004
    53e8:	f04f 0200 	mov.w	r2, #0
    53ec:	60da      	str	r2, [r3, #12]
   return (uint16)LPTMR0_CNR;
    53ee:	f04f 0300 	mov.w	r3, #0
    53f2:	f2c4 0304 	movt	r3, #16388	; 0x4004
    53f6:	68db      	ldr	r3, [r3, #12]
    53f8:	b29b      	uxth	r3, r3
}
    53fa:	4618      	mov	r0, r3
    53fc:	46bd      	mov	sp, r7
    53fe:	bc80      	pop	{r7}
    5400:	4770      	bx	lr
    5402:	bf00      	nop

00005404 <LPLD_LPTMR_DelayMs>:
 *
 *  :
 *      
 */
void LPLD_LPTMR_DelayMs(uint16 period_ms)
{
    5404:	b480      	push	{r7}
    5406:	b083      	sub	sp, #12
    5408:	af00      	add	r7, sp, #0
    540a:	4603      	mov	r3, r0
    540c:	80fb      	strh	r3, [r7, #6]
  if(!period_ms)
    540e:	88fb      	ldrh	r3, [r7, #6]
    5410:	2b00      	cmp	r3, #0
    5412:	d051      	beq.n	54b8 <LPLD_LPTMR_DelayMs+0xb4>
    return;
  
  OSC0_CR |= OSC_CR_ERCLKEN_MASK;
    5414:	f44f 43a0 	mov.w	r3, #20480	; 0x5000
    5418:	f2c4 0306 	movt	r3, #16390	; 0x4006
    541c:	f44f 42a0 	mov.w	r2, #20480	; 0x5000
    5420:	f2c4 0206 	movt	r2, #16390	; 0x4006
    5424:	7812      	ldrb	r2, [r2, #0]
    5426:	b2d2      	uxtb	r2, r2
    5428:	f062 027f 	orn	r2, r2, #127	; 0x7f
    542c:	b2d2      	uxtb	r2, r2
    542e:	701a      	strb	r2, [r3, #0]
  /* LPTMRʱ */
  SIM_SCGC5|=SIM_SCGC5_LPTIMER_MASK; 
    5430:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    5434:	f2c4 0304 	movt	r3, #16388	; 0x4004
    5438:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    543c:	f2c4 0204 	movt	r2, #16388	; 0x4004
    5440:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    5444:	f102 0218 	add.w	r2, r2, #24
    5448:	6812      	ldr	r2, [r2, #0]
    544a:	f042 0201 	orr.w	r2, r2, #1
    544e:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    5452:	f103 0318 	add.w	r3, r3, #24
    5456:	601a      	str	r2, [r3, #0]
  
  /* úʱ */
  LPTMR0_CMR = period_ms; 
    5458:	f04f 0300 	mov.w	r3, #0
    545c:	f2c4 0304 	movt	r3, #16388	; 0x4004
    5460:	88fa      	ldrh	r2, [r7, #6]
    5462:	609a      	str	r2, [r3, #8]
  
  /* LPTMRƵ1kHz LPOΪʱԴ */
  LPTMR0_PSR = 0|LPTMR_PSR_PCS(1)|LPTMR_PSR_PBYP_MASK; 
    5464:	f04f 0300 	mov.w	r3, #0
    5468:	f2c4 0304 	movt	r3, #16388	; 0x4004
    546c:	f04f 0205 	mov.w	r2, #5
    5470:	605a      	str	r2, [r3, #4]
  
  /* ʱ */
  LPTMR0_CSR |= LPTMR_CSR_TEN_MASK; 
    5472:	f04f 0300 	mov.w	r3, #0
    5476:	f2c4 0304 	movt	r3, #16388	; 0x4004
    547a:	f04f 0200 	mov.w	r2, #0
    547e:	f2c4 0204 	movt	r2, #16388	; 0x4004
    5482:	6812      	ldr	r2, [r2, #0]
    5484:	f042 0201 	orr.w	r2, r2, #1
    5488:	601a      	str	r2, [r3, #0]

  /* ȴﵽ趨ֵ */
  while (!(LPTMR0_CSR & LPTMR_CSR_TCF_MASK));
    548a:	bf00      	nop
    548c:	f04f 0300 	mov.w	r3, #0
    5490:	f2c4 0304 	movt	r3, #16388	; 0x4004
    5494:	681b      	ldr	r3, [r3, #0]
    5496:	f003 0380 	and.w	r3, r3, #128	; 0x80
    549a:	2b00      	cmp	r3, #0
    549c:	d0f6      	beq.n	548c <LPLD_LPTMR_DelayMs+0x88>
  
  /*ʱȽϱ־ */
  LPTMR0_CSR &= ~LPTMR_CSR_TEN_MASK;
    549e:	f04f 0300 	mov.w	r3, #0
    54a2:	f2c4 0304 	movt	r3, #16388	; 0x4004
    54a6:	f04f 0200 	mov.w	r2, #0
    54aa:	f2c4 0204 	movt	r2, #16388	; 0x4004
    54ae:	6812      	ldr	r2, [r2, #0]
    54b0:	f022 0201 	bic.w	r2, r2, #1
    54b4:	601a      	str	r2, [r3, #0]
    54b6:	e000      	b.n	54ba <LPLD_LPTMR_DelayMs+0xb6>
 *      
 */
void LPLD_LPTMR_DelayMs(uint16 period_ms)
{
  if(!period_ms)
    return;
    54b8:	bf00      	nop
  while (!(LPTMR0_CSR & LPTMR_CSR_TCF_MASK));
  
  /*ʱȽϱ־ */
  LPTMR0_CSR &= ~LPTMR_CSR_TEN_MASK;
  
}
    54ba:	f107 070c 	add.w	r7, r7, #12
    54be:	46bd      	mov	sp, r7
    54c0:	bc80      	pop	{r7}
    54c2:	4770      	bx	lr

000054c4 <LPT_IRQHandler>:
 * LPTMRжϴ
 * ļstartup_K60.sеж
 * û޸ģԶӦͨжϺ
 */
void LPT_IRQHandler(void)
{
    54c4:	b580      	push	{r7, lr}
    54c6:	af00      	add	r7, sp, #0
  LPTMR0_CSR|=LPTMR_CSR_TCF_MASK;  //LPTȽϱ־
    54c8:	f04f 0300 	mov.w	r3, #0
    54cc:	f2c4 0304 	movt	r3, #16388	; 0x4004
    54d0:	f04f 0200 	mov.w	r2, #0
    54d4:	f2c4 0204 	movt	r2, #16388	; 0x4004
    54d8:	6812      	ldr	r2, [r2, #0]
    54da:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    54de:	601a      	str	r2, [r3, #0]
  LPTMR_ISR[0]();
    54e0:	f241 6364 	movw	r3, #5732	; 0x1664
    54e4:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    54e8:	681b      	ldr	r3, [r3, #0]
    54ea:	4798      	blx	r3
}
    54ec:	bd80      	pop	{r7, pc}
    54ee:	bf00      	nop

000054f0 <LPLD_PLL_Setup>:
 *
 * 输出:
 *    内核频率，单位MHz
 */
uint8 LPLD_PLL_Setup(PllOptionEnum_Type core_clk_mhz)
{
    54f0:	b580      	push	{r7, lr}
    54f2:	b084      	sub	sp, #16
    54f4:	af00      	add	r7, sp, #0
    54f6:	4603      	mov	r3, r0
    54f8:	71fb      	strb	r3, [r7, #7]
  uint8 pll_freq;
  uint8 prdiv, vdiv;
  uint8 core_div, bus_div, flexbus_div, flash_div;
  
  core_div = 0;
    54fa:	f04f 0300 	mov.w	r3, #0
    54fe:	72bb      	strb	r3, [r7, #10]
  bus_div = 0;
    5500:	f04f 0300 	mov.w	r3, #0
    5504:	737b      	strb	r3, [r7, #13]
  flexbus_div = 0;
    5506:	f04f 0300 	mov.w	r3, #0
    550a:	733b      	strb	r3, [r7, #12]
  flash_div = 0;
    550c:	f04f 0300 	mov.w	r3, #0
    5510:	72fb      	strb	r3, [r7, #11]
  PLL参考时钟范围: 2MHz~4MHz
  PLL参考时钟 = 外部参考时钟(CPU_XTAL_CLK_HZ)/prdiv
  CoreClk = PLL参考时钟 x PLL倍频系数 /OUTDIV1
 *************************************************
 */
  core_clk_mhz = (PllOptionEnum_Type)(core_clk_mhz>200u?200u:core_clk_mhz);
    5512:	79fb      	ldrb	r3, [r7, #7]
    5514:	2bc8      	cmp	r3, #200	; 0xc8
    5516:	bf28      	it	cs
    5518:	23c8      	movcs	r3, #200	; 0xc8
    551a:	71fb      	strb	r3, [r7, #7]
   switch(core_clk_mhz)
    551c:	79fb      	ldrb	r3, [r7, #7]
    551e:	2b78      	cmp	r3, #120	; 0x78
    5520:	d01b      	beq.n	555a <LPLD_PLL_Setup+0x6a>
    5522:	2b78      	cmp	r3, #120	; 0x78
    5524:	dc04      	bgt.n	5530 <LPLD_PLL_Setup+0x40>
    5526:	2b32      	cmp	r3, #50	; 0x32
    5528:	d009      	beq.n	553e <LPLD_PLL_Setup+0x4e>
    552a:	2b64      	cmp	r3, #100	; 0x64
    552c:	d00e      	beq.n	554c <LPLD_PLL_Setup+0x5c>
    552e:	e030      	b.n	5592 <LPLD_PLL_Setup+0xa2>
    5530:	2bb4      	cmp	r3, #180	; 0xb4
    5532:	d020      	beq.n	5576 <LPLD_PLL_Setup+0x86>
    5534:	2bc8      	cmp	r3, #200	; 0xc8
    5536:	d025      	beq.n	5584 <LPLD_PLL_Setup+0x94>
    5538:	2b96      	cmp	r3, #150	; 0x96
    553a:	d015      	beq.n	5568 <LPLD_PLL_Setup+0x78>
    553c:	e029      	b.n	5592 <LPLD_PLL_Setup+0xa2>
  {
  case PLL_50:
    prdiv = 7u;
    553e:	f04f 0307 	mov.w	r3, #7
    5542:	73fb      	strb	r3, [r7, #15]
    vdiv = 1u;
    5544:	f04f 0301 	mov.w	r3, #1
    5548:	73bb      	strb	r3, [r7, #14]
    break;
    554a:	e028      	b.n	559e <LPLD_PLL_Setup+0xae>
  case PLL_100:
    prdiv = 7u;
    554c:	f04f 0307 	mov.w	r3, #7
    5550:	73fb      	strb	r3, [r7, #15]
    vdiv = 16u;
    5552:	f04f 0310 	mov.w	r3, #16
    5556:	73bb      	strb	r3, [r7, #14]
    break;
    5558:	e021      	b.n	559e <LPLD_PLL_Setup+0xae>
  case PLL_120:
    prdiv = 4u;
    555a:	f04f 0304 	mov.w	r3, #4
    555e:	73fb      	strb	r3, [r7, #15]
    vdiv = 8u;
    5560:	f04f 0308 	mov.w	r3, #8
    5564:	73bb      	strb	r3, [r7, #14]
    break;
    5566:	e01a      	b.n	559e <LPLD_PLL_Setup+0xae>
  case PLL_150:
    prdiv = 4u;
    5568:	f04f 0304 	mov.w	r3, #4
    556c:	73fb      	strb	r3, [r7, #15]
    vdiv = 14u;
    556e:	f04f 030e 	mov.w	r3, #14
    5572:	73bb      	strb	r3, [r7, #14]
    break;
    5574:	e013      	b.n	559e <LPLD_PLL_Setup+0xae>
  case PLL_180:
    prdiv = 4u;
    5576:	f04f 0304 	mov.w	r3, #4
    557a:	73fb      	strb	r3, [r7, #15]
    vdiv = 20u;
    557c:	f04f 0314 	mov.w	r3, #20
    5580:	73bb      	strb	r3, [r7, #14]
    break;
    5582:	e00c      	b.n	559e <LPLD_PLL_Setup+0xae>
  case PLL_200:
    prdiv = 4u;
    5584:	f04f 0304 	mov.w	r3, #4
    5588:	73fb      	strb	r3, [r7, #15]
    vdiv = 24u;
    558a:	f04f 0318 	mov.w	r3, #24
    558e:	73bb      	strb	r3, [r7, #14]
    break;
    5590:	e005      	b.n	559e <LPLD_PLL_Setup+0xae>
  default:
    return LPLD_PLL_Setup(PLL_120);
    5592:	f04f 0078 	mov.w	r0, #120	; 0x78
    5596:	f7ff ffab 	bl	54f0 <LPLD_PLL_Setup>
    559a:	4603      	mov	r3, r0
    559c:	e104      	b.n	57a8 <LPLD_PLL_Setup+0x2b8>
  }
  pll_freq = core_clk_mhz * 1;
    559e:	79fb      	ldrb	r3, [r7, #7]
    55a0:	727b      	strb	r3, [r7, #9]
  //core_div = 0;
  if((bus_div = (uint8)(core_clk_mhz/BUS_CLK_MHZ - 1u)) == (uint8)-1)
    55a2:	79fa      	ldrb	r2, [r7, #7]
    55a4:	f248 531f 	movw	r3, #34079	; 0x851f
    55a8:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
    55ac:	fba3 1302 	umull	r1, r3, r3, r2
    55b0:	ea4f 1313 	mov.w	r3, r3, lsr #4
    55b4:	b2db      	uxtb	r3, r3
    55b6:	f103 33ff 	add.w	r3, r3, #4294967295
    55ba:	737b      	strb	r3, [r7, #13]
    55bc:	7b7b      	ldrb	r3, [r7, #13]
    55be:	2bff      	cmp	r3, #255	; 0xff
    55c0:	d103      	bne.n	55ca <LPLD_PLL_Setup+0xda>
  {
    bus_div = 0;
    55c2:	f04f 0300 	mov.w	r3, #0
    55c6:	737b      	strb	r3, [r7, #13]
    55c8:	e00b      	b.n	55e2 <LPLD_PLL_Setup+0xf2>
  }
  else if(core_clk_mhz/(bus_div+1) > BUS_CLK_MHZ)
    55ca:	79fa      	ldrb	r2, [r7, #7]
    55cc:	7b7b      	ldrb	r3, [r7, #13]
    55ce:	f103 0301 	add.w	r3, r3, #1
    55d2:	fb92 f3f3 	sdiv	r3, r2, r3
    55d6:	2b32      	cmp	r3, #50	; 0x32
    55d8:	d903      	bls.n	55e2 <LPLD_PLL_Setup+0xf2>
  {
    bus_div += 1;
    55da:	7b7b      	ldrb	r3, [r7, #13]
    55dc:	f103 0301 	add.w	r3, r3, #1
    55e0:	737b      	strb	r3, [r7, #13]
  }
  if((flexbus_div = (core_clk_mhz/FLEXBUS_CLK_MHZ - 1u)) == (uint8)-1)
    55e2:	79fa      	ldrb	r2, [r7, #7]
    55e4:	f248 531f 	movw	r3, #34079	; 0x851f
    55e8:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
    55ec:	fba3 1302 	umull	r1, r3, r3, r2
    55f0:	ea4f 1313 	mov.w	r3, r3, lsr #4
    55f4:	b2db      	uxtb	r3, r3
    55f6:	f103 33ff 	add.w	r3, r3, #4294967295
    55fa:	733b      	strb	r3, [r7, #12]
    55fc:	7b3b      	ldrb	r3, [r7, #12]
    55fe:	2bff      	cmp	r3, #255	; 0xff
    5600:	d103      	bne.n	560a <LPLD_PLL_Setup+0x11a>
  {
    flexbus_div = 0;
    5602:	f04f 0300 	mov.w	r3, #0
    5606:	733b      	strb	r3, [r7, #12]
    5608:	e00b      	b.n	5622 <LPLD_PLL_Setup+0x132>
  }
  else if(core_clk_mhz/(flexbus_div+1) > FLEXBUS_CLK_MHZ)
    560a:	79fa      	ldrb	r2, [r7, #7]
    560c:	7b3b      	ldrb	r3, [r7, #12]
    560e:	f103 0301 	add.w	r3, r3, #1
    5612:	fb92 f3f3 	sdiv	r3, r2, r3
    5616:	2b32      	cmp	r3, #50	; 0x32
    5618:	d903      	bls.n	5622 <LPLD_PLL_Setup+0x132>
  {
    flexbus_div += 1;
    561a:	7b3b      	ldrb	r3, [r7, #12]
    561c:	f103 0301 	add.w	r3, r3, #1
    5620:	733b      	strb	r3, [r7, #12]
  }
  if((flash_div = (core_clk_mhz/FLASH_CLK_MHZ - 1u)) == (uint8)-1)
    5622:	79fa      	ldrb	r2, [r7, #7]
    5624:	f248 531f 	movw	r3, #34079	; 0x851f
    5628:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
    562c:	fba3 1302 	umull	r1, r3, r3, r2
    5630:	ea4f 03d3 	mov.w	r3, r3, lsr #3
    5634:	b2db      	uxtb	r3, r3
    5636:	f103 33ff 	add.w	r3, r3, #4294967295
    563a:	72fb      	strb	r3, [r7, #11]
    563c:	7afb      	ldrb	r3, [r7, #11]
    563e:	2bff      	cmp	r3, #255	; 0xff
    5640:	d103      	bne.n	564a <LPLD_PLL_Setup+0x15a>
  {
    flash_div = 0;
    5642:	f04f 0300 	mov.w	r3, #0
    5646:	72fb      	strb	r3, [r7, #11]
    5648:	e00b      	b.n	5662 <LPLD_PLL_Setup+0x172>
  }
  else if(core_clk_mhz/(flash_div+1) > FLASH_CLK_MHZ)
    564a:	79fa      	ldrb	r2, [r7, #7]
    564c:	7afb      	ldrb	r3, [r7, #11]
    564e:	f103 0301 	add.w	r3, r3, #1
    5652:	fb92 f3f3 	sdiv	r3, r2, r3
    5656:	2b19      	cmp	r3, #25
    5658:	d903      	bls.n	5662 <LPLD_PLL_Setup+0x172>
  {
    flash_div += 1;
    565a:	7afb      	ldrb	r3, [r7, #11]
    565c:	f103 0301 	add.w	r3, r3, #1
    5660:	72fb      	strb	r3, [r7, #11]
  }
 
  // 这里假设复位后 MCG 模块默认为 FEI 模式 
  
  // 首先移动到 FBE 模式
  MCG_C2 &= ~0x02;
    5662:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    5666:	f2c4 0306 	movt	r3, #16390	; 0x4006
    566a:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    566e:	f2c4 0206 	movt	r2, #16390	; 0x4006
    5672:	7852      	ldrb	r2, [r2, #1]
    5674:	b2d2      	uxtb	r2, r2
    5676:	f022 0202 	bic.w	r2, r2, #2
    567a:	b2d2      	uxtb	r2, r2
    567c:	705a      	strb	r2, [r3, #1]
  //编码1 RANGE = 1
  MCG_C2 |= MCG_C2_RANGE(1);
    567e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    5682:	f2c4 0306 	movt	r3, #16390	; 0x4006
    5686:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    568a:	f2c4 0206 	movt	r2, #16390	; 0x4006
    568e:	7852      	ldrb	r2, [r2, #1]
    5690:	b2d2      	uxtb	r2, r2
    5692:	f042 0210 	orr.w	r2, r2, #16
    5696:	b2d2      	uxtb	r2, r2
    5698:	705a      	strb	r2, [r3, #1]

  // 振荡器初始化完成后,释放锁存状态下的 oscillator 和 GPIO 
  SIM_SCGC4 |= SIM_SCGC4_LLWU_MASK;
    569a:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    569e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    56a2:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    56a6:	f2c4 0204 	movt	r2, #16388	; 0x4004
    56aa:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    56ae:	f102 0214 	add.w	r2, r2, #20
    56b2:	6812      	ldr	r2, [r2, #0]
    56b4:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
    56b8:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    56bc:	f103 0314 	add.w	r3, r3, #20
    56c0:	601a      	str	r2, [r3, #0]
//  LLWU->CS |= LLWU_CS_ACKISO_MASK;
  
  // 选择外部 oscilator 、参考分频器 and 清零 IREFS 启动外部osc
  // CLKS=2, FRDIV=7, IRCLKEN=0, IREFSTEN=0
  // 分频值预留我也不值到分频到多少了...
  MCG_C1 = MCG_C1_CLKS(2) | MCG_C1_FRDIV(7);  
    56c2:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    56c6:	f2c4 0306 	movt	r3, #16390	; 0x4006
    56ca:	f04f 02b8 	mov.w	r2, #184	; 0xb8
    56ce:	701a      	strb	r2, [r3, #0]
  
  while (MCG_S & MCG_S_IREFST_MASK){}; // 等待参考时钟清零
    56d0:	bf00      	nop
    56d2:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    56d6:	f2c4 0306 	movt	r3, #16390	; 0x4006
    56da:	799b      	ldrb	r3, [r3, #6]
    56dc:	b2db      	uxtb	r3, r3
    56de:	f003 0310 	and.w	r3, r3, #16
    56e2:	2b00      	cmp	r3, #0
    56e4:	d1f5      	bne.n	56d2 <LPLD_PLL_Setup+0x1e2>
  
  while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2){}; // 等待时钟状态显示为外部参考时钟(ext ref clk)
    56e6:	bf00      	nop
    56e8:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    56ec:	f2c4 0306 	movt	r3, #16390	; 0x4006
    56f0:	799b      	ldrb	r3, [r3, #6]
    56f2:	b2db      	uxtb	r3, r3
    56f4:	f003 030c 	and.w	r3, r3, #12
    56f8:	ea4f 0393 	mov.w	r3, r3, lsr #2
    56fc:	2b02      	cmp	r3, #2
    56fe:	d1f3      	bne.n	56e8 <LPLD_PLL_Setup+0x1f8>
  
  // 进入FBE模式
  // 配置 PLL 参考分频器, PLLCLKEN=0, PLLSTEN=0, PRDIV=5
  // 用晶振频率来选择 PRDIV 值. 仅在有频率晶振的时候支持
  // 产生 2MHz 的参考时钟给 PLL.
  MCG_C5 = MCG_C5_PRDIV(prdiv); // 设置 PLL 匹配晶振的参考分频数 
    5700:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    5704:	f2c4 0306 	movt	r3, #16390	; 0x4006
    5708:	7bfa      	ldrb	r2, [r7, #15]
    570a:	f002 0207 	and.w	r2, r2, #7
    570e:	b2d2      	uxtb	r2, r2
    5710:	711a      	strb	r2, [r3, #4]
  
  // 确保MCG_C6处于复位状态,禁止LOLIE、PLL、和时钟控制器,清PLL VCO分频器
  MCG_C6 = 0x0;
    5712:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    5716:	f2c4 0306 	movt	r3, #16390	; 0x4006
    571a:	f04f 0200 	mov.w	r2, #0
    571e:	715a      	strb	r2, [r3, #5]
  
  //设置系统时钟分频系数
  LPLD_Set_SYS_DIV(core_div, bus_div, flexbus_div, flash_div);  
    5720:	7ab8      	ldrb	r0, [r7, #10]
    5722:	7b79      	ldrb	r1, [r7, #13]
    5724:	7b3a      	ldrb	r2, [r7, #12]
    5726:	7afb      	ldrb	r3, [r7, #11]
    5728:	f000 f844 	bl	57b4 <LPLD_Set_SYS_DIV>
 // LPLD_Set_SYS_DIV(0, 1, 4, 4);  
  
  //设置倍频系数
  MCG_C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV(vdiv); 
    572c:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    5730:	f2c4 0306 	movt	r3, #16390	; 0x4006
    5734:	7bba      	ldrb	r2, [r7, #14]
    5736:	f002 021f 	and.w	r2, r2, #31
    573a:	b2d2      	uxtb	r2, r2
    573c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    5740:	b2d2      	uxtb	r2, r2
    5742:	715a      	strb	r2, [r3, #5]
  
  while (!(MCG_S & MCG_S_PLLST_MASK)){}; // wait for PLL status bit to set
    5744:	bf00      	nop
    5746:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    574a:	f2c4 0306 	movt	r3, #16390	; 0x4006
    574e:	799b      	ldrb	r3, [r3, #6]
    5750:	b2db      	uxtb	r3, r3
    5752:	f003 0320 	and.w	r3, r3, #32
    5756:	2b00      	cmp	r3, #0
    5758:	d0f5      	beq.n	5746 <LPLD_PLL_Setup+0x256>
  
  while (!(MCG_S & MCG_S_LOCK_MASK)){}; // Wait for LOCK bit to set
    575a:	bf00      	nop
    575c:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    5760:	f2c4 0306 	movt	r3, #16390	; 0x4006
    5764:	799b      	ldrb	r3, [r3, #6]
    5766:	b2db      	uxtb	r3, r3
    5768:	f003 0340 	and.w	r3, r3, #64	; 0x40
    576c:	2b00      	cmp	r3, #0
    576e:	d0f5      	beq.n	575c <LPLD_PLL_Setup+0x26c>
  
  // 已经进入PBE模式
  
  // Transition into PEE by setting CLKS to 0
  // CLKS=0, FRDIV=3, IREFS=0, IRCLKEN=0, IREFSTEN=0
  MCG_C1 &= ~MCG_C1_CLKS_MASK;
    5770:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    5774:	f2c4 0306 	movt	r3, #16390	; 0x4006
    5778:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    577c:	f2c4 0206 	movt	r2, #16390	; 0x4006
    5780:	7812      	ldrb	r2, [r2, #0]
    5782:	b2d2      	uxtb	r2, r2
    5784:	f002 023f 	and.w	r2, r2, #63	; 0x3f
    5788:	b2d2      	uxtb	r2, r2
    578a:	701a      	strb	r2, [r3, #0]
  
  // Wait for clock status bits to update
  while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3){};
    578c:	bf00      	nop
    578e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    5792:	f2c4 0306 	movt	r3, #16390	; 0x4006
    5796:	799b      	ldrb	r3, [r3, #6]
    5798:	b2db      	uxtb	r3, r3
    579a:	f003 030c 	and.w	r3, r3, #12
    579e:	ea4f 0393 	mov.w	r3, r3, lsr #2
    57a2:	2b03      	cmp	r3, #3
    57a4:	d1f3      	bne.n	578e <LPLD_PLL_Setup+0x29e>
  
  // 已经进入PEE模式
  
  return pll_freq;
    57a6:	7a7b      	ldrb	r3, [r7, #9]
} 
    57a8:	4618      	mov	r0, r3
    57aa:	f107 0710 	add.w	r7, r7, #16
    57ae:	46bd      	mov	sp, r7
    57b0:	bd80      	pop	{r7, pc}
    57b2:	bf00      	nop

000057b4 <LPLD_Set_SYS_DIV>:
 *
 * 参数:
 *    outdiv1~outdiv4--分别为core, bus, FlexBus, Flash时钟分频系数
 */
void LPLD_Set_SYS_DIV(uint32 outdiv1, uint32 outdiv2, uint32 outdiv3, uint32 outdiv4)
{
    57b4:	b480      	push	{r7}
    57b6:	b087      	sub	sp, #28
    57b8:	af00      	add	r7, sp, #0
    57ba:	60f8      	str	r0, [r7, #12]
    57bc:	60b9      	str	r1, [r7, #8]
    57be:	607a      	str	r2, [r7, #4]
    57c0:	603b      	str	r3, [r7, #0]
  uint32 temp_reg;
  uint8 i;
  
  temp_reg = FMC_PFAPR; // 备份 FMC_PFAPR 寄存器
    57c2:	f44f 4370 	mov.w	r3, #61440	; 0xf000
    57c6:	f2c4 0301 	movt	r3, #16385	; 0x4001
    57ca:	681b      	ldr	r3, [r3, #0]
    57cc:	613b      	str	r3, [r7, #16]
  
  // 设置 M0PFD 到 M7PFD 为 1 禁用预先读取
  FMC_PFAPR |= FMC_PFAPR_M7PFD_MASK | FMC_PFAPR_M6PFD_MASK | FMC_PFAPR_M5PFD_MASK
    57ce:	f44f 4370 	mov.w	r3, #61440	; 0xf000
    57d2:	f2c4 0301 	movt	r3, #16385	; 0x4001
    57d6:	f44f 4270 	mov.w	r2, #61440	; 0xf000
    57da:	f2c4 0201 	movt	r2, #16385	; 0x4001
    57de:	6812      	ldr	r2, [r2, #0]
    57e0:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
    57e4:	601a      	str	r2, [r3, #0]
             | FMC_PFAPR_M4PFD_MASK | FMC_PFAPR_M3PFD_MASK | FMC_PFAPR_M2PFD_MASK
             | FMC_PFAPR_M1PFD_MASK | FMC_PFAPR_M0PFD_MASK;
  
  // 设置时钟分频为期望值  
  SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(outdiv1) | SIM_CLKDIV1_OUTDIV2(outdiv2) 
    57e6:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    57ea:	f2c4 0304 	movt	r3, #16388	; 0x4004
    57ee:	68fa      	ldr	r2, [r7, #12]
    57f0:	ea4f 7102 	mov.w	r1, r2, lsl #28
    57f4:	68ba      	ldr	r2, [r7, #8]
    57f6:	ea4f 6202 	mov.w	r2, r2, lsl #24
    57fa:	f002 6270 	and.w	r2, r2, #251658240	; 0xf000000
    57fe:	4311      	orrs	r1, r2
              | SIM_CLKDIV1_OUTDIV3(outdiv3) | SIM_CLKDIV1_OUTDIV4(outdiv4);
    5800:	687a      	ldr	r2, [r7, #4]
    5802:	ea4f 5202 	mov.w	r2, r2, lsl #20
    5806:	f402 0270 	and.w	r2, r2, #15728640	; 0xf00000
    580a:	4311      	orrs	r1, r2
    580c:	683a      	ldr	r2, [r7, #0]
    580e:	ea4f 4202 	mov.w	r2, r2, lsl #16
    5812:	f402 2270 	and.w	r2, r2, #983040	; 0xf0000
    5816:	430a      	orrs	r2, r1
  FMC_PFAPR |= FMC_PFAPR_M7PFD_MASK | FMC_PFAPR_M6PFD_MASK | FMC_PFAPR_M5PFD_MASK
             | FMC_PFAPR_M4PFD_MASK | FMC_PFAPR_M3PFD_MASK | FMC_PFAPR_M2PFD_MASK
             | FMC_PFAPR_M1PFD_MASK | FMC_PFAPR_M0PFD_MASK;
  
  // 设置时钟分频为期望值  
  SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(outdiv1) | SIM_CLKDIV1_OUTDIV2(outdiv2) 
    5818:	f503 5382 	add.w	r3, r3, #4160	; 0x1040
    581c:	f103 0304 	add.w	r3, r3, #4
    5820:	601a      	str	r2, [r3, #0]
              | SIM_CLKDIV1_OUTDIV3(outdiv3) | SIM_CLKDIV1_OUTDIV4(outdiv4);

  // 延时一小段时间等待改变
  for (i = 0 ; i < outdiv4 ; i++)
    5822:	f04f 0300 	mov.w	r3, #0
    5826:	75fb      	strb	r3, [r7, #23]
    5828:	e003      	b.n	5832 <LPLD_Set_SYS_DIV+0x7e>
    582a:	7dfb      	ldrb	r3, [r7, #23]
    582c:	f103 0301 	add.w	r3, r3, #1
    5830:	75fb      	strb	r3, [r7, #23]
    5832:	7dfa      	ldrb	r2, [r7, #23]
    5834:	683b      	ldr	r3, [r7, #0]
    5836:	429a      	cmp	r2, r3
    5838:	d3f7      	bcc.n	582a <LPLD_Set_SYS_DIV+0x76>
  {}
  
  FMC_PFAPR = temp_reg; // 回复原先的 FMC_PFAPR 寄存器值
    583a:	f44f 4370 	mov.w	r3, #61440	; 0xf000
    583e:	f2c4 0301 	movt	r3, #16385	; 0x4001
    5842:	693a      	ldr	r2, [r7, #16]
    5844:	601a      	str	r2, [r3, #0]
  
  return;
    5846:	bf00      	nop
} // set_sys_dividers
    5848:	f107 071c 	add.w	r7, r7, #28
    584c:	46bd      	mov	sp, r7
    584e:	bc80      	pop	{r7}
    5850:	4770      	bx	lr
    5852:	bf00      	nop

00005854 <LPLD_PDB_Init>:
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_PDB_Init(PDB_InitTypeDef pdb_init_struct)
{
    5854:	b084      	sub	sp, #16
    5856:	b590      	push	{r4, r7, lr}
    5858:	b089      	sub	sp, #36	; 0x24
    585a:	af00      	add	r7, sp, #0
    585c:	f107 0c30 	add.w	ip, r7, #48	; 0x30
    5860:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  uint32 us = pdb_init_struct.PDB_CounterPeriodUs
    5864:	6b3a      	ldr	r2, [r7, #48]	; 0x30
            + pdb_init_struct.PDB_CounterPeriodMs*1000
            + pdb_init_struct.PDB_CounterPeriodS*1000000;
    5866:	6bb9      	ldr	r1, [r7, #56]	; 0x38
    5868:	f244 2340 	movw	r3, #16960	; 0x4240
    586c:	f2c0 030f 	movt	r3, #15
    5870:	fb03 f101 	mul.w	r1, r3, r1
 *    1--óɹ
 */
uint8 LPLD_PDB_Init(PDB_InitTypeDef pdb_init_struct)
{
  uint32 us = pdb_init_struct.PDB_CounterPeriodUs
            + pdb_init_struct.PDB_CounterPeriodMs*1000
    5874:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    5876:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    587a:	fb00 f303 	mul.w	r3, r0, r3
            + pdb_init_struct.PDB_CounterPeriodS*1000000;
    587e:	18cb      	adds	r3, r1, r3
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_PDB_Init(PDB_InitTypeDef pdb_init_struct)
{
  uint32 us = pdb_init_struct.PDB_CounterPeriodUs
    5880:	18d3      	adds	r3, r2, r3
    5882:	613b      	str	r3, [r7, #16]
            + pdb_init_struct.PDB_CounterPeriodMs*1000
            + pdb_init_struct.PDB_CounterPeriodS*1000000;
  uint32 delayus = pdb_init_struct.PDB_DelayUs
    5884:	6c7a      	ldr	r2, [r7, #68]	; 0x44
            + pdb_init_struct.PDB_DelayMs*1000
            + pdb_init_struct.PDB_DelayS*1000000;
    5886:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
    5888:	f244 2340 	movw	r3, #16960	; 0x4240
    588c:	f2c0 030f 	movt	r3, #15
    5890:	fb03 f101 	mul.w	r1, r3, r1
{
  uint32 us = pdb_init_struct.PDB_CounterPeriodUs
            + pdb_init_struct.PDB_CounterPeriodMs*1000
            + pdb_init_struct.PDB_CounterPeriodS*1000000;
  uint32 delayus = pdb_init_struct.PDB_DelayUs
            + pdb_init_struct.PDB_DelayMs*1000
    5894:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    5896:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    589a:	fb00 f303 	mul.w	r3, r0, r3
            + pdb_init_struct.PDB_DelayS*1000000;
    589e:	18cb      	adds	r3, r1, r3
uint8 LPLD_PDB_Init(PDB_InitTypeDef pdb_init_struct)
{
  uint32 us = pdb_init_struct.PDB_CounterPeriodUs
            + pdb_init_struct.PDB_CounterPeriodMs*1000
            + pdb_init_struct.PDB_CounterPeriodS*1000000;
  uint32 delayus = pdb_init_struct.PDB_DelayUs
    58a0:	18d3      	adds	r3, r2, r3
    58a2:	60fb      	str	r3, [r7, #12]
            + pdb_init_struct.PDB_DelayMs*1000
            + pdb_init_struct.PDB_DelayS*1000000;
  uint8 loadmode = pdb_init_struct.PDB_LoadModeSel;
    58a4:	f897 303c 	ldrb.w	r3, [r7, #60]	; 0x3c
    58a8:	72fb      	strb	r3, [r7, #11]
  uint8 trriger = pdb_init_struct.PDB_TriggerInputSourceSel;
    58aa:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
    58ae:	72bb      	strb	r3, [r7, #10]
  uint32 bus_clk = g_bus_clock/1000000;
    58b0:	f240 036c 	movw	r3, #108	; 0x6c
    58b4:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    58b8:	681a      	ldr	r2, [r3, #0]
    58ba:	f64d 6383 	movw	r3, #56963	; 0xde83
    58be:	f2c4 331b 	movt	r3, #17179	; 0x431b
    58c2:	fba3 1302 	umull	r1, r3, r3, r2
    58c6:	ea4f 4393 	mov.w	r3, r3, lsr #18
    58ca:	607b      	str	r3, [r7, #4]
  uint8 i,j;
  
  //
  //ASSERT( loadmode <= LOADMODE_3 );       //ģʽѡ
  //ASSERT( trriger <= TRIGGER_SOFTWARE );  //Դѡ
  if ((loadmode > LOADMODE_3) || (trriger > TRIGGER_SOFTWARE))
    58cc:	7afb      	ldrb	r3, [r7, #11]
    58ce:	2b03      	cmp	r3, #3
    58d0:	d802      	bhi.n	58d8 <LPLD_PDB_Init+0x84>
    58d2:	7abb      	ldrb	r3, [r7, #10]
    58d4:	2b0f      	cmp	r3, #15
    58d6:	d902      	bls.n	58de <LPLD_PDB_Init+0x8a>
        return 0;
    58d8:	f04f 0300 	mov.w	r3, #0
    58dc:	e15d      	b.n	5b9a <LPLD_PDB_Init+0x346>
   = (prescaler*mult*mod)/bus_clk
 *************************************************
 */
  
  //ļԶ趨prescalermultmodֵ
  for(i=0; i<4; i++)
    58de:	f04f 0300 	mov.w	r3, #0
    58e2:	75fb      	strb	r3, [r7, #23]
    58e4:	e035      	b.n	5952 <LPLD_PDB_Init+0xfe>
  {
    mult = i;
    58e6:	7dfb      	ldrb	r3, [r7, #23]
    58e8:	77bb      	strb	r3, [r7, #30]
    for(j=0; j<8; j++)
    58ea:	f04f 0300 	mov.w	r3, #0
    58ee:	75bb      	strb	r3, [r7, #22]
    58f0:	e01b      	b.n	592a <LPLD_PDB_Init+0xd6>
    {
      prescaler = j;
    58f2:	7dbb      	ldrb	r3, [r7, #22]
    58f4:	77fb      	strb	r3, [r7, #31]
      mod = (bus_clk*us)/((1<<j)*pdb_sc_mults[i]);
    58f6:	687b      	ldr	r3, [r7, #4]
    58f8:	693a      	ldr	r2, [r7, #16]
    58fa:	fb02 f203 	mul.w	r2, r2, r3
    58fe:	7df9      	ldrb	r1, [r7, #23]
    5900:	f648 43a4 	movw	r3, #36004	; 0x8ca4
    5904:	f2c0 0300 	movt	r3, #0
    5908:	5c5b      	ldrb	r3, [r3, r1]
    590a:	4619      	mov	r1, r3
    590c:	7dbb      	ldrb	r3, [r7, #22]
    590e:	fa01 f303 	lsl.w	r3, r1, r3
    5912:	fbb2 f3f3 	udiv	r3, r2, r3
    5916:	61bb      	str	r3, [r7, #24]
      if(mod <= 0xFFFFu)
    5918:	69ba      	ldr	r2, [r7, #24]
    591a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    591e:	429a      	cmp	r2, r3
    5920:	d907      	bls.n	5932 <LPLD_PDB_Init+0xde>
  
  //ļԶ趨prescalermultmodֵ
  for(i=0; i<4; i++)
  {
    mult = i;
    for(j=0; j<8; j++)
    5922:	7dbb      	ldrb	r3, [r7, #22]
    5924:	f103 0301 	add.w	r3, r3, #1
    5928:	75bb      	strb	r3, [r7, #22]
    592a:	7dbb      	ldrb	r3, [r7, #22]
    592c:	2b07      	cmp	r3, #7
    592e:	d9e0      	bls.n	58f2 <LPLD_PDB_Init+0x9e>
    5930:	e000      	b.n	5934 <LPLD_PDB_Init+0xe0>
    {
      prescaler = j;
      mod = (bus_clk*us)/((1<<j)*pdb_sc_mults[i]);
      if(mod <= 0xFFFFu)
        break;
    5932:	bf00      	nop
    }
    if(mod <= 0xFFFFu)
    5934:	69ba      	ldr	r2, [r7, #24]
    5936:	f64f 73ff 	movw	r3, #65535	; 0xffff
    593a:	429a      	cmp	r2, r3
    593c:	d90d      	bls.n	595a <LPLD_PDB_Init+0x106>
      break;
    else if(i == 3)
    593e:	7dfb      	ldrb	r3, [r7, #23]
    5940:	2b03      	cmp	r3, #3
    5942:	d102      	bne.n	594a <LPLD_PDB_Init+0xf6>
      return 0;         //PDBõĹС
    5944:	f04f 0300 	mov.w	r3, #0
    5948:	e127      	b.n	5b9a <LPLD_PDB_Init+0x346>
   = (prescaler*mult*mod)/bus_clk
 *************************************************
 */
  
  //ļԶ趨prescalermultmodֵ
  for(i=0; i<4; i++)
    594a:	7dfb      	ldrb	r3, [r7, #23]
    594c:	f103 0301 	add.w	r3, r3, #1
    5950:	75fb      	strb	r3, [r7, #23]
    5952:	7dfb      	ldrb	r3, [r7, #23]
    5954:	2b03      	cmp	r3, #3
    5956:	d9c6      	bls.n	58e6 <LPLD_PDB_Init+0x92>
    5958:	e000      	b.n	595c <LPLD_PDB_Init+0x108>
      mod = (bus_clk*us)/((1<<j)*pdb_sc_mults[i]);
      if(mod <= 0xFFFFu)
        break;
    }
    if(mod <= 0xFFFFu)
      break;
    595a:	bf00      	nop
    else if(i == 3)
      return 0;         //PDBõĹС
  }
  
  //ʹPDBʱ
  SIM_SCGC6 |= SIM_SCGC6_PDB_MASK;
    595c:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    5960:	f2c4 0304 	movt	r3, #16388	; 0x4004
    5964:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    5968:	f2c4 0204 	movt	r2, #16388	; 0x4004
    596c:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    5970:	f102 021c 	add.w	r2, r2, #28
    5974:	6812      	ldr	r2, [r2, #0]
    5976:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
    597a:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    597e:	f103 031c 	add.w	r3, r3, #28
    5982:	601a      	str	r2, [r3, #0]
  
  //ʼSCĴ
  PDB0_SC = 0x00;
    5984:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5988:	f2c4 0303 	movt	r3, #16387	; 0x4003
    598c:	f04f 0200 	mov.w	r2, #0
    5990:	601a      	str	r2, [r3, #0]
  //ʹPDB
  PDB0_SC |= PDB_SC_PDBEN_MASK;
    5992:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5996:	f2c4 0303 	movt	r3, #16387	; 0x4003
    599a:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    599e:	f2c4 0203 	movt	r2, #16387	; 0x4003
    59a2:	6812      	ldr	r2, [r2, #0]
    59a4:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    59a8:	601a      	str	r2, [r3, #0]
  PDB0_SC |= PDB_SC_MULT(mult);
    59aa:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    59ae:	f2c4 0303 	movt	r3, #16387	; 0x4003
    59b2:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    59b6:	f2c4 0203 	movt	r2, #16387	; 0x4003
    59ba:	6811      	ldr	r1, [r2, #0]
    59bc:	7fba      	ldrb	r2, [r7, #30]
    59be:	ea4f 0282 	mov.w	r2, r2, lsl #2
    59c2:	f002 020c 	and.w	r2, r2, #12
    59c6:	430a      	orrs	r2, r1
    59c8:	601a      	str	r2, [r3, #0]
  PDB0_SC |= PDB_SC_PRESCALER(prescaler);
    59ca:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    59ce:	f2c4 0303 	movt	r3, #16387	; 0x4003
    59d2:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    59d6:	f2c4 0203 	movt	r2, #16387	; 0x4003
    59da:	6811      	ldr	r1, [r2, #0]
    59dc:	7ffa      	ldrb	r2, [r7, #31]
    59de:	ea4f 3202 	mov.w	r2, r2, lsl #12
    59e2:	f402 42e0 	and.w	r2, r2, #28672	; 0x7000
    59e6:	430a      	orrs	r2, r1
    59e8:	601a      	str	r2, [r3, #0]
  //MODIDLYCHnDLYmINTxPOyDLYĴļģʽ
  PDB0_SC |= PDB_SC_LDMOD(loadmode); 
    59ea:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    59ee:	f2c4 0303 	movt	r3, #16387	; 0x4003
    59f2:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    59f6:	f2c4 0203 	movt	r2, #16387	; 0x4003
    59fa:	6811      	ldr	r1, [r2, #0]
    59fc:	7afa      	ldrb	r2, [r7, #11]
    59fe:	ea4f 4282 	mov.w	r2, r2, lsl #18
    5a02:	f402 2240 	and.w	r2, r2, #786432	; 0xc0000
    5a06:	430a      	orrs	r2, r1
    5a08:	601a      	str	r2, [r3, #0]
  //ôԴ
  PDB0_SC |= PDB_SC_TRGSEL(trriger);
    5a0a:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5a0e:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5a12:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    5a16:	f2c4 0203 	movt	r2, #16387	; 0x4003
    5a1a:	6811      	ldr	r1, [r2, #0]
    5a1c:	7aba      	ldrb	r2, [r7, #10]
    5a1e:	ea4f 2202 	mov.w	r2, r2, lsl #8
    5a22:	f402 6270 	and.w	r2, r2, #3840	; 0xf00
    5a26:	430a      	orrs	r2, r1
    5a28:	601a      	str	r2, [r3, #0]
  
  //Ƿʹģʽ
  if(pdb_init_struct.PDB_ContinuousModeEnable == TRUE)
    5a2a:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
    5a2e:	2b01      	cmp	r3, #1
    5a30:	d10c      	bne.n	5a4c <LPLD_PDB_Init+0x1f8>
    PDB0_SC |= PDB_SC_CONT_MASK;
    5a32:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5a36:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5a3a:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    5a3e:	f2c4 0203 	movt	r2, #16387	; 0x4003
    5a42:	6812      	ldr	r2, [r2, #0]
    5a44:	f042 0202 	orr.w	r2, r2, #2
    5a48:	601a      	str	r2, [r3, #0]
    5a4a:	e00b      	b.n	5a64 <LPLD_PDB_Init+0x210>
  else
    PDB0_SC &= ~(PDB_SC_CONT_MASK);
    5a4c:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5a50:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5a54:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    5a58:	f2c4 0203 	movt	r2, #16387	; 0x4003
    5a5c:	6812      	ldr	r2, [r2, #0]
    5a5e:	f022 0202 	bic.w	r2, r2, #2
    5a62:	601a      	str	r2, [r3, #0]
  
  //ǷʹDMA
  if(pdb_init_struct.PDB_DmaEnable == TRUE)
    5a64:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
    5a68:	2b01      	cmp	r3, #1
    5a6a:	d10c      	bne.n	5a86 <LPLD_PDB_Init+0x232>
    PDB0_SC |= PDB_SC_DMAEN_MASK;
    5a6c:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5a70:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5a74:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    5a78:	f2c4 0203 	movt	r2, #16387	; 0x4003
    5a7c:	6812      	ldr	r2, [r2, #0]
    5a7e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
    5a82:	601a      	str	r2, [r3, #0]
    5a84:	e00b      	b.n	5a9e <LPLD_PDB_Init+0x24a>
  else
    PDB0_SC &= ~(PDB_SC_DMAEN_MASK);
    5a86:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5a8a:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5a8e:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    5a92:	f2c4 0203 	movt	r2, #16387	; 0x4003
    5a96:	6812      	ldr	r2, [r2, #0]
    5a98:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    5a9c:	601a      	str	r2, [r3, #0]
  
  if(pdb_init_struct.PDB_Isr != NULL)
    5a9e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    5aa0:	2b00      	cmp	r3, #0
    5aa2:	d022      	beq.n	5aea <LPLD_PDB_Init+0x296>
  {
    PDB_ISR[0] = pdb_init_struct.PDB_Isr;
    5aa4:	6d3a      	ldr	r2, [r7, #80]	; 0x50
    5aa6:	f241 636c 	movw	r3, #5740	; 0x166c
    5aaa:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    5aae:	601a      	str	r2, [r3, #0]
    //ǷʹPDBж
    if(pdb_init_struct.PDB_IntEnable == TRUE)
    5ab0:	f897 3040 	ldrb.w	r3, [r7, #64]	; 0x40
    5ab4:	2b01      	cmp	r3, #1
    5ab6:	d10c      	bne.n	5ad2 <LPLD_PDB_Init+0x27e>
      PDB0_SC |= PDB_SC_PDBIE_MASK;
    5ab8:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5abc:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5ac0:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    5ac4:	f2c4 0203 	movt	r2, #16387	; 0x4003
    5ac8:	6812      	ldr	r2, [r2, #0]
    5aca:	f042 0220 	orr.w	r2, r2, #32
    5ace:	601a      	str	r2, [r3, #0]
    5ad0:	e00b      	b.n	5aea <LPLD_PDB_Init+0x296>
    else
      PDB0_SC &= ~(PDB_SC_PDBIE_MASK);
    5ad2:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5ad6:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5ada:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    5ade:	f2c4 0203 	movt	r2, #16387	; 0x4003
    5ae2:	6812      	ldr	r2, [r2, #0]
    5ae4:	f022 0220 	bic.w	r2, r2, #32
    5ae8:	601a      	str	r2, [r3, #0]
  }
  
  if(pdb_init_struct.PDB_SeqErrIsr != NULL)
    5aea:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    5aec:	2b00      	cmp	r3, #0
    5aee:	d022      	beq.n	5b36 <LPLD_PDB_Init+0x2e2>
  {
    PDB_SE_ISR[0] = pdb_init_struct.PDB_SeqErrIsr;
    5af0:	6d7a      	ldr	r2, [r7, #84]	; 0x54
    5af2:	f241 6368 	movw	r3, #5736	; 0x1668
    5af6:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    5afa:	601a      	str	r2, [r3, #0]
    //ǷʹPDBдж
    if(pdb_init_struct.PDB_SeqErrIntEnable == TRUE)
    5afc:	f897 3041 	ldrb.w	r3, [r7, #65]	; 0x41
    5b00:	2b01      	cmp	r3, #1
    5b02:	d10c      	bne.n	5b1e <LPLD_PDB_Init+0x2ca>
      PDB0_SC |= PDB_SC_PDBEIE_MASK;
    5b04:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5b08:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5b0c:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    5b10:	f2c4 0203 	movt	r2, #16387	; 0x4003
    5b14:	6812      	ldr	r2, [r2, #0]
    5b16:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
    5b1a:	601a      	str	r2, [r3, #0]
    5b1c:	e00b      	b.n	5b36 <LPLD_PDB_Init+0x2e2>
    else
      PDB0_SC &= ~(PDB_SC_PDBEIE_MASK);
    5b1e:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5b22:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5b26:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    5b2a:	f2c4 0203 	movt	r2, #16387	; 0x4003
    5b2e:	6812      	ldr	r2, [r2, #0]
    5b30:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
    5b34:	601a      	str	r2, [r3, #0]
  }
  
  //PDBжʱʱ
  if( delayus <= us )
    5b36:	68fa      	ldr	r2, [r7, #12]
    5b38:	693b      	ldr	r3, [r7, #16]
    5b3a:	429a      	cmp	r2, r3
    5b3c:	d81f      	bhi.n	5b7e <LPLD_PDB_Init+0x32a>
  {
    temp = (float32)mod/(float32)us;
    5b3e:	69b8      	ldr	r0, [r7, #24]
    5b40:	f002 fe4e 	bl	87e0 <__aeabi_ui2f>
    5b44:	4604      	mov	r4, r0
    5b46:	6938      	ldr	r0, [r7, #16]
    5b48:	f002 fe4a 	bl	87e0 <__aeabi_ui2f>
    5b4c:	4603      	mov	r3, r0
    5b4e:	4620      	mov	r0, r4
    5b50:	4619      	mov	r1, r3
    5b52:	f002 ff51 	bl	89f8 <__aeabi_fdiv>
    5b56:	4603      	mov	r3, r0
    5b58:	603b      	str	r3, [r7, #0]
    PDB0_IDLY = (uint32)(delayus*temp);
    5b5a:	f44f 44c0 	mov.w	r4, #24576	; 0x6000
    5b5e:	f2c4 0403 	movt	r4, #16387	; 0x4003
    5b62:	68f8      	ldr	r0, [r7, #12]
    5b64:	f002 fe3c 	bl	87e0 <__aeabi_ui2f>
    5b68:	4603      	mov	r3, r0
    5b6a:	4618      	mov	r0, r3
    5b6c:	6839      	ldr	r1, [r7, #0]
    5b6e:	f002 fe8f 	bl	8890 <__aeabi_fmul>
    5b72:	4603      	mov	r3, r0
    5b74:	4618      	mov	r0, r3
    5b76:	f002 ffdb 	bl	8b30 <__aeabi_f2uiz>
    5b7a:	4603      	mov	r3, r0
    5b7c:	60e3      	str	r3, [r4, #12]
  }
  
  //ֵ
  PDB0_SC |= PDB_SC_LDOK_MASK;
    5b7e:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5b82:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5b86:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    5b8a:	f2c4 0203 	movt	r2, #16387	; 0x4003
    5b8e:	6812      	ldr	r2, [r2, #0]
    5b90:	f042 0201 	orr.w	r2, r2, #1
    5b94:	601a      	str	r2, [r3, #0]
  
  return 1;
    5b96:	f04f 0301 	mov.w	r3, #1
}
    5b9a:	4618      	mov	r0, r3
    5b9c:	f107 0724 	add.w	r7, r7, #36	; 0x24
    5ba0:	46bd      	mov	sp, r7
    5ba2:	e8bd 4090 	ldmia.w	sp!, {r4, r7, lr}
    5ba6:	b004      	add	sp, #16
    5ba8:	4770      	bx	lr
    5baa:	bf00      	nop

00005bac <LPLD_PDB_Deinit>:
 *
 * :
 *    
 */
void LPLD_PDB_Deinit(void)
{
    5bac:	b580      	push	{r7, lr}
    5bae:	af00      	add	r7, sp, #0
 
  PDB0_CH0C1 = 0;
    5bb0:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5bb4:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5bb8:	f04f 0200 	mov.w	r2, #0
    5bbc:	611a      	str	r2, [r3, #16]
  PDB0_CH1C1 = 0;
    5bbe:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5bc2:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5bc6:	f04f 0200 	mov.w	r2, #0
    5bca:	639a      	str	r2, [r3, #56]	; 0x38
  
  PDB0_DACINTC0 = 0;
    5bcc:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5bd0:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5bd4:	f04f 0200 	mov.w	r2, #0
    5bd8:	f8c3 2150 	str.w	r2, [r3, #336]	; 0x150
  PDB0_DACINTC1 = 0;
    5bdc:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5be0:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5be4:	f04f 0200 	mov.w	r2, #0
    5be8:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158
  
  PDB0_SC = 0;
    5bec:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5bf0:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5bf4:	f04f 0200 	mov.w	r2, #0
    5bf8:	601a      	str	r2, [r3, #0]
  
  //PDBʱ
  SIM_SCGC6 &= ~(SIM_SCGC6_PDB_MASK);
    5bfa:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    5bfe:	f2c4 0304 	movt	r3, #16388	; 0x4004
    5c02:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    5c06:	f2c4 0204 	movt	r2, #16388	; 0x4004
    5c0a:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    5c0e:	f102 021c 	add.w	r2, r2, #28
    5c12:	6812      	ldr	r2, [r2, #0]
    5c14:	f422 0280 	bic.w	r2, r2, #4194304	; 0x400000
    5c18:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    5c1c:	f103 031c 	add.w	r3, r3, #28
    5c20:	601a      	str	r2, [r3, #0]
  
  disable_irq(INT_PDB0 - 16);
    5c22:	f04f 0048 	mov.w	r0, #72	; 0x48
    5c26:	f7fb f837 	bl	c98 <disable_irq>
}
    5c2a:	bd80      	pop	{r7, pc}

00005c2c <LPLD_PDB_AdcTriggerCfg>:
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_PDB_AdcTriggerCfg(ADC_MemMapPtr adcx, uint32 cfg, uint16 delay)
{
    5c2c:	b4b0      	push	{r4, r5, r7}
    5c2e:	b089      	sub	sp, #36	; 0x24
    5c30:	af00      	add	r7, sp, #0
    5c32:	60f8      	str	r0, [r7, #12]
    5c34:	60b9      	str	r1, [r7, #8]
    5c36:	4613      	mov	r3, r2
    5c38:	80fb      	strh	r3, [r7, #6]
  uint8 n,m;
  uint8 prescaler, mult;
  uint32 bus_clk = g_bus_clock/1000000;
    5c3a:	f240 036c 	movw	r3, #108	; 0x6c
    5c3e:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    5c42:	681a      	ldr	r2, [r3, #0]
    5c44:	f64d 6383 	movw	r3, #56963	; 0xde83
    5c48:	f2c4 331b 	movt	r3, #17179	; 0x431b
    5c4c:	fba3 1302 	umull	r1, r3, r3, r2
    5c50:	ea4f 4393 	mov.w	r3, r3, lsr #18
    5c54:	61bb      	str	r3, [r7, #24]

  if(adcx == ADC0)
    5c56:	68fa      	ldr	r2, [r7, #12]
    5c58:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    5c5c:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5c60:	429a      	cmp	r2, r3
    5c62:	d103      	bne.n	5c6c <LPLD_PDB_AdcTriggerCfg+0x40>
    n = 0;
    5c64:	f04f 0300 	mov.w	r3, #0
    5c68:	77fb      	strb	r3, [r7, #31]
    5c6a:	e00d      	b.n	5c88 <LPLD_PDB_AdcTriggerCfg+0x5c>
  else if(adcx == ADC1)
    5c6c:	68fa      	ldr	r2, [r7, #12]
    5c6e:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    5c72:	f2c4 030b 	movt	r3, #16395	; 0x400b
    5c76:	429a      	cmp	r2, r3
    5c78:	d103      	bne.n	5c82 <LPLD_PDB_AdcTriggerCfg+0x56>
    n = 1;
    5c7a:	f04f 0301 	mov.w	r3, #1
    5c7e:	77fb      	strb	r3, [r7, #31]
    5c80:	e002      	b.n	5c88 <LPLD_PDB_AdcTriggerCfg+0x5c>
  else
    return 0;
    5c82:	f04f 0300 	mov.w	r3, #0
    5c86:	e07a      	b.n	5d7e <LPLD_PDB_AdcTriggerCfg+0x152>
    
  if(cfg & 0x01)
    5c88:	68bb      	ldr	r3, [r7, #8]
    5c8a:	f003 0301 	and.w	r3, r3, #1
    5c8e:	2b00      	cmp	r3, #0
    5c90:	d003      	beq.n	5c9a <LPLD_PDB_AdcTriggerCfg+0x6e>
    m = 0;
    5c92:	f04f 0300 	mov.w	r3, #0
    5c96:	77bb      	strb	r3, [r7, #30]
    5c98:	e00b      	b.n	5cb2 <LPLD_PDB_AdcTriggerCfg+0x86>
  else if(cfg & 0x02)
    5c9a:	68bb      	ldr	r3, [r7, #8]
    5c9c:	f003 0302 	and.w	r3, r3, #2
    5ca0:	2b00      	cmp	r3, #0
    5ca2:	d003      	beq.n	5cac <LPLD_PDB_AdcTriggerCfg+0x80>
    m = 1;
    5ca4:	f04f 0301 	mov.w	r3, #1
    5ca8:	77bb      	strb	r3, [r7, #30]
    5caa:	e002      	b.n	5cb2 <LPLD_PDB_AdcTriggerCfg+0x86>
  else
    return 0;
    5cac:	f04f 0300 	mov.w	r3, #0
    5cb0:	e065      	b.n	5d7e <LPLD_PDB_AdcTriggerCfg+0x152>
  
  prescaler = 1<<((PDB0_SC & PDB_SC_PRESCALER_MASK) >> PDB_SC_PRESCALER_SHIFT);
    5cb2:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5cb6:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5cba:	681b      	ldr	r3, [r3, #0]
    5cbc:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
    5cc0:	ea4f 3313 	mov.w	r3, r3, lsr #12
    5cc4:	f04f 0201 	mov.w	r2, #1
    5cc8:	fa02 f303 	lsl.w	r3, r2, r3
    5ccc:	75fb      	strb	r3, [r7, #23]
  mult = pdb_sc_mults[(PDB0_SC & PDB_SC_MULT_MASK) >> PDB_SC_MULT_SHIFT];
    5cce:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5cd2:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5cd6:	681b      	ldr	r3, [r3, #0]
    5cd8:	f003 030c 	and.w	r3, r3, #12
    5cdc:	ea4f 0293 	mov.w	r2, r3, lsr #2
    5ce0:	f648 43a4 	movw	r3, #36004	; 0x8ca4
    5ce4:	f2c0 0300 	movt	r3, #0
    5ce8:	5c9b      	ldrb	r3, [r3, r2]
    5cea:	75bb      	strb	r3, [r7, #22]
  
  PDB0_C1(n) |= cfg;        //ݲBBģʽѡԤʹԤ
    5cec:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    5cf0:	f2c4 0203 	movt	r2, #16387	; 0x4003
    5cf4:	7ff8      	ldrb	r0, [r7, #31]
    5cf6:	f44f 41c0 	mov.w	r1, #24576	; 0x6000
    5cfa:	f2c4 0103 	movt	r1, #16387	; 0x4003
    5cfe:	7ffc      	ldrb	r4, [r7, #31]
    5d00:	4623      	mov	r3, r4
    5d02:	ea4f 0383 	mov.w	r3, r3, lsl #2
    5d06:	191b      	adds	r3, r3, r4
    5d08:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    5d0c:	18cb      	adds	r3, r1, r3
    5d0e:	f103 0310 	add.w	r3, r3, #16
    5d12:	6819      	ldr	r1, [r3, #0]
    5d14:	68bb      	ldr	r3, [r7, #8]
    5d16:	4319      	orrs	r1, r3
    5d18:	4603      	mov	r3, r0
    5d1a:	ea4f 0383 	mov.w	r3, r3, lsl #2
    5d1e:	181b      	adds	r3, r3, r0
    5d20:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    5d24:	18d3      	adds	r3, r2, r3
    5d26:	f103 0310 	add.w	r3, r3, #16
    5d2a:	6019      	str	r1, [r3, #0]
  PDB0_DLY(n, m) = (bus_clk * delay)/(prescaler * mult);    //ADCnmԤʱֵ
    5d2c:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    5d30:	f2c4 0203 	movt	r2, #16387	; 0x4003
    5d34:	7ff9      	ldrb	r1, [r7, #31]
    5d36:	7fbc      	ldrb	r4, [r7, #30]
    5d38:	88fb      	ldrh	r3, [r7, #6]
    5d3a:	69b8      	ldr	r0, [r7, #24]
    5d3c:	fb00 f003 	mul.w	r0, r0, r3
    5d40:	7dfb      	ldrb	r3, [r7, #23]
    5d42:	7dbd      	ldrb	r5, [r7, #22]
    5d44:	fb05 f303 	mul.w	r3, r5, r3
    5d48:	fbb0 f0f3 	udiv	r0, r0, r3
    5d4c:	460b      	mov	r3, r1
    5d4e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    5d52:	185b      	adds	r3, r3, r1
    5d54:	ea4f 0343 	mov.w	r3, r3, lsl #1
    5d58:	191b      	adds	r3, r3, r4
    5d5a:	f103 0306 	add.w	r3, r3, #6
    5d5e:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  
  PDB0_SC |= PDB_SC_LDOK_MASK; //ֵ
    5d62:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5d66:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5d6a:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    5d6e:	f2c4 0203 	movt	r2, #16387	; 0x4003
    5d72:	6812      	ldr	r2, [r2, #0]
    5d74:	f042 0201 	orr.w	r2, r2, #1
    5d78:	601a      	str	r2, [r3, #0]
  
  return 1;
    5d7a:	f04f 0301 	mov.w	r3, #1
}
    5d7e:	4618      	mov	r0, r3
    5d80:	f107 0724 	add.w	r7, r7, #36	; 0x24
    5d84:	46bd      	mov	sp, r7
    5d86:	bcb0      	pop	{r4, r5, r7}
    5d88:	4770      	bx	lr
    5d8a:	bf00      	nop

00005d8c <LPLD_PDB_DacTriggerCfg>:
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_PDB_DacTriggerCfg(DAC_MemMapPtr dacx, uint32 cfg, uint16 int_delay)
{
    5d8c:	b490      	push	{r4, r7}
    5d8e:	b088      	sub	sp, #32
    5d90:	af00      	add	r7, sp, #0
    5d92:	60f8      	str	r0, [r7, #12]
    5d94:	60b9      	str	r1, [r7, #8]
    5d96:	4613      	mov	r3, r2
    5d98:	80fb      	strh	r3, [r7, #6]
  uint8 n;
  uint8 prescaler, mult;
  uint32 bus_clk = g_bus_clock/1000000;
    5d9a:	f240 036c 	movw	r3, #108	; 0x6c
    5d9e:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    5da2:	681a      	ldr	r2, [r3, #0]
    5da4:	f64d 6383 	movw	r3, #56963	; 0xde83
    5da8:	f2c4 331b 	movt	r3, #17179	; 0x431b
    5dac:	fba3 1302 	umull	r1, r3, r3, r2
    5db0:	ea4f 4393 	mov.w	r3, r3, lsr #18
    5db4:	61bb      	str	r3, [r7, #24]
  
  if(dacx == DAC0)
    5db6:	68fa      	ldr	r2, [r7, #12]
    5db8:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    5dbc:	f2c4 030c 	movt	r3, #16396	; 0x400c
    5dc0:	429a      	cmp	r2, r3
    5dc2:	d103      	bne.n	5dcc <LPLD_PDB_DacTriggerCfg+0x40>
    n = 0;
    5dc4:	f04f 0300 	mov.w	r3, #0
    5dc8:	77fb      	strb	r3, [r7, #31]
    5dca:	e00d      	b.n	5de8 <LPLD_PDB_DacTriggerCfg+0x5c>
  else if(dacx == DAC1)
    5dcc:	68fa      	ldr	r2, [r7, #12]
    5dce:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    5dd2:	f2c4 030c 	movt	r3, #16396	; 0x400c
    5dd6:	429a      	cmp	r2, r3
    5dd8:	d103      	bne.n	5de2 <LPLD_PDB_DacTriggerCfg+0x56>
    n = 1;
    5dda:	f04f 0301 	mov.w	r3, #1
    5dde:	77fb      	strb	r3, [r7, #31]
    5de0:	e002      	b.n	5de8 <LPLD_PDB_DacTriggerCfg+0x5c>
  else
    return 0;
    5de2:	f04f 0300 	mov.w	r3, #0
    5de6:	e053      	b.n	5e90 <LPLD_PDB_DacTriggerCfg+0x104>
  
  prescaler = 1<<((PDB0_SC & PDB_SC_PRESCALER_MASK) >> PDB_SC_PRESCALER_SHIFT);
    5de8:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5dec:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5df0:	681b      	ldr	r3, [r3, #0]
    5df2:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
    5df6:	ea4f 3313 	mov.w	r3, r3, lsr #12
    5dfa:	f04f 0201 	mov.w	r2, #1
    5dfe:	fa02 f303 	lsl.w	r3, r2, r3
    5e02:	75fb      	strb	r3, [r7, #23]
  mult = pdb_sc_mults[(PDB0_SC & PDB_SC_MULT_MASK) >> PDB_SC_MULT_SHIFT];
    5e04:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5e08:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5e0c:	681b      	ldr	r3, [r3, #0]
    5e0e:	f003 030c 	and.w	r3, r3, #12
    5e12:	ea4f 0293 	mov.w	r2, r3, lsr #2
    5e16:	f648 43a4 	movw	r3, #36004	; 0x8ca4
    5e1a:	f2c0 0300 	movt	r3, #0
    5e1e:	5c9b      	ldrb	r3, [r3, r2]
    5e20:	75bb      	strb	r3, [r7, #22]
  
  PDB0_INTC(n) |= cfg;     //ʹⲿڲ
    5e22:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5e26:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5e2a:	7ff8      	ldrb	r0, [r7, #31]
    5e2c:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    5e30:	f2c4 0203 	movt	r2, #16387	; 0x4003
    5e34:	7ff9      	ldrb	r1, [r7, #31]
    5e36:	f101 012a 	add.w	r1, r1, #42	; 0x2a
    5e3a:	f852 1031 	ldr.w	r1, [r2, r1, lsl #3]
    5e3e:	68ba      	ldr	r2, [r7, #8]
    5e40:	4311      	orrs	r1, r2
    5e42:	f100 022a 	add.w	r2, r0, #42	; 0x2a
    5e46:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
  PDB0_INT(n) = (bus_clk * int_delay)/(prescaler * mult);    //DACnļʱ
    5e4a:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    5e4e:	f2c4 0203 	movt	r2, #16387	; 0x4003
    5e52:	7ffb      	ldrb	r3, [r7, #31]
    5e54:	88f9      	ldrh	r1, [r7, #6]
    5e56:	69b8      	ldr	r0, [r7, #24]
    5e58:	fb00 f001 	mul.w	r0, r0, r1
    5e5c:	7df9      	ldrb	r1, [r7, #23]
    5e5e:	7dbc      	ldrb	r4, [r7, #22]
    5e60:	fb04 f101 	mul.w	r1, r4, r1
    5e64:	fbb0 f1f1 	udiv	r1, r0, r1
    5e68:	f103 032a 	add.w	r3, r3, #42	; 0x2a
    5e6c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    5e70:	18d3      	adds	r3, r2, r3
    5e72:	6059      	str	r1, [r3, #4]
  
  PDB0_SC |= PDB_SC_LDOK_MASK; //ֵ
    5e74:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5e78:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5e7c:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    5e80:	f2c4 0203 	movt	r2, #16387	; 0x4003
    5e84:	6812      	ldr	r2, [r2, #0]
    5e86:	f042 0201 	orr.w	r2, r2, #1
    5e8a:	601a      	str	r2, [r3, #0]
  
  return 1;
    5e8c:	f04f 0301 	mov.w	r3, #1
}
    5e90:	4618      	mov	r0, r3
    5e92:	f107 0720 	add.w	r7, r7, #32
    5e96:	46bd      	mov	sp, r7
    5e98:	bc90      	pop	{r4, r7}
    5e9a:	4770      	bx	lr

00005e9c <PDB0_IRQHandler>:
 * PDBжϴ
 * ļstartup_K60.sеж
 * û޸ģԶӦͨжϺ
 */
void PDB0_IRQHandler(void)
{
    5e9c:	b580      	push	{r7, lr}
    5e9e:	af00      	add	r7, sp, #0
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif
  
  //ǷΪPDBж
  if((PDB0_SC & PDB_SC_PDBIF_MASK) && (PDB0_SC & PDB_SC_PDBIE_MASK))
    5ea0:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5ea4:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5ea8:	681b      	ldr	r3, [r3, #0]
    5eaa:	f003 0340 	and.w	r3, r3, #64	; 0x40
    5eae:	2b00      	cmp	r3, #0
    5eb0:	d01a      	beq.n	5ee8 <PDB0_IRQHandler+0x4c>
    5eb2:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5eb6:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5eba:	681b      	ldr	r3, [r3, #0]
    5ebc:	f003 0320 	and.w	r3, r3, #32
    5ec0:	2b00      	cmp	r3, #0
    5ec2:	d011      	beq.n	5ee8 <PDB0_IRQHandler+0x4c>
  {
    //ûԶжϷ
    PDB_ISR[0]();  
    5ec4:	f241 636c 	movw	r3, #5740	; 0x166c
    5ec8:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    5ecc:	681b      	ldr	r3, [r3, #0]
    5ece:	4798      	blx	r3
    //жϱ־λ  
    PDB0_SC &= ~PDB_SC_PDBIF_MASK;
    5ed0:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5ed4:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5ed8:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    5edc:	f2c4 0203 	movt	r2, #16387	; 0x4003
    5ee0:	6812      	ldr	r2, [r2, #0]
    5ee2:	f022 0240 	bic.w	r2, r2, #64	; 0x40
    5ee6:	601a      	str	r2, [r3, #0]
  }
  
  //ǷΪPDBдж CH0
  if((PDB0_CH0S & PDB_S_ERR(1)) && (PDB0_SC & PDB_SC_PDBEIE_MASK))
    5ee8:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5eec:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5ef0:	695b      	ldr	r3, [r3, #20]
    5ef2:	f003 0301 	and.w	r3, r3, #1
    5ef6:	2b00      	cmp	r3, #0
    5ef8:	d01a      	beq.n	5f30 <PDB0_IRQHandler+0x94>
    5efa:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5efe:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5f02:	681b      	ldr	r3, [r3, #0]
    5f04:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
    5f08:	2b00      	cmp	r3, #0
    5f0a:	d011      	beq.n	5f30 <PDB0_IRQHandler+0x94>
  {
    //ûԶжϷ
    PDB_SE_ISR[0]();  
    5f0c:	f241 6368 	movw	r3, #5736	; 0x1668
    5f10:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    5f14:	681b      	ldr	r3, [r3, #0]
    5f16:	4798      	blx	r3
    PDB0_CH0S |= PDB_S_ERR(1);
    5f18:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5f1c:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5f20:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    5f24:	f2c4 0203 	movt	r2, #16387	; 0x4003
    5f28:	6952      	ldr	r2, [r2, #20]
    5f2a:	f042 0201 	orr.w	r2, r2, #1
    5f2e:	615a      	str	r2, [r3, #20]
  }
  
  //ǷΪPDBдж CH1
  if((PDB0_CH1S & PDB_S_ERR(2)) && (PDB0_SC & PDB_SC_PDBEIE_MASK))
    5f30:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5f34:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5f38:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    5f3a:	f003 0302 	and.w	r3, r3, #2
    5f3e:	2b00      	cmp	r3, #0
    5f40:	d01a      	beq.n	5f78 <PDB0_IRQHandler+0xdc>
    5f42:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5f46:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5f4a:	681b      	ldr	r3, [r3, #0]
    5f4c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
    5f50:	2b00      	cmp	r3, #0
    5f52:	d011      	beq.n	5f78 <PDB0_IRQHandler+0xdc>
  {
    //ûԶжϷ
    PDB_SE_ISR[0]();  
    5f54:	f241 6368 	movw	r3, #5736	; 0x1668
    5f58:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    5f5c:	681b      	ldr	r3, [r3, #0]
    5f5e:	4798      	blx	r3
    PDB0_CH1S |= PDB_S_ERR(2);
    5f60:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
    5f64:	f2c4 0303 	movt	r3, #16387	; 0x4003
    5f68:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
    5f6c:	f2c4 0203 	movt	r2, #16387	; 0x4003
    5f70:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
    5f72:	f042 0202 	orr.w	r2, r2, #2
    5f76:	63da      	str	r2, [r3, #60]	; 0x3c
  }
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    5f78:	bd80      	pop	{r7, pc}
    5f7a:	bf00      	nop

00005f7c <LPLD_PIT_Init>:
 * 输出:
 *    0--配置错误
 *    1--配置成功
 */
uint8 LPLD_PIT_Init(PIT_InitTypeDef pit_init_structure)
{ 
    5f7c:	b084      	sub	sp, #16
    5f7e:	b480      	push	{r7}
    5f80:	b085      	sub	sp, #20
    5f82:	af00      	add	r7, sp, #0
    5f84:	f107 0c18 	add.w	ip, r7, #24
    5f88:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  //计算定时加载值
  uint32 ldval = pit_init_structure.PIT_PeriodUs*(g_bus_clock/1000000)
    5f8c:	69fa      	ldr	r2, [r7, #28]
    5f8e:	f240 036c 	movw	r3, #108	; 0x6c
    5f92:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    5f96:	6819      	ldr	r1, [r3, #0]
    5f98:	f64d 6383 	movw	r3, #56963	; 0xde83
    5f9c:	f2c4 331b 	movt	r3, #17179	; 0x431b
    5fa0:	fba3 0301 	umull	r0, r3, r3, r1
    5fa4:	ea4f 4393 	mov.w	r3, r3, lsr #18
    5fa8:	fb03 f202 	mul.w	r2, r3, r2
               + pit_init_structure.PIT_PeriodMs*1000*(g_bus_clock/1000000)
    5fac:	6a39      	ldr	r1, [r7, #32]
    5fae:	f240 036c 	movw	r3, #108	; 0x6c
    5fb2:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    5fb6:	6818      	ldr	r0, [r3, #0]
    5fb8:	f64d 6383 	movw	r3, #56963	; 0xde83
    5fbc:	f2c4 331b 	movt	r3, #17179	; 0x431b
    5fc0:	fba3 c300 	umull	ip, r3, r3, r0
    5fc4:	ea4f 4393 	mov.w	r3, r3, lsr #18
    5fc8:	fb03 f301 	mul.w	r3, r3, r1
    5fcc:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    5fd0:	fb01 f303 	mul.w	r3, r1, r3
    5fd4:	18d2      	adds	r2, r2, r3
               + pit_init_structure.PIT_PeriodS*1000000*(g_bus_clock/1000000);
    5fd6:	6a79      	ldr	r1, [r7, #36]	; 0x24
    5fd8:	f240 036c 	movw	r3, #108	; 0x6c
    5fdc:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    5fe0:	6818      	ldr	r0, [r3, #0]
    5fe2:	f64d 6383 	movw	r3, #56963	; 0xde83
    5fe6:	f2c4 331b 	movt	r3, #17179	; 0x431b
    5fea:	fba3 c300 	umull	ip, r3, r3, r0
    5fee:	ea4f 4393 	mov.w	r3, r3, lsr #18
    5ff2:	fb03 f101 	mul.w	r1, r3, r1
    5ff6:	f244 2340 	movw	r3, #16960	; 0x4240
    5ffa:	f2c0 030f 	movt	r3, #15
    5ffe:	fb03 f301 	mul.w	r3, r3, r1
 *    1--配置成功
 */
uint8 LPLD_PIT_Init(PIT_InitTypeDef pit_init_structure)
{ 
  //计算定时加载值
  uint32 ldval = pit_init_structure.PIT_PeriodUs*(g_bus_clock/1000000)
    6002:	18d3      	adds	r3, r2, r3
    6004:	60fb      	str	r3, [r7, #12]
               + pit_init_structure.PIT_PeriodMs*1000*(g_bus_clock/1000000)
               + pit_init_structure.PIT_PeriodS*1000000*(g_bus_clock/1000000);
  PITx pitx = pit_init_structure.PIT_Pitx;
    6006:	7e3b      	ldrb	r3, [r7, #24]
    6008:	72fb      	strb	r3, [r7, #11]
  PIT_ISR_CALLBACK isr_func = pit_init_structure.PIT_Isr;
    600a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    600c:	607b      	str	r3, [r7, #4]
  
  //参数检查
  //ASSERT( pitx <= PIT3);        //判断模块号
  //ASSERT( ldval > 0);           //判断时加载值  
  if (pitx > PIT3)
    600e:	7afb      	ldrb	r3, [r7, #11]
    6010:	2b03      	cmp	r3, #3
    6012:	d902      	bls.n	601a <LPLD_PIT_Init+0x9e>
    return 0;
    6014:	f04f 0300 	mov.w	r3, #0
    6018:	e060      	b.n	60dc <LPLD_PIT_Init+0x160>
  if (ldval <= 0)
    601a:	68fb      	ldr	r3, [r7, #12]
    601c:	2b00      	cmp	r3, #0
    601e:	d102      	bne.n	6026 <LPLD_PIT_Init+0xaa>
    return 0;
    6020:	f04f 0300 	mov.w	r3, #0
    6024:	e05a      	b.n	60dc <LPLD_PIT_Init+0x160>
  
  //开启定时模块时钟
  SIM_SCGC6 |= SIM_SCGC6_PIT_MASK;
    6026:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    602a:	f2c4 0304 	movt	r3, #16388	; 0x4004
    602e:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    6032:	f2c4 0204 	movt	r2, #16388	; 0x4004
    6036:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    603a:	f102 021c 	add.w	r2, r2, #28
    603e:	6812      	ldr	r2, [r2, #0]
    6040:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
    6044:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    6048:	f103 031c 	add.w	r3, r3, #28
    604c:	601a      	str	r2, [r3, #0]
  
  // 开启 PIT
  PIT_MCR = 0x00;
    604e:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    6052:	f2c4 0303 	movt	r3, #16387	; 0x4003
    6056:	f04f 0200 	mov.w	r2, #0
    605a:	601a      	str	r2, [r3, #0]
 
  if(isr_func != NULL){
    605c:	687b      	ldr	r3, [r7, #4]
    605e:	2b00      	cmp	r3, #0
    6060:	d014      	beq.n	608c <LPLD_PIT_Init+0x110>
    PIT_ISR[pitx] = isr_func;
    6062:	7afa      	ldrb	r2, [r7, #11]
    6064:	f241 6370 	movw	r3, #5744	; 0x1670
    6068:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    606c:	6879      	ldr	r1, [r7, #4]
    606e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    //使能中断
    PIT->CHANNEL[pitx].TCTRL = PIT_TCTRL_TIE_MASK;
    6072:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    6076:	f2c4 0303 	movt	r3, #16387	; 0x4003
    607a:	7afa      	ldrb	r2, [r7, #11]
    607c:	ea4f 1202 	mov.w	r2, r2, lsl #4
    6080:	189b      	adds	r3, r3, r2
    6082:	f503 7384 	add.w	r3, r3, #264	; 0x108
    6086:	f04f 0202 	mov.w	r2, #2
    608a:	601a      	str	r2, [r3, #0]
    //在NVIC中使能PIT中断
    //enable_irq(68 + pitx); 
  }
  
  //period = (period_ns/bus_period_ns)-1
  PIT->CHANNEL[pitx].LDVAL = ldval-1;
    608c:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    6090:	f2c4 0303 	movt	r3, #16387	; 0x4003
    6094:	7af9      	ldrb	r1, [r7, #11]
    6096:	68fa      	ldr	r2, [r7, #12]
    6098:	f102 32ff 	add.w	r2, r2, #4294967295
    609c:	f101 0110 	add.w	r1, r1, #16
    60a0:	ea4f 1101 	mov.w	r1, r1, lsl #4
    60a4:	185b      	adds	r3, r3, r1
    60a6:	601a      	str	r2, [r3, #0]
  //使能中断
  //PIT->CHANNEL[pitx].TCTRL = PIT_TCTRL_TIE_MASK;
  //开始定时
  PIT->CHANNEL[pitx].TCTRL |= PIT_TCTRL_TEN_MASK;
    60a8:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    60ac:	f2c4 0303 	movt	r3, #16387	; 0x4003
    60b0:	7af9      	ldrb	r1, [r7, #11]
    60b2:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    60b6:	f2c4 0203 	movt	r2, #16387	; 0x4003
    60ba:	7af8      	ldrb	r0, [r7, #11]
    60bc:	ea4f 1000 	mov.w	r0, r0, lsl #4
    60c0:	1812      	adds	r2, r2, r0
    60c2:	f502 7284 	add.w	r2, r2, #264	; 0x108
    60c6:	6812      	ldr	r2, [r2, #0]
    60c8:	f042 0201 	orr.w	r2, r2, #1
    60cc:	ea4f 1101 	mov.w	r1, r1, lsl #4
    60d0:	185b      	adds	r3, r3, r1
    60d2:	f503 7384 	add.w	r3, r3, #264	; 0x108
    60d6:	601a      	str	r2, [r3, #0]
  
  return 1;
    60d8:	f04f 0301 	mov.w	r3, #1
}
    60dc:	4618      	mov	r0, r3
    60de:	f107 0714 	add.w	r7, r7, #20
    60e2:	46bd      	mov	sp, r7
    60e4:	bc80      	pop	{r7}
    60e6:	b004      	add	sp, #16
    60e8:	4770      	bx	lr
    60ea:	bf00      	nop

000060ec <LPLD_PIT_Deinit>:
 *
 * 输出:
 *    无
 */
void LPLD_PIT_Deinit(PIT_InitTypeDef pit_init_structure)
{ 
    60ec:	b084      	sub	sp, #16
    60ee:	b580      	push	{r7, lr}
    60f0:	b082      	sub	sp, #8
    60f2:	af00      	add	r7, sp, #0
    60f4:	f107 0c10 	add.w	ip, r7, #16
    60f8:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  PITx pitx = pit_init_structure.PIT_Pitx;
    60fc:	7c3b      	ldrb	r3, [r7, #16]
    60fe:	71fb      	strb	r3, [r7, #7]
  
  //参数检查
  //ASSERT( pitx <= PIT3);        //判断模块号              

  disable_irq(68 + pitx); 
    6100:	79fb      	ldrb	r3, [r7, #7]
    6102:	f103 0344 	add.w	r3, r3, #68	; 0x44
    6106:	4618      	mov	r0, r3
    6108:	f7fa fdc6 	bl	c98 <disable_irq>

  //禁用中断\停止定时
  PIT->CHANNEL[pitx].TCTRL = 0;
    610c:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    6110:	f2c4 0303 	movt	r3, #16387	; 0x4003
    6114:	79fa      	ldrb	r2, [r7, #7]
    6116:	ea4f 1202 	mov.w	r2, r2, lsl #4
    611a:	189b      	adds	r3, r3, r2
    611c:	f503 7384 	add.w	r3, r3, #264	; 0x108
    6120:	f04f 0200 	mov.w	r2, #0
    6124:	601a      	str	r2, [r3, #0]
}
    6126:	f107 0708 	add.w	r7, r7, #8
    612a:	46bd      	mov	sp, r7
    612c:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    6130:	b004      	add	sp, #16
    6132:	4770      	bx	lr

00006134 <LPLD_PIT_EnableIrq>:
 * 输出:
 *    无
 *
 */
void LPLD_PIT_EnableIrq(PIT_InitTypeDef pit_init_structure)
{
    6134:	b084      	sub	sp, #16
    6136:	b580      	push	{r7, lr}
    6138:	b082      	sub	sp, #8
    613a:	af00      	add	r7, sp, #0
    613c:	f107 0c10 	add.w	ip, r7, #16
    6140:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  PITx pitx = pit_init_structure.PIT_Pitx;
    6144:	7c3b      	ldrb	r3, [r7, #16]
    6146:	71fb      	strb	r3, [r7, #7]
  
  //参数检查
  //ASSERT( pitx <= PIT3);                //判断PITx

  enable_irq(68 + pitx); 
    6148:	79fb      	ldrb	r3, [r7, #7]
    614a:	f103 0344 	add.w	r3, r3, #68	; 0x44
    614e:	4618      	mov	r0, r3
    6150:	f7fa fcde 	bl	b10 <enable_irq>
}
    6154:	f107 0708 	add.w	r7, r7, #8
    6158:	46bd      	mov	sp, r7
    615a:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    615e:	b004      	add	sp, #16
    6160:	4770      	bx	lr
    6162:	bf00      	nop

00006164 <LPLD_PIT_DisableIrq>:
 * 输出:
 *    无
 *
 */
void LPLD_PIT_DisableIrq(PIT_InitTypeDef pit_init_structure)
{
    6164:	b084      	sub	sp, #16
    6166:	b580      	push	{r7, lr}
    6168:	b082      	sub	sp, #8
    616a:	af00      	add	r7, sp, #0
    616c:	f107 0c10 	add.w	ip, r7, #16
    6170:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  PITx pitx = pit_init_structure.PIT_Pitx;
    6174:	7c3b      	ldrb	r3, [r7, #16]
    6176:	71fb      	strb	r3, [r7, #7]
  
  //参数检查
  //ASSERT( pitx <= PIT3);                //判断PITx
  
  disable_irq(68 + pitx);
    6178:	79fb      	ldrb	r3, [r7, #7]
    617a:	f103 0344 	add.w	r3, r3, #68	; 0x44
    617e:	4618      	mov	r0, r3
    6180:	f7fa fd8a 	bl	c98 <disable_irq>
}
    6184:	f107 0708 	add.w	r7, r7, #8
    6188:	46bd      	mov	sp, r7
    618a:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    618e:	b004      	add	sp, #16
    6190:	4770      	bx	lr
    6192:	bf00      	nop

00006194 <LPLD_PIT_TimeStart>:

//pit开始记时
void LPLD_PIT_TimeStart(PITx PIT_pitx)
{
    6194:	b480      	push	{r7}
    6196:	b083      	sub	sp, #12
    6198:	af00      	add	r7, sp, #0
    619a:	4603      	mov	r3, r0
    619c:	71fb      	strb	r3, [r7, #7]
    //开启PIT模块
    SIM_SCGC6 |= SIM_SCGC6_PIT_MASK;
    619e:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    61a2:	f2c4 0304 	movt	r3, #16388	; 0x4004
    61a6:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    61aa:	f2c4 0204 	movt	r2, #16388	; 0x4004
    61ae:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    61b2:	f102 021c 	add.w	r2, r2, #28
    61b6:	6812      	ldr	r2, [r2, #0]
    61b8:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
    61bc:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    61c0:	f103 031c 	add.w	r3, r3, #28
    61c4:	601a      	str	r2, [r3, #0]
    //使能PIT定时器时钟，调试模式下继续使用
    PIT_MCR &= ~(PIT_MCR_MDIS_MASK | PIT_MCR_FRZ_MASK);
    61c6:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    61ca:	f2c4 0303 	movt	r3, #16387	; 0x4003
    61ce:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    61d2:	f2c4 0203 	movt	r2, #16387	; 0x4003
    61d6:	6812      	ldr	r2, [r2, #0]
    61d8:	f022 0203 	bic.w	r2, r2, #3
    61dc:	601a      	str	r2, [r3, #0]
    //禁用PIT， 以便设置加载值生效
    PIT_TCTRL (PIT_pitx) &= ~(PIT_TCTRL_TEN_MASK);
    61de:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    61e2:	f2c4 0303 	movt	r3, #16387	; 0x4003
    61e6:	79f9      	ldrb	r1, [r7, #7]
    61e8:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    61ec:	f2c4 0203 	movt	r2, #16387	; 0x4003
    61f0:	79f8      	ldrb	r0, [r7, #7]
    61f2:	ea4f 1000 	mov.w	r0, r0, lsl #4
    61f6:	1812      	adds	r2, r2, r0
    61f8:	f502 7284 	add.w	r2, r2, #264	; 0x108
    61fc:	6812      	ldr	r2, [r2, #0]
    61fe:	f022 0201 	bic.w	r2, r2, #1
    6202:	ea4f 1101 	mov.w	r1, r1, lsl #4
    6206:	185b      	adds	r3, r3, r1
    6208:	f503 7384 	add.w	r3, r3, #264	; 0x108
    620c:	601a      	str	r2, [r3, #0]
    //设置溢出中断时间
    PIT_LDVAL (PIT_pitx) = ~0;
    620e:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    6212:	f2c4 0303 	movt	r3, #16387	; 0x4003
    6216:	79fa      	ldrb	r2, [r7, #7]
    6218:	f102 0210 	add.w	r2, r2, #16
    621c:	ea4f 1202 	mov.w	r2, r2, lsl #4
    6220:	189b      	adds	r3, r3, r2
    6222:	f04f 32ff 	mov.w	r2, #4294967295
    6226:	601a      	str	r2, [r3, #0]
    //清中断标志位
    //PIT_Flag_Clear (PIT_pitx);
    PIT_TFLG (PIT_pitx) |= PIT_TFLG_TIF_MASK;
    6228:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    622c:	f2c4 0303 	movt	r3, #16387	; 0x4003
    6230:	79f9      	ldrb	r1, [r7, #7]
    6232:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    6236:	f2c4 0203 	movt	r2, #16387	; 0x4003
    623a:	79f8      	ldrb	r0, [r7, #7]
    623c:	ea4f 1000 	mov.w	r0, r0, lsl #4
    6240:	1812      	adds	r2, r2, r0
    6242:	f502 7284 	add.w	r2, r2, #264	; 0x108
    6246:	6852      	ldr	r2, [r2, #4]
    6248:	f042 0201 	orr.w	r2, r2, #1
    624c:	ea4f 1101 	mov.w	r1, r1, lsl #4
    6250:	185b      	adds	r3, r3, r1
    6252:	f503 7384 	add.w	r3, r3, #264	; 0x108
    6256:	605a      	str	r2, [r3, #4]
    //禁止PITn定时器 (用来清空计数值)
    PIT_TCTRL (PIT_pitx) &= ~PIT_TCTRL_TEN_MASK;
    6258:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    625c:	f2c4 0303 	movt	r3, #16387	; 0x4003
    6260:	79f9      	ldrb	r1, [r7, #7]
    6262:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    6266:	f2c4 0203 	movt	r2, #16387	; 0x4003
    626a:	79f8      	ldrb	r0, [r7, #7]
    626c:	ea4f 1000 	mov.w	r0, r0, lsl #4
    6270:	1812      	adds	r2, r2, r0
    6272:	f502 7284 	add.w	r2, r2, #264	; 0x108
    6276:	6812      	ldr	r2, [r2, #0]
    6278:	f022 0201 	bic.w	r2, r2, #1
    627c:	ea4f 1101 	mov.w	r1, r1, lsl #4
    6280:	185b      	adds	r3, r3, r1
    6282:	f503 7384 	add.w	r3, r3, #264	; 0x108
    6286:	601a      	str	r2, [r3, #0]
    //使能PIT定时器
    PIT_TCTRL (PIT_pitx) = (0
    6288:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    628c:	f2c4 0303 	movt	r3, #16387	; 0x4003
    6290:	79fa      	ldrb	r2, [r7, #7]
    6292:	ea4f 1202 	mov.w	r2, r2, lsl #4
    6296:	189b      	adds	r3, r3, r2
    6298:	f503 7384 	add.w	r3, r3, #264	; 0x108
    629c:	f04f 0201 	mov.w	r2, #1
    62a0:	601a      	str	r2, [r3, #0]
                           |PIT_TCTRL_TEN_MASK
                           );

}
    62a2:	f107 070c 	add.w	r7, r7, #12
    62a6:	46bd      	mov	sp, r7
    62a8:	bc80      	pop	{r7}
    62aa:	4770      	bx	lr

000062ac <LPLD_PIT_TimeGetUs>:
//获取PIT计时时间，（超时关闭定时器）
uint32 LPLD_PIT_TimeGetUs (PITx PIT_pitx)
{
    62ac:	b480      	push	{r7}
    62ae:	b085      	sub	sp, #20
    62b0:	af00      	add	r7, sp, #0
    62b2:	4603      	mov	r3, r0
    62b4:	71fb      	strb	r3, [r7, #7]
    uint32 val;
    val = (~0) - PIT_CVAL(PIT_pitx);
    62b6:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    62ba:	f2c4 0303 	movt	r3, #16387	; 0x4003
    62be:	79fa      	ldrb	r2, [r7, #7]
    62c0:	f102 0210 	add.w	r2, r2, #16
    62c4:	ea4f 1202 	mov.w	r2, r2, lsl #4
    62c8:	189b      	adds	r3, r3, r2
    62ca:	685b      	ldr	r3, [r3, #4]
    62cc:	ea6f 0303 	mvn.w	r3, r3
    62d0:	60fb      	str	r3, [r7, #12]

    if (PIT_TFLG(PIT_pitx) & PIT_TFLG_TIF_MASK)
    62d2:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    62d6:	f2c4 0303 	movt	r3, #16387	; 0x4003
    62da:	79fa      	ldrb	r2, [r7, #7]
    62dc:	ea4f 1202 	mov.w	r2, r2, lsl #4
    62e0:	189b      	adds	r3, r3, r2
    62e2:	f503 7384 	add.w	r3, r3, #264	; 0x108
    62e6:	685b      	ldr	r3, [r3, #4]
    62e8:	f003 0301 	and.w	r3, r3, #1
    62ec:	2b00      	cmp	r3, #0
    62ee:	d032      	beq.n	6356 <LPLD_PIT_TimeGetUs+0xaa>
    {
        //更换下一句的表达方式
        //PIT_Flag_Clear(PIT_pitx);
        PIT_TFLG (PIT_pitx) |= PIT_TFLG_TIF_MASK;
    62f0:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    62f4:	f2c4 0303 	movt	r3, #16387	; 0x4003
    62f8:	79f9      	ldrb	r1, [r7, #7]
    62fa:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    62fe:	f2c4 0203 	movt	r2, #16387	; 0x4003
    6302:	79f8      	ldrb	r0, [r7, #7]
    6304:	ea4f 1000 	mov.w	r0, r0, lsl #4
    6308:	1812      	adds	r2, r2, r0
    630a:	f502 7284 	add.w	r2, r2, #264	; 0x108
    630e:	6852      	ldr	r2, [r2, #4]
    6310:	f042 0201 	orr.w	r2, r2, #1
    6314:	ea4f 1101 	mov.w	r1, r1, lsl #4
    6318:	185b      	adds	r3, r3, r1
    631a:	f503 7384 	add.w	r3, r3, #264	; 0x108
    631e:	605a      	str	r2, [r3, #4]

        PIT_TCTRL(PIT_pitx) &= ~PIT_TCTRL_TEN_MASK;
    6320:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    6324:	f2c4 0303 	movt	r3, #16387	; 0x4003
    6328:	79f9      	ldrb	r1, [r7, #7]
    632a:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    632e:	f2c4 0203 	movt	r2, #16387	; 0x4003
    6332:	79f8      	ldrb	r0, [r7, #7]
    6334:	ea4f 1000 	mov.w	r0, r0, lsl #4
    6338:	1812      	adds	r2, r2, r0
    633a:	f502 7284 	add.w	r2, r2, #264	; 0x108
    633e:	6812      	ldr	r2, [r2, #0]
    6340:	f022 0201 	bic.w	r2, r2, #1
    6344:	ea4f 1101 	mov.w	r1, r1, lsl #4
    6348:	185b      	adds	r3, r3, r1
    634a:	f503 7384 	add.w	r3, r3, #264	; 0x108
    634e:	601a      	str	r2, [r3, #0]
        return ~0;
    6350:	f04f 33ff 	mov.w	r3, #4294967295
    6354:	e017      	b.n	6386 <LPLD_PIT_TimeGetUs+0xda>
    }
    if (val == (~0))
    6356:	68fb      	ldr	r3, [r7, #12]
    6358:	f1b3 3fff 	cmp.w	r3, #4294967295
    635c:	d103      	bne.n	6366 <LPLD_PIT_TimeGetUs+0xba>
    {
        val --;
    635e:	68fb      	ldr	r3, [r7, #12]
    6360:	f103 33ff 	add.w	r3, r3, #4294967295
    6364:	60fb      	str	r3, [r7, #12]
    }
    return (val/(g_bus_clock/1000000));
    6366:	f240 036c 	movw	r3, #108	; 0x6c
    636a:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    636e:	681a      	ldr	r2, [r3, #0]
    6370:	f64d 6383 	movw	r3, #56963	; 0xde83
    6374:	f2c4 331b 	movt	r3, #17179	; 0x431b
    6378:	fba3 1302 	umull	r1, r3, r3, r2
    637c:	ea4f 4393 	mov.w	r3, r3, lsr #18
    6380:	68fa      	ldr	r2, [r7, #12]
    6382:	fbb2 f3f3 	udiv	r3, r2, r3
}
    6386:	4618      	mov	r0, r3
    6388:	f107 0714 	add.w	r7, r7, #20
    638c:	46bd      	mov	sp, r7
    638e:	bc80      	pop	{r7}
    6390:	4770      	bx	lr
    6392:	bf00      	nop

00006394 <LPLD_PIT_TimeClose>:

//关闭PIT计时
void LPLD_PIT_TimeClose(PITx PIT_pitx)
{
    6394:	b480      	push	{r7}
    6396:	b083      	sub	sp, #12
    6398:	af00      	add	r7, sp, #0
    639a:	4603      	mov	r3, r0
    639c:	71fb      	strb	r3, [r7, #7]
    PIT_TFLG (PIT_pitx) |= PIT_TFLG_TIF_MASK;
    639e:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    63a2:	f2c4 0303 	movt	r3, #16387	; 0x4003
    63a6:	79f9      	ldrb	r1, [r7, #7]
    63a8:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    63ac:	f2c4 0203 	movt	r2, #16387	; 0x4003
    63b0:	79f8      	ldrb	r0, [r7, #7]
    63b2:	ea4f 1000 	mov.w	r0, r0, lsl #4
    63b6:	1812      	adds	r2, r2, r0
    63b8:	f502 7284 	add.w	r2, r2, #264	; 0x108
    63bc:	6852      	ldr	r2, [r2, #4]
    63be:	f042 0201 	orr.w	r2, r2, #1
    63c2:	ea4f 1101 	mov.w	r1, r1, lsl #4
    63c6:	185b      	adds	r3, r3, r1
    63c8:	f503 7384 	add.w	r3, r3, #264	; 0x108
    63cc:	605a      	str	r2, [r3, #4]

    //PIT_Flag_Clear(PIT_pitx);
    PIT_TCTRL(PIT_pitx) &= ~PIT_TCTRL_TEN_MASK;
    63ce:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    63d2:	f2c4 0303 	movt	r3, #16387	; 0x4003
    63d6:	79f9      	ldrb	r1, [r7, #7]
    63d8:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    63dc:	f2c4 0203 	movt	r2, #16387	; 0x4003
    63e0:	79f8      	ldrb	r0, [r7, #7]
    63e2:	ea4f 1000 	mov.w	r0, r0, lsl #4
    63e6:	1812      	adds	r2, r2, r0
    63e8:	f502 7284 	add.w	r2, r2, #264	; 0x108
    63ec:	6812      	ldr	r2, [r2, #0]
    63ee:	f022 0201 	bic.w	r2, r2, #1
    63f2:	ea4f 1101 	mov.w	r1, r1, lsl #4
    63f6:	185b      	adds	r3, r3, r1
    63f8:	f503 7384 	add.w	r3, r3, #264	; 0x108
    63fc:	601a      	str	r2, [r3, #0]
}
    63fe:	f107 070c 	add.w	r7, r7, #12
    6402:	46bd      	mov	sp, r7
    6404:	bc80      	pop	{r7}
    6406:	4770      	bx	lr

00006408 <PIT0_IRQHandler>:
 * 与启动文件startup_K60.s中的中断向量表关联
 * 用户无需修改，程序自动进入对应通道中断函数
 */

void PIT0_IRQHandler(void)
{
    6408:	b580      	push	{r7, lr}
    640a:	af00      	add	r7, sp, #0
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif
  
  //调用用户自定义中断服务
  PIT_ISR[0]();  
    640c:	f241 6370 	movw	r3, #5744	; 0x1670
    6410:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    6414:	681b      	ldr	r3, [r3, #0]
    6416:	4798      	blx	r3
  //清除中断标志位
  PIT->CHANNEL[0].TFLG |= PIT_TFLG_TIF_MASK;
    6418:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    641c:	f2c4 0303 	movt	r3, #16387	; 0x4003
    6420:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    6424:	f2c4 0203 	movt	r2, #16387	; 0x4003
    6428:	f8d2 210c 	ldr.w	r2, [r2, #268]	; 0x10c
    642c:	f042 0201 	orr.w	r2, r2, #1
    6430:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
  
#if (UCOS_II > 0u)
  OSIntExit();          //告知系统此时即将离开中断服务子函数
#endif
}
    6434:	bd80      	pop	{r7, pc}
    6436:	bf00      	nop

00006438 <PIT1_IRQHandler>:
void PIT1_IRQHandler(void)
{
    6438:	b580      	push	{r7, lr}
    643a:	af00      	add	r7, sp, #0
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif
  
  //调用用户自定义中断服务
  PIT_ISR[1]();  
    643c:	f241 6370 	movw	r3, #5744	; 0x1670
    6440:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    6444:	685b      	ldr	r3, [r3, #4]
    6446:	4798      	blx	r3
  //清除中断标志位
  PIT->CHANNEL[1].TFLG |= PIT_TFLG_TIF_MASK;
    6448:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    644c:	f2c4 0303 	movt	r3, #16387	; 0x4003
    6450:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    6454:	f2c4 0203 	movt	r2, #16387	; 0x4003
    6458:	f8d2 211c 	ldr.w	r2, [r2, #284]	; 0x11c
    645c:	f042 0201 	orr.w	r2, r2, #1
    6460:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
  
#if (UCOS_II > 0u)
  OSIntExit();          //告知系统此时即将离开中断服务子函数
#endif
}
    6464:	bd80      	pop	{r7, pc}
    6466:	bf00      	nop

00006468 <PIT2_IRQHandler>:
void PIT2_IRQHandler(void)
{
    6468:	b580      	push	{r7, lr}
    646a:	af00      	add	r7, sp, #0
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif
  
  //调用用户自定义中断服务
  PIT_ISR[2]();  
    646c:	f241 6370 	movw	r3, #5744	; 0x1670
    6470:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    6474:	689b      	ldr	r3, [r3, #8]
    6476:	4798      	blx	r3
  //清除中断标志位
  PIT->CHANNEL[2].TFLG |= PIT_TFLG_TIF_MASK;
    6478:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    647c:	f2c4 0303 	movt	r3, #16387	; 0x4003
    6480:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    6484:	f2c4 0203 	movt	r2, #16387	; 0x4003
    6488:	f8d2 212c 	ldr.w	r2, [r2, #300]	; 0x12c
    648c:	f042 0201 	orr.w	r2, r2, #1
    6490:	f8c3 212c 	str.w	r2, [r3, #300]	; 0x12c
  
#if (UCOS_II > 0u)
  OSIntExit();          //告知系统此时即将离开中断服务子函数
#endif
}
    6494:	bd80      	pop	{r7, pc}
    6496:	bf00      	nop

00006498 <PIT3_IRQHandler>:
void PIT3_IRQHandler(void)
{
    6498:	b580      	push	{r7, lr}
    649a:	af00      	add	r7, sp, #0
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif
  
  //调用用户自定义中断服务
  PIT_ISR[3]();  
    649c:	f241 6370 	movw	r3, #5744	; 0x1670
    64a0:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    64a4:	68db      	ldr	r3, [r3, #12]
    64a6:	4798      	blx	r3
  //清除中断标志位
  PIT->CHANNEL[3].TFLG |= PIT_TFLG_TIF_MASK;
    64a8:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    64ac:	f2c4 0303 	movt	r3, #16387	; 0x4003
    64b0:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    64b4:	f2c4 0203 	movt	r2, #16387	; 0x4003
    64b8:	f8d2 213c 	ldr.w	r2, [r2, #316]	; 0x13c
    64bc:	f042 0201 	orr.w	r2, r2, #1
    64c0:	f8c3 213c 	str.w	r2, [r3, #316]	; 0x13c
}
    64c4:	bd80      	pop	{r7, pc}
    64c6:	bf00      	nop

000064c8 <LPLD_SPI_Init>:
 *    0--ô
 *    1--óɹ
 */

uint8 LPLD_SPI_Init(SPI_InitTypeDef spi_init_structure)
{
    64c8:	b084      	sub	sp, #16
    64ca:	b480      	push	{r7}
    64cc:	b08f      	sub	sp, #60	; 0x3c
    64ce:	af00      	add	r7, sp, #0
    64d0:	f107 0c40 	add.w	ip, r7, #64	; 0x40
    64d4:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  SPI_MemMapPtr spix = spi_init_structure.SPI_SPIx;
    64d8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    64da:	637b      	str	r3, [r7, #52]	; 0x34
  uint8 spi_mode = spi_init_structure.SPI_ModeSelect;
    64dc:	f897 3044 	ldrb.w	r3, [r7, #68]	; 0x44
    64e0:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
  uint8 sck_div = spi_init_structure.SPI_SckDivider; 
    64e4:	f897 3045 	ldrb.w	r3, [r7, #69]	; 0x45
    64e8:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
  boolean txFIFO_enable = spi_init_structure.SPI_EnableTxFIFO;
    64ec:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
    64f0:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31
  boolean rxFIFO_enable = spi_init_structure.SPI_EnableRxFIFO;
    64f4:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
    64f8:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
  //SPIжϱ
  boolean tx_complete_int = spi_init_structure.SPI_TxCompleteIntEnable;
    64fc:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
    6500:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  boolean QueueEnd_Request_int = spi_init_structure.SPI_QueueEndIntEnable; 
    6504:	f897 3049 	ldrb.w	r3, [r7, #73]	; 0x49
    6508:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
  boolean txFIFO_underflow_int = spi_init_structure.SPI_TxFIFO_UnderflowIntEnable;
    650c:	f897 304a 	ldrb.w	r3, [r7, #74]	; 0x4a
    6510:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
  boolean rxFIFO_overflow_int = spi_init_structure.SPI_RxFIFO_OverflowIntEnable;
    6514:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
    6518:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
  boolean txFIFO_Fill_int = spi_init_structure.SPI_TxFIFO_FillIntEnable;
    651c:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
    6520:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  boolean rxFIFO_Drain_int = spi_init_structure.SPI_RxFIFO_DrainIntEnable; 
    6524:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
    6528:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
  boolean txFIFO_req = spi_init_structure.SPI_TxFIFO_RequestSelect;
    652c:	f897 304e 	ldrb.w	r3, [r7, #78]	; 0x4e
    6530:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29
  boolean rxFIFO_req = spi_init_structure.SPI_RxFIFO_RequestSelect;
    6534:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
    6538:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
  //ѡSPI
  PortPinsEnum_Type miso_pin = spi_init_structure.SPI_MisoPin;//MISO 
    653c:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
    6540:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  PortPinsEnum_Type mosi_pin = spi_init_structure.SPI_MosiPin;//MOSI
    6544:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
    6548:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
  PortPinsEnum_Type sck_pin = spi_init_structure.SPI_SckPin;  //SCK
    654c:	f897 3056 	ldrb.w	r3, [r7, #86]	; 0x56
    6550:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
  PortPinsEnum_Type pcs0_pin = spi_init_structure.SPI_Pcs0Pin;//PCS0
    6554:	f897 3050 	ldrb.w	r3, [r7, #80]	; 0x50
    6558:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
  PortPinsEnum_Type pcs1_pin = spi_init_structure.SPI_Pcs1Pin;//PCS1
    655c:	f897 3051 	ldrb.w	r3, [r7, #81]	; 0x51
    6560:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  PortPinsEnum_Type pcs2_pin = spi_init_structure.SPI_Pcs2Pin;//PCS2
    6564:	f897 3052 	ldrb.w	r3, [r7, #82]	; 0x52
    6568:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
  PortPinsEnum_Type pcs3_pin = spi_init_structure.SPI_Pcs3Pin;//PCS3
    656c:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
    6570:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
  PortPinsEnum_Type pcs4_pin = spi_init_structure.SPI_Pcs4Pin;//PCS4
    6574:	f897 3054 	ldrb.w	r3, [r7, #84]	; 0x54
    6578:	f887 3020 	strb.w	r3, [r7, #32]
  PortPinsEnum_Type pcs5_pin = spi_init_structure.SPI_Pcs5Pin;//PCS5
    657c:	f897 3055 	ldrb.w	r3, [r7, #85]	; 0x55
    6580:	77fb      	strb	r3, [r7, #31]
  //жϻص
  SPI_ISR_CALLBACK TxComplete_isr = spi_init_structure.SPI_TxCompleteIntIsr;
    6582:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    6584:	61bb      	str	r3, [r7, #24]
  SPI_ISR_CALLBACK QueueEndReq_isr = spi_init_structure.SPI_QueueEndIntIsr;
    6586:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    6588:	617b      	str	r3, [r7, #20]
  SPI_ISR_CALLBACK UnderflowInt_isr = spi_init_structure.SPI_TxFIFO_UnderflowIntIsr;
    658a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    658c:	613b      	str	r3, [r7, #16]
  SPI_ISR_CALLBACK OverflowInt_isr = spi_init_structure.SPI_RxFIFO_OverflowIntIsr;
    658e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    6590:	60fb      	str	r3, [r7, #12]
  SPI_ISR_CALLBACK FillInt_isr = spi_init_structure.SPI_TxFIFO_FillIntIsr;
    6592:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    6594:	60bb      	str	r3, [r7, #8]
  SPI_ISR_CALLBACK DrainInt_isr = spi_init_structure.SPI_RxFIFO_DrainIntIsr;
    6596:	6f3b      	ldr	r3, [r7, #112]	; 0x70
    6598:	607b      	str	r3, [r7, #4]
 
    if (spi_mode <= SPI_MODE_MASTER || sck_div <= SPI_SCK_DIV_32768)
    659a:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
    659e:	2b00      	cmp	r3, #0
    65a0:	d003      	beq.n	65aa <LPLD_SPI_Init+0xe2>
    65a2:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
    65a6:	2b0f      	cmp	r3, #15
    65a8:	d802      	bhi.n	65b0 <LPLD_SPI_Init+0xe8>
        return 0;
    65aa:	f04f 0300 	mov.w	r3, #0
    65ae:	e359      	b.n	6c64 <LPLD_SPI_Init+0x79c>
    //

  if(spix == SPI0)
    65b0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    65b2:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    65b6:	f2c4 0302 	movt	r3, #16386	; 0x4002
    65ba:	429a      	cmp	r2, r3
    65bc:	d12b      	bne.n	6616 <LPLD_SPI_Init+0x14e>
  {
    SIM_SCGC6 |= SIM_SCGC6_DSPI0_MASK;  
    65be:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    65c2:	f2c4 0304 	movt	r3, #16388	; 0x4004
    65c6:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    65ca:	f2c4 0204 	movt	r2, #16388	; 0x4004
    65ce:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    65d2:	f102 021c 	add.w	r2, r2, #28
    65d6:	6812      	ldr	r2, [r2, #0]
    65d8:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
    65dc:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    65e0:	f103 031c 	add.w	r3, r3, #28
    65e4:	601a      	str	r2, [r3, #0]

    //ѡPCS0
    switch(pcs0_pin)
    65e6:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
    65ea:	2b0e      	cmp	r3, #14
    65ec:	d002      	beq.n	65f4 <LPLD_SPI_Init+0x12c>
    65ee:	2b40      	cmp	r3, #64	; 0x40
    65f0:	d007      	beq.n	6602 <LPLD_SPI_Init+0x13a>
    65f2:	e00d      	b.n	6610 <LPLD_SPI_Init+0x148>
    {
        case PTA14:
            PORTA->PCR[14] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    65f4:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    65f8:	f2c4 0304 	movt	r3, #16388	; 0x4004
    65fc:	f44f 7210 	mov.w	r2, #576	; 0x240
    6600:	639a      	str	r2, [r3, #56]	; 0x38
        case PTC4:
            PORTA->PCR[4] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    6602:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    6606:	f2c4 0304 	movt	r3, #16388	; 0x4004
    660a:	f44f 7210 	mov.w	r2, #576	; 0x240
    660e:	611a      	str	r2, [r3, #16]
        default:
            return 0;
    6610:	f04f 0300 	mov.w	r3, #0
    6614:	e326      	b.n	6c64 <LPLD_SPI_Init+0x79c>
    else if (miso_pin == PTC7)//miso_pin == PTC7
    {
      PORTC->PCR[7] = 0 | PORT_PCR_MUX(2); //SIN
    } 
  }
  else if(spix == SPI1)
    6616:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    6618:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    661c:	f2c4 0302 	movt	r3, #16386	; 0x4002
    6620:	429a      	cmp	r2, r3
    6622:	f040 809f 	bne.w	6764 <LPLD_SPI_Init+0x29c>
  {
    SIM_SCGC6 |= SIM_SCGC6_DSPI1_MASK;
    6626:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    662a:	f2c4 0304 	movt	r3, #16388	; 0x4004
    662e:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    6632:	f2c4 0204 	movt	r2, #16388	; 0x4004
    6636:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    663a:	f102 021c 	add.w	r2, r2, #28
    663e:	6812      	ldr	r2, [r2, #0]
    6640:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
    6644:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    6648:	f103 031c 	add.w	r3, r3, #28
    664c:	601a      	str	r2, [r3, #0]
    //ѡPCS0
    if(pcs0_pin == PTB10)
    664e:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
    6652:	2b2a      	cmp	r3, #42	; 0x2a
    6654:	d107      	bne.n	6666 <LPLD_SPI_Init+0x19e>
    {
      PORTB->PCR[10] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    6656:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    665a:	f2c4 0304 	movt	r3, #16388	; 0x4004
    665e:	f44f 7210 	mov.w	r2, #576	; 0x240
    6662:	629a      	str	r2, [r3, #40]	; 0x28
    6664:	e00a      	b.n	667c <LPLD_SPI_Init+0x1b4>
    }
    else if (pcs0_pin == PTE4)//pcs0_pin == PTE4
    6666:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
    666a:	2b80      	cmp	r3, #128	; 0x80
    666c:	d106      	bne.n	667c <LPLD_SPI_Init+0x1b4>
    {
      PORTE->PCR[4] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    666e:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    6672:	f2c4 0304 	movt	r3, #16388	; 0x4004
    6676:	f44f 7210 	mov.w	r2, #576	; 0x240
    667a:	611a      	str	r2, [r3, #16]
    }
    //ѡPCS1
    if(pcs1_pin == PTB9)
    667c:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    6680:	2b29      	cmp	r3, #41	; 0x29
    6682:	d107      	bne.n	6694 <LPLD_SPI_Init+0x1cc>
    {
      PORTB->PCR[9]  = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    6684:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    6688:	f2c4 0304 	movt	r3, #16388	; 0x4004
    668c:	f44f 7210 	mov.w	r2, #576	; 0x240
    6690:	625a      	str	r2, [r3, #36]	; 0x24
    6692:	e00a      	b.n	66aa <LPLD_SPI_Init+0x1e2>
    }
    else if (pcs1_pin == PTE0)//pcs1_pin == PTE0
    6694:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    6698:	2b7c      	cmp	r3, #124	; 0x7c
    669a:	d106      	bne.n	66aa <LPLD_SPI_Init+0x1e2>
    {
      PORTE->PCR[0] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    669c:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    66a0:	f2c4 0304 	movt	r3, #16388	; 0x4004
    66a4:	f44f 7210 	mov.w	r2, #576	; 0x240
    66a8:	601a      	str	r2, [r3, #0]
    }
    //ѡPCS2
    if(pcs2_pin == PTE5)
    66aa:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
    66ae:	2b81      	cmp	r3, #129	; 0x81
    66b0:	d106      	bne.n	66c0 <LPLD_SPI_Init+0x1f8>
    {
      PORTE->PCR[5]  = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    66b2:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    66b6:	f2c4 0304 	movt	r3, #16388	; 0x4004
    66ba:	f44f 7210 	mov.w	r2, #576	; 0x240
    66be:	615a      	str	r2, [r3, #20]
    }

    //ѡPCS3
    if(pcs3_pin == PTE6)
    66c0:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
    66c4:	2b82      	cmp	r3, #130	; 0x82
    66c6:	d106      	bne.n	66d6 <LPLD_SPI_Init+0x20e>
    {
      PORTE->PCR[6]  = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    66c8:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    66cc:	f2c4 0304 	movt	r3, #16388	; 0x4004
    66d0:	f44f 7210 	mov.w	r2, #576	; 0x240
    66d4:	619a      	str	r2, [r3, #24]
    }

    //ѡSCK
    if(sck_pin == PTB11)
    66d6:	f897 3025 	ldrb.w	r3, [r7, #37]	; 0x25
    66da:	2b2b      	cmp	r3, #43	; 0x2b
    66dc:	d107      	bne.n	66ee <LPLD_SPI_Init+0x226>
    {
      PORTB->PCR[11] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    66de:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    66e2:	f2c4 0304 	movt	r3, #16388	; 0x4004
    66e6:	f44f 7210 	mov.w	r2, #576	; 0x240
    66ea:	62da      	str	r2, [r3, #44]	; 0x2c
    66ec:	e00a      	b.n	6704 <LPLD_SPI_Init+0x23c>
    }
    else if (sck_pin == PTE2)//sck_pin == PTE2
    66ee:	f897 3025 	ldrb.w	r3, [r7, #37]	; 0x25
    66f2:	2b7e      	cmp	r3, #126	; 0x7e
    66f4:	d106      	bne.n	6704 <LPLD_SPI_Init+0x23c>
    {
      PORTE->PCR[2] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;//SCK
    66f6:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    66fa:	f2c4 0304 	movt	r3, #16388	; 0x4004
    66fe:	f44f 7210 	mov.w	r2, #576	; 0x240
    6702:	609a      	str	r2, [r3, #8]
    }
    //ѡMOSI
    if(mosi_pin == PTB16)
    6704:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
    6708:	2b30      	cmp	r3, #48	; 0x30
    670a:	d107      	bne.n	671c <LPLD_SPI_Init+0x254>
    {
      PORTB->PCR[16] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;//SOUT
    670c:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    6710:	f2c4 0304 	movt	r3, #16388	; 0x4004
    6714:	f44f 7210 	mov.w	r2, #576	; 0x240
    6718:	641a      	str	r2, [r3, #64]	; 0x40
    671a:	e00a      	b.n	6732 <LPLD_SPI_Init+0x26a>
    }
    else if (mosi_pin == PTE1)//mosi_pin == PTE1
    671c:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
    6720:	2b7d      	cmp	r3, #125	; 0x7d
    6722:	d106      	bne.n	6732 <LPLD_SPI_Init+0x26a>
    {
      PORTE->PCR[1] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;//SOUT
    6724:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    6728:	f2c4 0304 	movt	r3, #16388	; 0x4004
    672c:	f44f 7210 	mov.w	r2, #576	; 0x240
    6730:	605a      	str	r2, [r3, #4]
    }
    //ѡMISO
    if(miso_pin == PTB17)
    6732:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
    6736:	2b31      	cmp	r3, #49	; 0x31
    6738:	d107      	bne.n	674a <LPLD_SPI_Init+0x282>
    {
      PORTB->PCR[17] = 0 | PORT_PCR_MUX(2); //SIN
    673a:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    673e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    6742:	f44f 7200 	mov.w	r2, #512	; 0x200
    6746:	645a      	str	r2, [r3, #68]	; 0x44
    6748:	e08e      	b.n	6868 <LPLD_SPI_Init+0x3a0>
    }
    else if (miso_pin == PTE3)//miso_pin == PTE3
    674a:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
    674e:	2b7f      	cmp	r3, #127	; 0x7f
    6750:	f040 808a 	bne.w	6868 <LPLD_SPI_Init+0x3a0>
    {
      PORTE->PCR[3] = 0 | PORT_PCR_MUX(2); //SIN
    6754:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    6758:	f2c4 0304 	movt	r3, #16388	; 0x4004
    675c:	f44f 7200 	mov.w	r2, #512	; 0x200
    6760:	60da      	str	r2, [r3, #12]
    6762:	e081      	b.n	6868 <LPLD_SPI_Init+0x3a0>
    } 
  }
  else if(spix == SPI2)
    6764:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    6766:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    676a:	f2c4 030a 	movt	r3, #16394	; 0x400a
    676e:	429a      	cmp	r2, r3
    6770:	d17a      	bne.n	6868 <LPLD_SPI_Init+0x3a0>
  {
    SIM_SCGC3 |= SIM_SCGC3_DSPI2_MASK;
    6772:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    6776:	f2c4 0304 	movt	r3, #16388	; 0x4004
    677a:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    677e:	f2c4 0204 	movt	r2, #16388	; 0x4004
    6782:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    6786:	f102 0210 	add.w	r2, r2, #16
    678a:	6812      	ldr	r2, [r2, #0]
    678c:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
    6790:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    6794:	f103 0310 	add.w	r3, r3, #16
    6798:	601a      	str	r2, [r3, #0]
    //ѡPCS0
    if(pcs0_pin == PTD11)
    679a:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
    679e:	2b67      	cmp	r3, #103	; 0x67
    67a0:	d107      	bne.n	67b2 <LPLD_SPI_Init+0x2ea>
    {
      PORTD->PCR[11] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    67a2:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    67a6:	f2c4 0304 	movt	r3, #16388	; 0x4004
    67aa:	f44f 7210 	mov.w	r2, #576	; 0x240
    67ae:	62da      	str	r2, [r3, #44]	; 0x2c
    67b0:	e00a      	b.n	67c8 <LPLD_SPI_Init+0x300>
    }
    else if (pcs0_pin == PTB20)//pcs0_pin == PTB20
    67b2:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
    67b6:	2b34      	cmp	r3, #52	; 0x34
    67b8:	d106      	bne.n	67c8 <LPLD_SPI_Init+0x300>
    {
      PORTB->PCR[20] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    67ba:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    67be:	f2c4 0304 	movt	r3, #16388	; 0x4004
    67c2:	f44f 7210 	mov.w	r2, #576	; 0x240
    67c6:	651a      	str	r2, [r3, #80]	; 0x50
    }
    //ѡPCS1
    if(pcs1_pin == PTD15)
    67c8:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    67cc:	2b6b      	cmp	r3, #107	; 0x6b
    67ce:	d106      	bne.n	67de <LPLD_SPI_Init+0x316>
    {
      PORTD->PCR[15]  = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    67d0:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    67d4:	f2c4 0304 	movt	r3, #16388	; 0x4004
    67d8:	f44f 7210 	mov.w	r2, #576	; 0x240
    67dc:	63da      	str	r2, [r3, #60]	; 0x3c
    }

    //ѡSCK
    if(sck_pin == PTD12)
    67de:	f897 3025 	ldrb.w	r3, [r7, #37]	; 0x25
    67e2:	2b68      	cmp	r3, #104	; 0x68
    67e4:	d107      	bne.n	67f6 <LPLD_SPI_Init+0x32e>
    {
      PORTD->PCR[12] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    67e6:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    67ea:	f2c4 0304 	movt	r3, #16388	; 0x4004
    67ee:	f44f 7210 	mov.w	r2, #576	; 0x240
    67f2:	631a      	str	r2, [r3, #48]	; 0x30
    67f4:	e00a      	b.n	680c <LPLD_SPI_Init+0x344>
    }
    else if (sck_pin == PTB21)//sck_pin == PTB21
    67f6:	f897 3025 	ldrb.w	r3, [r7, #37]	; 0x25
    67fa:	2b35      	cmp	r3, #53	; 0x35
    67fc:	d106      	bne.n	680c <LPLD_SPI_Init+0x344>
    {
      PORTB->PCR[21] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;//SCK
    67fe:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    6802:	f2c4 0304 	movt	r3, #16388	; 0x4004
    6806:	f44f 7210 	mov.w	r2, #576	; 0x240
    680a:	655a      	str	r2, [r3, #84]	; 0x54
    }
    //ѡMOSI
    if(mosi_pin == PTD13)
    680c:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
    6810:	2b69      	cmp	r3, #105	; 0x69
    6812:	d107      	bne.n	6824 <LPLD_SPI_Init+0x35c>
    {
      PORTD->PCR[13] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;//SOUT
    6814:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    6818:	f2c4 0304 	movt	r3, #16388	; 0x4004
    681c:	f44f 7210 	mov.w	r2, #576	; 0x240
    6820:	635a      	str	r2, [r3, #52]	; 0x34
    6822:	e00a      	b.n	683a <LPLD_SPI_Init+0x372>
    }
    else if (mosi_pin == PTB22)//mosi_pin == PTB22
    6824:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
    6828:	2b36      	cmp	r3, #54	; 0x36
    682a:	d106      	bne.n	683a <LPLD_SPI_Init+0x372>
    {
      PORTB->PCR[22] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;//SOUT
    682c:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    6830:	f2c4 0304 	movt	r3, #16388	; 0x4004
    6834:	f44f 7210 	mov.w	r2, #576	; 0x240
    6838:	659a      	str	r2, [r3, #88]	; 0x58
    }
    //ѡMISO
    if(miso_pin == PTD14)
    683a:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
    683e:	2b6a      	cmp	r3, #106	; 0x6a
    6840:	d107      	bne.n	6852 <LPLD_SPI_Init+0x38a>
    {
      PORTD->PCR[14] = 0 | PORT_PCR_MUX(2); //SIN
    6842:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    6846:	f2c4 0304 	movt	r3, #16388	; 0x4004
    684a:	f44f 7200 	mov.w	r2, #512	; 0x200
    684e:	639a      	str	r2, [r3, #56]	; 0x38
    6850:	e00a      	b.n	6868 <LPLD_SPI_Init+0x3a0>
    }
    else if (miso_pin == PTB23)//miso_pin == PTB23
    6852:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
    6856:	2b37      	cmp	r3, #55	; 0x37
    6858:	d106      	bne.n	6868 <LPLD_SPI_Init+0x3a0>
    {
      PORTB->PCR[23] = 0 | PORT_PCR_MUX(2); //SIN
    685a:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    685e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    6862:	f44f 7200 	mov.w	r2, #512	; 0x200
    6866:	65da      	str	r2, [r3, #92]	; 0x5c
    } 
  }

  spix->MCR &=  ~(SPI_MCR_MDIS_MASK);
    6868:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    686a:	681b      	ldr	r3, [r3, #0]
    686c:	f423 4280 	bic.w	r2, r3, #16384	; 0x4000
    6870:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6872:	601a      	str	r2, [r3, #0]
  spix->MCR |=  (SPI_MCR_HALT_MASK        
    6874:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6876:	681a      	ldr	r2, [r3, #0]
    6878:	f640 4301 	movw	r3, #3073	; 0xc01
    687c:	f2c0 033f 	movt	r3, #63	; 0x3f
    6880:	4313      	orrs	r3, r2
    6882:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    6884:	6013      	str	r3, [r2, #0]
                |SPI_MCR_PCSIS_MASK       
                |SPI_MCR_CLR_TXF_MASK    
                |SPI_MCR_CLR_RXF_MASK); 
 
  //ѡSPIģʽ
  switch (spi_mode)
    6886:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
    688a:	2b00      	cmp	r3, #0
    688c:	d008      	beq.n	68a0 <LPLD_SPI_Init+0x3d8>
    688e:	2b01      	cmp	r3, #1
    6890:	d10d      	bne.n	68ae <LPLD_SPI_Init+0x3e6>
  {
    case SPI_MODE_SLAVE:
        spix->MCR &= ~SPI_MCR_MSTR_MASK;
    6892:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6894:	681b      	ldr	r3, [r3, #0]
    6896:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    689a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    689c:	601a      	str	r2, [r3, #0]
        break;
    689e:	e009      	b.n	68b4 <LPLD_SPI_Init+0x3ec>
    case SPI_MODE_MASTER:
        spix->MCR |= SPI_MCR_MSTR_MASK;
    68a0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    68a2:	681b      	ldr	r3, [r3, #0]
    68a4:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
    68a8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    68aa:	601a      	str	r2, [r3, #0]
        break;
    68ac:	e002      	b.n	68b4 <LPLD_SPI_Init+0x3ec>
    default:
        return 0;
    68ae:	f04f 0300 	mov.w	r3, #0
    68b2:	e1d7      	b.n	6c64 <LPLD_SPI_Init+0x79c>
  }

  //ѡʹtx FIFO
  if(txFIFO_enable == TRUE)
    68b4:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
    68b8:	2b01      	cmp	r3, #1
    68ba:	d106      	bne.n	68ca <LPLD_SPI_Init+0x402>
  {
    spix->MCR &= ~SPI_MCR_DIS_TXF_MASK; 
    68bc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    68be:	681b      	ldr	r3, [r3, #0]
    68c0:	f423 5200 	bic.w	r2, r3, #8192	; 0x2000
    68c4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    68c6:	601a      	str	r2, [r3, #0]
    68c8:	e005      	b.n	68d6 <LPLD_SPI_Init+0x40e>
  }
  else
  {
    spix->MCR |= SPI_MCR_DIS_TXF_MASK;//ѡͳʽ
    68ca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    68cc:	681b      	ldr	r3, [r3, #0]
    68ce:	f443 5200 	orr.w	r2, r3, #8192	; 0x2000
    68d2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    68d4:	601a      	str	r2, [r3, #0]
  }
  //ѡʹRx FIFO
  if(rxFIFO_enable == TRUE)
    68d6:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
    68da:	2b01      	cmp	r3, #1
    68dc:	d106      	bne.n	68ec <LPLD_SPI_Init+0x424>
  {
    spix->MCR &= ~SPI_MCR_DIS_RXF_MASK;
    68de:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    68e0:	681b      	ldr	r3, [r3, #0]
    68e2:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
    68e6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    68e8:	601a      	str	r2, [r3, #0]
    68ea:	e005      	b.n	68f8 <LPLD_SPI_Init+0x430>
  }
  else
  {
    spix->MCR |= SPI_MCR_DIS_RXF_MASK; //ѡͳʽ
    68ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    68ee:	681b      	ldr	r3, [r3, #0]
    68f0:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
    68f4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    68f6:	601a      	str	r2, [r3, #0]
  }
  //ѡʹܷж
  if(tx_complete_int == TRUE)
    68f8:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    68fc:	2b01      	cmp	r3, #1
    68fe:	d106      	bne.n	690e <LPLD_SPI_Init+0x446>
  {
    spix->RSER |= SPI_RSER_TCF_RE_MASK; 
    6900:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6902:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    6904:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
    6908:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    690a:	631a      	str	r2, [r3, #48]	; 0x30
    690c:	e005      	b.n	691a <LPLD_SPI_Init+0x452>
  }
  else
  { 
    spix->RSER &= ~SPI_RSER_TCF_RE_MASK;
    690e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6910:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    6912:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    6916:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6918:	631a      	str	r2, [r3, #48]	; 0x30
  }
  //ѡʹܷͶнж
  if(QueueEnd_Request_int == TRUE)
    691a:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
    691e:	2b01      	cmp	r3, #1
    6920:	d106      	bne.n	6930 <LPLD_SPI_Init+0x468>
  {
    spix->RSER |=SPI_RSER_EOQF_RE_MASK;
    6922:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6924:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    6926:	f043 5280 	orr.w	r2, r3, #268435456	; 0x10000000
    692a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    692c:	631a      	str	r2, [r3, #48]	; 0x30
    692e:	e005      	b.n	693c <LPLD_SPI_Init+0x474>
  }
  else
    spix->RSER &= ~SPI_RSER_EOQF_RE_MASK;
    6930:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6932:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    6934:	f023 5280 	bic.w	r2, r3, #268435456	; 0x10000000
    6938:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    693a:	631a      	str	r2, [r3, #48]	; 0x30
  //ѡʹtxFIFOΪж
  if(txFIFO_underflow_int== TRUE)
    693c:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    6940:	2b01      	cmp	r3, #1
    6942:	d106      	bne.n	6952 <LPLD_SPI_Init+0x48a>
  {
    spix->RSER |=SPI_RSER_TFUF_RE_MASK;
    6944:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6946:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    6948:	f043 6200 	orr.w	r2, r3, #134217728	; 0x8000000
    694c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    694e:	631a      	str	r2, [r3, #48]	; 0x30
    6950:	e005      	b.n	695e <LPLD_SPI_Init+0x496>
  }
  else
    spix->RSER &= ~SPI_RSER_TFUF_RE_MASK;
    6952:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6954:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    6956:	f023 6200 	bic.w	r2, r3, #134217728	; 0x8000000
    695a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    695c:	631a      	str	r2, [r3, #48]	; 0x30
  //ѡʹrxFIFOж
  if(rxFIFO_overflow_int== TRUE)
    695e:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    6962:	2b01      	cmp	r3, #1
    6964:	d106      	bne.n	6974 <LPLD_SPI_Init+0x4ac>
  {
    spix->RSER |=SPI_RSER_RFOF_RE_MASK;
    6966:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6968:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    696a:	f443 2200 	orr.w	r2, r3, #524288	; 0x80000
    696e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6970:	631a      	str	r2, [r3, #48]	; 0x30
    6972:	e005      	b.n	6980 <LPLD_SPI_Init+0x4b8>
  }
  else
  {
    spix->RSER &= ~SPI_RSER_RFOF_RE_MASK;
    6974:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6976:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    6978:	f423 2200 	bic.w	r2, r3, #524288	; 0x80000
    697c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    697e:	631a      	str	r2, [r3, #48]	; 0x30
  }
  //ѡʹtxFIFOݽжϻDMA
  if(txFIFO_Fill_int== TRUE)
    6980:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
    6984:	2b01      	cmp	r3, #1
    6986:	d106      	bne.n	6996 <LPLD_SPI_Init+0x4ce>
  {
    spix->RSER |=SPI_RSER_TFFF_RE_MASK;
    6988:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    698a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    698c:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
    6990:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6992:	631a      	str	r2, [r3, #48]	; 0x30
    6994:	e005      	b.n	69a2 <LPLD_SPI_Init+0x4da>
  }
  else
  {
    spix->RSER &= ~SPI_RSER_TFFF_RE_MASK;
    6996:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6998:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    699a:	f023 7200 	bic.w	r2, r3, #33554432	; 0x2000000
    699e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    69a0:	631a      	str	r2, [r3, #48]	; 0x30
  }
  //ѡʹrxFIFOǿжϻDMA
  if(rxFIFO_Drain_int== TRUE)
    69a2:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
    69a6:	2b01      	cmp	r3, #1
    69a8:	d106      	bne.n	69b8 <LPLD_SPI_Init+0x4f0>
  {
    spix->RSER |=SPI_RSER_RFDF_RE_MASK;
    69aa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    69ac:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    69ae:	f443 3200 	orr.w	r2, r3, #131072	; 0x20000
    69b2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    69b4:	631a      	str	r2, [r3, #48]	; 0x30
    69b6:	e005      	b.n	69c4 <LPLD_SPI_Init+0x4fc>
  }
  else
  {
    spix->RSER &= ~SPI_RSER_RFDF_RE_MASK;
    69b8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    69ba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    69bc:	f423 3200 	bic.w	r2, r3, #131072	; 0x20000
    69c0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    69c2:	631a      	str	r2, [r3, #48]	; 0x30
  }
  //ѡʹtxFIFOжϻDMA
  if(txFIFO_req == SPI_FIFO_DMAREQUEST)
    69c4:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
    69c8:	2b01      	cmp	r3, #1
    69ca:	d106      	bne.n	69da <LPLD_SPI_Init+0x512>
  {
    spix->RSER |=SPI_RSER_TFFF_DIRS_MASK;
    69cc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    69ce:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    69d0:	f043 7280 	orr.w	r2, r3, #16777216	; 0x1000000
    69d4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    69d6:	631a      	str	r2, [r3, #48]	; 0x30
    69d8:	e005      	b.n	69e6 <LPLD_SPI_Init+0x51e>
  }
  else
  {
    spix->RSER &= ~SPI_RSER_TFFF_DIRS_MASK;
    69da:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    69dc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    69de:	f023 7280 	bic.w	r2, r3, #16777216	; 0x1000000
    69e2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    69e4:	631a      	str	r2, [r3, #48]	; 0x30
  }
  //ѡʹrxFIFOжϻDMA
  if(rxFIFO_req == SPI_FIFO_DMAREQUEST)
    69e6:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
    69ea:	2b01      	cmp	r3, #1
    69ec:	d106      	bne.n	69fc <LPLD_SPI_Init+0x534>
  {
    spix->RSER |= SPI_RSER_RFDF_DIRS_MASK;
    69ee:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    69f0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    69f2:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
    69f6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    69f8:	631a      	str	r2, [r3, #48]	; 0x30
    69fa:	e005      	b.n	6a08 <LPLD_SPI_Init+0x540>
  }
  else 
  {
    spix->RSER &= ~SPI_RSER_RFDF_DIRS_MASK;
    69fc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    69fe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    6a00:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
    6a04:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6a06:	631a      	str	r2, [r3, #48]	; 0x30
  }
  //жϻص

  if(spix == SPI0)
    6a08:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    6a0a:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    6a0e:	f2c4 0302 	movt	r3, #16386	; 0x4002
    6a12:	429a      	cmp	r2, r3
    6a14:	d146      	bne.n	6aa4 <LPLD_SPI_Init+0x5dc>
  {
    if(tx_complete_int == TRUE)
    6a16:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    6a1a:	2b01      	cmp	r3, #1
    6a1c:	d105      	bne.n	6a2a <LPLD_SPI_Init+0x562>
    { SPI0_ISR[SPI_TxComplete_Int] = TxComplete_isr; }
    6a1e:	f241 6398 	movw	r3, #5784	; 0x1698
    6a22:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    6a26:	69ba      	ldr	r2, [r7, #24]
    6a28:	601a      	str	r2, [r3, #0]
    if(QueueEnd_Request_int == TRUE)
    6a2a:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
    6a2e:	2b01      	cmp	r3, #1
    6a30:	d105      	bne.n	6a3e <LPLD_SPI_Init+0x576>
    { SPI0_ISR[SPI_QueueEndReq_Int] = QueueEndReq_isr; }
    6a32:	f241 6398 	movw	r3, #5784	; 0x1698
    6a36:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    6a3a:	697a      	ldr	r2, [r7, #20]
    6a3c:	605a      	str	r2, [r3, #4]
    if(txFIFO_underflow_int == TRUE)
    6a3e:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    6a42:	2b01      	cmp	r3, #1
    6a44:	d105      	bne.n	6a52 <LPLD_SPI_Init+0x58a>
    { SPI0_ISR[SPI_TxFIFO_UnderflowInt] = UnderflowInt_isr; }
    6a46:	f241 6398 	movw	r3, #5784	; 0x1698
    6a4a:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    6a4e:	693a      	ldr	r2, [r7, #16]
    6a50:	609a      	str	r2, [r3, #8]
    if(rxFIFO_overflow_int == TRUE)
    6a52:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    6a56:	2b01      	cmp	r3, #1
    6a58:	d105      	bne.n	6a66 <LPLD_SPI_Init+0x59e>
    { SPI0_ISR[SPI_RxFIFO_OverflowInt] = OverflowInt_isr; }
    6a5a:	f241 6398 	movw	r3, #5784	; 0x1698
    6a5e:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    6a62:	68fa      	ldr	r2, [r7, #12]
    6a64:	60da      	str	r2, [r3, #12]
    if(txFIFO_Fill_int == TRUE && txFIFO_req == SPI_FIFO_INTREQUEST)
    6a66:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
    6a6a:	2b01      	cmp	r3, #1
    6a6c:	d109      	bne.n	6a82 <LPLD_SPI_Init+0x5ba>
    6a6e:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
    6a72:	2b00      	cmp	r3, #0
    6a74:	d105      	bne.n	6a82 <LPLD_SPI_Init+0x5ba>
    { SPI0_ISR[SPI_TxFIFO_FillInt] = FillInt_isr; }
    6a76:	f241 6398 	movw	r3, #5784	; 0x1698
    6a7a:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    6a7e:	68ba      	ldr	r2, [r7, #8]
    6a80:	611a      	str	r2, [r3, #16]
    if(rxFIFO_Drain_int == TRUE && rxFIFO_req == SPI_FIFO_INTREQUEST)
    6a82:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
    6a86:	2b01      	cmp	r3, #1
    6a88:	f040 80a3 	bne.w	6bd2 <LPLD_SPI_Init+0x70a>
    6a8c:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
    6a90:	2b00      	cmp	r3, #0
    6a92:	f040 809e 	bne.w	6bd2 <LPLD_SPI_Init+0x70a>
    { SPI0_ISR[SPI_RxFIFO_DrainInt] = DrainInt_isr; }
    6a96:	f241 6398 	movw	r3, #5784	; 0x1698
    6a9a:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    6a9e:	687a      	ldr	r2, [r7, #4]
    6aa0:	615a      	str	r2, [r3, #20]
    6aa2:	e096      	b.n	6bd2 <LPLD_SPI_Init+0x70a>
  }
  else if (spix == SPI1)
    6aa4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    6aa6:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    6aaa:	f2c4 0302 	movt	r3, #16386	; 0x4002
    6aae:	429a      	cmp	r2, r3
    6ab0:	d144      	bne.n	6b3c <LPLD_SPI_Init+0x674>
  {
    if(tx_complete_int == TRUE)
    6ab2:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    6ab6:	2b01      	cmp	r3, #1
    6ab8:	d105      	bne.n	6ac6 <LPLD_SPI_Init+0x5fe>
    { SPI1_ISR[SPI_TxComplete_Int] = TxComplete_isr; }
    6aba:	f241 63b0 	movw	r3, #5808	; 0x16b0
    6abe:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    6ac2:	69ba      	ldr	r2, [r7, #24]
    6ac4:	601a      	str	r2, [r3, #0]
    if(QueueEnd_Request_int == TRUE)
    6ac6:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
    6aca:	2b01      	cmp	r3, #1
    6acc:	d105      	bne.n	6ada <LPLD_SPI_Init+0x612>
    { SPI1_ISR[SPI_QueueEndReq_Int] = QueueEndReq_isr; }
    6ace:	f241 63b0 	movw	r3, #5808	; 0x16b0
    6ad2:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    6ad6:	697a      	ldr	r2, [r7, #20]
    6ad8:	605a      	str	r2, [r3, #4]
    if(txFIFO_underflow_int == TRUE)
    6ada:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    6ade:	2b01      	cmp	r3, #1
    6ae0:	d105      	bne.n	6aee <LPLD_SPI_Init+0x626>
    { SPI1_ISR[SPI_TxFIFO_UnderflowInt] = UnderflowInt_isr; }
    6ae2:	f241 63b0 	movw	r3, #5808	; 0x16b0
    6ae6:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    6aea:	693a      	ldr	r2, [r7, #16]
    6aec:	609a      	str	r2, [r3, #8]
    if(rxFIFO_overflow_int == TRUE)
    6aee:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    6af2:	2b01      	cmp	r3, #1
    6af4:	d105      	bne.n	6b02 <LPLD_SPI_Init+0x63a>
    { SPI1_ISR[SPI_RxFIFO_OverflowInt] = OverflowInt_isr; }
    6af6:	f241 63b0 	movw	r3, #5808	; 0x16b0
    6afa:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    6afe:	68fa      	ldr	r2, [r7, #12]
    6b00:	60da      	str	r2, [r3, #12]
    if(txFIFO_Fill_int == TRUE && txFIFO_req == SPI_FIFO_INTREQUEST)
    6b02:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
    6b06:	2b01      	cmp	r3, #1
    6b08:	d109      	bne.n	6b1e <LPLD_SPI_Init+0x656>
    6b0a:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
    6b0e:	2b00      	cmp	r3, #0
    6b10:	d105      	bne.n	6b1e <LPLD_SPI_Init+0x656>
    { SPI1_ISR[SPI_TxFIFO_FillInt] = FillInt_isr; }
    6b12:	f241 63b0 	movw	r3, #5808	; 0x16b0
    6b16:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    6b1a:	68ba      	ldr	r2, [r7, #8]
    6b1c:	611a      	str	r2, [r3, #16]
    if(rxFIFO_Drain_int == TRUE && rxFIFO_req == SPI_FIFO_INTREQUEST)
    6b1e:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
    6b22:	2b01      	cmp	r3, #1
    6b24:	d155      	bne.n	6bd2 <LPLD_SPI_Init+0x70a>
    6b26:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
    6b2a:	2b00      	cmp	r3, #0
    6b2c:	d151      	bne.n	6bd2 <LPLD_SPI_Init+0x70a>
    { SPI1_ISR[SPI_RxFIFO_DrainInt] = DrainInt_isr; }
    6b2e:	f241 63b0 	movw	r3, #5808	; 0x16b0
    6b32:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    6b36:	687a      	ldr	r2, [r7, #4]
    6b38:	615a      	str	r2, [r3, #20]
    6b3a:	e04a      	b.n	6bd2 <LPLD_SPI_Init+0x70a>
  }
  else if (spix == SPI2)
    6b3c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    6b3e:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    6b42:	f2c4 030a 	movt	r3, #16394	; 0x400a
    6b46:	429a      	cmp	r2, r3
    6b48:	d143      	bne.n	6bd2 <LPLD_SPI_Init+0x70a>
  {
    if(tx_complete_int == TRUE)
    6b4a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    6b4e:	2b01      	cmp	r3, #1
    6b50:	d105      	bne.n	6b5e <LPLD_SPI_Init+0x696>
    { SPI2_ISR[SPI_TxComplete_Int] = TxComplete_isr; }
    6b52:	f241 6380 	movw	r3, #5760	; 0x1680
    6b56:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    6b5a:	69ba      	ldr	r2, [r7, #24]
    6b5c:	601a      	str	r2, [r3, #0]
    if(QueueEnd_Request_int == TRUE)
    6b5e:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
    6b62:	2b01      	cmp	r3, #1
    6b64:	d105      	bne.n	6b72 <LPLD_SPI_Init+0x6aa>
    { SPI2_ISR[SPI_QueueEndReq_Int] = QueueEndReq_isr; }
    6b66:	f241 6380 	movw	r3, #5760	; 0x1680
    6b6a:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    6b6e:	697a      	ldr	r2, [r7, #20]
    6b70:	605a      	str	r2, [r3, #4]
    if(txFIFO_underflow_int == TRUE)
    6b72:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
    6b76:	2b01      	cmp	r3, #1
    6b78:	d105      	bne.n	6b86 <LPLD_SPI_Init+0x6be>
    { SPI2_ISR[SPI_TxFIFO_UnderflowInt] = UnderflowInt_isr; }
    6b7a:	f241 6380 	movw	r3, #5760	; 0x1680
    6b7e:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    6b82:	693a      	ldr	r2, [r7, #16]
    6b84:	609a      	str	r2, [r3, #8]
    if(rxFIFO_overflow_int == TRUE)
    6b86:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    6b8a:	2b01      	cmp	r3, #1
    6b8c:	d105      	bne.n	6b9a <LPLD_SPI_Init+0x6d2>
    { SPI2_ISR[SPI_RxFIFO_OverflowInt] = OverflowInt_isr; }
    6b8e:	f241 6380 	movw	r3, #5760	; 0x1680
    6b92:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    6b96:	68fa      	ldr	r2, [r7, #12]
    6b98:	60da      	str	r2, [r3, #12]
    if(txFIFO_Fill_int == TRUE && txFIFO_req == SPI_FIFO_INTREQUEST)
    6b9a:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
    6b9e:	2b01      	cmp	r3, #1
    6ba0:	d109      	bne.n	6bb6 <LPLD_SPI_Init+0x6ee>
    6ba2:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
    6ba6:	2b00      	cmp	r3, #0
    6ba8:	d105      	bne.n	6bb6 <LPLD_SPI_Init+0x6ee>
    { SPI2_ISR[SPI_TxFIFO_FillInt] = FillInt_isr; }
    6baa:	f241 6380 	movw	r3, #5760	; 0x1680
    6bae:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    6bb2:	68ba      	ldr	r2, [r7, #8]
    6bb4:	611a      	str	r2, [r3, #16]
    if(rxFIFO_Drain_int == TRUE && rxFIFO_req == SPI_FIFO_INTREQUEST)
    6bb6:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
    6bba:	2b01      	cmp	r3, #1
    6bbc:	d109      	bne.n	6bd2 <LPLD_SPI_Init+0x70a>
    6bbe:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
    6bc2:	2b00      	cmp	r3, #0
    6bc4:	d105      	bne.n	6bd2 <LPLD_SPI_Init+0x70a>
    { SPI2_ISR[SPI_RxFIFO_DrainInt] = DrainInt_isr; }
    6bc6:	f241 6380 	movw	r3, #5760	; 0x1680
    6bca:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    6bce:	687a      	ldr	r2, [r7, #4]
    6bd0:	615a      	str	r2, [r3, #20]
  }
  //SPI CTARĴSPIʱ
  spix->CTAR[0] &= (~SPI_CTAR_LSBFE_MASK);
    6bd2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6bd4:	68db      	ldr	r3, [r3, #12]
    6bd6:	f023 7280 	bic.w	r2, r3, #16777216	; 0x1000000
    6bda:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6bdc:	60da      	str	r2, [r3, #12]

  spix->CTAR[0] |=  (SPI_CTAR_DBR_MASK  
    6bde:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6be0:	68db      	ldr	r3, [r3, #12]
    6be2:	f043 4238 	orr.w	r2, r3, #3087007744	; 0xb8000000
    6be6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6be8:	60da      	str	r2, [r3, #12]
                      |SPI_CTAR_PBR(0)           
                      |SPI_CTAR_FMSZ(7));        
                       
  //SPIƵ
  //SCKƵ = g_bus_clock/ SCK_DIV_x                                             
  spix->CTAR[0] |=SPI_CTAR_BR(sck_div);
    6bea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6bec:	68da      	ldr	r2, [r3, #12]
    6bee:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
    6bf2:	f003 030f 	and.w	r3, r3, #15
    6bf6:	431a      	orrs	r2, r3
    6bf8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6bfa:	60da      	str	r2, [r3, #12]

  //tCSC = (1/g_bus_clock) x PCSSCK x CSSCK
  //tCSC = 1/50,000,000 x PCSSCK x CSSCK
  spix->CTAR[0] |=SPI_CTAR_PCSSCK(1); 
    6bfc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6bfe:	68db      	ldr	r3, [r3, #12]
    6c00:	f443 0280 	orr.w	r2, r3, #4194304	; 0x400000
    6c04:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6c06:	60da      	str	r2, [r3, #12]
  spix->CTAR[0] |=SPI_CTAR_CSSCK(1);  
    6c08:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6c0a:	68db      	ldr	r3, [r3, #12]
    6c0c:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
    6c10:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6c12:	60da      	str	r2, [r3, #12]
  
  //tDT = (1/g_bus_clock) x PDT x DT
  spix->CTAR[0] |=SPI_CTAR_DT(1);
    6c14:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6c16:	68db      	ldr	r3, [r3, #12]
    6c18:	f043 0210 	orr.w	r2, r3, #16
    6c1c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6c1e:	60da      	str	r2, [r3, #12]
  spix->CTAR[0] |=SPI_CTAR_PDT(1);
    6c20:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6c22:	68db      	ldr	r3, [r3, #12]
    6c24:	f443 2280 	orr.w	r2, r3, #262144	; 0x40000
    6c28:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6c2a:	60da      	str	r2, [r3, #12]
  
  //Config the Delay of the last edge of SCK and the negation of PCS
  //tASC = (1/g_bus_clock) x PASC x ASC
  spix->CTAR[0] |=SPI_CTAR_PASC(1);
    6c2c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6c2e:	68db      	ldr	r3, [r3, #12]
    6c30:	f443 1280 	orr.w	r2, r3, #1048576	; 0x100000
    6c34:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6c36:	60da      	str	r2, [r3, #12]
  spix->CTAR[0] |=SPI_CTAR_ASC(1);
    6c38:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6c3a:	68db      	ldr	r3, [r3, #12]
    6c3c:	f443 7280 	orr.w	r2, r3, #256	; 0x100
    6c40:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6c42:	60da      	str	r2, [r3, #12]
  //־λ
  spix->SR |=  (SPI_SR_RFDF_MASK   
    6c44:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6c46:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6c48:	f043 431a 	orr.w	r3, r3, #2583691264	; 0x9a000000
    6c4c:	f443 2320 	orr.w	r3, r3, #655360	; 0xa0000
    6c50:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    6c52:	62d3      	str	r3, [r2, #44]	; 0x2c
              |SPI_SR_TFFF_MASK
              |SPI_SR_TFUF_MASK
              |SPI_SR_TCF_MASK
              |SPI_SR_EOQF_MASK);
  //ʹSPIx
  spix->MCR &=~SPI_MCR_HALT_MASK; 
    6c54:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6c56:	681b      	ldr	r3, [r3, #0]
    6c58:	f023 0201 	bic.w	r2, r3, #1
    6c5c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6c5e:	601a      	str	r2, [r3, #0]
  
  return 1;
    6c60:	f04f 0301 	mov.w	r3, #1
}
    6c64:	4618      	mov	r0, r3
    6c66:	f107 073c 	add.w	r7, r7, #60	; 0x3c
    6c6a:	46bd      	mov	sp, r7
    6c6c:	bc80      	pop	{r7}
    6c6e:	b004      	add	sp, #16
    6c70:	4770      	bx	lr
    6c72:	bf00      	nop

00006c74 <LPLD_SPI_Deinit>:
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_SPI_Deinit(SPI_InitTypeDef spi_init_structure)
{
    6c74:	b084      	sub	sp, #16
    6c76:	b580      	push	{r7, lr}
    6c78:	b082      	sub	sp, #8
    6c7a:	af00      	add	r7, sp, #0
    6c7c:	f107 0c10 	add.w	ip, r7, #16
    6c80:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  SPI_MemMapPtr spix = spi_init_structure.SPI_SPIx;
    6c84:	693b      	ldr	r3, [r7, #16]
    6c86:	607b      	str	r3, [r7, #4]
  spix->MCR |= SPI_MCR_HALT_MASK; //
    6c88:	687b      	ldr	r3, [r7, #4]
    6c8a:	681b      	ldr	r3, [r3, #0]
    6c8c:	f043 0201 	orr.w	r2, r3, #1
    6c90:	687b      	ldr	r3, [r7, #4]
    6c92:	601a      	str	r2, [r3, #0]
  if(spix == SPI0)
    6c94:	687a      	ldr	r2, [r7, #4]
    6c96:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    6c9a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    6c9e:	429a      	cmp	r2, r3
    6ca0:	d118      	bne.n	6cd4 <LPLD_SPI_Deinit+0x60>
  {
    disable_irq(INT_SPI0 - 16);
    6ca2:	f04f 001a 	mov.w	r0, #26
    6ca6:	f7f9 fff7 	bl	c98 <disable_irq>
    SIM_SCGC6 &= ~SIM_SCGC6_DSPI0_MASK;
    6caa:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    6cae:	f2c4 0304 	movt	r3, #16388	; 0x4004
    6cb2:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    6cb6:	f2c4 0204 	movt	r2, #16388	; 0x4004
    6cba:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    6cbe:	f102 021c 	add.w	r2, r2, #28
    6cc2:	6812      	ldr	r2, [r2, #0]
    6cc4:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
    6cc8:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    6ccc:	f103 031c 	add.w	r3, r3, #28
    6cd0:	601a      	str	r2, [r3, #0]
    6cd2:	e042      	b.n	6d5a <LPLD_SPI_Deinit+0xe6>
  }
  else if(spix == SPI1)
    6cd4:	687a      	ldr	r2, [r7, #4]
    6cd6:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    6cda:	f2c4 0302 	movt	r3, #16386	; 0x4002
    6cde:	429a      	cmp	r2, r3
    6ce0:	d118      	bne.n	6d14 <LPLD_SPI_Deinit+0xa0>
  {
    disable_irq(INT_SPI1 - 16);
    6ce2:	f04f 001b 	mov.w	r0, #27
    6ce6:	f7f9 ffd7 	bl	c98 <disable_irq>
    SIM_SCGC6 &= ~SIM_SCGC6_DSPI1_MASK;
    6cea:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    6cee:	f2c4 0304 	movt	r3, #16388	; 0x4004
    6cf2:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    6cf6:	f2c4 0204 	movt	r2, #16388	; 0x4004
    6cfa:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    6cfe:	f102 021c 	add.w	r2, r2, #28
    6d02:	6812      	ldr	r2, [r2, #0]
    6d04:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
    6d08:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    6d0c:	f103 031c 	add.w	r3, r3, #28
    6d10:	601a      	str	r2, [r3, #0]
    6d12:	e022      	b.n	6d5a <LPLD_SPI_Deinit+0xe6>
  }
  else if(spix == SPI2)
    6d14:	687a      	ldr	r2, [r7, #4]
    6d16:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    6d1a:	f2c4 030a 	movt	r3, #16394	; 0x400a
    6d1e:	429a      	cmp	r2, r3
    6d20:	d118      	bne.n	6d54 <LPLD_SPI_Deinit+0xe0>
  {
    disable_irq(INT_SPI2 - 16);
    6d22:	f04f 001c 	mov.w	r0, #28
    6d26:	f7f9 ffb7 	bl	c98 <disable_irq>
    SIM_SCGC3 &= ~SIM_SCGC3_DSPI2_MASK;
    6d2a:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    6d2e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    6d32:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    6d36:	f2c4 0204 	movt	r2, #16388	; 0x4004
    6d3a:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    6d3e:	f102 0210 	add.w	r2, r2, #16
    6d42:	6812      	ldr	r2, [r2, #0]
    6d44:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
    6d48:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    6d4c:	f103 0310 	add.w	r3, r3, #16
    6d50:	601a      	str	r2, [r3, #0]
    6d52:	e002      	b.n	6d5a <LPLD_SPI_Deinit+0xe6>
  }
  else
    return 0;
    6d54:	f04f 0300 	mov.w	r3, #0
    6d58:	e001      	b.n	6d5e <LPLD_SPI_Deinit+0xea>
  return 1;
    6d5a:	f04f 0301 	mov.w	r3, #1
}
    6d5e:	4618      	mov	r0, r3
    6d60:	f107 0708 	add.w	r7, r7, #8
    6d64:	46bd      	mov	sp, r7
    6d66:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    6d6a:	b004      	add	sp, #16
    6d6c:	4770      	bx	lr
    6d6e:	bf00      	nop

00006d70 <LPLD_SPI_EnableIrq>:
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_SPI_EnableIrq(SPI_InitTypeDef spi_init_structure)
{
    6d70:	b084      	sub	sp, #16
    6d72:	b580      	push	{r7, lr}
    6d74:	b082      	sub	sp, #8
    6d76:	af00      	add	r7, sp, #0
    6d78:	f107 0c10 	add.w	ip, r7, #16
    6d7c:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  SPI_MemMapPtr spix = spi_init_structure.SPI_SPIx;
    6d80:	693b      	ldr	r3, [r7, #16]
    6d82:	607b      	str	r3, [r7, #4]
  if(spix == SPI0)
    6d84:	687a      	ldr	r2, [r7, #4]
    6d86:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    6d8a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    6d8e:	429a      	cmp	r2, r3
    6d90:	d104      	bne.n	6d9c <LPLD_SPI_EnableIrq+0x2c>
  {
    enable_irq(INT_SPI0 - 16);
    6d92:	f04f 001a 	mov.w	r0, #26
    6d96:	f7f9 febb 	bl	b10 <enable_irq>
    6d9a:	e01a      	b.n	6dd2 <LPLD_SPI_EnableIrq+0x62>
  }
  else if(spix == SPI1)
    6d9c:	687a      	ldr	r2, [r7, #4]
    6d9e:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    6da2:	f2c4 0302 	movt	r3, #16386	; 0x4002
    6da6:	429a      	cmp	r2, r3
    6da8:	d104      	bne.n	6db4 <LPLD_SPI_EnableIrq+0x44>
  {
    enable_irq(INT_SPI1 - 16);
    6daa:	f04f 001b 	mov.w	r0, #27
    6dae:	f7f9 feaf 	bl	b10 <enable_irq>
    6db2:	e00e      	b.n	6dd2 <LPLD_SPI_EnableIrq+0x62>
  }
  else if(spix == SPI2)
    6db4:	687a      	ldr	r2, [r7, #4]
    6db6:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    6dba:	f2c4 030a 	movt	r3, #16394	; 0x400a
    6dbe:	429a      	cmp	r2, r3
    6dc0:	d104      	bne.n	6dcc <LPLD_SPI_EnableIrq+0x5c>
  {
    enable_irq(INT_SPI2 - 16);
    6dc2:	f04f 001c 	mov.w	r0, #28
    6dc6:	f7f9 fea3 	bl	b10 <enable_irq>
    6dca:	e002      	b.n	6dd2 <LPLD_SPI_EnableIrq+0x62>
  }
  else
    return 0;
    6dcc:	f04f 0300 	mov.w	r3, #0
    6dd0:	e001      	b.n	6dd6 <LPLD_SPI_EnableIrq+0x66>

  return 1;
    6dd2:	f04f 0301 	mov.w	r3, #1
}
    6dd6:	4618      	mov	r0, r3
    6dd8:	f107 0708 	add.w	r7, r7, #8
    6ddc:	46bd      	mov	sp, r7
    6dde:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    6de2:	b004      	add	sp, #16
    6de4:	4770      	bx	lr
    6de6:	bf00      	nop

00006de8 <LPLD_SPI_DisableIrq>:
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_SPI_DisableIrq(SPI_InitTypeDef spi_init_structure)
{
    6de8:	b084      	sub	sp, #16
    6dea:	b580      	push	{r7, lr}
    6dec:	b082      	sub	sp, #8
    6dee:	af00      	add	r7, sp, #0
    6df0:	f107 0c10 	add.w	ip, r7, #16
    6df4:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  SPI_MemMapPtr spix = spi_init_structure.SPI_SPIx;
    6df8:	693b      	ldr	r3, [r7, #16]
    6dfa:	607b      	str	r3, [r7, #4]
  if(spix == SPI0)
    6dfc:	687a      	ldr	r2, [r7, #4]
    6dfe:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    6e02:	f2c4 0302 	movt	r3, #16386	; 0x4002
    6e06:	429a      	cmp	r2, r3
    6e08:	d104      	bne.n	6e14 <LPLD_SPI_DisableIrq+0x2c>
  {
    disable_irq(INT_SPI0 - 16);
    6e0a:	f04f 001a 	mov.w	r0, #26
    6e0e:	f7f9 ff43 	bl	c98 <disable_irq>
    6e12:	e01a      	b.n	6e4a <LPLD_SPI_DisableIrq+0x62>
  }
  else if(spix == SPI1)
    6e14:	687a      	ldr	r2, [r7, #4]
    6e16:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    6e1a:	f2c4 0302 	movt	r3, #16386	; 0x4002
    6e1e:	429a      	cmp	r2, r3
    6e20:	d104      	bne.n	6e2c <LPLD_SPI_DisableIrq+0x44>
  {
    disable_irq(INT_SPI1 - 16);
    6e22:	f04f 001b 	mov.w	r0, #27
    6e26:	f7f9 ff37 	bl	c98 <disable_irq>
    6e2a:	e00e      	b.n	6e4a <LPLD_SPI_DisableIrq+0x62>
  }
  else if(spix == SPI2)
    6e2c:	687a      	ldr	r2, [r7, #4]
    6e2e:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    6e32:	f2c4 030a 	movt	r3, #16394	; 0x400a
    6e36:	429a      	cmp	r2, r3
    6e38:	d104      	bne.n	6e44 <LPLD_SPI_DisableIrq+0x5c>
  {
    disable_irq(INT_SPI2 - 16);
    6e3a:	f04f 001c 	mov.w	r0, #28
    6e3e:	f7f9 ff2b 	bl	c98 <disable_irq>
    6e42:	e002      	b.n	6e4a <LPLD_SPI_DisableIrq+0x62>
  }
  else
    return 0;
    6e44:	f04f 0300 	mov.w	r3, #0
    6e48:	e001      	b.n	6e4e <LPLD_SPI_DisableIrq+0x66>
  return 1;
    6e4a:	f04f 0301 	mov.w	r3, #1
}
    6e4e:	4618      	mov	r0, r3
    6e50:	f107 0708 	add.w	r7, r7, #8
    6e54:	46bd      	mov	sp, r7
    6e56:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    6e5a:	b004      	add	sp, #16
    6e5c:	4770      	bx	lr
    6e5e:	bf00      	nop

00006e60 <LPLD_SPI_Master_WriteRead>:
 *      |__SPI_PCS_INACTIVE -ƬѡЧ,PCSźűΪߵƽ
 * :
 *    ȡӻ8λ
 */
uint8 LPLD_SPI_Master_WriteRead(SPI_MemMapPtr spix,uint8 data,uint8 pcsx,uint8 pcs_state)
{
    6e60:	b480      	push	{r7}
    6e62:	b085      	sub	sp, #20
    6e64:	af00      	add	r7, sp, #0
    6e66:	6078      	str	r0, [r7, #4]
    6e68:	70f9      	strb	r1, [r7, #3]
    6e6a:	70ba      	strb	r2, [r7, #2]
    6e6c:	707b      	strb	r3, [r7, #1]
  uint8 temp;
  
  spix->PUSHR  = (((uint32_t)(((uint32_t)(pcs_state))<<SPI_PUSHR_CONT_SHIFT))&SPI_PUSHR_CONT_MASK)
    6e6e:	787b      	ldrb	r3, [r7, #1]
               |SPI_PUSHR_CTAS(0)
    6e70:	ea4f 72c3 	mov.w	r2, r3, lsl #31
               |SPI_PUSHR_PCS(pcsx)
    6e74:	78bb      	ldrb	r3, [r7, #2]
    6e76:	ea4f 4303 	mov.w	r3, r3, lsl #16
    6e7a:	f403 137c 	and.w	r3, r3, #4128768	; 0x3f0000
    6e7e:	431a      	orrs	r2, r3
               |data;                 
    6e80:	78fb      	ldrb	r3, [r7, #3]
    6e82:	431a      	orrs	r2, r3
 */
uint8 LPLD_SPI_Master_WriteRead(SPI_MemMapPtr spix,uint8 data,uint8 pcsx,uint8 pcs_state)
{
  uint8 temp;
  
  spix->PUSHR  = (((uint32_t)(((uint32_t)(pcs_state))<<SPI_PUSHR_CONT_SHIFT))&SPI_PUSHR_CONT_MASK)
    6e84:	687b      	ldr	r3, [r7, #4]
    6e86:	635a      	str	r2, [r3, #52]	; 0x34
               |SPI_PUSHR_CTAS(0)
               |SPI_PUSHR_PCS(pcsx)
               |data;                 
  
  while(!(spix->SR & SPI_SR_TCF_MASK));
    6e88:	bf00      	nop
    6e8a:	687b      	ldr	r3, [r7, #4]
    6e8c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6e8e:	2b00      	cmp	r3, #0
    6e90:	dafb      	bge.n	6e8a <LPLD_SPI_Master_WriteRead+0x2a>
  spix->SR |= SPI_SR_TCF_MASK ;               
    6e92:	687b      	ldr	r3, [r7, #4]
    6e94:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6e96:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
    6e9a:	687b      	ldr	r3, [r7, #4]
    6e9c:	62da      	str	r2, [r3, #44]	; 0x2c
  
  while(!(spix->SR & SPI_SR_RFDF_MASK)); 
    6e9e:	bf00      	nop
    6ea0:	687b      	ldr	r3, [r7, #4]
    6ea2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6ea4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
    6ea8:	2b00      	cmp	r3, #0
    6eaa:	d0f9      	beq.n	6ea0 <LPLD_SPI_Master_WriteRead+0x40>
  temp = (uint8)(spix->POPR & 0xff);           
    6eac:	687b      	ldr	r3, [r7, #4]
    6eae:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    6eb0:	73fb      	strb	r3, [r7, #15]
  spix->SR |= SPI_SR_RFDF_MASK;                
    6eb2:	687b      	ldr	r3, [r7, #4]
    6eb4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6eb6:	f443 3200 	orr.w	r2, r3, #131072	; 0x20000
    6eba:	687b      	ldr	r3, [r7, #4]
    6ebc:	62da      	str	r2, [r3, #44]	; 0x2c
  return temp;
    6ebe:	7bfb      	ldrb	r3, [r7, #15]
  
}
    6ec0:	4618      	mov	r0, r3
    6ec2:	f107 0714 	add.w	r7, r7, #20
    6ec6:	46bd      	mov	sp, r7
    6ec8:	bc80      	pop	{r7}
    6eca:	4770      	bx	lr

00006ecc <LPLD_SPI_Master_Read>:
 *      |__SPI2 -ѡSPI2ģ
 * :
 *    ȡӻ8λ
 */
uint8 LPLD_SPI_Master_Read(SPI_MemMapPtr spix)
{
    6ecc:	b480      	push	{r7}
    6ece:	b085      	sub	sp, #20
    6ed0:	af00      	add	r7, sp, #0
    6ed2:	6078      	str	r0, [r7, #4]
  uint8 temp;

  while(!(spix->SR & SPI_SR_RFDF_MASK)); //=1 RIFO is not empty
    6ed4:	bf00      	nop
    6ed6:	687b      	ldr	r3, [r7, #4]
    6ed8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6eda:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
    6ede:	2b00      	cmp	r3, #0
    6ee0:	d0f9      	beq.n	6ed6 <LPLD_SPI_Master_Read+0xa>
  temp=(uint8)spix->POPR;
    6ee2:	687b      	ldr	r3, [r7, #4]
    6ee4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    6ee6:	73fb      	strb	r3, [r7, #15]
  spix->SR |=SPI_SR_RFDF_MASK;
    6ee8:	687b      	ldr	r3, [r7, #4]
    6eea:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6eec:	f443 3200 	orr.w	r2, r3, #131072	; 0x20000
    6ef0:	687b      	ldr	r3, [r7, #4]
    6ef2:	62da      	str	r2, [r3, #44]	; 0x2c

  return temp;
    6ef4:	7bfb      	ldrb	r3, [r7, #15]
}
    6ef6:	4618      	mov	r0, r3
    6ef8:	f107 0714 	add.w	r7, r7, #20
    6efc:	46bd      	mov	sp, r7
    6efe:	bc80      	pop	{r7}
    6f00:	4770      	bx	lr
    6f02:	bf00      	nop

00006f04 <LPLD_SPI_Master_Write>:
 *    pcs_state--һ֡ݴɺCS״̬
 *      |__SPI_PCS_ASSERTED -ƬѡЧ,PCSźűΪ͵ƽ
 *      |__SPI_PCS_INACTIVE -ƬѡЧ,PCSźűΪߵƽ
 */
void LPLD_SPI_Master_Write(SPI_MemMapPtr spix,uint8 data,uint8 pcsx,uint8 pcs_state)
{  
    6f04:	b480      	push	{r7}
    6f06:	b083      	sub	sp, #12
    6f08:	af00      	add	r7, sp, #0
    6f0a:	6078      	str	r0, [r7, #4]
    6f0c:	70f9      	strb	r1, [r7, #3]
    6f0e:	70ba      	strb	r2, [r7, #2]
    6f10:	707b      	strb	r3, [r7, #1]
  
  spix->PUSHR = (((uint32_t)(((uint32_t)(pcs_state))<<SPI_PUSHR_CONT_SHIFT)) & SPI_PUSHR_CONT_MASK)
    6f12:	787b      	ldrb	r3, [r7, #1]
               |SPI_PUSHR_CTAS(0)
    6f14:	ea4f 72c3 	mov.w	r2, r3, lsl #31
               |SPI_PUSHR_PCS(pcsx)
    6f18:	78bb      	ldrb	r3, [r7, #2]
    6f1a:	ea4f 4303 	mov.w	r3, r3, lsl #16
    6f1e:	f403 137c 	and.w	r3, r3, #4128768	; 0x3f0000
    6f22:	431a      	orrs	r2, r3
               |data; 
    6f24:	78fb      	ldrb	r3, [r7, #3]
    6f26:	431a      	orrs	r2, r3
 *      |__SPI_PCS_INACTIVE -ƬѡЧ,PCSźűΪߵƽ
 */
void LPLD_SPI_Master_Write(SPI_MemMapPtr spix,uint8 data,uint8 pcsx,uint8 pcs_state)
{  
  
  spix->PUSHR = (((uint32_t)(((uint32_t)(pcs_state))<<SPI_PUSHR_CONT_SHIFT)) & SPI_PUSHR_CONT_MASK)
    6f28:	687b      	ldr	r3, [r7, #4]
    6f2a:	635a      	str	r2, [r3, #52]	; 0x34
               |SPI_PUSHR_CTAS(0)
               |SPI_PUSHR_PCS(pcsx)
               |data; 

  while(!(spix->SR & SPI_SR_TCF_MASK));
    6f2c:	bf00      	nop
    6f2e:	687b      	ldr	r3, [r7, #4]
    6f30:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6f32:	2b00      	cmp	r3, #0
    6f34:	dafb      	bge.n	6f2e <LPLD_SPI_Master_Write+0x2a>
  spix->SR |= SPI_SR_TCF_MASK ;            
    6f36:	687b      	ldr	r3, [r7, #4]
    6f38:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6f3a:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
    6f3e:	687b      	ldr	r3, [r7, #4]
    6f40:	62da      	str	r2, [r3, #44]	; 0x2c
}
    6f42:	f107 070c 	add.w	r7, r7, #12
    6f46:	46bd      	mov	sp, r7
    6f48:	bc80      	pop	{r7}
    6f4a:	4770      	bx	lr

00006f4c <SPI0_IRQHandler>:


void SPI0_IRQHandler(void)
{
    6f4c:	b580      	push	{r7, lr}
    6f4e:	af00      	add	r7, sp, #0
  OS_CPU_SR  cpu_sr = 0u;
  OS_ENTER_CRITICAL(); 
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif
  if( SPI0->SR & SPI_SR_TCF_MASK)
    6f50:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    6f54:	f2c4 0302 	movt	r3, #16386	; 0x4002
    6f58:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6f5a:	2b00      	cmp	r3, #0
    6f5c:	da12      	bge.n	6f84 <SPI0_IRQHandler+0x38>
  {
    SPI0_ISR[SPI_TxComplete_Int]();
    6f5e:	f241 6398 	movw	r3, #5784	; 0x1698
    6f62:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    6f66:	681b      	ldr	r3, [r3, #0]
    6f68:	4798      	blx	r3
    SPI0->SR |= SPI_SR_TCF_MASK;
    6f6a:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    6f6e:	f2c4 0302 	movt	r3, #16386	; 0x4002
    6f72:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    6f76:	f2c4 0202 	movt	r2, #16386	; 0x4002
    6f7a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    6f7c:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    6f80:	62da      	str	r2, [r3, #44]	; 0x2c
    6f82:	e08a      	b.n	709a <SPI0_IRQHandler+0x14e>
  }
  else if( SPI0->SR & SPI_SR_EOQF_MASK)
    6f84:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    6f88:	f2c4 0302 	movt	r3, #16386	; 0x4002
    6f8c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6f8e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
    6f92:	2b00      	cmp	r3, #0
    6f94:	d012      	beq.n	6fbc <SPI0_IRQHandler+0x70>
  {
    SPI0_ISR[SPI_QueueEndReq_Int]();
    6f96:	f241 6398 	movw	r3, #5784	; 0x1698
    6f9a:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    6f9e:	685b      	ldr	r3, [r3, #4]
    6fa0:	4798      	blx	r3
    SPI0->SR |= SPI_SR_EOQF_MASK;
    6fa2:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    6fa6:	f2c4 0302 	movt	r3, #16386	; 0x4002
    6faa:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    6fae:	f2c4 0202 	movt	r2, #16386	; 0x4002
    6fb2:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    6fb4:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
    6fb8:	62da      	str	r2, [r3, #44]	; 0x2c
    6fba:	e06e      	b.n	709a <SPI0_IRQHandler+0x14e>
  }
  else if( SPI0->SR & SPI_SR_TFUF_MASK)
    6fbc:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    6fc0:	f2c4 0302 	movt	r3, #16386	; 0x4002
    6fc4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6fc6:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
    6fca:	2b00      	cmp	r3, #0
    6fcc:	d012      	beq.n	6ff4 <SPI0_IRQHandler+0xa8>
  {
    SPI0_ISR[SPI_TxFIFO_UnderflowInt]();
    6fce:	f241 6398 	movw	r3, #5784	; 0x1698
    6fd2:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    6fd6:	689b      	ldr	r3, [r3, #8]
    6fd8:	4798      	blx	r3
    SPI0->SR |= SPI_SR_TFUF_MASK;
    6fda:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    6fde:	f2c4 0302 	movt	r3, #16386	; 0x4002
    6fe2:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    6fe6:	f2c4 0202 	movt	r2, #16386	; 0x4002
    6fea:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    6fec:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
    6ff0:	62da      	str	r2, [r3, #44]	; 0x2c
    6ff2:	e052      	b.n	709a <SPI0_IRQHandler+0x14e>
  }
  else if( SPI0->SR & SPI_SR_TFFF_MASK)
    6ff4:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    6ff8:	f2c4 0302 	movt	r3, #16386	; 0x4002
    6ffc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6ffe:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    7002:	2b00      	cmp	r3, #0
    7004:	d012      	beq.n	702c <SPI0_IRQHandler+0xe0>
  {  
    SPI0_ISR[SPI_TxFIFO_FillInt]();    
    7006:	f241 6398 	movw	r3, #5784	; 0x1698
    700a:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    700e:	691b      	ldr	r3, [r3, #16]
    7010:	4798      	blx	r3
    SPI0->SR |= SPI_SR_TFFF_MASK;
    7012:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    7016:	f2c4 0302 	movt	r3, #16386	; 0x4002
    701a:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    701e:	f2c4 0202 	movt	r2, #16386	; 0x4002
    7022:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    7024:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
    7028:	62da      	str	r2, [r3, #44]	; 0x2c
    702a:	e036      	b.n	709a <SPI0_IRQHandler+0x14e>
  }
  else if( SPI0->SR & SPI_SR_RFOF_MASK)
    702c:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    7030:	f2c4 0302 	movt	r3, #16386	; 0x4002
    7034:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    7036:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
    703a:	2b00      	cmp	r3, #0
    703c:	d012      	beq.n	7064 <SPI0_IRQHandler+0x118>
  {   
    SPI0_ISR[SPI_RxFIFO_OverflowInt]();
    703e:	f241 6398 	movw	r3, #5784	; 0x1698
    7042:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    7046:	68db      	ldr	r3, [r3, #12]
    7048:	4798      	blx	r3
    SPI0->SR |= SPI_SR_RFOF_MASK;
    704a:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    704e:	f2c4 0302 	movt	r3, #16386	; 0x4002
    7052:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    7056:	f2c4 0202 	movt	r2, #16386	; 0x4002
    705a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    705c:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
    7060:	62da      	str	r2, [r3, #44]	; 0x2c
    7062:	e01a      	b.n	709a <SPI0_IRQHandler+0x14e>
  }
  else if( SPI0->SR & SPI_SR_RFDF_MASK)
    7064:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    7068:	f2c4 0302 	movt	r3, #16386	; 0x4002
    706c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    706e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
    7072:	2b00      	cmp	r3, #0
    7074:	d011      	beq.n	709a <SPI0_IRQHandler+0x14e>
  {
    SPI0_ISR[SPI_RxFIFO_DrainInt]();
    7076:	f241 6398 	movw	r3, #5784	; 0x1698
    707a:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    707e:	695b      	ldr	r3, [r3, #20]
    7080:	4798      	blx	r3
    SPI0->SR |= SPI_SR_RFDF_MASK;
    7082:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    7086:	f2c4 0302 	movt	r3, #16386	; 0x4002
    708a:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    708e:	f2c4 0202 	movt	r2, #16386	; 0x4002
    7092:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    7094:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
    7098:	62da      	str	r2, [r3, #44]	; 0x2c
  }
#if (UCOS_II > 0u)
  OSIntExit();          
#endif
}
    709a:	bd80      	pop	{r7, pc}

0000709c <SPI1_IRQHandler>:


void SPI1_IRQHandler(void)
{
    709c:	b580      	push	{r7, lr}
    709e:	af00      	add	r7, sp, #0
  OS_CPU_SR  cpu_sr = 0u;
  OS_ENTER_CRITICAL(); 
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif
  if( SPI1->SR & SPI_SR_TCF_MASK)
    70a0:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    70a4:	f2c4 0302 	movt	r3, #16386	; 0x4002
    70a8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    70aa:	2b00      	cmp	r3, #0
    70ac:	da12      	bge.n	70d4 <SPI1_IRQHandler+0x38>
  {
    SPI1_ISR[SPI_TxComplete_Int]();
    70ae:	f241 63b0 	movw	r3, #5808	; 0x16b0
    70b2:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    70b6:	681b      	ldr	r3, [r3, #0]
    70b8:	4798      	blx	r3
    SPI1->SR |= SPI_SR_TCF_MASK;
    70ba:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    70be:	f2c4 0302 	movt	r3, #16386	; 0x4002
    70c2:	f44f 4250 	mov.w	r2, #53248	; 0xd000
    70c6:	f2c4 0202 	movt	r2, #16386	; 0x4002
    70ca:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    70cc:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    70d0:	62da      	str	r2, [r3, #44]	; 0x2c
    70d2:	e08a      	b.n	71ea <SPI1_IRQHandler+0x14e>
  }
  else if( SPI1->SR & SPI_SR_EOQF_MASK)
    70d4:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    70d8:	f2c4 0302 	movt	r3, #16386	; 0x4002
    70dc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    70de:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
    70e2:	2b00      	cmp	r3, #0
    70e4:	d012      	beq.n	710c <SPI1_IRQHandler+0x70>
  {
    SPI1_ISR[SPI_QueueEndReq_Int]();
    70e6:	f241 63b0 	movw	r3, #5808	; 0x16b0
    70ea:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    70ee:	685b      	ldr	r3, [r3, #4]
    70f0:	4798      	blx	r3
    SPI1->SR |= SPI_SR_EOQF_MASK;
    70f2:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    70f6:	f2c4 0302 	movt	r3, #16386	; 0x4002
    70fa:	f44f 4250 	mov.w	r2, #53248	; 0xd000
    70fe:	f2c4 0202 	movt	r2, #16386	; 0x4002
    7102:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    7104:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
    7108:	62da      	str	r2, [r3, #44]	; 0x2c
    710a:	e06e      	b.n	71ea <SPI1_IRQHandler+0x14e>
  }
  else if( SPI1->SR & SPI_SR_TFUF_MASK)
    710c:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    7110:	f2c4 0302 	movt	r3, #16386	; 0x4002
    7114:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    7116:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
    711a:	2b00      	cmp	r3, #0
    711c:	d012      	beq.n	7144 <SPI1_IRQHandler+0xa8>
  {
    SPI1_ISR[SPI_TxFIFO_UnderflowInt]();
    711e:	f241 63b0 	movw	r3, #5808	; 0x16b0
    7122:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    7126:	689b      	ldr	r3, [r3, #8]
    7128:	4798      	blx	r3
    SPI1->SR |= SPI_SR_TFUF_MASK;
    712a:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    712e:	f2c4 0302 	movt	r3, #16386	; 0x4002
    7132:	f44f 4250 	mov.w	r2, #53248	; 0xd000
    7136:	f2c4 0202 	movt	r2, #16386	; 0x4002
    713a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    713c:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
    7140:	62da      	str	r2, [r3, #44]	; 0x2c
    7142:	e052      	b.n	71ea <SPI1_IRQHandler+0x14e>
  }
  else if( SPI1->SR & SPI_SR_TFFF_MASK)
    7144:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    7148:	f2c4 0302 	movt	r3, #16386	; 0x4002
    714c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    714e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    7152:	2b00      	cmp	r3, #0
    7154:	d012      	beq.n	717c <SPI1_IRQHandler+0xe0>
  {  
    SPI1_ISR[SPI_TxFIFO_FillInt]();    
    7156:	f241 63b0 	movw	r3, #5808	; 0x16b0
    715a:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    715e:	691b      	ldr	r3, [r3, #16]
    7160:	4798      	blx	r3
    SPI1->SR |= SPI_SR_TFFF_MASK;
    7162:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    7166:	f2c4 0302 	movt	r3, #16386	; 0x4002
    716a:	f44f 4250 	mov.w	r2, #53248	; 0xd000
    716e:	f2c4 0202 	movt	r2, #16386	; 0x4002
    7172:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    7174:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
    7178:	62da      	str	r2, [r3, #44]	; 0x2c
    717a:	e036      	b.n	71ea <SPI1_IRQHandler+0x14e>
  }
  else if( SPI1->SR & SPI_SR_RFOF_MASK)
    717c:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    7180:	f2c4 0302 	movt	r3, #16386	; 0x4002
    7184:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    7186:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
    718a:	2b00      	cmp	r3, #0
    718c:	d012      	beq.n	71b4 <SPI1_IRQHandler+0x118>
  {   
    SPI1_ISR[SPI_RxFIFO_OverflowInt]();
    718e:	f241 63b0 	movw	r3, #5808	; 0x16b0
    7192:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    7196:	68db      	ldr	r3, [r3, #12]
    7198:	4798      	blx	r3
    SPI1->SR |= SPI_SR_RFOF_MASK;
    719a:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    719e:	f2c4 0302 	movt	r3, #16386	; 0x4002
    71a2:	f44f 4250 	mov.w	r2, #53248	; 0xd000
    71a6:	f2c4 0202 	movt	r2, #16386	; 0x4002
    71aa:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    71ac:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
    71b0:	62da      	str	r2, [r3, #44]	; 0x2c
    71b2:	e01a      	b.n	71ea <SPI1_IRQHandler+0x14e>
  }
  else if( SPI1->SR & SPI_SR_RFDF_MASK)
    71b4:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    71b8:	f2c4 0302 	movt	r3, #16386	; 0x4002
    71bc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    71be:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
    71c2:	2b00      	cmp	r3, #0
    71c4:	d011      	beq.n	71ea <SPI1_IRQHandler+0x14e>
  {
    SPI1_ISR[SPI_RxFIFO_DrainInt]();
    71c6:	f241 63b0 	movw	r3, #5808	; 0x16b0
    71ca:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    71ce:	695b      	ldr	r3, [r3, #20]
    71d0:	4798      	blx	r3
    SPI1->SR |= SPI_SR_RFDF_MASK;
    71d2:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    71d6:	f2c4 0302 	movt	r3, #16386	; 0x4002
    71da:	f44f 4250 	mov.w	r2, #53248	; 0xd000
    71de:	f2c4 0202 	movt	r2, #16386	; 0x4002
    71e2:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    71e4:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
    71e8:	62da      	str	r2, [r3, #44]	; 0x2c
  }
#if (UCOS_II > 0u)
  OSIntExit();         
#endif
}
    71ea:	bd80      	pop	{r7, pc}

000071ec <SPI2_IRQHandler>:


void SPI2_IRQHandler(void)
{
    71ec:	b580      	push	{r7, lr}
    71ee:	af00      	add	r7, sp, #0
  OS_CPU_SR  cpu_sr = 0u;
  OS_ENTER_CRITICAL(); 
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif
  if( SPI2->SR & SPI_SR_TCF_MASK)
    71f0:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    71f4:	f2c4 030a 	movt	r3, #16394	; 0x400a
    71f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    71fa:	2b00      	cmp	r3, #0
    71fc:	da12      	bge.n	7224 <SPI2_IRQHandler+0x38>
  {
    SPI2_ISR[SPI_TxComplete_Int]();
    71fe:	f241 6380 	movw	r3, #5760	; 0x1680
    7202:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    7206:	681b      	ldr	r3, [r3, #0]
    7208:	4798      	blx	r3
    SPI2->SR |= SPI_SR_TCF_MASK;
    720a:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    720e:	f2c4 030a 	movt	r3, #16394	; 0x400a
    7212:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    7216:	f2c4 020a 	movt	r2, #16394	; 0x400a
    721a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    721c:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    7220:	62da      	str	r2, [r3, #44]	; 0x2c
    7222:	e08a      	b.n	733a <SPI2_IRQHandler+0x14e>
  }
  else if( SPI2->SR & SPI_SR_EOQF_MASK)
    7224:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    7228:	f2c4 030a 	movt	r3, #16394	; 0x400a
    722c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    722e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
    7232:	2b00      	cmp	r3, #0
    7234:	d012      	beq.n	725c <SPI2_IRQHandler+0x70>
  {
    SPI2_ISR[SPI_QueueEndReq_Int]();
    7236:	f241 6380 	movw	r3, #5760	; 0x1680
    723a:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    723e:	685b      	ldr	r3, [r3, #4]
    7240:	4798      	blx	r3
    SPI2->SR |= SPI_SR_EOQF_MASK;
    7242:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    7246:	f2c4 030a 	movt	r3, #16394	; 0x400a
    724a:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    724e:	f2c4 020a 	movt	r2, #16394	; 0x400a
    7252:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    7254:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
    7258:	62da      	str	r2, [r3, #44]	; 0x2c
    725a:	e06e      	b.n	733a <SPI2_IRQHandler+0x14e>
  }
  else if( SPI2->SR & SPI_SR_TFUF_MASK)
    725c:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    7260:	f2c4 030a 	movt	r3, #16394	; 0x400a
    7264:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    7266:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
    726a:	2b00      	cmp	r3, #0
    726c:	d012      	beq.n	7294 <SPI2_IRQHandler+0xa8>
  {
    SPI2_ISR[SPI_TxFIFO_UnderflowInt]();
    726e:	f241 6380 	movw	r3, #5760	; 0x1680
    7272:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    7276:	689b      	ldr	r3, [r3, #8]
    7278:	4798      	blx	r3
    SPI2->SR |= SPI_SR_TFUF_MASK;
    727a:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    727e:	f2c4 030a 	movt	r3, #16394	; 0x400a
    7282:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    7286:	f2c4 020a 	movt	r2, #16394	; 0x400a
    728a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    728c:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
    7290:	62da      	str	r2, [r3, #44]	; 0x2c
    7292:	e052      	b.n	733a <SPI2_IRQHandler+0x14e>
  }
  else if( SPI2->SR & SPI_SR_TFFF_MASK)
    7294:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    7298:	f2c4 030a 	movt	r3, #16394	; 0x400a
    729c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    729e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    72a2:	2b00      	cmp	r3, #0
    72a4:	d012      	beq.n	72cc <SPI2_IRQHandler+0xe0>
  {  
    SPI2_ISR[SPI_TxFIFO_FillInt]();    
    72a6:	f241 6380 	movw	r3, #5760	; 0x1680
    72aa:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    72ae:	691b      	ldr	r3, [r3, #16]
    72b0:	4798      	blx	r3
    SPI2->SR |= SPI_SR_TFFF_MASK;
    72b2:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    72b6:	f2c4 030a 	movt	r3, #16394	; 0x400a
    72ba:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    72be:	f2c4 020a 	movt	r2, #16394	; 0x400a
    72c2:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    72c4:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
    72c8:	62da      	str	r2, [r3, #44]	; 0x2c
    72ca:	e036      	b.n	733a <SPI2_IRQHandler+0x14e>
  }
  else if( SPI2->SR & SPI_SR_RFOF_MASK)
    72cc:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    72d0:	f2c4 030a 	movt	r3, #16394	; 0x400a
    72d4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    72d6:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
    72da:	2b00      	cmp	r3, #0
    72dc:	d012      	beq.n	7304 <SPI2_IRQHandler+0x118>
  {   
    SPI2_ISR[SPI_RxFIFO_OverflowInt]();
    72de:	f241 6380 	movw	r3, #5760	; 0x1680
    72e2:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    72e6:	68db      	ldr	r3, [r3, #12]
    72e8:	4798      	blx	r3
    SPI2->SR |= SPI_SR_RFOF_MASK;
    72ea:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    72ee:	f2c4 030a 	movt	r3, #16394	; 0x400a
    72f2:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    72f6:	f2c4 020a 	movt	r2, #16394	; 0x400a
    72fa:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    72fc:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
    7300:	62da      	str	r2, [r3, #44]	; 0x2c
    7302:	e01a      	b.n	733a <SPI2_IRQHandler+0x14e>
  }
  else if( SPI2->SR & SPI_SR_RFDF_MASK)
    7304:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    7308:	f2c4 030a 	movt	r3, #16394	; 0x400a
    730c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    730e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
    7312:	2b00      	cmp	r3, #0
    7314:	d011      	beq.n	733a <SPI2_IRQHandler+0x14e>
  {
    SPI2_ISR[SPI_RxFIFO_DrainInt]();
    7316:	f241 6380 	movw	r3, #5760	; 0x1680
    731a:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    731e:	695b      	ldr	r3, [r3, #20]
    7320:	4798      	blx	r3
    SPI2->SR |= SPI_SR_RFDF_MASK;
    7322:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    7326:	f2c4 030a 	movt	r3, #16394	; 0x400a
    732a:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    732e:	f2c4 020a 	movt	r2, #16394	; 0x400a
    7332:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    7334:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
    7338:	62da      	str	r2, [r3, #44]	; 0x2c
  }
#if (UCOS_II > 0u)
  OSIntExit();          
#endif
}
    733a:	bd80      	pop	{r7, pc}

0000733c <LPLD_UART_Init>:
 * 输出:
 *    无
 *
 */
void LPLD_UART_Init(UART_InitTypeDef uart_init_structure)
{
    733c:	b084      	sub	sp, #16
    733e:	b490      	push	{r4, r7}
    7340:	b088      	sub	sp, #32
    7342:	af00      	add	r7, sp, #0
    7344:	f107 0c28 	add.w	ip, r7, #40	; 0x28
    7348:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  register uint16 sbr, brfa;
  uint32 sysclk;
  uint8 temp, x;
  UART_MemMapPtr uartx = uart_init_structure.UART_Uartx;
    734c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    734e:	617b      	str	r3, [r7, #20]
  uint32 baud = uart_init_structure.UART_BaudRate;
    7350:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    7352:	613b      	str	r3, [r7, #16]
  PortPinsEnum_Type tx_pin = uart_init_structure.UART_TxPin;
    7354:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
    7358:	73fb      	strb	r3, [r7, #15]
  PortPinsEnum_Type rx_pin = uart_init_structure.UART_RxPin;
    735a:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
    735e:	73bb      	strb	r3, [r7, #14]
  UART_ISR_CALLBACK rx_isr = uart_init_structure.UART_RxIsr;
    7360:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    7362:	60bb      	str	r3, [r7, #8]
  UART_ISR_CALLBACK tx_isr = uart_init_structure.UART_TxIsr;
    7364:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    7366:	607b      	str	r3, [r7, #4]
  
  if(baud == 0)
    7368:	693b      	ldr	r3, [r7, #16]
    736a:	2b00      	cmp	r3, #0
    736c:	d102      	bne.n	7374 <LPLD_UART_Init+0x38>
  {
    baud = 9600;
    736e:	f44f 5316 	mov.w	r3, #9600	; 0x2580
    7372:	613b      	str	r3, [r7, #16]
  }
  
  //使能选中的UART串口通道时钟，相应GPIO的UART复用功能   
  if(uartx == UART0_BASE_PTR)
    7374:	697a      	ldr	r2, [r7, #20]
    7376:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    737a:	f2c4 0306 	movt	r3, #16390	; 0x4006
    737e:	429a      	cmp	r2, r3
    7380:	d157      	bne.n	7432 <LPLD_UART_Init+0xf6>
  {
    x = 0;
    7382:	f04f 0300 	mov.w	r3, #0
    7386:	76fb      	strb	r3, [r7, #27]
    sysclk = g_core_clock;
    7388:	f240 0368 	movw	r3, #104	; 0x68
    738c:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    7390:	681b      	ldr	r3, [r3, #0]
    7392:	61fb      	str	r3, [r7, #28]
    SIM_SCGC4 |= SIM_SCGC4_UART0_MASK;
    7394:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    7398:	f2c4 0304 	movt	r3, #16388	; 0x4004
    739c:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    73a0:	f2c4 0204 	movt	r2, #16388	; 0x4004
    73a4:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    73a8:	f102 0214 	add.w	r2, r2, #20
    73ac:	6812      	ldr	r2, [r2, #0]
    73ae:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    73b2:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    73b6:	f103 0314 	add.w	r3, r3, #20
    73ba:	601a      	str	r2, [r3, #0]
    //设置Tx引脚
    if(tx_pin == PTA2)
    73bc:	7bfb      	ldrb	r3, [r7, #15]
    73be:	2b02      	cmp	r3, #2
    73c0:	d107      	bne.n	73d2 <LPLD_UART_Init+0x96>
      PORTA_BASE_PTR->PCR[2] = PORT_PCR_MUX(2); 
    73c2:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    73c6:	f2c4 0304 	movt	r3, #16388	; 0x4004
    73ca:	f44f 7200 	mov.w	r2, #512	; 0x200
    73ce:	609a      	str	r2, [r3, #8]
    73d0:	e011      	b.n	73f6 <LPLD_UART_Init+0xba>
    else if(tx_pin == PTA14)
    73d2:	7bfb      	ldrb	r3, [r7, #15]
    73d4:	2b0e      	cmp	r3, #14
    73d6:	d107      	bne.n	73e8 <LPLD_UART_Init+0xac>
      PORTA_BASE_PTR->PCR[14] = PORT_PCR_MUX(3); 
    73d8:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    73dc:	f2c4 0304 	movt	r3, #16388	; 0x4004
    73e0:	f44f 7240 	mov.w	r2, #768	; 0x300
    73e4:	639a      	str	r2, [r3, #56]	; 0x38
    73e6:	e006      	b.n	73f6 <LPLD_UART_Init+0xba>
    else
      PORTB_BASE_PTR->PCR[17] = PORT_PCR_MUX(3); 
    73e8:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    73ec:	f2c4 0304 	movt	r3, #16388	; 0x4004
    73f0:	f44f 7240 	mov.w	r2, #768	; 0x300
    73f4:	645a      	str	r2, [r3, #68]	; 0x44
    //设置Rx引脚
    if(rx_pin == PTA1)
    73f6:	7bbb      	ldrb	r3, [r7, #14]
    73f8:	2b01      	cmp	r3, #1
    73fa:	d107      	bne.n	740c <LPLD_UART_Init+0xd0>
      PORTA_BASE_PTR->PCR[1] = PORT_PCR_MUX(2); 
    73fc:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    7400:	f2c4 0304 	movt	r3, #16388	; 0x4004
    7404:	f44f 7200 	mov.w	r2, #512	; 0x200
    7408:	605a      	str	r2, [r3, #4]
    740a:	e16a      	b.n	76e2 <LPLD_UART_Init+0x3a6>
    else if(rx_pin == PTA15)
    740c:	7bbb      	ldrb	r3, [r7, #14]
    740e:	2b0f      	cmp	r3, #15
    7410:	d107      	bne.n	7422 <LPLD_UART_Init+0xe6>
      PORTA_BASE_PTR->PCR[15] = PORT_PCR_MUX(3); 
    7412:	f44f 4310 	mov.w	r3, #36864	; 0x9000
    7416:	f2c4 0304 	movt	r3, #16388	; 0x4004
    741a:	f44f 7240 	mov.w	r2, #768	; 0x300
    741e:	63da      	str	r2, [r3, #60]	; 0x3c
    7420:	e15f      	b.n	76e2 <LPLD_UART_Init+0x3a6>
    else
      PORTB_BASE_PTR->PCR[16] = PORT_PCR_MUX(3); 
    7422:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    7426:	f2c4 0304 	movt	r3, #16388	; 0x4004
    742a:	f44f 7240 	mov.w	r2, #768	; 0x300
    742e:	641a      	str	r2, [r3, #64]	; 0x40
    7430:	e157      	b.n	76e2 <LPLD_UART_Init+0x3a6>
  }
  else
  {
    if (uartx == UART1_BASE_PTR)
    7432:	697a      	ldr	r2, [r7, #20]
    7434:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    7438:	f2c4 0306 	movt	r3, #16390	; 0x4006
    743c:	429a      	cmp	r2, r3
    743e:	d141      	bne.n	74c4 <LPLD_UART_Init+0x188>
    {
      x = 1;
    7440:	f04f 0301 	mov.w	r3, #1
    7444:	76fb      	strb	r3, [r7, #27]
      sysclk = g_core_clock;
    7446:	f240 0368 	movw	r3, #104	; 0x68
    744a:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    744e:	681b      	ldr	r3, [r3, #0]
    7450:	61fb      	str	r3, [r7, #28]
      SIM_SCGC4 |= SIM_SCGC4_UART1_MASK;
    7452:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    7456:	f2c4 0304 	movt	r3, #16388	; 0x4004
    745a:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    745e:	f2c4 0204 	movt	r2, #16388	; 0x4004
    7462:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    7466:	f102 0214 	add.w	r2, r2, #20
    746a:	6812      	ldr	r2, [r2, #0]
    746c:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
    7470:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    7474:	f103 0314 	add.w	r3, r3, #20
    7478:	601a      	str	r2, [r3, #0]
      
      if(tx_pin == PTE0)   
    747a:	7bfb      	ldrb	r3, [r7, #15]
    747c:	2b7c      	cmp	r3, #124	; 0x7c
    747e:	d107      	bne.n	7490 <LPLD_UART_Init+0x154>
        PORTE_BASE_PTR->PCR[0] = PORT_PCR_MUX(3); 
    7480:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    7484:	f2c4 0304 	movt	r3, #16388	; 0x4004
    7488:	f44f 7240 	mov.w	r2, #768	; 0x300
    748c:	601a      	str	r2, [r3, #0]
    748e:	e006      	b.n	749e <LPLD_UART_Init+0x162>
      else
        PORTC_BASE_PTR->PCR[4] = PORT_PCR_MUX(3); 
    7490:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    7494:	f2c4 0304 	movt	r3, #16388	; 0x4004
    7498:	f44f 7240 	mov.w	r2, #768	; 0x300
    749c:	611a      	str	r2, [r3, #16]
      
      if(rx_pin == PTE1)
    749e:	7bbb      	ldrb	r3, [r7, #14]
    74a0:	2b7d      	cmp	r3, #125	; 0x7d
    74a2:	d107      	bne.n	74b4 <LPLD_UART_Init+0x178>
        PORTE_BASE_PTR->PCR[1] = PORT_PCR_MUX(3); 
    74a4:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    74a8:	f2c4 0304 	movt	r3, #16388	; 0x4004
    74ac:	f44f 7240 	mov.w	r2, #768	; 0x300
    74b0:	605a      	str	r2, [r3, #4]
    74b2:	e116      	b.n	76e2 <LPLD_UART_Init+0x3a6>
      else
        PORTC_BASE_PTR->PCR[3] = PORT_PCR_MUX(3); 
    74b4:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    74b8:	f2c4 0304 	movt	r3, #16388	; 0x4004
    74bc:	f44f 7240 	mov.w	r2, #768	; 0x300
    74c0:	60da      	str	r2, [r3, #12]
    74c2:	e10e      	b.n	76e2 <LPLD_UART_Init+0x3a6>
    }
    else
    {
      sysclk = g_bus_clock;
    74c4:	f240 036c 	movw	r3, #108	; 0x6c
    74c8:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    74cc:	681b      	ldr	r3, [r3, #0]
    74ce:	61fb      	str	r3, [r7, #28]
      if (uartx == UART2_BASE_PTR)
    74d0:	697a      	ldr	r2, [r7, #20]
    74d2:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    74d6:	f2c4 0306 	movt	r3, #16390	; 0x4006
    74da:	429a      	cmp	r2, r3
    74dc:	d125      	bne.n	752a <LPLD_UART_Init+0x1ee>
      {
        x = 2;
    74de:	f04f 0302 	mov.w	r3, #2
    74e2:	76fb      	strb	r3, [r7, #27]
        SIM_SCGC4 |= SIM_SCGC4_UART2_MASK;
    74e4:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    74e8:	f2c4 0304 	movt	r3, #16388	; 0x4004
    74ec:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    74f0:	f2c4 0204 	movt	r2, #16388	; 0x4004
    74f4:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    74f8:	f102 0214 	add.w	r2, r2, #20
    74fc:	6812      	ldr	r2, [r2, #0]
    74fe:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
    7502:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    7506:	f103 0314 	add.w	r3, r3, #20
    750a:	601a      	str	r2, [r3, #0]
        
        PORTD_BASE_PTR->PCR[3] = PORT_PCR_MUX(3); 
    750c:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    7510:	f2c4 0304 	movt	r3, #16388	; 0x4004
    7514:	f44f 7240 	mov.w	r2, #768	; 0x300
    7518:	60da      	str	r2, [r3, #12]
        PORTD_BASE_PTR->PCR[2] = PORT_PCR_MUX(3);
    751a:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    751e:	f2c4 0304 	movt	r3, #16388	; 0x4004
    7522:	f44f 7240 	mov.w	r2, #768	; 0x300
    7526:	609a      	str	r2, [r3, #8]
    7528:	e0db      	b.n	76e2 <LPLD_UART_Init+0x3a6>
      }
      else
      {
        if(uartx == UART3_BASE_PTR)
    752a:	697a      	ldr	r2, [r7, #20]
    752c:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    7530:	f2c4 0306 	movt	r3, #16390	; 0x4006
    7534:	429a      	cmp	r2, r3
    7536:	d151      	bne.n	75dc <LPLD_UART_Init+0x2a0>
        {
          x = 3;
    7538:	f04f 0303 	mov.w	r3, #3
    753c:	76fb      	strb	r3, [r7, #27]
          SIM_SCGC4 |= SIM_SCGC4_UART3_MASK;
    753e:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    7542:	f2c4 0304 	movt	r3, #16388	; 0x4004
    7546:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    754a:	f2c4 0204 	movt	r2, #16388	; 0x4004
    754e:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    7552:	f102 0214 	add.w	r2, r2, #20
    7556:	6812      	ldr	r2, [r2, #0]
    7558:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
    755c:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    7560:	f103 0314 	add.w	r3, r3, #20
    7564:	601a      	str	r2, [r3, #0]
          
          if(tx_pin == PTE4)
    7566:	7bfb      	ldrb	r3, [r7, #15]
    7568:	2b80      	cmp	r3, #128	; 0x80
    756a:	d107      	bne.n	757c <LPLD_UART_Init+0x240>
            PORTE_BASE_PTR->PCR[4] = PORT_PCR_MUX(3); 
    756c:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    7570:	f2c4 0304 	movt	r3, #16388	; 0x4004
    7574:	f44f 7240 	mov.w	r2, #768	; 0x300
    7578:	611a      	str	r2, [r3, #16]
    757a:	e011      	b.n	75a0 <LPLD_UART_Init+0x264>
          else if(tx_pin == PTB11)
    757c:	7bfb      	ldrb	r3, [r7, #15]
    757e:	2b2b      	cmp	r3, #43	; 0x2b
    7580:	d107      	bne.n	7592 <LPLD_UART_Init+0x256>
            PORTB_BASE_PTR->PCR[11] = PORT_PCR_MUX(3); 
    7582:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    7586:	f2c4 0304 	movt	r3, #16388	; 0x4004
    758a:	f44f 7240 	mov.w	r2, #768	; 0x300
    758e:	62da      	str	r2, [r3, #44]	; 0x2c
    7590:	e006      	b.n	75a0 <LPLD_UART_Init+0x264>
          else 
            PORTC_BASE_PTR->PCR[17] = PORT_PCR_MUX(3); 
    7592:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    7596:	f2c4 0304 	movt	r3, #16388	; 0x4004
    759a:	f44f 7240 	mov.w	r2, #768	; 0x300
    759e:	645a      	str	r2, [r3, #68]	; 0x44
          
          if(rx_pin == PTE5)
    75a0:	7bbb      	ldrb	r3, [r7, #14]
    75a2:	2b81      	cmp	r3, #129	; 0x81
    75a4:	d107      	bne.n	75b6 <LPLD_UART_Init+0x27a>
            PORTE_BASE_PTR->PCR[5] = PORT_PCR_MUX(3); 
    75a6:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    75aa:	f2c4 0304 	movt	r3, #16388	; 0x4004
    75ae:	f44f 7240 	mov.w	r2, #768	; 0x300
    75b2:	615a      	str	r2, [r3, #20]
    75b4:	e095      	b.n	76e2 <LPLD_UART_Init+0x3a6>
          else if(rx_pin == PTB10)
    75b6:	7bbb      	ldrb	r3, [r7, #14]
    75b8:	2b2a      	cmp	r3, #42	; 0x2a
    75ba:	d107      	bne.n	75cc <LPLD_UART_Init+0x290>
            PORTB_BASE_PTR->PCR[10] = PORT_PCR_MUX(3); 
    75bc:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    75c0:	f2c4 0304 	movt	r3, #16388	; 0x4004
    75c4:	f44f 7240 	mov.w	r2, #768	; 0x300
    75c8:	629a      	str	r2, [r3, #40]	; 0x28
    75ca:	e08a      	b.n	76e2 <LPLD_UART_Init+0x3a6>
          else
            PORTC_BASE_PTR->PCR[16] = PORT_PCR_MUX(3);
    75cc:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    75d0:	f2c4 0304 	movt	r3, #16388	; 0x4004
    75d4:	f44f 7240 	mov.w	r2, #768	; 0x300
    75d8:	641a      	str	r2, [r3, #64]	; 0x40
    75da:	e082      	b.n	76e2 <LPLD_UART_Init+0x3a6>
        }
        else
        {
          if(uartx == UART4_BASE_PTR)
    75dc:	697a      	ldr	r2, [r7, #20]
    75de:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    75e2:	f2c4 030e 	movt	r3, #16398	; 0x400e
    75e6:	429a      	cmp	r2, r3
    75e8:	d13b      	bne.n	7662 <LPLD_UART_Init+0x326>
          {
            x = 4;
    75ea:	f04f 0304 	mov.w	r3, #4
    75ee:	76fb      	strb	r3, [r7, #27]
            SIM_SCGC1 |= SIM_SCGC1_UART4_MASK;
    75f0:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    75f4:	f2c4 0304 	movt	r3, #16388	; 0x4004
    75f8:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    75fc:	f2c4 0204 	movt	r2, #16388	; 0x4004
    7600:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    7604:	f102 0208 	add.w	r2, r2, #8
    7608:	6812      	ldr	r2, [r2, #0]
    760a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    760e:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    7612:	f103 0308 	add.w	r3, r3, #8
    7616:	601a      	str	r2, [r3, #0]
            
            if(tx_pin == PTE24)
    7618:	7bfb      	ldrb	r3, [r7, #15]
    761a:	2b94      	cmp	r3, #148	; 0x94
    761c:	d107      	bne.n	762e <LPLD_UART_Init+0x2f2>
              PORTE_BASE_PTR->PCR[24] = PORT_PCR_MUX(3); 
    761e:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    7622:	f2c4 0304 	movt	r3, #16388	; 0x4004
    7626:	f44f 7240 	mov.w	r2, #768	; 0x300
    762a:	661a      	str	r2, [r3, #96]	; 0x60
    762c:	e006      	b.n	763c <LPLD_UART_Init+0x300>
            else
              PORTC_BASE_PTR->PCR[15] = PORT_PCR_MUX(3); 
    762e:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    7632:	f2c4 0304 	movt	r3, #16388	; 0x4004
    7636:	f44f 7240 	mov.w	r2, #768	; 0x300
    763a:	63da      	str	r2, [r3, #60]	; 0x3c
            
            if(rx_pin == PTE25)
    763c:	7bbb      	ldrb	r3, [r7, #14]
    763e:	2b95      	cmp	r3, #149	; 0x95
    7640:	d107      	bne.n	7652 <LPLD_UART_Init+0x316>
              PORTE_BASE_PTR->PCR[25] = PORT_PCR_MUX(3); 
    7642:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    7646:	f2c4 0304 	movt	r3, #16388	; 0x4004
    764a:	f44f 7240 	mov.w	r2, #768	; 0x300
    764e:	665a      	str	r2, [r3, #100]	; 0x64
    7650:	e047      	b.n	76e2 <LPLD_UART_Init+0x3a6>
            else
              PORTC_BASE_PTR->PCR[14] = PORT_PCR_MUX(3);
    7652:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    7656:	f2c4 0304 	movt	r3, #16388	; 0x4004
    765a:	f44f 7240 	mov.w	r2, #768	; 0x300
    765e:	639a      	str	r2, [r3, #56]	; 0x38
    7660:	e03f      	b.n	76e2 <LPLD_UART_Init+0x3a6>
          }
          else
          {
            x = 5;
    7662:	f04f 0305 	mov.w	r3, #5
    7666:	76fb      	strb	r3, [r7, #27]
            uartx = UART5_BASE_PTR;
    7668:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    766c:	f2c4 030e 	movt	r3, #16398	; 0x400e
    7670:	617b      	str	r3, [r7, #20]
            SIM_SCGC1 |= SIM_SCGC1_UART5_MASK;
    7672:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
    7676:	f2c4 0304 	movt	r3, #16388	; 0x4004
    767a:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
    767e:	f2c4 0204 	movt	r2, #16388	; 0x4004
    7682:	f502 5281 	add.w	r2, r2, #4128	; 0x1020
    7686:	f102 0208 	add.w	r2, r2, #8
    768a:	6812      	ldr	r2, [r2, #0]
    768c:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
    7690:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    7694:	f103 0308 	add.w	r3, r3, #8
    7698:	601a      	str	r2, [r3, #0]
            
            if(tx_pin == PTD9)
    769a:	7bfb      	ldrb	r3, [r7, #15]
    769c:	2b65      	cmp	r3, #101	; 0x65
    769e:	d107      	bne.n	76b0 <LPLD_UART_Init+0x374>
              PORTD_BASE_PTR->PCR[9] = PORT_PCR_MUX(3); 
    76a0:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    76a4:	f2c4 0304 	movt	r3, #16388	; 0x4004
    76a8:	f44f 7240 	mov.w	r2, #768	; 0x300
    76ac:	625a      	str	r2, [r3, #36]	; 0x24
    76ae:	e006      	b.n	76be <LPLD_UART_Init+0x382>
            else
              PORTE_BASE_PTR->PCR[8] = PORT_PCR_MUX(3); 
    76b0:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    76b4:	f2c4 0304 	movt	r3, #16388	; 0x4004
    76b8:	f44f 7240 	mov.w	r2, #768	; 0x300
    76bc:	621a      	str	r2, [r3, #32]
            
            if(rx_pin == PTD8)
    76be:	7bbb      	ldrb	r3, [r7, #14]
    76c0:	2b64      	cmp	r3, #100	; 0x64
    76c2:	d107      	bne.n	76d4 <LPLD_UART_Init+0x398>
              PORTD_BASE_PTR->PCR[8] = PORT_PCR_MUX(3); 
    76c4:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    76c8:	f2c4 0304 	movt	r3, #16388	; 0x4004
    76cc:	f44f 7240 	mov.w	r2, #768	; 0x300
    76d0:	621a      	str	r2, [r3, #32]
    76d2:	e006      	b.n	76e2 <LPLD_UART_Init+0x3a6>
            else
              PORTE_BASE_PTR->PCR[9] = PORT_PCR_MUX(3); 
    76d4:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    76d8:	f2c4 0304 	movt	r3, #16388	; 0x4004
    76dc:	f44f 7240 	mov.w	r2, #768	; 0x300
    76e0:	625a      	str	r2, [r3, #36]	; 0x24
      }
    }
  }
  
  //在配置好其他寄存器前，先关闭发送器和接收器
  uartx->C2 &= ~(UART_C2_TE_MASK | UART_C2_RE_MASK );
    76e2:	697b      	ldr	r3, [r7, #20]
    76e4:	78db      	ldrb	r3, [r3, #3]
    76e6:	b2db      	uxtb	r3, r3
    76e8:	f023 030c 	bic.w	r3, r3, #12
    76ec:	b2da      	uxtb	r2, r3
    76ee:	697b      	ldr	r3, [r7, #20]
    76f0:	70da      	strb	r2, [r3, #3]
  
  //配置UART为 8位, 无奇偶校验 */
  uartx->C1 = 0;	
    76f2:	697b      	ldr	r3, [r7, #20]
    76f4:	f04f 0200 	mov.w	r2, #0
    76f8:	709a      	strb	r2, [r3, #2]
  
  //计算波特率
  sbr = (uint16)((sysclk)/(baud * 16));
    76fa:	693b      	ldr	r3, [r7, #16]
    76fc:	ea4f 1303 	mov.w	r3, r3, lsl #4
    7700:	69fa      	ldr	r2, [r7, #28]
    7702:	fbb2 f3f3 	udiv	r3, r2, r3
    7706:	b29c      	uxth	r4, r3
  
  //保存UARTx_BDH寄存器中除了SBR的值
  temp = uartx->BDH & ~(UART_BDH_SBR(0x1F));
    7708:	697b      	ldr	r3, [r7, #20]
    770a:	781b      	ldrb	r3, [r3, #0]
    770c:	b2db      	uxtb	r3, r3
    770e:	f023 031f 	bic.w	r3, r3, #31
    7712:	70fb      	strb	r3, [r7, #3]
  
  uartx->BDH = temp |  UART_BDH_SBR(((sbr & 0x1F00) >> 8));
    7714:	4623      	mov	r3, r4
    7716:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
    771a:	ea4f 2323 	mov.w	r3, r3, asr #8
    771e:	b2db      	uxtb	r3, r3
    7720:	f003 031f 	and.w	r3, r3, #31
    7724:	b2da      	uxtb	r2, r3
    7726:	78fb      	ldrb	r3, [r7, #3]
    7728:	4313      	orrs	r3, r2
    772a:	b2da      	uxtb	r2, r3
    772c:	697b      	ldr	r3, [r7, #20]
    772e:	701a      	strb	r2, [r3, #0]
  uartx->BDL = (uint8)(sbr & UART_BDL_SBR_MASK);
    7730:	b2e2      	uxtb	r2, r4
    7732:	697b      	ldr	r3, [r7, #20]
    7734:	705a      	strb	r2, [r3, #1]
  
  //配置波特率的微调分数
  brfa = (((sysclk*32)/(baud * 16)) - (sbr * 32));
    7736:	69fb      	ldr	r3, [r7, #28]
    7738:	ea4f 1243 	mov.w	r2, r3, lsl #5
    773c:	693b      	ldr	r3, [r7, #16]
    773e:	ea4f 1303 	mov.w	r3, r3, lsl #4
    7742:	fbb2 f3f3 	udiv	r3, r2, r3
    7746:	b29a      	uxth	r2, r3
    7748:	4623      	mov	r3, r4
    774a:	4619      	mov	r1, r3
    774c:	ea4f 21c1 	mov.w	r1, r1, lsl #11
    7750:	1acb      	subs	r3, r1, r3
    7752:	ea4f 1343 	mov.w	r3, r3, lsl #5
    7756:	b29b      	uxth	r3, r3
    7758:	18d3      	adds	r3, r2, r3
    775a:	b29c      	uxth	r4, r3
  
  //保存UARTx_C4寄存器中除了BRFA的值
  temp = uartx->C4 & ~(UART_C4_BRFA(0x1F));
    775c:	697b      	ldr	r3, [r7, #20]
    775e:	7a9b      	ldrb	r3, [r3, #10]
    7760:	b2db      	uxtb	r3, r3
    7762:	f023 031f 	bic.w	r3, r3, #31
    7766:	70fb      	strb	r3, [r7, #3]
  
  uartx->C4 = temp |  UART_C4_BRFA(brfa);    
    7768:	b2e3      	uxtb	r3, r4
    776a:	f003 031f 	and.w	r3, r3, #31
    776e:	b2da      	uxtb	r2, r3
    7770:	78fb      	ldrb	r3, [r7, #3]
    7772:	4313      	orrs	r3, r2
    7774:	b2da      	uxtb	r2, r3
    7776:	697b      	ldr	r3, [r7, #20]
    7778:	729a      	strb	r2, [r3, #10]
  
  //配置接收中断
  if(uart_init_structure.UART_RxIntEnable == TRUE && rx_isr != NULL)
    777a:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
    777e:	2b01      	cmp	r3, #1
    7780:	d113      	bne.n	77aa <LPLD_UART_Init+0x46e>
    7782:	68bb      	ldr	r3, [r7, #8]
    7784:	2b00      	cmp	r3, #0
    7786:	d010      	beq.n	77aa <LPLD_UART_Init+0x46e>
  {
    uartx->C2 |= UART_C2_RIE_MASK; 
    7788:	697b      	ldr	r3, [r7, #20]
    778a:	78db      	ldrb	r3, [r3, #3]
    778c:	b2db      	uxtb	r3, r3
    778e:	f043 0320 	orr.w	r3, r3, #32
    7792:	b2da      	uxtb	r2, r3
    7794:	697b      	ldr	r3, [r7, #20]
    7796:	70da      	strb	r2, [r3, #3]
    UART_R_ISR[x] = rx_isr;
    7798:	7efa      	ldrb	r2, [r7, #27]
    779a:	f241 63e0 	movw	r3, #5856	; 0x16e0
    779e:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    77a2:	68b9      	ldr	r1, [r7, #8]
    77a4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    77a8:	e007      	b.n	77ba <LPLD_UART_Init+0x47e>
  } 
  else
  {
    uartx->C2 &= ~(UART_C2_RIE_MASK); 
    77aa:	697b      	ldr	r3, [r7, #20]
    77ac:	78db      	ldrb	r3, [r3, #3]
    77ae:	b2db      	uxtb	r3, r3
    77b0:	f023 0320 	bic.w	r3, r3, #32
    77b4:	b2da      	uxtb	r2, r3
    77b6:	697b      	ldr	r3, [r7, #20]
    77b8:	70da      	strb	r2, [r3, #3]
  }
  //配置发送中断
  if(uart_init_structure.UART_TxIntEnable == TRUE && tx_isr != NULL)
    77ba:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
    77be:	2b01      	cmp	r3, #1
    77c0:	d113      	bne.n	77ea <LPLD_UART_Init+0x4ae>
    77c2:	687b      	ldr	r3, [r7, #4]
    77c4:	2b00      	cmp	r3, #0
    77c6:	d010      	beq.n	77ea <LPLD_UART_Init+0x4ae>
  {
    uartx->C2 |= UART_C2_TIE_MASK; 
    77c8:	697b      	ldr	r3, [r7, #20]
    77ca:	78db      	ldrb	r3, [r3, #3]
    77cc:	b2db      	uxtb	r3, r3
    77ce:	f063 037f 	orn	r3, r3, #127	; 0x7f
    77d2:	b2da      	uxtb	r2, r3
    77d4:	697b      	ldr	r3, [r7, #20]
    77d6:	70da      	strb	r2, [r3, #3]
    UART_T_ISR[x] = tx_isr;
    77d8:	7efa      	ldrb	r2, [r7, #27]
    77da:	f241 63c8 	movw	r3, #5832	; 0x16c8
    77de:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    77e2:	6879      	ldr	r1, [r7, #4]
    77e4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    77e8:	e007      	b.n	77fa <LPLD_UART_Init+0x4be>
  } 
  else
  {
    uartx->C2 &= ~(UART_C2_TIE_MASK); 
    77ea:	697b      	ldr	r3, [r7, #20]
    77ec:	78db      	ldrb	r3, [r3, #3]
    77ee:	b2db      	uxtb	r3, r3
    77f0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    77f4:	b2da      	uxtb	r2, r3
    77f6:	697b      	ldr	r3, [r7, #20]
    77f8:	70da      	strb	r2, [r3, #3]
  }
  
  //使能发送器和接收器
  uartx->C2 |= (UART_C2_TE_MASK | UART_C2_RE_MASK );    
    77fa:	697b      	ldr	r3, [r7, #20]
    77fc:	78db      	ldrb	r3, [r3, #3]
    77fe:	b2db      	uxtb	r3, r3
    7800:	f043 030c 	orr.w	r3, r3, #12
    7804:	b2da      	uxtb	r2, r3
    7806:	697b      	ldr	r3, [r7, #20]
    7808:	70da      	strb	r2, [r3, #3]
}
    780a:	f107 0720 	add.w	r7, r7, #32
    780e:	46bd      	mov	sp, r7
    7810:	bc90      	pop	{r4, r7}
    7812:	b004      	add	sp, #16
    7814:	4770      	bx	lr
    7816:	bf00      	nop

00007818 <LPLD_UART_GetChar>:
 * 输出:
 *    串口接收的1个字节
 *
 */
int8 LPLD_UART_GetChar(UART_MemMapPtr uartx)
{
    7818:	b480      	push	{r7}
    781a:	b083      	sub	sp, #12
    781c:	af00      	add	r7, sp, #0
    781e:	6078      	str	r0, [r7, #4]
  //等待数据接收
  while (!(uartx->S1 & UART_S1_RDRF_MASK));
    7820:	bf00      	nop
    7822:	687b      	ldr	r3, [r7, #4]
    7824:	791b      	ldrb	r3, [r3, #4]
    7826:	b2db      	uxtb	r3, r3
    7828:	f003 0320 	and.w	r3, r3, #32
    782c:	2b00      	cmp	r3, #0
    782e:	d0f8      	beq.n	7822 <LPLD_UART_GetChar+0xa>
  
  //返回接收的1个字节数据
  return uartx->D;
    7830:	687b      	ldr	r3, [r7, #4]
    7832:	79db      	ldrb	r3, [r3, #7]
    7834:	b2db      	uxtb	r3, r3
    7836:	b2db      	uxtb	r3, r3
    7838:	b25b      	sxtb	r3, r3
}
    783a:	4618      	mov	r0, r3
    783c:	f107 070c 	add.w	r7, r7, #12
    7840:	46bd      	mov	sp, r7
    7842:	bc80      	pop	{r7}
    7844:	4770      	bx	lr
    7846:	bf00      	nop

00007848 <LPLD_UART_GetChar_Present>:
 * 输出:
 *  0       没有接收到字符
 *  1       已经接收到字符
 */
int32 LPLD_UART_GetChar_Present(UART_MemMapPtr uartx)
{
    7848:	b480      	push	{r7}
    784a:	b083      	sub	sp, #12
    784c:	af00      	add	r7, sp, #0
    784e:	6078      	str	r0, [r7, #4]
    return (uartx->S1 & UART_S1_RDRF_MASK);
    7850:	687b      	ldr	r3, [r7, #4]
    7852:	791b      	ldrb	r3, [r3, #4]
    7854:	b2db      	uxtb	r3, r3
    7856:	f003 0320 	and.w	r3, r3, #32
}
    785a:	4618      	mov	r0, r3
    785c:	f107 070c 	add.w	r7, r7, #12
    7860:	46bd      	mov	sp, r7
    7862:	bc80      	pop	{r7}
    7864:	4770      	bx	lr
    7866:	bf00      	nop

00007868 <LPLD_UART_PutChar>:
 * 输出:
 *    无
 *
 */
void LPLD_UART_PutChar(UART_MemMapPtr uartx, int8 ch)
{
    7868:	b480      	push	{r7}
    786a:	b083      	sub	sp, #12
    786c:	af00      	add	r7, sp, #0
    786e:	6078      	str	r0, [r7, #4]
    7870:	460b      	mov	r3, r1
    7872:	70fb      	strb	r3, [r7, #3]
  //等待FIFO准备就绪
  while(!(uartx->S1 & UART_S1_TDRE_MASK));
    7874:	bf00      	nop
    7876:	687b      	ldr	r3, [r7, #4]
    7878:	791b      	ldrb	r3, [r3, #4]
    787a:	b2db      	uxtb	r3, r3
    787c:	b2db      	uxtb	r3, r3
    787e:	b25b      	sxtb	r3, r3
    7880:	2b00      	cmp	r3, #0
    7882:	daf8      	bge.n	7876 <LPLD_UART_PutChar+0xe>
  
  //将要发送的1个字节发给UART数据寄存器
  uartx->D = (uint8)ch;
    7884:	78fa      	ldrb	r2, [r7, #3]
    7886:	687b      	ldr	r3, [r7, #4]
    7888:	71da      	strb	r2, [r3, #7]
}
    788a:	f107 070c 	add.w	r7, r7, #12
    788e:	46bd      	mov	sp, r7
    7890:	bc80      	pop	{r7}
    7892:	4770      	bx	lr

00007894 <LPLD_UART_PutCharArr>:
 * 输出:
 *    无
 *
 */
void LPLD_UART_PutCharArr(UART_MemMapPtr uartx, char *ch, int32 len)
{
    7894:	b580      	push	{r7, lr}
    7896:	b084      	sub	sp, #16
    7898:	af00      	add	r7, sp, #0
    789a:	60f8      	str	r0, [r7, #12]
    789c:	60b9      	str	r1, [r7, #8]
    789e:	607a      	str	r2, [r7, #4]
  while(len--)
    78a0:	e00b      	b.n	78ba <LPLD_UART_PutCharArr+0x26>
  {
    LPLD_UART_PutChar(uartx, *(ch++));
    78a2:	68bb      	ldr	r3, [r7, #8]
    78a4:	781b      	ldrb	r3, [r3, #0]
    78a6:	b2db      	uxtb	r3, r3
    78a8:	68ba      	ldr	r2, [r7, #8]
    78aa:	f102 0201 	add.w	r2, r2, #1
    78ae:	60ba      	str	r2, [r7, #8]
    78b0:	b25b      	sxtb	r3, r3
    78b2:	68f8      	ldr	r0, [r7, #12]
    78b4:	4619      	mov	r1, r3
    78b6:	f7ff ffd7 	bl	7868 <LPLD_UART_PutChar>
 *    无
 *
 */
void LPLD_UART_PutCharArr(UART_MemMapPtr uartx, char *ch, int32 len)
{
  while(len--)
    78ba:	687b      	ldr	r3, [r7, #4]
    78bc:	2b00      	cmp	r3, #0
    78be:	bf0c      	ite	eq
    78c0:	2300      	moveq	r3, #0
    78c2:	2301      	movne	r3, #1
    78c4:	b2db      	uxtb	r3, r3
    78c6:	687a      	ldr	r2, [r7, #4]
    78c8:	f102 32ff 	add.w	r2, r2, #4294967295
    78cc:	607a      	str	r2, [r7, #4]
    78ce:	2b00      	cmp	r3, #0
    78d0:	d1e7      	bne.n	78a2 <LPLD_UART_PutCharArr+0xe>
  {
    LPLD_UART_PutChar(uartx, *(ch++));
  }
}
    78d2:	f107 0710 	add.w	r7, r7, #16
    78d6:	46bd      	mov	sp, r7
    78d8:	bd80      	pop	{r7, pc}
    78da:	bf00      	nop

000078dc <LPLD_UART_EnableIrq>:
 * 输出:
 *    无
 *
 */
void LPLD_UART_EnableIrq(UART_InitTypeDef uart_init_structure)
{
    78dc:	b084      	sub	sp, #16
    78de:	b580      	push	{r7, lr}
    78e0:	af00      	add	r7, sp, #0
    78e2:	f107 0c08 	add.w	ip, r7, #8
    78e6:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  if(uart_init_structure.UART_Uartx == UART0_BASE_PTR)
    78ea:	68ba      	ldr	r2, [r7, #8]
    78ec:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    78f0:	f2c4 0306 	movt	r3, #16390	; 0x4006
    78f4:	429a      	cmp	r2, r3
    78f6:	d104      	bne.n	7902 <LPLD_UART_EnableIrq+0x26>
  {
    enable_irq(INT_UART0_RX_TX - 16);
    78f8:	f04f 002d 	mov.w	r0, #45	; 0x2d
    78fc:	f7f9 f908 	bl	b10 <enable_irq>
    7900:	e03a      	b.n	7978 <LPLD_UART_EnableIrq+0x9c>
  }
  else if(uart_init_structure.UART_Uartx == UART1_BASE_PTR)
    7902:	68ba      	ldr	r2, [r7, #8]
    7904:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    7908:	f2c4 0306 	movt	r3, #16390	; 0x4006
    790c:	429a      	cmp	r2, r3
    790e:	d104      	bne.n	791a <LPLD_UART_EnableIrq+0x3e>
  {
    enable_irq(INT_UART1_RX_TX - 16);
    7910:	f04f 002f 	mov.w	r0, #47	; 0x2f
    7914:	f7f9 f8fc 	bl	b10 <enable_irq>
    7918:	e02e      	b.n	7978 <LPLD_UART_EnableIrq+0x9c>
  }
  else if(uart_init_structure.UART_Uartx == UART2_BASE_PTR)
    791a:	68ba      	ldr	r2, [r7, #8]
    791c:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    7920:	f2c4 0306 	movt	r3, #16390	; 0x4006
    7924:	429a      	cmp	r2, r3
    7926:	d104      	bne.n	7932 <LPLD_UART_EnableIrq+0x56>
  {
    enable_irq(INT_UART3_RX_TX - 16);
    7928:	f04f 0033 	mov.w	r0, #51	; 0x33
    792c:	f7f9 f8f0 	bl	b10 <enable_irq>
    7930:	e022      	b.n	7978 <LPLD_UART_EnableIrq+0x9c>
  }
  else if(uart_init_structure.UART_Uartx == UART3_BASE_PTR)
    7932:	68ba      	ldr	r2, [r7, #8]
    7934:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    7938:	f2c4 0306 	movt	r3, #16390	; 0x4006
    793c:	429a      	cmp	r2, r3
    793e:	d104      	bne.n	794a <LPLD_UART_EnableIrq+0x6e>
  {
    enable_irq(INT_UART3_RX_TX - 16);
    7940:	f04f 0033 	mov.w	r0, #51	; 0x33
    7944:	f7f9 f8e4 	bl	b10 <enable_irq>
    7948:	e016      	b.n	7978 <LPLD_UART_EnableIrq+0x9c>
  }
  else if(uart_init_structure.UART_Uartx == UART4_BASE_PTR)
    794a:	68ba      	ldr	r2, [r7, #8]
    794c:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    7950:	f2c4 030e 	movt	r3, #16398	; 0x400e
    7954:	429a      	cmp	r2, r3
    7956:	d104      	bne.n	7962 <LPLD_UART_EnableIrq+0x86>
  {
    enable_irq(INT_UART4_RX_TX - 16);
    7958:	f04f 0035 	mov.w	r0, #53	; 0x35
    795c:	f7f9 f8d8 	bl	b10 <enable_irq>
    7960:	e00a      	b.n	7978 <LPLD_UART_EnableIrq+0x9c>
  }
  else if(uart_init_structure.UART_Uartx == UART5_BASE_PTR)
    7962:	68ba      	ldr	r2, [r7, #8]
    7964:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    7968:	f2c4 030e 	movt	r3, #16398	; 0x400e
    796c:	429a      	cmp	r2, r3
    796e:	d103      	bne.n	7978 <LPLD_UART_EnableIrq+0x9c>
  {
    enable_irq(INT_UART5_RX_TX - 16);
    7970:	f04f 0037 	mov.w	r0, #55	; 0x37
    7974:	f7f9 f8cc 	bl	b10 <enable_irq>
  }
}
    7978:	46bd      	mov	sp, r7
    797a:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    797e:	b004      	add	sp, #16
    7980:	4770      	bx	lr
    7982:	bf00      	nop

00007984 <LPLD_UART_DisableIrq>:
 * 输出:
 *    无
 *
 */
void LPLD_UART_DisableIrq(UART_InitTypeDef uart_init_structure)
{
    7984:	b084      	sub	sp, #16
    7986:	b580      	push	{r7, lr}
    7988:	af00      	add	r7, sp, #0
    798a:	f107 0c08 	add.w	ip, r7, #8
    798e:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  //根据中断请求号使能相应中断
  if(uart_init_structure.UART_Uartx == UART0_BASE_PTR)
    7992:	68ba      	ldr	r2, [r7, #8]
    7994:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    7998:	f2c4 0306 	movt	r3, #16390	; 0x4006
    799c:	429a      	cmp	r2, r3
    799e:	d104      	bne.n	79aa <LPLD_UART_DisableIrq+0x26>
    disable_irq(INT_UART0_RX_TX - 16);
    79a0:	f04f 002d 	mov.w	r0, #45	; 0x2d
    79a4:	f7f9 f978 	bl	c98 <disable_irq>
    79a8:	e03a      	b.n	7a20 <LPLD_UART_DisableIrq+0x9c>
  else if(uart_init_structure.UART_Uartx == UART1_BASE_PTR)
    79aa:	68ba      	ldr	r2, [r7, #8]
    79ac:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    79b0:	f2c4 0306 	movt	r3, #16390	; 0x4006
    79b4:	429a      	cmp	r2, r3
    79b6:	d104      	bne.n	79c2 <LPLD_UART_DisableIrq+0x3e>
    disable_irq(INT_UART1_RX_TX - 16);
    79b8:	f04f 002f 	mov.w	r0, #47	; 0x2f
    79bc:	f7f9 f96c 	bl	c98 <disable_irq>
    79c0:	e02e      	b.n	7a20 <LPLD_UART_DisableIrq+0x9c>
  else if(uart_init_structure.UART_Uartx == UART2_BASE_PTR)
    79c2:	68ba      	ldr	r2, [r7, #8]
    79c4:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    79c8:	f2c4 0306 	movt	r3, #16390	; 0x4006
    79cc:	429a      	cmp	r2, r3
    79ce:	d104      	bne.n	79da <LPLD_UART_DisableIrq+0x56>
    disable_irq(INT_UART2_RX_TX - 16);
    79d0:	f04f 0031 	mov.w	r0, #49	; 0x31
    79d4:	f7f9 f960 	bl	c98 <disable_irq>
    79d8:	e022      	b.n	7a20 <LPLD_UART_DisableIrq+0x9c>
  else if(uart_init_structure.UART_Uartx == UART3_BASE_PTR)
    79da:	68ba      	ldr	r2, [r7, #8]
    79dc:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    79e0:	f2c4 0306 	movt	r3, #16390	; 0x4006
    79e4:	429a      	cmp	r2, r3
    79e6:	d104      	bne.n	79f2 <LPLD_UART_DisableIrq+0x6e>
    disable_irq(INT_UART3_RX_TX - 16);
    79e8:	f04f 0033 	mov.w	r0, #51	; 0x33
    79ec:	f7f9 f954 	bl	c98 <disable_irq>
    79f0:	e016      	b.n	7a20 <LPLD_UART_DisableIrq+0x9c>
  else if(uart_init_structure.UART_Uartx == UART4_BASE_PTR)
    79f2:	68ba      	ldr	r2, [r7, #8]
    79f4:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    79f8:	f2c4 030e 	movt	r3, #16398	; 0x400e
    79fc:	429a      	cmp	r2, r3
    79fe:	d104      	bne.n	7a0a <LPLD_UART_DisableIrq+0x86>
    disable_irq(INT_UART4_RX_TX - 16);
    7a00:	f04f 0035 	mov.w	r0, #53	; 0x35
    7a04:	f7f9 f948 	bl	c98 <disable_irq>
    7a08:	e00a      	b.n	7a20 <LPLD_UART_DisableIrq+0x9c>
  else if(uart_init_structure.UART_Uartx == UART5_BASE_PTR)
    7a0a:	68ba      	ldr	r2, [r7, #8]
    7a0c:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    7a10:	f2c4 030e 	movt	r3, #16398	; 0x400e
    7a14:	429a      	cmp	r2, r3
    7a16:	d103      	bne.n	7a20 <LPLD_UART_DisableIrq+0x9c>
    disable_irq(INT_UART5_RX_TX - 16);
    7a18:	f04f 0037 	mov.w	r0, #55	; 0x37
    7a1c:	f7f9 f93c 	bl	c98 <disable_irq>
}
    7a20:	46bd      	mov	sp, r7
    7a22:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    7a26:	b004      	add	sp, #16
    7a28:	4770      	bx	lr
    7a2a:	bf00      	nop

00007a2c <UART0_RX_TX_IRQHandler>:

//HW层中断函数，用户无需调用
//UART0
void UART0_RX_TX_IRQHandler(void)
{
    7a2c:	b580      	push	{r7, lr}
    7a2e:	af00      	add	r7, sp, #0
  
  //进入接收中断函数
  if((UART0_S1 & UART_S1_RDRF_MASK) && (UART0_C2 & UART_C2_RIE_MASK))
    7a30:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    7a34:	f2c4 0306 	movt	r3, #16390	; 0x4006
    7a38:	791b      	ldrb	r3, [r3, #4]
    7a3a:	b2db      	uxtb	r3, r3
    7a3c:	f003 0320 	and.w	r3, r3, #32
    7a40:	2b00      	cmp	r3, #0
    7a42:	d00f      	beq.n	7a64 <UART0_RX_TX_IRQHandler+0x38>
    7a44:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    7a48:	f2c4 0306 	movt	r3, #16390	; 0x4006
    7a4c:	78db      	ldrb	r3, [r3, #3]
    7a4e:	b2db      	uxtb	r3, r3
    7a50:	f003 0320 	and.w	r3, r3, #32
    7a54:	2b00      	cmp	r3, #0
    7a56:	d005      	beq.n	7a64 <UART0_RX_TX_IRQHandler+0x38>
  {
    UART_R_ISR[0]();
    7a58:	f241 63e0 	movw	r3, #5856	; 0x16e0
    7a5c:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    7a60:	681b      	ldr	r3, [r3, #0]
    7a62:	4798      	blx	r3
  }
  //进入发送中断函数
  if((UART0_S1 & UART_S1_TDRE_MASK) && (UART0_C2 & UART_C2_TIE_MASK))
    7a64:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    7a68:	f2c4 0306 	movt	r3, #16390	; 0x4006
    7a6c:	791b      	ldrb	r3, [r3, #4]
    7a6e:	b2db      	uxtb	r3, r3
    7a70:	b2db      	uxtb	r3, r3
    7a72:	b25b      	sxtb	r3, r3
    7a74:	2b00      	cmp	r3, #0
    7a76:	da0f      	bge.n	7a98 <UART0_RX_TX_IRQHandler+0x6c>
    7a78:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    7a7c:	f2c4 0306 	movt	r3, #16390	; 0x4006
    7a80:	78db      	ldrb	r3, [r3, #3]
    7a82:	b2db      	uxtb	r3, r3
    7a84:	b2db      	uxtb	r3, r3
    7a86:	b25b      	sxtb	r3, r3
    7a88:	2b00      	cmp	r3, #0
    7a8a:	da05      	bge.n	7a98 <UART0_RX_TX_IRQHandler+0x6c>
  {
    UART_T_ISR[0]();
    7a8c:	f241 63c8 	movw	r3, #5832	; 0x16c8
    7a90:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    7a94:	681b      	ldr	r3, [r3, #0]
    7a96:	4798      	blx	r3
  }
}
    7a98:	bd80      	pop	{r7, pc}
    7a9a:	bf00      	nop

00007a9c <UART1_RX_TX_IRQHandler>:

//UART1
void UART1_RX_TX_IRQHandler(void)
{
    7a9c:	b580      	push	{r7, lr}
    7a9e:	af00      	add	r7, sp, #0
  
  //进入接收中断函数
  if((UART1_S1 & UART_S1_RDRF_MASK) && (UART1_C2 & UART_C2_RIE_MASK))
    7aa0:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    7aa4:	f2c4 0306 	movt	r3, #16390	; 0x4006
    7aa8:	791b      	ldrb	r3, [r3, #4]
    7aaa:	b2db      	uxtb	r3, r3
    7aac:	f003 0320 	and.w	r3, r3, #32
    7ab0:	2b00      	cmp	r3, #0
    7ab2:	d00f      	beq.n	7ad4 <UART1_RX_TX_IRQHandler+0x38>
    7ab4:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    7ab8:	f2c4 0306 	movt	r3, #16390	; 0x4006
    7abc:	78db      	ldrb	r3, [r3, #3]
    7abe:	b2db      	uxtb	r3, r3
    7ac0:	f003 0320 	and.w	r3, r3, #32
    7ac4:	2b00      	cmp	r3, #0
    7ac6:	d005      	beq.n	7ad4 <UART1_RX_TX_IRQHandler+0x38>
  {
    UART_R_ISR[0]();
    7ac8:	f241 63e0 	movw	r3, #5856	; 0x16e0
    7acc:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    7ad0:	681b      	ldr	r3, [r3, #0]
    7ad2:	4798      	blx	r3
  }
  //进入发送中断函数
  if((UART1_S1 & UART_S1_TDRE_MASK) && (UART1_C2 & UART_C2_TIE_MASK))
    7ad4:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    7ad8:	f2c4 0306 	movt	r3, #16390	; 0x4006
    7adc:	791b      	ldrb	r3, [r3, #4]
    7ade:	b2db      	uxtb	r3, r3
    7ae0:	b2db      	uxtb	r3, r3
    7ae2:	b25b      	sxtb	r3, r3
    7ae4:	2b00      	cmp	r3, #0
    7ae6:	da0f      	bge.n	7b08 <UART1_RX_TX_IRQHandler+0x6c>
    7ae8:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    7aec:	f2c4 0306 	movt	r3, #16390	; 0x4006
    7af0:	78db      	ldrb	r3, [r3, #3]
    7af2:	b2db      	uxtb	r3, r3
    7af4:	b2db      	uxtb	r3, r3
    7af6:	b25b      	sxtb	r3, r3
    7af8:	2b00      	cmp	r3, #0
    7afa:	da05      	bge.n	7b08 <UART1_RX_TX_IRQHandler+0x6c>
  {
    UART_T_ISR[0]();
    7afc:	f241 63c8 	movw	r3, #5832	; 0x16c8
    7b00:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    7b04:	681b      	ldr	r3, [r3, #0]
    7b06:	4798      	blx	r3
  }
}
    7b08:	bd80      	pop	{r7, pc}
    7b0a:	bf00      	nop

00007b0c <UART2_RX_TX_IRQHandler>:

//UART2
void UART2_RX_TX_IRQHandler(void)
{
    7b0c:	b580      	push	{r7, lr}
    7b0e:	af00      	add	r7, sp, #0
  //进入接收中断函数
  if((UART2_S1 & UART_S1_RDRF_MASK) && (UART2_C2 & UART_C2_RIE_MASK))
    7b10:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    7b14:	f2c4 0306 	movt	r3, #16390	; 0x4006
    7b18:	791b      	ldrb	r3, [r3, #4]
    7b1a:	b2db      	uxtb	r3, r3
    7b1c:	f003 0320 	and.w	r3, r3, #32
    7b20:	2b00      	cmp	r3, #0
    7b22:	d00f      	beq.n	7b44 <UART2_RX_TX_IRQHandler+0x38>
    7b24:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    7b28:	f2c4 0306 	movt	r3, #16390	; 0x4006
    7b2c:	78db      	ldrb	r3, [r3, #3]
    7b2e:	b2db      	uxtb	r3, r3
    7b30:	f003 0320 	and.w	r3, r3, #32
    7b34:	2b00      	cmp	r3, #0
    7b36:	d005      	beq.n	7b44 <UART2_RX_TX_IRQHandler+0x38>
  {
    UART_R_ISR[0]();
    7b38:	f241 63e0 	movw	r3, #5856	; 0x16e0
    7b3c:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    7b40:	681b      	ldr	r3, [r3, #0]
    7b42:	4798      	blx	r3
  }
  //进入发送中断函数
  if((UART2_S1 & UART_S1_TDRE_MASK) && (UART2_C2 & UART_C2_TIE_MASK))
    7b44:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    7b48:	f2c4 0306 	movt	r3, #16390	; 0x4006
    7b4c:	791b      	ldrb	r3, [r3, #4]
    7b4e:	b2db      	uxtb	r3, r3
    7b50:	b2db      	uxtb	r3, r3
    7b52:	b25b      	sxtb	r3, r3
    7b54:	2b00      	cmp	r3, #0
    7b56:	da0f      	bge.n	7b78 <UART2_RX_TX_IRQHandler+0x6c>
    7b58:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    7b5c:	f2c4 0306 	movt	r3, #16390	; 0x4006
    7b60:	78db      	ldrb	r3, [r3, #3]
    7b62:	b2db      	uxtb	r3, r3
    7b64:	b2db      	uxtb	r3, r3
    7b66:	b25b      	sxtb	r3, r3
    7b68:	2b00      	cmp	r3, #0
    7b6a:	da05      	bge.n	7b78 <UART2_RX_TX_IRQHandler+0x6c>
  {
    UART_T_ISR[0]();
    7b6c:	f241 63c8 	movw	r3, #5832	; 0x16c8
    7b70:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    7b74:	681b      	ldr	r3, [r3, #0]
    7b76:	4798      	blx	r3
  }
}
    7b78:	bd80      	pop	{r7, pc}
    7b7a:	bf00      	nop

00007b7c <UART3_RX_TX_IRQHandler>:

//uart3
void UART3_RX_TX_IRQHandler(void)
{
    7b7c:	b580      	push	{r7, lr}
    7b7e:	af00      	add	r7, sp, #0
  //进入接收中断函数
  if((UART3_S1 & UART_S1_RDRF_MASK) && (UART3_C2 & UART_C2_RIE_MASK))
    7b80:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    7b84:	f2c4 0306 	movt	r3, #16390	; 0x4006
    7b88:	791b      	ldrb	r3, [r3, #4]
    7b8a:	b2db      	uxtb	r3, r3
    7b8c:	f003 0320 	and.w	r3, r3, #32
    7b90:	2b00      	cmp	r3, #0
    7b92:	d00f      	beq.n	7bb4 <UART3_RX_TX_IRQHandler+0x38>
    7b94:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    7b98:	f2c4 0306 	movt	r3, #16390	; 0x4006
    7b9c:	78db      	ldrb	r3, [r3, #3]
    7b9e:	b2db      	uxtb	r3, r3
    7ba0:	f003 0320 	and.w	r3, r3, #32
    7ba4:	2b00      	cmp	r3, #0
    7ba6:	d005      	beq.n	7bb4 <UART3_RX_TX_IRQHandler+0x38>
  {
    UART_R_ISR[0]();
    7ba8:	f241 63e0 	movw	r3, #5856	; 0x16e0
    7bac:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    7bb0:	681b      	ldr	r3, [r3, #0]
    7bb2:	4798      	blx	r3
  }
  //进入发送中断函数
  if((UART3_S1 & UART_S1_TDRE_MASK) && (UART3_C2 & UART_C2_TIE_MASK))
    7bb4:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    7bb8:	f2c4 0306 	movt	r3, #16390	; 0x4006
    7bbc:	791b      	ldrb	r3, [r3, #4]
    7bbe:	b2db      	uxtb	r3, r3
    7bc0:	b2db      	uxtb	r3, r3
    7bc2:	b25b      	sxtb	r3, r3
    7bc4:	2b00      	cmp	r3, #0
    7bc6:	da0f      	bge.n	7be8 <UART3_RX_TX_IRQHandler+0x6c>
    7bc8:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    7bcc:	f2c4 0306 	movt	r3, #16390	; 0x4006
    7bd0:	78db      	ldrb	r3, [r3, #3]
    7bd2:	b2db      	uxtb	r3, r3
    7bd4:	b2db      	uxtb	r3, r3
    7bd6:	b25b      	sxtb	r3, r3
    7bd8:	2b00      	cmp	r3, #0
    7bda:	da05      	bge.n	7be8 <UART3_RX_TX_IRQHandler+0x6c>
  {
    UART_T_ISR[0]();
    7bdc:	f241 63c8 	movw	r3, #5832	; 0x16c8
    7be0:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    7be4:	681b      	ldr	r3, [r3, #0]
    7be6:	4798      	blx	r3
  }
}
    7be8:	bd80      	pop	{r7, pc}
    7bea:	bf00      	nop

00007bec <UART4_RX_TX_IRQHandler>:

//uart4
void UART4_RX_TX_IRQHandler(void)
{
    7bec:	b580      	push	{r7, lr}
    7bee:	af00      	add	r7, sp, #0
  //进入接收中断函数
  if((UART4_S1 & UART_S1_RDRF_MASK) && (UART4_C2 & UART_C2_RIE_MASK))
    7bf0:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    7bf4:	f2c4 030e 	movt	r3, #16398	; 0x400e
    7bf8:	791b      	ldrb	r3, [r3, #4]
    7bfa:	b2db      	uxtb	r3, r3
    7bfc:	f003 0320 	and.w	r3, r3, #32
    7c00:	2b00      	cmp	r3, #0
    7c02:	d00f      	beq.n	7c24 <UART4_RX_TX_IRQHandler+0x38>
    7c04:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    7c08:	f2c4 030e 	movt	r3, #16398	; 0x400e
    7c0c:	78db      	ldrb	r3, [r3, #3]
    7c0e:	b2db      	uxtb	r3, r3
    7c10:	f003 0320 	and.w	r3, r3, #32
    7c14:	2b00      	cmp	r3, #0
    7c16:	d005      	beq.n	7c24 <UART4_RX_TX_IRQHandler+0x38>
  {
    UART_R_ISR[0]();
    7c18:	f241 63e0 	movw	r3, #5856	; 0x16e0
    7c1c:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    7c20:	681b      	ldr	r3, [r3, #0]
    7c22:	4798      	blx	r3
  }
  //进入发送中断函数
  if((UART4_S1 & UART_S1_TDRE_MASK) && (UART4_C2 & UART_C2_TIE_MASK))
    7c24:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    7c28:	f2c4 030e 	movt	r3, #16398	; 0x400e
    7c2c:	791b      	ldrb	r3, [r3, #4]
    7c2e:	b2db      	uxtb	r3, r3
    7c30:	b2db      	uxtb	r3, r3
    7c32:	b25b      	sxtb	r3, r3
    7c34:	2b00      	cmp	r3, #0
    7c36:	da0f      	bge.n	7c58 <UART4_RX_TX_IRQHandler+0x6c>
    7c38:	f44f 4320 	mov.w	r3, #40960	; 0xa000
    7c3c:	f2c4 030e 	movt	r3, #16398	; 0x400e
    7c40:	78db      	ldrb	r3, [r3, #3]
    7c42:	b2db      	uxtb	r3, r3
    7c44:	b2db      	uxtb	r3, r3
    7c46:	b25b      	sxtb	r3, r3
    7c48:	2b00      	cmp	r3, #0
    7c4a:	da05      	bge.n	7c58 <UART4_RX_TX_IRQHandler+0x6c>
  {
    UART_T_ISR[0]();
    7c4c:	f241 63c8 	movw	r3, #5832	; 0x16c8
    7c50:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    7c54:	681b      	ldr	r3, [r3, #0]
    7c56:	4798      	blx	r3
  }
}
    7c58:	bd80      	pop	{r7, pc}
    7c5a:	bf00      	nop

00007c5c <UART5_RX_TX_IRQHandler>:

//uart3
void UART5_RX_TX_IRQHandler(void)
{
    7c5c:	b580      	push	{r7, lr}
    7c5e:	af00      	add	r7, sp, #0
  //进入接收中断函数
  if((UART5_S1 & UART_S1_RDRF_MASK) && (UART5_C2 & UART_C2_RIE_MASK))
    7c60:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    7c64:	f2c4 030e 	movt	r3, #16398	; 0x400e
    7c68:	791b      	ldrb	r3, [r3, #4]
    7c6a:	b2db      	uxtb	r3, r3
    7c6c:	f003 0320 	and.w	r3, r3, #32
    7c70:	2b00      	cmp	r3, #0
    7c72:	d00f      	beq.n	7c94 <UART5_RX_TX_IRQHandler+0x38>
    7c74:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    7c78:	f2c4 030e 	movt	r3, #16398	; 0x400e
    7c7c:	78db      	ldrb	r3, [r3, #3]
    7c7e:	b2db      	uxtb	r3, r3
    7c80:	f003 0320 	and.w	r3, r3, #32
    7c84:	2b00      	cmp	r3, #0
    7c86:	d005      	beq.n	7c94 <UART5_RX_TX_IRQHandler+0x38>
  {
    UART_R_ISR[0]();
    7c88:	f241 63e0 	movw	r3, #5856	; 0x16e0
    7c8c:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    7c90:	681b      	ldr	r3, [r3, #0]
    7c92:	4798      	blx	r3
  }
  //进入发送中断函数
  if((UART5_S1 & UART_S1_TDRE_MASK) && (UART5_C2 & UART_C2_TIE_MASK))
    7c94:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    7c98:	f2c4 030e 	movt	r3, #16398	; 0x400e
    7c9c:	791b      	ldrb	r3, [r3, #4]
    7c9e:	b2db      	uxtb	r3, r3
    7ca0:	b2db      	uxtb	r3, r3
    7ca2:	b25b      	sxtb	r3, r3
    7ca4:	2b00      	cmp	r3, #0
    7ca6:	da0f      	bge.n	7cc8 <UART5_RX_TX_IRQHandler+0x6c>
    7ca8:	f44f 4330 	mov.w	r3, #45056	; 0xb000
    7cac:	f2c4 030e 	movt	r3, #16398	; 0x400e
    7cb0:	78db      	ldrb	r3, [r3, #3]
    7cb2:	b2db      	uxtb	r3, r3
    7cb4:	b2db      	uxtb	r3, r3
    7cb6:	b25b      	sxtb	r3, r3
    7cb8:	2b00      	cmp	r3, #0
    7cba:	da05      	bge.n	7cc8 <UART5_RX_TX_IRQHandler+0x6c>
  {
    UART_T_ISR[0]();
    7cbc:	f241 63c8 	movw	r3, #5832	; 0x16c8
    7cc0:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
    7cc4:	681b      	ldr	r3, [r3, #0]
    7cc6:	4798      	blx	r3
  }
}
    7cc8:	bd80      	pop	{r7, pc}
    7cca:	bf00      	nop

00007ccc <in_char>:
#include "common.h"
#include "hw_uart.h"

/********************************************************************/
int8 in_char (void)
{
    7ccc:	b580      	push	{r7, lr}
    7cce:	af00      	add	r7, sp, #0
	return LPLD_UART_GetChar(TERM_PORT);
    7cd0:	f44f 4020 	mov.w	r0, #40960	; 0xa000
    7cd4:	f2c4 000e 	movt	r0, #16398	; 0x400e
    7cd8:	f7ff fd9e 	bl	7818 <LPLD_UART_GetChar>
    7cdc:	4603      	mov	r3, r0
}
    7cde:	4618      	mov	r0, r3
    7ce0:	bd80      	pop	{r7, pc}
    7ce2:	bf00      	nop

00007ce4 <out_char>:
/********************************************************************/
void out_char (int8 ch)
{
    7ce4:	b580      	push	{r7, lr}
    7ce6:	b082      	sub	sp, #8
    7ce8:	af00      	add	r7, sp, #0
    7cea:	4603      	mov	r3, r0
    7cec:	71fb      	strb	r3, [r7, #7]
	LPLD_UART_PutChar(TERM_PORT, ch);
    7cee:	f997 3007 	ldrsb.w	r3, [r7, #7]
    7cf2:	f44f 4020 	mov.w	r0, #40960	; 0xa000
    7cf6:	f2c4 000e 	movt	r0, #16398	; 0x400e
    7cfa:	4619      	mov	r1, r3
    7cfc:	f7ff fdb4 	bl	7868 <LPLD_UART_PutChar>
}
    7d00:	f107 0708 	add.w	r7, r7, #8
    7d04:	46bd      	mov	sp, r7
    7d06:	bd80      	pop	{r7, pc}

00007d08 <char_present>:
/********************************************************************/
int32 char_present (void)
{
    7d08:	b580      	push	{r7, lr}
    7d0a:	af00      	add	r7, sp, #0
	return LPLD_UART_GetChar_Present(TERM_PORT);
    7d0c:	f44f 4020 	mov.w	r0, #40960	; 0xa000
    7d10:	f2c4 000e 	movt	r0, #16398	; 0x400e
    7d14:	f7ff fd98 	bl	7848 <LPLD_UART_GetChar_Present>
    7d18:	4603      	mov	r3, r0
}
    7d1a:	4618      	mov	r0, r3
    7d1c:	bd80      	pop	{r7, pc}
    7d1e:	bf00      	nop

00007d20 <printk_putc>:
#define IS_FMT_p(a)     (a & FMT_p)
#define IS_FMT_n(a)     (a & FMT_n)

/********************************************************************/
static void printk_putc (int32 c, int32 *count, PRINTK_INFO *info)
{
    7d20:	b580      	push	{r7, lr}
    7d22:	b084      	sub	sp, #16
    7d24:	af00      	add	r7, sp, #0
    7d26:	60f8      	str	r0, [r7, #12]
    7d28:	60b9      	str	r1, [r7, #8]
    7d2a:	607a      	str	r2, [r7, #4]
    switch (info->dest)
    7d2c:	687b      	ldr	r3, [r7, #4]
    7d2e:	681b      	ldr	r3, [r3, #0]
    7d30:	2b01      	cmp	r3, #1
    7d32:	d002      	beq.n	7d3a <printk_putc+0x1a>
    7d34:	2b02      	cmp	r3, #2
    7d36:	d008      	beq.n	7d4a <printk_putc+0x2a>
    7d38:	e013      	b.n	7d62 <printk_putc+0x42>
    {
        case DEST_CONSOLE:
            info->func((int8)c);
    7d3a:	687b      	ldr	r3, [r7, #4]
    7d3c:	685b      	ldr	r3, [r3, #4]
    7d3e:	68fa      	ldr	r2, [r7, #12]
    7d40:	b2d2      	uxtb	r2, r2
    7d42:	b252      	sxtb	r2, r2
    7d44:	4610      	mov	r0, r2
    7d46:	4798      	blx	r3
            break;
    7d48:	e00c      	b.n	7d64 <printk_putc+0x44>
        case DEST_STRING:
            *(info->loc) = (uint8)c;
    7d4a:	687b      	ldr	r3, [r7, #4]
    7d4c:	689b      	ldr	r3, [r3, #8]
    7d4e:	68fa      	ldr	r2, [r7, #12]
    7d50:	b2d2      	uxtb	r2, r2
    7d52:	701a      	strb	r2, [r3, #0]
            ++(info->loc);
    7d54:	687b      	ldr	r3, [r7, #4]
    7d56:	689b      	ldr	r3, [r3, #8]
    7d58:	f103 0201 	add.w	r2, r3, #1
    7d5c:	687b      	ldr	r3, [r7, #4]
    7d5e:	609a      	str	r2, [r3, #8]
            break;
    7d60:	e000      	b.n	7d64 <printk_putc+0x44>
        default:
            break;
    7d62:	bf00      	nop
    }
    *count += 1;
    7d64:	68bb      	ldr	r3, [r7, #8]
    7d66:	681b      	ldr	r3, [r3, #0]
    7d68:	f103 0201 	add.w	r2, r3, #1
    7d6c:	68bb      	ldr	r3, [r7, #8]
    7d6e:	601a      	str	r2, [r3, #0]
}
    7d70:	f107 0710 	add.w	r7, r7, #16
    7d74:	46bd      	mov	sp, r7
    7d76:	bd80      	pop	{r7, pc}

00007d78 <printk_mknumstr>:

/********************************************************************/
static int32 printk_mknumstr (int8 *numstr, void *nump, int32 neg, int32 radix)
{
    7d78:	b480      	push	{r7}
    7d7a:	b08d      	sub	sp, #52	; 0x34
    7d7c:	af00      	add	r7, sp, #0
    7d7e:	60f8      	str	r0, [r7, #12]
    7d80:	60b9      	str	r1, [r7, #8]
    7d82:	607a      	str	r2, [r7, #4]
    7d84:	603b      	str	r3, [r7, #0]
    uint32 ua,ub,uc;

    int32 nlen;
    int8 *nstrp;

    nlen = 0;
    7d86:	f04f 0300 	mov.w	r3, #0
    7d8a:	61fb      	str	r3, [r7, #28]
    nstrp = numstr;
    7d8c:	68fb      	ldr	r3, [r7, #12]
    7d8e:	61bb      	str	r3, [r7, #24]
    *nstrp++ = '\0';
    7d90:	69bb      	ldr	r3, [r7, #24]
    7d92:	f04f 0200 	mov.w	r2, #0
    7d96:	701a      	strb	r2, [r3, #0]
    7d98:	69bb      	ldr	r3, [r7, #24]
    7d9a:	f103 0301 	add.w	r3, r3, #1
    7d9e:	61bb      	str	r3, [r7, #24]

    if (neg)
    7da0:	687b      	ldr	r3, [r7, #4]
    7da2:	2b00      	cmp	r3, #0
    7da4:	d038      	beq.n	7e18 <printk_mknumstr+0xa0>
    {
        a = *(int32 *)nump;
    7da6:	68bb      	ldr	r3, [r7, #8]
    7da8:	681b      	ldr	r3, [r3, #0]
    7daa:	62fb      	str	r3, [r7, #44]	; 0x2c
        if (a == 0)
    7dac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    7dae:	2b00      	cmp	r3, #0
    7db0:	d12e      	bne.n	7e10 <printk_mknumstr+0x98>
        {
            *nstrp = '0';
    7db2:	69bb      	ldr	r3, [r7, #24]
    7db4:	f04f 0230 	mov.w	r2, #48	; 0x30
    7db8:	701a      	strb	r2, [r3, #0]
            ++nlen;
    7dba:	69fb      	ldr	r3, [r7, #28]
    7dbc:	f103 0301 	add.w	r3, r3, #1
    7dc0:	61fb      	str	r3, [r7, #28]
            goto done;
    7dc2:	e061      	b.n	7e88 <printk_mknumstr+0x110>
        }
        while (a != 0)
        {
            b = (int32)a / (int32)radix;
    7dc4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    7dc6:	683b      	ldr	r3, [r7, #0]
    7dc8:	fb92 f3f3 	sdiv	r3, r2, r3
    7dcc:	617b      	str	r3, [r7, #20]
            c = (int32)a - ((int32)b * (int32)radix);
    7dce:	697b      	ldr	r3, [r7, #20]
    7dd0:	683a      	ldr	r2, [r7, #0]
    7dd2:	fb02 f303 	mul.w	r3, r2, r3
    7dd6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    7dd8:	1ad3      	subs	r3, r2, r3
    7dda:	62bb      	str	r3, [r7, #40]	; 0x28
            if (c < 0)
    7ddc:	6abb      	ldr	r3, [r7, #40]	; 0x28
    7dde:	2b00      	cmp	r3, #0
    7de0:	da04      	bge.n	7dec <printk_mknumstr+0x74>
            {
                c = ~c + 1 + '0';
    7de2:	6abb      	ldr	r3, [r7, #40]	; 0x28
    7de4:	f1c3 0330 	rsb	r3, r3, #48	; 0x30
    7de8:	62bb      	str	r3, [r7, #40]	; 0x28
    7dea:	e003      	b.n	7df4 <printk_mknumstr+0x7c>
            }
            else
            {
                c = c + '0';
    7dec:	6abb      	ldr	r3, [r7, #40]	; 0x28
    7dee:	f103 0330 	add.w	r3, r3, #48	; 0x30
    7df2:	62bb      	str	r3, [r7, #40]	; 0x28
            }
            a = b;
    7df4:	697b      	ldr	r3, [r7, #20]
    7df6:	62fb      	str	r3, [r7, #44]	; 0x2c
            *nstrp++ = (int8)c;
    7df8:	6abb      	ldr	r3, [r7, #40]	; 0x28
    7dfa:	b2da      	uxtb	r2, r3
    7dfc:	69bb      	ldr	r3, [r7, #24]
    7dfe:	701a      	strb	r2, [r3, #0]
    7e00:	69bb      	ldr	r3, [r7, #24]
    7e02:	f103 0301 	add.w	r3, r3, #1
    7e06:	61bb      	str	r3, [r7, #24]
            ++nlen;
    7e08:	69fb      	ldr	r3, [r7, #28]
    7e0a:	f103 0301 	add.w	r3, r3, #1
    7e0e:	61fb      	str	r3, [r7, #28]
        {
            *nstrp = '0';
            ++nlen;
            goto done;
        }
        while (a != 0)
    7e10:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    7e12:	2b00      	cmp	r3, #0
    7e14:	d1d6      	bne.n	7dc4 <printk_mknumstr+0x4c>
    7e16:	e037      	b.n	7e88 <printk_mknumstr+0x110>
            ++nlen;
        }
    }
    else
    {
        ua = *(uint32 *)nump;
    7e18:	68bb      	ldr	r3, [r7, #8]
    7e1a:	681b      	ldr	r3, [r3, #0]
    7e1c:	627b      	str	r3, [r7, #36]	; 0x24
        if (ua == 0)
    7e1e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    7e20:	2b00      	cmp	r3, #0
    7e22:	d12e      	bne.n	7e82 <printk_mknumstr+0x10a>
        {
            *nstrp = '0';
    7e24:	69bb      	ldr	r3, [r7, #24]
    7e26:	f04f 0230 	mov.w	r2, #48	; 0x30
    7e2a:	701a      	strb	r2, [r3, #0]
            ++nlen;
    7e2c:	69fb      	ldr	r3, [r7, #28]
    7e2e:	f103 0301 	add.w	r3, r3, #1
    7e32:	61fb      	str	r3, [r7, #28]
            goto done;
    7e34:	e028      	b.n	7e88 <printk_mknumstr+0x110>
        }
        while (ua != 0)
        {
            ub = (uint32)ua / (uint32)radix;
    7e36:	683b      	ldr	r3, [r7, #0]
    7e38:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    7e3a:	fbb2 f3f3 	udiv	r3, r2, r3
    7e3e:	613b      	str	r3, [r7, #16]
            uc = (uint32)ua - ((uint32)ub * (uint32)radix);
    7e40:	683b      	ldr	r3, [r7, #0]
    7e42:	693a      	ldr	r2, [r7, #16]
    7e44:	fb02 f303 	mul.w	r3, r2, r3
    7e48:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    7e4a:	1ad3      	subs	r3, r2, r3
    7e4c:	623b      	str	r3, [r7, #32]
            if (uc < 10)
    7e4e:	6a3b      	ldr	r3, [r7, #32]
    7e50:	2b09      	cmp	r3, #9
    7e52:	d804      	bhi.n	7e5e <printk_mknumstr+0xe6>
            {
                uc = uc + '0';
    7e54:	6a3b      	ldr	r3, [r7, #32]
    7e56:	f103 0330 	add.w	r3, r3, #48	; 0x30
    7e5a:	623b      	str	r3, [r7, #32]
    7e5c:	e003      	b.n	7e66 <printk_mknumstr+0xee>
            }
            else
            {
                uc = uc - 10 + 'A';
    7e5e:	6a3b      	ldr	r3, [r7, #32]
    7e60:	f103 0337 	add.w	r3, r3, #55	; 0x37
    7e64:	623b      	str	r3, [r7, #32]
            }
            ua = ub;
    7e66:	693b      	ldr	r3, [r7, #16]
    7e68:	627b      	str	r3, [r7, #36]	; 0x24
            *nstrp++ = (int8)uc;
    7e6a:	6a3b      	ldr	r3, [r7, #32]
    7e6c:	b2da      	uxtb	r2, r3
    7e6e:	69bb      	ldr	r3, [r7, #24]
    7e70:	701a      	strb	r2, [r3, #0]
    7e72:	69bb      	ldr	r3, [r7, #24]
    7e74:	f103 0301 	add.w	r3, r3, #1
    7e78:	61bb      	str	r3, [r7, #24]
            ++nlen;
    7e7a:	69fb      	ldr	r3, [r7, #28]
    7e7c:	f103 0301 	add.w	r3, r3, #1
    7e80:	61fb      	str	r3, [r7, #28]
        {
            *nstrp = '0';
            ++nlen;
            goto done;
        }
        while (ua != 0)
    7e82:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    7e84:	2b00      	cmp	r3, #0
    7e86:	d1d6      	bne.n	7e36 <printk_mknumstr+0xbe>
            *nstrp++ = (int8)uc;
            ++nlen;
        }
    }
    done:
    return nlen;
    7e88:	69fb      	ldr	r3, [r7, #28]
}
    7e8a:	4618      	mov	r0, r3
    7e8c:	f107 0734 	add.w	r7, r7, #52	; 0x34
    7e90:	46bd      	mov	sp, r7
    7e92:	bc80      	pop	{r7}
    7e94:	4770      	bx	lr
    7e96:	bf00      	nop

00007e98 <printk_pad_zero>:

/********************************************************************/
static void printk_pad_zero (int32 curlen, int32 field_width, int32 *count, PRINTK_INFO *info)
{
    7e98:	b580      	push	{r7, lr}
    7e9a:	b086      	sub	sp, #24
    7e9c:	af00      	add	r7, sp, #0
    7e9e:	60f8      	str	r0, [r7, #12]
    7ea0:	60b9      	str	r1, [r7, #8]
    7ea2:	607a      	str	r2, [r7, #4]
    7ea4:	603b      	str	r3, [r7, #0]
    int32 i;

    for (i = curlen; i < field_width; i++)
    7ea6:	68fb      	ldr	r3, [r7, #12]
    7ea8:	617b      	str	r3, [r7, #20]
    7eaa:	e009      	b.n	7ec0 <printk_pad_zero+0x28>
    {
        printk_putc('0',count, info);
    7eac:	f04f 0030 	mov.w	r0, #48	; 0x30
    7eb0:	6879      	ldr	r1, [r7, #4]
    7eb2:	683a      	ldr	r2, [r7, #0]
    7eb4:	f7ff ff34 	bl	7d20 <printk_putc>
/********************************************************************/
static void printk_pad_zero (int32 curlen, int32 field_width, int32 *count, PRINTK_INFO *info)
{
    int32 i;

    for (i = curlen; i < field_width; i++)
    7eb8:	697b      	ldr	r3, [r7, #20]
    7eba:	f103 0301 	add.w	r3, r3, #1
    7ebe:	617b      	str	r3, [r7, #20]
    7ec0:	697a      	ldr	r2, [r7, #20]
    7ec2:	68bb      	ldr	r3, [r7, #8]
    7ec4:	429a      	cmp	r2, r3
    7ec6:	dbf1      	blt.n	7eac <printk_pad_zero+0x14>
    {
        printk_putc('0',count, info);
    }
}
    7ec8:	f107 0718 	add.w	r7, r7, #24
    7ecc:	46bd      	mov	sp, r7
    7ece:	bd80      	pop	{r7, pc}

00007ed0 <printk_pad_space>:

/********************************************************************/
static void
printk_pad_space (int32 curlen, int32 field_width, int32 *count, PRINTK_INFO *info)
{
    7ed0:	b580      	push	{r7, lr}
    7ed2:	b086      	sub	sp, #24
    7ed4:	af00      	add	r7, sp, #0
    7ed6:	60f8      	str	r0, [r7, #12]
    7ed8:	60b9      	str	r1, [r7, #8]
    7eda:	607a      	str	r2, [r7, #4]
    7edc:	603b      	str	r3, [r7, #0]
    int32 i;

    for (i = curlen; i < field_width; i++)
    7ede:	68fb      	ldr	r3, [r7, #12]
    7ee0:	617b      	str	r3, [r7, #20]
    7ee2:	e009      	b.n	7ef8 <printk_pad_space+0x28>
    {
        printk_putc(' ',count, info);
    7ee4:	f04f 0020 	mov.w	r0, #32
    7ee8:	6879      	ldr	r1, [r7, #4]
    7eea:	683a      	ldr	r2, [r7, #0]
    7eec:	f7ff ff18 	bl	7d20 <printk_putc>
static void
printk_pad_space (int32 curlen, int32 field_width, int32 *count, PRINTK_INFO *info)
{
    int32 i;

    for (i = curlen; i < field_width; i++)
    7ef0:	697b      	ldr	r3, [r7, #20]
    7ef2:	f103 0301 	add.w	r3, r3, #1
    7ef6:	617b      	str	r3, [r7, #20]
    7ef8:	697a      	ldr	r2, [r7, #20]
    7efa:	68bb      	ldr	r3, [r7, #8]
    7efc:	429a      	cmp	r2, r3
    7efe:	dbf1      	blt.n	7ee4 <printk_pad_space+0x14>
    {
        printk_putc(' ',count, info);
    }
}
    7f00:	f107 0718 	add.w	r7, r7, #24
    7f04:	46bd      	mov	sp, r7
    7f06:	bd80      	pop	{r7, pc}

00007f08 <printk>:

/********************************************************************/
int32 printk (PRINTK_INFO *info, const char *fmt, va_list ap)
{
    7f08:	b580      	push	{r7, lr}
    7f0a:	b09c      	sub	sp, #112	; 0x70
    7f0c:	af00      	add	r7, sp, #0
    7f0e:	60f8      	str	r0, [r7, #12]
    7f10:	60b9      	str	r1, [r7, #8]
    7f12:	607a      	str	r2, [r7, #4]
    int8 vstr[33];
    int8 *vstrp;
    int32 vlen;

    int32 done;
    int32 count = 0;
    7f14:	f04f 0300 	mov.w	r3, #0
    7f18:	61bb      	str	r3, [r7, #24]

    /*
     * Start parsing apart the format string and display appropriate
     * formats and data.
     */
    for (p = (int8 *)fmt; (c = *p) != 0; p++)
    7f1a:	68bb      	ldr	r3, [r7, #8]
    7f1c:	66fb      	str	r3, [r7, #108]	; 0x6c
    7f1e:	e352      	b.n	85c6 <printk+0x6be>
         * All formats begin with a '%' marker.  Special chars like
         * '\n' or '\t' are normally converted to the appropriate
         * character by the __compiler__.  Thus, no need for this
         * routine to account for the '\' character.
         */
        if (c != '%')
    7f20:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    7f22:	2b25      	cmp	r3, #37	; 0x25
    7f24:	d01b      	beq.n	7f5e <printk+0x56>
            /*
             * This needs to be replaced with something like
             * 'out_char()' or call an OS routine.
             */
#ifndef UNIX_DEBUG
            if (c != '\n')
    7f26:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    7f28:	2b0a      	cmp	r3, #10
    7f2a:	d007      	beq.n	7f3c <printk+0x34>
            {
                printk_putc(c, &count, info);
    7f2c:	f107 0318 	add.w	r3, r7, #24
    7f30:	6cb8      	ldr	r0, [r7, #72]	; 0x48
    7f32:	4619      	mov	r1, r3
    7f34:	68fa      	ldr	r2, [r7, #12]
    7f36:	f7ff fef3 	bl	7d20 <printk_putc>

            /*
             * By using 'continue', the next iteration of the loop
             * is used, skipping the code that follows.
             */
            continue;
    7f3a:	e340      	b.n	85be <printk+0x6b6>
            {
                printk_putc(c, &count, info);
            }
            else
            {
                printk_putc(0x0D /* CR */, &count, info);
    7f3c:	f107 0318 	add.w	r3, r7, #24
    7f40:	f04f 000d 	mov.w	r0, #13
    7f44:	4619      	mov	r1, r3
    7f46:	68fa      	ldr	r2, [r7, #12]
    7f48:	f7ff feea 	bl	7d20 <printk_putc>
                printk_putc(0x0A /* LF */, &count, info);
    7f4c:	f107 0318 	add.w	r3, r7, #24
    7f50:	f04f 000a 	mov.w	r0, #10
    7f54:	4619      	mov	r1, r3
    7f56:	68fa      	ldr	r2, [r7, #12]
    7f58:	f7ff fee2 	bl	7d20 <printk_putc>

            /*
             * By using 'continue', the next iteration of the loop
             * is used, skipping the code that follows.
             */
            continue;
    7f5c:	e32f      	b.n	85be <printk+0x6b6>
        }

        /*
         * First check for specification modifier flags.
         */
        flags_used = 0;
    7f5e:	f04f 0300 	mov.w	r3, #0
    7f62:	65fb      	str	r3, [r7, #92]	; 0x5c
        done = FALSE;
    7f64:	f04f 0300 	mov.w	r3, #0
    7f68:	663b      	str	r3, [r7, #96]	; 0x60
        while (!done)
    7f6a:	e050      	b.n	800e <printk+0x106>
        {
            switch (/* c = */ *++p)
    7f6c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    7f6e:	f103 0301 	add.w	r3, r3, #1
    7f72:	66fb      	str	r3, [r7, #108]	; 0x6c
    7f74:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    7f76:	781b      	ldrb	r3, [r3, #0]
    7f78:	b25b      	sxtb	r3, r3
    7f7a:	f1a3 0320 	sub.w	r3, r3, #32
    7f7e:	2b10      	cmp	r3, #16
    7f80:	d83d      	bhi.n	7ffe <printk+0xf6>
    7f82:	a201      	add	r2, pc, #4	; (adr r2, 7f88 <printk+0x80>)
    7f84:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    7f88:	00007fe1 	andeq	r7, r0, r1, ror #31
    7f8c:	00007fff 	strdeq	r7, [r0], -pc	; <UNPREDICTABLE>
    7f90:	00007fff 	strdeq	r7, [r0], -pc	; <UNPREDICTABLE>
    7f94:	00007ff5 	strdeq	r7, [r0], -r5
    7f98:	00007fff 	strdeq	r7, [r0], -pc	; <UNPREDICTABLE>
    7f9c:	00007fff 	strdeq	r7, [r0], -pc	; <UNPREDICTABLE>
    7fa0:	00007fff 	strdeq	r7, [r0], -pc	; <UNPREDICTABLE>
    7fa4:	00007fff 	strdeq	r7, [r0], -pc	; <UNPREDICTABLE>
    7fa8:	00007fff 	strdeq	r7, [r0], -pc	; <UNPREDICTABLE>
    7fac:	00007fff 	strdeq	r7, [r0], -pc	; <UNPREDICTABLE>
    7fb0:	00007fff 	strdeq	r7, [r0], -pc	; <UNPREDICTABLE>
    7fb4:	00007fd7 	ldrdeq	r7, [r0], -r7	; <UNPREDICTABLE>
    7fb8:	00007fff 	strdeq	r7, [r0], -pc	; <UNPREDICTABLE>
    7fbc:	00007fcd 	andeq	r7, r0, sp, asr #31
    7fc0:	00007fff 	strdeq	r7, [r0], -pc	; <UNPREDICTABLE>
    7fc4:	00007fff 	strdeq	r7, [r0], -pc	; <UNPREDICTABLE>
    7fc8:	00007feb 	andeq	r7, r0, fp, ror #31
            {
                case '-':
                    flags_used |= FLAGS_MINUS;
    7fcc:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    7fce:	f043 0301 	orr.w	r3, r3, #1
    7fd2:	65fb      	str	r3, [r7, #92]	; 0x5c
                    break;
    7fd4:	e01b      	b.n	800e <printk+0x106>
                case '+':
                    flags_used |= FLAGS_PLUS;
    7fd6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    7fd8:	f043 0302 	orr.w	r3, r3, #2
    7fdc:	65fb      	str	r3, [r7, #92]	; 0x5c
                    break;
    7fde:	e016      	b.n	800e <printk+0x106>
                case ' ':
                    flags_used |= FLAGS_SPACE;
    7fe0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    7fe2:	f043 0304 	orr.w	r3, r3, #4
    7fe6:	65fb      	str	r3, [r7, #92]	; 0x5c
                    break;
    7fe8:	e011      	b.n	800e <printk+0x106>
                case '0':
                    flags_used |= FLAGS_ZERO;
    7fea:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    7fec:	f043 0308 	orr.w	r3, r3, #8
    7ff0:	65fb      	str	r3, [r7, #92]	; 0x5c
                    break;
    7ff2:	e00c      	b.n	800e <printk+0x106>
                case '#':
                    flags_used |= FLAGS_POUND;
    7ff4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    7ff6:	f043 0310 	orr.w	r3, r3, #16
    7ffa:	65fb      	str	r3, [r7, #92]	; 0x5c
                    break;
    7ffc:	e007      	b.n	800e <printk+0x106>
                default:
                    /* we've gone one int8 too far */
                    --p;
    7ffe:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    8000:	f103 33ff 	add.w	r3, r3, #4294967295
    8004:	66fb      	str	r3, [r7, #108]	; 0x6c
                    done = TRUE;
    8006:	f04f 0301 	mov.w	r3, #1
    800a:	663b      	str	r3, [r7, #96]	; 0x60
                    break;
    800c:	bf00      	nop
        /*
         * First check for specification modifier flags.
         */
        flags_used = 0;
        done = FALSE;
        while (!done)
    800e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    8010:	2b00      	cmp	r3, #0
    8012:	d0ab      	beq.n	7f6c <printk+0x64>
        }

        /*
         * Next check for minimum field width.
         */
        field_width = 0;
    8014:	f04f 0300 	mov.w	r3, #0
    8018:	65bb      	str	r3, [r7, #88]	; 0x58
        done = FALSE;
    801a:	f04f 0300 	mov.w	r3, #0
    801e:	663b      	str	r3, [r7, #96]	; 0x60
        while (!done)
    8020:	e022      	b.n	8068 <printk+0x160>
        {
            switch (c = *++p)
    8022:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    8024:	f103 0301 	add.w	r3, r3, #1
    8028:	66fb      	str	r3, [r7, #108]	; 0x6c
    802a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    802c:	781b      	ldrb	r3, [r3, #0]
    802e:	b25b      	sxtb	r3, r3
    8030:	64bb      	str	r3, [r7, #72]	; 0x48
    8032:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    8034:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
    8038:	2b09      	cmp	r3, #9
    803a:	d80d      	bhi.n	8058 <printk+0x150>
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    field_width = (field_width * 10) + (c - '0');
    803c:	6dba      	ldr	r2, [r7, #88]	; 0x58
    803e:	4613      	mov	r3, r2
    8040:	ea4f 0383 	mov.w	r3, r3, lsl #2
    8044:	189b      	adds	r3, r3, r2
    8046:	ea4f 0343 	mov.w	r3, r3, lsl #1
    804a:	461a      	mov	r2, r3
    804c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    804e:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
    8052:	18d3      	adds	r3, r2, r3
    8054:	65bb      	str	r3, [r7, #88]	; 0x58
                    break;
    8056:	e007      	b.n	8068 <printk+0x160>
                default:
                    /* we've gone one int8 too far */
                    --p;
    8058:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    805a:	f103 33ff 	add.w	r3, r3, #4294967295
    805e:	66fb      	str	r3, [r7, #108]	; 0x6c
                    done = TRUE;
    8060:	f04f 0301 	mov.w	r3, #1
    8064:	663b      	str	r3, [r7, #96]	; 0x60
                    break;
    8066:	bf00      	nop
        /*
         * Next check for minimum field width.
         */
        field_width = 0;
        done = FALSE;
        while (!done)
    8068:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    806a:	2b00      	cmp	r3, #0
    806c:	d0d9      	beq.n	8022 <printk+0x11a>
        }

        /*
         * Next check for the width and precision field separator.
         */
        if (/* (c = *++p) */ *++p == '.')
    806e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    8070:	f103 0301 	add.w	r3, r3, #1
    8074:	66fb      	str	r3, [r7, #108]	; 0x6c
    8076:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    8078:	781b      	ldrb	r3, [r3, #0]
    807a:	b25b      	sxtb	r3, r3
    807c:	2b2e      	cmp	r3, #46	; 0x2e
    807e:	d11b      	bne.n	80b8 <printk+0x1b0>

            /*
             * Must get precision field width, if present.
             */
            /* precision_width = 0; */
            done = FALSE;
    8080:	f04f 0300 	mov.w	r3, #0
    8084:	663b      	str	r3, [r7, #96]	; 0x60
            while (!done)
    8086:	e013      	b.n	80b0 <printk+0x1a8>
            {
                switch (/* c = uncomment if used below */ *++p)
    8088:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    808a:	f103 0301 	add.w	r3, r3, #1
    808e:	66fb      	str	r3, [r7, #108]	; 0x6c
    8090:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    8092:	781b      	ldrb	r3, [r3, #0]
    8094:	b25b      	sxtb	r3, r3
    8096:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
    809a:	2b09      	cmp	r3, #9
    809c:	d800      	bhi.n	80a0 <printk+0x198>
                    case '9':
#if 0
                        precision_width = (precision_width * 10) +
                            (c - '0');
#endif
                        break;
    809e:	e007      	b.n	80b0 <printk+0x1a8>
                    default:
                        /* we've gone one int8 too far */
                        --p;
    80a0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    80a2:	f103 33ff 	add.w	r3, r3, #4294967295
    80a6:	66fb      	str	r3, [r7, #108]	; 0x6c
                        done = TRUE;
    80a8:	f04f 0301 	mov.w	r3, #1
    80ac:	663b      	str	r3, [r7, #96]	; 0x60
                        break;
    80ae:	bf00      	nop
            /*
             * Must get precision field width, if present.
             */
            /* precision_width = 0; */
            done = FALSE;
            while (!done)
    80b0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    80b2:	2b00      	cmp	r3, #0
    80b4:	d0e8      	beq.n	8088 <printk+0x180>
    80b6:	e003      	b.n	80c0 <printk+0x1b8>
            }
        }
        else
        {
            /* we've gone one int8 too far */
            --p;
    80b8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    80ba:	f103 33ff 	add.w	r3, r3, #4294967295
    80be:	66fb      	str	r3, [r7, #108]	; 0x6c

        /*
         * Check for the length modifier.
         */
        /* length_modifier = 0; */
        switch (/* c = */ *++p)
    80c0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    80c2:	f103 0301 	add.w	r3, r3, #1
    80c6:	66fb      	str	r3, [r7, #108]	; 0x6c
    80c8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    80ca:	781b      	ldrb	r3, [r3, #0]
    80cc:	b25b      	sxtb	r3, r3
    80ce:	2b68      	cmp	r3, #104	; 0x68
    80d0:	d008      	beq.n	80e4 <printk+0x1dc>
    80d2:	2b6c      	cmp	r3, #108	; 0x6c
    80d4:	d008      	beq.n	80e8 <printk+0x1e0>
    80d6:	2b4c      	cmp	r3, #76	; 0x4c
    80d8:	d008      	beq.n	80ec <printk+0x1e4>
            case 'L':
                /* length_modifier |= LENMOD_L; */
                break;
            default:
                /* we've gone one int8 too far */
                --p;
    80da:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    80dc:	f103 33ff 	add.w	r3, r3, #4294967295
    80e0:	66fb      	str	r3, [r7, #108]	; 0x6c
                break;
    80e2:	e004      	b.n	80ee <printk+0x1e6>
        /* length_modifier = 0; */
        switch (/* c = */ *++p)
        {
            case 'h':
                /* length_modifier |= LENMOD_h; */
                break;
    80e4:	bf00      	nop
    80e6:	e002      	b.n	80ee <printk+0x1e6>
            case 'l':
                /* length_modifier |= LENMOD_l; */
                break;
    80e8:	bf00      	nop
    80ea:	e000      	b.n	80ee <printk+0x1e6>
            case 'L':
                /* length_modifier |= LENMOD_L; */
                break;
    80ec:	bf00      	nop
        }

        /*
         * Now we're ready to examine the format.
         */
        switch (c = *++p)
    80ee:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    80f0:	f103 0301 	add.w	r3, r3, #1
    80f4:	66fb      	str	r3, [r7, #108]	; 0x6c
    80f6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    80f8:	781b      	ldrb	r3, [r3, #0]
    80fa:	b25b      	sxtb	r3, r3
    80fc:	64bb      	str	r3, [r7, #72]	; 0x48
    80fe:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    8100:	f1a3 0358 	sub.w	r3, r3, #88	; 0x58
    8104:	2b20      	cmp	r3, #32
    8106:	f200 824f 	bhi.w	85a8 <printk+0x6a0>
    810a:	a201      	add	r2, pc, #4	; (adr r2, 8110 <printk+0x208>)
    810c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    8110:	000082a9 	andeq	r8, r0, r9, lsr #5
    8114:	000085a9 	andeq	r8, r0, r9, lsr #11
    8118:	000085a9 	andeq	r8, r0, r9, lsr #11
    811c:	000085a9 	andeq	r8, r0, r9, lsr #11
    8120:	000085a9 	andeq	r8, r0, r9, lsr #11
    8124:	000085a9 	andeq	r8, r0, r9, lsr #11
    8128:	000085a9 	andeq	r8, r0, r9, lsr #11
    812c:	000085a9 	andeq	r8, r0, r9, lsr #11
    8130:	000085a9 	andeq	r8, r0, r9, lsr #11
    8134:	000085a9 	andeq	r8, r0, r9, lsr #11
    8138:	000083f1 	strdeq	r8, [r0], -r1
    813c:	000084f9 	strdeq	r8, [r0], -r9
    8140:	00008195 	muleq	r0, r5, r1
    8144:	000085a9 	andeq	r8, r0, r9, lsr #11
    8148:	000085a9 	andeq	r8, r0, r9, lsr #11
    814c:	000085a9 	andeq	r8, r0, r9, lsr #11
    8150:	000085a9 	andeq	r8, r0, r9, lsr #11
    8154:	00008195 	muleq	r0, r5, r1
    8158:	000085a9 	andeq	r8, r0, r9, lsr #11
    815c:	000085a9 	andeq	r8, r0, r9, lsr #11
    8160:	000085a9 	andeq	r8, r0, r9, lsr #11
    8164:	000085a9 	andeq	r8, r0, r9, lsr #11
    8168:	00008595 	muleq	r0, r5, r5
    816c:	000083c9 	andeq	r8, r0, r9, asr #7
    8170:	00008419 	andeq	r8, r0, r9, lsl r4
    8174:	000085a9 	andeq	r8, r0, r9, lsr #11
    8178:	000085a9 	andeq	r8, r0, r9, lsr #11
    817c:	00008519 	andeq	r8, r0, r9, lsl r5
    8180:	000085a9 	andeq	r8, r0, r9, lsr #11
    8184:	00008441 	andeq	r8, r0, r1, asr #8
    8188:	000085a9 	andeq	r8, r0, r9, lsr #11
    818c:	000085a9 	andeq	r8, r0, r9, lsr #11
    8190:	000082a9 	andeq	r8, r0, r9, lsr #5
        {
            case 'd':
            case 'i':
                ival = (int32)va_arg(ap, int32);
    8194:	687b      	ldr	r3, [r7, #4]
    8196:	f103 0204 	add.w	r2, r3, #4
    819a:	607a      	str	r2, [r7, #4]
    819c:	681b      	ldr	r3, [r3, #0]
    819e:	617b      	str	r3, [r7, #20]
                vlen = printk_mknumstr(vstr,&ival,TRUE,10);
    81a0:	f107 021c 	add.w	r2, r7, #28
    81a4:	f107 0314 	add.w	r3, r7, #20
    81a8:	4610      	mov	r0, r2
    81aa:	4619      	mov	r1, r3
    81ac:	f04f 0201 	mov.w	r2, #1
    81b0:	f04f 030a 	mov.w	r3, #10
    81b4:	f7ff fde0 	bl	7d78 <printk_mknumstr>
    81b8:	6678      	str	r0, [r7, #100]	; 0x64
                vstrp = &vstr[vlen];
    81ba:	f107 021c 	add.w	r2, r7, #28
    81be:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    81c0:	18d3      	adds	r3, r2, r3
    81c2:	66bb      	str	r3, [r7, #104]	; 0x68

                if (ival < 0)
    81c4:	697b      	ldr	r3, [r7, #20]
    81c6:	2b00      	cmp	r3, #0
    81c8:	da07      	bge.n	81da <printk+0x2d2>
                {
                    schar = '-';
    81ca:	f04f 032d 	mov.w	r3, #45	; 0x2d
    81ce:	657b      	str	r3, [r7, #84]	; 0x54
                    ++vlen;
    81d0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    81d2:	f103 0301 	add.w	r3, r3, #1
    81d6:	667b      	str	r3, [r7, #100]	; 0x64
    81d8:	e01c      	b.n	8214 <printk+0x30c>
                }
                else
                {
                    if (IS_FLAG_PLUS(flags_used))
    81da:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    81dc:	f003 0302 	and.w	r3, r3, #2
    81e0:	2b00      	cmp	r3, #0
    81e2:	d007      	beq.n	81f4 <printk+0x2ec>
                    {
                        schar = '+';
    81e4:	f04f 032b 	mov.w	r3, #43	; 0x2b
    81e8:	657b      	str	r3, [r7, #84]	; 0x54
                        ++vlen;
    81ea:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    81ec:	f103 0301 	add.w	r3, r3, #1
    81f0:	667b      	str	r3, [r7, #100]	; 0x64
    81f2:	e00f      	b.n	8214 <printk+0x30c>
                    }
                    else
                    {
                        if (IS_FLAG_SPACE(flags_used))
    81f4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    81f6:	f003 0304 	and.w	r3, r3, #4
    81fa:	2b00      	cmp	r3, #0
    81fc:	d007      	beq.n	820e <printk+0x306>
                        {
                            schar = ' ';
    81fe:	f04f 0320 	mov.w	r3, #32
    8202:	657b      	str	r3, [r7, #84]	; 0x54
                            ++vlen;
    8204:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    8206:	f103 0301 	add.w	r3, r3, #1
    820a:	667b      	str	r3, [r7, #100]	; 0x64
    820c:	e002      	b.n	8214 <printk+0x30c>
                        }
                        else
                        {
                            schar = 0;
    820e:	f04f 0300 	mov.w	r3, #0
    8212:	657b      	str	r3, [r7, #84]	; 0x54
                        }
                    }
                }
                dschar = FALSE;
    8214:	f04f 0300 	mov.w	r3, #0
    8218:	653b      	str	r3, [r7, #80]	; 0x50
            
                /*
                 * do the ZERO pad.
                 */
                if (IS_FLAG_ZERO(flags_used))
    821a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    821c:	f003 0308 	and.w	r3, r3, #8
    8220:	2b00      	cmp	r3, #0
    8222:	d017      	beq.n	8254 <printk+0x34c>
                {
                    if (schar)
    8224:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    8226:	2b00      	cmp	r3, #0
    8228:	d006      	beq.n	8238 <printk+0x330>
                        printk_putc(schar, &count, info);
    822a:	f107 0318 	add.w	r3, r7, #24
    822e:	6d78      	ldr	r0, [r7, #84]	; 0x54
    8230:	4619      	mov	r1, r3
    8232:	68fa      	ldr	r2, [r7, #12]
    8234:	f7ff fd74 	bl	7d20 <printk_putc>
                    dschar = TRUE;
    8238:	f04f 0301 	mov.w	r3, #1
    823c:	653b      	str	r3, [r7, #80]	; 0x50
            
                    printk_pad_zero (vlen, field_width, &count, info);
    823e:	f107 0318 	add.w	r3, r7, #24
    8242:	6e78      	ldr	r0, [r7, #100]	; 0x64
    8244:	6db9      	ldr	r1, [r7, #88]	; 0x58
    8246:	461a      	mov	r2, r3
    8248:	68fb      	ldr	r3, [r7, #12]
    824a:	f7ff fe25 	bl	7e98 <printk_pad_zero>
                    vlen = field_width;
    824e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    8250:	667b      	str	r3, [r7, #100]	; 0x64
    8252:	e019      	b.n	8288 <printk+0x380>
                }
                else
                {
                    if (!IS_FLAG_MINUS(flags_used))
    8254:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    8256:	f003 0301 	and.w	r3, r3, #1
    825a:	2b00      	cmp	r3, #0
    825c:	d114      	bne.n	8288 <printk+0x380>
                    {
                        printk_pad_space (vlen, field_width, &count, info);
    825e:	f107 0318 	add.w	r3, r7, #24
    8262:	6e78      	ldr	r0, [r7, #100]	; 0x64
    8264:	6db9      	ldr	r1, [r7, #88]	; 0x58
    8266:	461a      	mov	r2, r3
    8268:	68fb      	ldr	r3, [r7, #12]
    826a:	f7ff fe31 	bl	7ed0 <printk_pad_space>
            
                        if (schar)
    826e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    8270:	2b00      	cmp	r3, #0
    8272:	d006      	beq.n	8282 <printk+0x37a>
                            printk_putc(schar, &count, info);
    8274:	f107 0318 	add.w	r3, r7, #24
    8278:	6d78      	ldr	r0, [r7, #84]	; 0x54
    827a:	4619      	mov	r1, r3
    827c:	68fa      	ldr	r2, [r7, #12]
    827e:	f7ff fd4f 	bl	7d20 <printk_putc>
                        dschar = TRUE;
    8282:	f04f 0301 	mov.w	r3, #1
    8286:	653b      	str	r3, [r7, #80]	; 0x50
                    }
                }
            
                /* the string was built in reverse order, now display in */
                /* correct order */
                if (!dschar && schar)
    8288:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    828a:	2b00      	cmp	r3, #0
    828c:	f040 810e 	bne.w	84ac <printk+0x5a4>
    8290:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    8292:	2b00      	cmp	r3, #0
    8294:	f000 810a 	beq.w	84ac <printk+0x5a4>
                {
                    printk_putc(schar, &count, info);
    8298:	f107 0318 	add.w	r3, r7, #24
    829c:	6d78      	ldr	r0, [r7, #84]	; 0x54
    829e:	4619      	mov	r1, r3
    82a0:	68fa      	ldr	r2, [r7, #12]
    82a2:	f7ff fd3d 	bl	7d20 <printk_putc>
                }
                goto cont_xd;
    82a6:	e101      	b.n	84ac <printk+0x5a4>

            case 'x':
            case 'X':
                uval = (uint32)va_arg(ap, uint32);
    82a8:	687b      	ldr	r3, [r7, #4]
    82aa:	f103 0204 	add.w	r2, r3, #4
    82ae:	607a      	str	r2, [r7, #4]
    82b0:	681b      	ldr	r3, [r3, #0]
    82b2:	613b      	str	r3, [r7, #16]
                vlen = printk_mknumstr(vstr,&uval,FALSE,16);
    82b4:	f107 021c 	add.w	r2, r7, #28
    82b8:	f107 0310 	add.w	r3, r7, #16
    82bc:	4610      	mov	r0, r2
    82be:	4619      	mov	r1, r3
    82c0:	f04f 0200 	mov.w	r2, #0
    82c4:	f04f 0310 	mov.w	r3, #16
    82c8:	f7ff fd56 	bl	7d78 <printk_mknumstr>
    82cc:	6678      	str	r0, [r7, #100]	; 0x64
                vstrp = &vstr[vlen];
    82ce:	f107 021c 	add.w	r2, r7, #28
    82d2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    82d4:	18d3      	adds	r3, r2, r3
    82d6:	66bb      	str	r3, [r7, #104]	; 0x68

                dschar = FALSE;
    82d8:	f04f 0300 	mov.w	r3, #0
    82dc:	653b      	str	r3, [r7, #80]	; 0x50
                if (IS_FLAG_ZERO(flags_used))
    82de:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    82e0:	f003 0308 	and.w	r3, r3, #8
    82e4:	2b00      	cmp	r3, #0
    82e6:	d022      	beq.n	832e <printk+0x426>
                {
                    if (IS_FLAG_POUND(flags_used))
    82e8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    82ea:	f003 0310 	and.w	r3, r3, #16
    82ee:	2b00      	cmp	r3, #0
    82f0:	d012      	beq.n	8318 <printk+0x410>
                    {
                        printk_putc('0', &count, info);
    82f2:	f107 0318 	add.w	r3, r7, #24
    82f6:	f04f 0030 	mov.w	r0, #48	; 0x30
    82fa:	4619      	mov	r1, r3
    82fc:	68fa      	ldr	r2, [r7, #12]
    82fe:	f7ff fd0f 	bl	7d20 <printk_putc>
                        printk_putc('x', &count, info);
    8302:	f107 0318 	add.w	r3, r7, #24
    8306:	f04f 0078 	mov.w	r0, #120	; 0x78
    830a:	4619      	mov	r1, r3
    830c:	68fa      	ldr	r2, [r7, #12]
    830e:	f7ff fd07 	bl	7d20 <printk_putc>
                        /*vlen += 2;*/
                        dschar = TRUE;
    8312:	f04f 0301 	mov.w	r3, #1
    8316:	653b      	str	r3, [r7, #80]	; 0x50
                    }
                    printk_pad_zero (vlen, field_width, &count, info);
    8318:	f107 0318 	add.w	r3, r7, #24
    831c:	6e78      	ldr	r0, [r7, #100]	; 0x64
    831e:	6db9      	ldr	r1, [r7, #88]	; 0x58
    8320:	461a      	mov	r2, r3
    8322:	68fb      	ldr	r3, [r7, #12]
    8324:	f7ff fdb8 	bl	7e98 <printk_pad_zero>
                    vlen = field_width;
    8328:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    832a:	667b      	str	r3, [r7, #100]	; 0x64
    832c:	e02d      	b.n	838a <printk+0x482>
                }
                else
                {
                    if (!IS_FLAG_MINUS(flags_used))
    832e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    8330:	f003 0301 	and.w	r3, r3, #1
    8334:	2b00      	cmp	r3, #0
    8336:	d128      	bne.n	838a <printk+0x482>
                    {
                        if (IS_FLAG_POUND(flags_used))
    8338:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    833a:	f003 0310 	and.w	r3, r3, #16
    833e:	2b00      	cmp	r3, #0
    8340:	d003      	beq.n	834a <printk+0x442>
                        {
                            vlen += 2;
    8342:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    8344:	f103 0302 	add.w	r3, r3, #2
    8348:	667b      	str	r3, [r7, #100]	; 0x64
                        }
                        printk_pad_space (vlen, field_width, &count, info);
    834a:	f107 0318 	add.w	r3, r7, #24
    834e:	6e78      	ldr	r0, [r7, #100]	; 0x64
    8350:	6db9      	ldr	r1, [r7, #88]	; 0x58
    8352:	461a      	mov	r2, r3
    8354:	68fb      	ldr	r3, [r7, #12]
    8356:	f7ff fdbb 	bl	7ed0 <printk_pad_space>
                        if (IS_FLAG_POUND(flags_used))
    835a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    835c:	f003 0310 	and.w	r3, r3, #16
    8360:	2b00      	cmp	r3, #0
    8362:	d012      	beq.n	838a <printk+0x482>
                        {
                            printk_putc('0', &count, info);
    8364:	f107 0318 	add.w	r3, r7, #24
    8368:	f04f 0030 	mov.w	r0, #48	; 0x30
    836c:	4619      	mov	r1, r3
    836e:	68fa      	ldr	r2, [r7, #12]
    8370:	f7ff fcd6 	bl	7d20 <printk_putc>
                            printk_putc('x', &count, info);
    8374:	f107 0318 	add.w	r3, r7, #24
    8378:	f04f 0078 	mov.w	r0, #120	; 0x78
    837c:	4619      	mov	r1, r3
    837e:	68fa      	ldr	r2, [r7, #12]
    8380:	f7ff fcce 	bl	7d20 <printk_putc>
                            dschar = TRUE;
    8384:	f04f 0301 	mov.w	r3, #1
    8388:	653b      	str	r3, [r7, #80]	; 0x50
                        }
                    }
                }

                if ((IS_FLAG_POUND(flags_used)) && !dschar)
    838a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    838c:	f003 0310 	and.w	r3, r3, #16
    8390:	2b00      	cmp	r3, #0
    8392:	f000 808d 	beq.w	84b0 <printk+0x5a8>
    8396:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    8398:	2b00      	cmp	r3, #0
    839a:	f040 8089 	bne.w	84b0 <printk+0x5a8>
                {
                    printk_putc('0', &count, info);
    839e:	f107 0318 	add.w	r3, r7, #24
    83a2:	f04f 0030 	mov.w	r0, #48	; 0x30
    83a6:	4619      	mov	r1, r3
    83a8:	68fa      	ldr	r2, [r7, #12]
    83aa:	f7ff fcb9 	bl	7d20 <printk_putc>
                    printk_putc('x', &count, info);
    83ae:	f107 0318 	add.w	r3, r7, #24
    83b2:	f04f 0078 	mov.w	r0, #120	; 0x78
    83b6:	4619      	mov	r1, r3
    83b8:	68fa      	ldr	r2, [r7, #12]
    83ba:	f7ff fcb1 	bl	7d20 <printk_putc>
                    vlen += 2;
    83be:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    83c0:	f103 0302 	add.w	r3, r3, #2
    83c4:	667b      	str	r3, [r7, #100]	; 0x64
                }
                goto cont_xd;
    83c6:	e073      	b.n	84b0 <printk+0x5a8>

            case 'o':
                uval = (uint32)va_arg(ap, uint32);
    83c8:	687b      	ldr	r3, [r7, #4]
    83ca:	f103 0204 	add.w	r2, r3, #4
    83ce:	607a      	str	r2, [r7, #4]
    83d0:	681b      	ldr	r3, [r3, #0]
    83d2:	613b      	str	r3, [r7, #16]
                vlen = printk_mknumstr(vstr,&uval,FALSE,8);
    83d4:	f107 021c 	add.w	r2, r7, #28
    83d8:	f107 0310 	add.w	r3, r7, #16
    83dc:	4610      	mov	r0, r2
    83de:	4619      	mov	r1, r3
    83e0:	f04f 0200 	mov.w	r2, #0
    83e4:	f04f 0308 	mov.w	r3, #8
    83e8:	f7ff fcc6 	bl	7d78 <printk_mknumstr>
    83ec:	6678      	str	r0, [r7, #100]	; 0x64
                goto cont_u;
    83ee:	e03a      	b.n	8466 <printk+0x55e>
            case 'b':
                uval = (uint32)va_arg(ap, uint32);
    83f0:	687b      	ldr	r3, [r7, #4]
    83f2:	f103 0204 	add.w	r2, r3, #4
    83f6:	607a      	str	r2, [r7, #4]
    83f8:	681b      	ldr	r3, [r3, #0]
    83fa:	613b      	str	r3, [r7, #16]
                vlen = printk_mknumstr(vstr,&uval,FALSE,2);
    83fc:	f107 021c 	add.w	r2, r7, #28
    8400:	f107 0310 	add.w	r3, r7, #16
    8404:	4610      	mov	r0, r2
    8406:	4619      	mov	r1, r3
    8408:	f04f 0200 	mov.w	r2, #0
    840c:	f04f 0302 	mov.w	r3, #2
    8410:	f7ff fcb2 	bl	7d78 <printk_mknumstr>
    8414:	6678      	str	r0, [r7, #100]	; 0x64
                goto cont_u;
    8416:	e026      	b.n	8466 <printk+0x55e>
            case 'p':
                uval = (uint32)va_arg(ap, void *);
    8418:	687b      	ldr	r3, [r7, #4]
    841a:	f103 0204 	add.w	r2, r3, #4
    841e:	607a      	str	r2, [r7, #4]
    8420:	681b      	ldr	r3, [r3, #0]
    8422:	613b      	str	r3, [r7, #16]
                vlen = printk_mknumstr(vstr,&uval,FALSE,16);
    8424:	f107 021c 	add.w	r2, r7, #28
    8428:	f107 0310 	add.w	r3, r7, #16
    842c:	4610      	mov	r0, r2
    842e:	4619      	mov	r1, r3
    8430:	f04f 0200 	mov.w	r2, #0
    8434:	f04f 0310 	mov.w	r3, #16
    8438:	f7ff fc9e 	bl	7d78 <printk_mknumstr>
    843c:	6678      	str	r0, [r7, #100]	; 0x64
                goto cont_u;
    843e:	e012      	b.n	8466 <printk+0x55e>
            case 'u':
                uval = (uint32)va_arg(ap, uint32);
    8440:	687b      	ldr	r3, [r7, #4]
    8442:	f103 0204 	add.w	r2, r3, #4
    8446:	607a      	str	r2, [r7, #4]
    8448:	681b      	ldr	r3, [r3, #0]
    844a:	613b      	str	r3, [r7, #16]
                vlen = printk_mknumstr(vstr,&uval,FALSE,10);
    844c:	f107 021c 	add.w	r2, r7, #28
    8450:	f107 0310 	add.w	r3, r7, #16
    8454:	4610      	mov	r0, r2
    8456:	4619      	mov	r1, r3
    8458:	f04f 0200 	mov.w	r2, #0
    845c:	f04f 030a 	mov.w	r3, #10
    8460:	f7ff fc8a 	bl	7d78 <printk_mknumstr>
    8464:	6678      	str	r0, [r7, #100]	; 0x64

                cont_u:
                    vstrp = &vstr[vlen];
    8466:	f107 021c 	add.w	r2, r7, #28
    846a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    846c:	18d3      	adds	r3, r2, r3
    846e:	66bb      	str	r3, [r7, #104]	; 0x68

                    if (IS_FLAG_ZERO(flags_used))
    8470:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    8472:	f003 0308 	and.w	r3, r3, #8
    8476:	2b00      	cmp	r3, #0
    8478:	d00a      	beq.n	8490 <printk+0x588>
                    {
                        printk_pad_zero (vlen, field_width, &count, info);
    847a:	f107 0318 	add.w	r3, r7, #24
    847e:	6e78      	ldr	r0, [r7, #100]	; 0x64
    8480:	6db9      	ldr	r1, [r7, #88]	; 0x58
    8482:	461a      	mov	r2, r3
    8484:	68fb      	ldr	r3, [r7, #12]
    8486:	f7ff fd07 	bl	7e98 <printk_pad_zero>
                        vlen = field_width;
    848a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    848c:	667b      	str	r3, [r7, #100]	; 0x64
                            printk_pad_space (vlen, field_width, &count, info);
                        }
                    }

                cont_xd:
                    while (*vstrp)
    848e:	e020      	b.n	84d2 <printk+0x5ca>
                        printk_pad_zero (vlen, field_width, &count, info);
                        vlen = field_width;
                    }
                    else
                    {
                        if (!IS_FLAG_MINUS(flags_used))
    8490:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    8492:	f003 0301 	and.w	r3, r3, #1
    8496:	2b00      	cmp	r3, #0
    8498:	d11b      	bne.n	84d2 <printk+0x5ca>
                        {
                            printk_pad_space (vlen, field_width, &count, info);
    849a:	f107 0318 	add.w	r3, r7, #24
    849e:	6e78      	ldr	r0, [r7, #100]	; 0x64
    84a0:	6db9      	ldr	r1, [r7, #88]	; 0x58
    84a2:	461a      	mov	r2, r3
    84a4:	68fb      	ldr	r3, [r7, #12]
    84a6:	f7ff fd13 	bl	7ed0 <printk_pad_space>
                        }
                    }

                cont_xd:
                    while (*vstrp)
    84aa:	e012      	b.n	84d2 <printk+0x5ca>
                /* correct order */
                if (!dschar && schar)
                {
                    printk_putc(schar, &count, info);
                }
                goto cont_xd;
    84ac:	bf00      	nop
    84ae:	e000      	b.n	84b2 <printk+0x5aa>
                {
                    printk_putc('0', &count, info);
                    printk_putc('x', &count, info);
                    vlen += 2;
                }
                goto cont_xd;
    84b0:	bf00      	nop
                            printk_pad_space (vlen, field_width, &count, info);
                        }
                    }

                cont_xd:
                    while (*vstrp)
    84b2:	e00e      	b.n	84d2 <printk+0x5ca>
                        printk_putc(*vstrp--, &count, info);
    84b4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    84b6:	781b      	ldrb	r3, [r3, #0]
    84b8:	b25a      	sxtb	r2, r3
    84ba:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    84bc:	f103 33ff 	add.w	r3, r3, #4294967295
    84c0:	66bb      	str	r3, [r7, #104]	; 0x68
    84c2:	f107 0318 	add.w	r3, r7, #24
    84c6:	4610      	mov	r0, r2
    84c8:	4619      	mov	r1, r3
    84ca:	68fa      	ldr	r2, [r7, #12]
    84cc:	f7ff fc28 	bl	7d20 <printk_putc>
    84d0:	e000      	b.n	84d4 <printk+0x5cc>
                            printk_pad_space (vlen, field_width, &count, info);
                        }
                    }

                cont_xd:
                    while (*vstrp)
    84d2:	bf00      	nop
    84d4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    84d6:	781b      	ldrb	r3, [r3, #0]
    84d8:	2b00      	cmp	r3, #0
    84da:	d1eb      	bne.n	84b4 <printk+0x5ac>
                        printk_putc(*vstrp--, &count, info);

                    if (IS_FLAG_MINUS(flags_used))
    84dc:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    84de:	f003 0301 	and.w	r3, r3, #1
    84e2:	2b00      	cmp	r3, #0
    84e4:	d068      	beq.n	85b8 <printk+0x6b0>
                    {
                        printk_pad_space (vlen, field_width, &count, info);
    84e6:	f107 0318 	add.w	r3, r7, #24
    84ea:	6e78      	ldr	r0, [r7, #100]	; 0x64
    84ec:	6db9      	ldr	r1, [r7, #88]	; 0x58
    84ee:	461a      	mov	r2, r3
    84f0:	68fb      	ldr	r3, [r7, #12]
    84f2:	f7ff fced 	bl	7ed0 <printk_pad_space>
                    }
                break;
    84f6:	e05f      	b.n	85b8 <printk+0x6b0>

            case 'c':
                cval = (int8)va_arg(ap, uint32);
    84f8:	687b      	ldr	r3, [r7, #4]
    84fa:	f103 0204 	add.w	r2, r3, #4
    84fe:	607a      	str	r2, [r7, #4]
    8500:	681b      	ldr	r3, [r3, #0]
    8502:	b2db      	uxtb	r3, r3
    8504:	b25b      	sxtb	r3, r3
    8506:	647b      	str	r3, [r7, #68]	; 0x44
                printk_putc(cval,&count, info);
    8508:	f107 0318 	add.w	r3, r7, #24
    850c:	6c78      	ldr	r0, [r7, #68]	; 0x44
    850e:	4619      	mov	r1, r3
    8510:	68fa      	ldr	r2, [r7, #12]
    8512:	f7ff fc05 	bl	7d20 <printk_putc>
                break;
    8516:	e052      	b.n	85be <printk+0x6b6>
            case 's':
                sval = (int8 *)va_arg(ap, int8 *);
    8518:	687b      	ldr	r3, [r7, #4]
    851a:	f103 0204 	add.w	r2, r3, #4
    851e:	607a      	str	r2, [r7, #4]
    8520:	681b      	ldr	r3, [r3, #0]
    8522:	64fb      	str	r3, [r7, #76]	; 0x4c
                if (sval)
    8524:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    8526:	2b00      	cmp	r3, #0
    8528:	d048      	beq.n	85bc <printk+0x6b4>
                {
                    vlen = strlen((const char *)sval);
    852a:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
    852c:	f000 fb20 	bl	8b70 <strlen>
    8530:	4603      	mov	r3, r0
    8532:	667b      	str	r3, [r7, #100]	; 0x64
                    if (!IS_FLAG_MINUS(flags_used))
    8534:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    8536:	f003 0301 	and.w	r3, r3, #1
    853a:	2b00      	cmp	r3, #0
    853c:	d117      	bne.n	856e <printk+0x666>
                    {
                        printk_pad_space (vlen, field_width, &count, info);
    853e:	f107 0318 	add.w	r3, r7, #24
    8542:	6e78      	ldr	r0, [r7, #100]	; 0x64
    8544:	6db9      	ldr	r1, [r7, #88]	; 0x58
    8546:	461a      	mov	r2, r3
    8548:	68fb      	ldr	r3, [r7, #12]
    854a:	f7ff fcc1 	bl	7ed0 <printk_pad_space>
                    }
                    while (*sval)
    854e:	e00e      	b.n	856e <printk+0x666>
                        printk_putc(*sval++,&count, info);
    8550:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    8552:	781b      	ldrb	r3, [r3, #0]
    8554:	b25a      	sxtb	r2, r3
    8556:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    8558:	f103 0301 	add.w	r3, r3, #1
    855c:	64fb      	str	r3, [r7, #76]	; 0x4c
    855e:	f107 0318 	add.w	r3, r7, #24
    8562:	4610      	mov	r0, r2
    8564:	4619      	mov	r1, r3
    8566:	68fa      	ldr	r2, [r7, #12]
    8568:	f7ff fbda 	bl	7d20 <printk_putc>
    856c:	e000      	b.n	8570 <printk+0x668>
                    vlen = strlen((const char *)sval);
                    if (!IS_FLAG_MINUS(flags_used))
                    {
                        printk_pad_space (vlen, field_width, &count, info);
                    }
                    while (*sval)
    856e:	bf00      	nop
    8570:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    8572:	781b      	ldrb	r3, [r3, #0]
    8574:	2b00      	cmp	r3, #0
    8576:	d1eb      	bne.n	8550 <printk+0x648>
                        printk_putc(*sval++,&count, info);
                    if (IS_FLAG_MINUS(flags_used))
    8578:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    857a:	f003 0301 	and.w	r3, r3, #1
    857e:	2b00      	cmp	r3, #0
    8580:	d01c      	beq.n	85bc <printk+0x6b4>
                    {
                        printk_pad_space (vlen, field_width, &count, info);
    8582:	f107 0318 	add.w	r3, r7, #24
    8586:	6e78      	ldr	r0, [r7, #100]	; 0x64
    8588:	6db9      	ldr	r1, [r7, #88]	; 0x58
    858a:	461a      	mov	r2, r3
    858c:	68fb      	ldr	r3, [r7, #12]
    858e:	f7ff fc9f 	bl	7ed0 <printk_pad_space>
                    }
                }
                break;
    8592:	e013      	b.n	85bc <printk+0x6b4>
            case 'n':
                ivalp = (int32 *)va_arg(ap, int32 *);
    8594:	687b      	ldr	r3, [r7, #4]
    8596:	f103 0204 	add.w	r2, r3, #4
    859a:	607a      	str	r2, [r7, #4]
    859c:	681b      	ldr	r3, [r3, #0]
    859e:	643b      	str	r3, [r7, #64]	; 0x40
                *ivalp = count;
    85a0:	69ba      	ldr	r2, [r7, #24]
    85a2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    85a4:	601a      	str	r2, [r3, #0]
                break;
    85a6:	e00a      	b.n	85be <printk+0x6b6>
            default:
                printk_putc(c,&count, info);
    85a8:	f107 0318 	add.w	r3, r7, #24
    85ac:	6cb8      	ldr	r0, [r7, #72]	; 0x48
    85ae:	4619      	mov	r1, r3
    85b0:	68fa      	ldr	r2, [r7, #12]
    85b2:	f7ff fbb5 	bl	7d20 <printk_putc>
                break;
    85b6:	e002      	b.n	85be <printk+0x6b6>

                    if (IS_FLAG_MINUS(flags_used))
                    {
                        printk_pad_space (vlen, field_width, &count, info);
                    }
                break;
    85b8:	bf00      	nop
    85ba:	e000      	b.n	85be <printk+0x6b6>
                    if (IS_FLAG_MINUS(flags_used))
                    {
                        printk_pad_space (vlen, field_width, &count, info);
                    }
                }
                break;
    85bc:	bf00      	nop

    /*
     * Start parsing apart the format string and display appropriate
     * formats and data.
     */
    for (p = (int8 *)fmt; (c = *p) != 0; p++)
    85be:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    85c0:	f103 0301 	add.w	r3, r3, #1
    85c4:	66fb      	str	r3, [r7, #108]	; 0x6c
    85c6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    85c8:	781b      	ldrb	r3, [r3, #0]
    85ca:	b25b      	sxtb	r3, r3
    85cc:	64bb      	str	r3, [r7, #72]	; 0x48
    85ce:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    85d0:	2b00      	cmp	r3, #0
    85d2:	f47f aca5 	bne.w	7f20 <printk+0x18>
            default:
                printk_putc(c,&count, info);
                break;
        }
    }
    return count;
    85d6:	69bb      	ldr	r3, [r7, #24]
}
    85d8:	4618      	mov	r0, r3
    85da:	f107 0770 	add.w	r7, r7, #112	; 0x70
    85de:	46bd      	mov	sp, r7
    85e0:	bd80      	pop	{r7, pc}
    85e2:	bf00      	nop

000085e4 <printf>:

/********************************************************************/
int printf (const char *fmt, ...)
{
    85e4:	b40f      	push	{r0, r1, r2, r3}
    85e6:	b580      	push	{r7, lr}
    85e8:	b086      	sub	sp, #24
    85ea:	af00      	add	r7, sp, #0
    va_list ap;
    int32 rvalue;
    PRINTK_INFO info;


    info.dest = DEST_CONSOLE;
    85ec:	f04f 0301 	mov.w	r3, #1
    85f0:	607b      	str	r3, [r7, #4]
    info.func = &out_char;
    85f2:	f647 43e5 	movw	r3, #31973	; 0x7ce5
    85f6:	f2c0 0300 	movt	r3, #0
    85fa:	60bb      	str	r3, [r7, #8]
    /*
     * Initialize the pointer to the variable length argument list.
     */
    va_start(ap, fmt);
    85fc:	f107 0324 	add.w	r3, r7, #36	; 0x24
    8600:	613b      	str	r3, [r7, #16]
    rvalue = printk(&info, fmt, ap);
    8602:	f107 0304 	add.w	r3, r7, #4
    8606:	4618      	mov	r0, r3
    8608:	6a39      	ldr	r1, [r7, #32]
    860a:	693a      	ldr	r2, [r7, #16]
    860c:	f7ff fc7c 	bl	7f08 <printk>
    8610:	6178      	str	r0, [r7, #20]
    /*
     * Cleanup the variable length argument list.
     */
    va_end(ap);
    return rvalue;
    8612:	697b      	ldr	r3, [r7, #20]
}
    8614:	4618      	mov	r0, r3
    8616:	f107 0718 	add.w	r7, r7, #24
    861a:	46bd      	mov	sp, r7
    861c:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    8620:	b004      	add	sp, #16
    8622:	4770      	bx	lr

00008624 <sprintf>:

/********************************************************************/
int sprintf (char *s, const char *fmt, ...)
{
    8624:	b40e      	push	{r1, r2, r3}
    8626:	b580      	push	{r7, lr}
    8628:	b089      	sub	sp, #36	; 0x24
    862a:	af00      	add	r7, sp, #0
    862c:	6078      	str	r0, [r7, #4]
    va_list ap;
    int32 rvalue = 0;
    862e:	f04f 0300 	mov.w	r3, #0
    8632:	61fb      	str	r3, [r7, #28]
    PRINTK_INFO info;

    /*
     * Initialize the pointer to the variable length argument list.
     */
    if (s != 0)
    8634:	687b      	ldr	r3, [r7, #4]
    8636:	2b00      	cmp	r3, #0
    8638:	d013      	beq.n	8662 <sprintf+0x3e>
    {
        info.dest = DEST_STRING;
    863a:	f04f 0302 	mov.w	r3, #2
    863e:	60fb      	str	r3, [r7, #12]
        info.loc = (int8 *)s;
    8640:	687b      	ldr	r3, [r7, #4]
    8642:	617b      	str	r3, [r7, #20]
        va_start(ap, fmt);
    8644:	f107 0330 	add.w	r3, r7, #48	; 0x30
    8648:	61bb      	str	r3, [r7, #24]
        rvalue = printk(&info, fmt, ap);
    864a:	f107 030c 	add.w	r3, r7, #12
    864e:	4618      	mov	r0, r3
    8650:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    8652:	69ba      	ldr	r2, [r7, #24]
    8654:	f7ff fc58 	bl	7f08 <printk>
    8658:	61f8      	str	r0, [r7, #28]
        *info.loc = '\0';
    865a:	697b      	ldr	r3, [r7, #20]
    865c:	f04f 0200 	mov.w	r2, #0
    8660:	701a      	strb	r2, [r3, #0]
        va_end(ap);
    }
    return rvalue;
    8662:	69fb      	ldr	r3, [r7, #28]
}
    8664:	4618      	mov	r0, r3
    8666:	f107 0724 	add.w	r7, r7, #36	; 0x24
    866a:	46bd      	mov	sp, r7
    866c:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
    8670:	b003      	add	sp, #12
    8672:	4770      	bx	lr

00008674 <__aeabi_frsub>:
    8674:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
    8678:	e002      	b.n	8680 <__addsf3>
    867a:	bf00      	nop

0000867c <__aeabi_fsub>:
    867c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

00008680 <__addsf3>:
    8680:	0042      	lsls	r2, r0, #1
    8682:	bf1f      	itttt	ne
    8684:	ea5f 0341 	movsne.w	r3, r1, lsl #1
    8688:	ea92 0f03 	teqne	r2, r3
    868c:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
    8690:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
    8694:	d06a      	beq.n	876c <__addsf3+0xec>
    8696:	ea4f 6212 	mov.w	r2, r2, lsr #24
    869a:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
    869e:	bfc1      	itttt	gt
    86a0:	18d2      	addgt	r2, r2, r3
    86a2:	4041      	eorgt	r1, r0
    86a4:	4048      	eorgt	r0, r1
    86a6:	4041      	eorgt	r1, r0
    86a8:	bfb8      	it	lt
    86aa:	425b      	neglt	r3, r3
    86ac:	2b19      	cmp	r3, #25
    86ae:	bf88      	it	hi
    86b0:	4770      	bxhi	lr
    86b2:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
    86b6:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    86ba:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    86be:	bf18      	it	ne
    86c0:	4240      	negne	r0, r0
    86c2:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    86c6:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
    86ca:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
    86ce:	bf18      	it	ne
    86d0:	4249      	negne	r1, r1
    86d2:	ea92 0f03 	teq	r2, r3
    86d6:	d03f      	beq.n	8758 <__addsf3+0xd8>
    86d8:	f1a2 0201 	sub.w	r2, r2, #1
    86dc:	fa41 fc03 	asr.w	ip, r1, r3
    86e0:	eb10 000c 	adds.w	r0, r0, ip
    86e4:	f1c3 0320 	rsb	r3, r3, #32
    86e8:	fa01 f103 	lsl.w	r1, r1, r3
    86ec:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
    86f0:	d502      	bpl.n	86f8 <__addsf3+0x78>
    86f2:	4249      	negs	r1, r1
    86f4:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
    86f8:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    86fc:	d313      	bcc.n	8726 <__addsf3+0xa6>
    86fe:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
    8702:	d306      	bcc.n	8712 <__addsf3+0x92>
    8704:	0840      	lsrs	r0, r0, #1
    8706:	ea4f 0131 	mov.w	r1, r1, rrx
    870a:	f102 0201 	add.w	r2, r2, #1
    870e:	2afe      	cmp	r2, #254	; 0xfe
    8710:	d251      	bcs.n	87b6 <__addsf3+0x136>
    8712:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
    8716:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
    871a:	bf08      	it	eq
    871c:	f020 0001 	biceq.w	r0, r0, #1
    8720:	ea40 0003 	orr.w	r0, r0, r3
    8724:	4770      	bx	lr
    8726:	0049      	lsls	r1, r1, #1
    8728:	eb40 0000 	adc.w	r0, r0, r0
    872c:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
    8730:	f1a2 0201 	sub.w	r2, r2, #1
    8734:	d1ed      	bne.n	8712 <__addsf3+0x92>
    8736:	fab0 fc80 	clz	ip, r0
    873a:	f1ac 0c08 	sub.w	ip, ip, #8
    873e:	ebb2 020c 	subs.w	r2, r2, ip
    8742:	fa00 f00c 	lsl.w	r0, r0, ip
    8746:	bfaa      	itet	ge
    8748:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
    874c:	4252      	neglt	r2, r2
    874e:	4318      	orrge	r0, r3
    8750:	bfbc      	itt	lt
    8752:	40d0      	lsrlt	r0, r2
    8754:	4318      	orrlt	r0, r3
    8756:	4770      	bx	lr
    8758:	f092 0f00 	teq	r2, #0
    875c:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
    8760:	bf06      	itte	eq
    8762:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
    8766:	3201      	addeq	r2, #1
    8768:	3b01      	subne	r3, #1
    876a:	e7b5      	b.n	86d8 <__addsf3+0x58>
    876c:	ea4f 0341 	mov.w	r3, r1, lsl #1
    8770:	ea7f 6c22 	mvns.w	ip, r2, asr #24
    8774:	bf18      	it	ne
    8776:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
    877a:	d021      	beq.n	87c0 <__addsf3+0x140>
    877c:	ea92 0f03 	teq	r2, r3
    8780:	d004      	beq.n	878c <__addsf3+0x10c>
    8782:	f092 0f00 	teq	r2, #0
    8786:	bf08      	it	eq
    8788:	4608      	moveq	r0, r1
    878a:	4770      	bx	lr
    878c:	ea90 0f01 	teq	r0, r1
    8790:	bf1c      	itt	ne
    8792:	2000      	movne	r0, #0
    8794:	4770      	bxne	lr
    8796:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
    879a:	d104      	bne.n	87a6 <__addsf3+0x126>
    879c:	0040      	lsls	r0, r0, #1
    879e:	bf28      	it	cs
    87a0:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
    87a4:	4770      	bx	lr
    87a6:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
    87aa:	bf3c      	itt	cc
    87ac:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
    87b0:	4770      	bxcc	lr
    87b2:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
    87b6:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
    87ba:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    87be:	4770      	bx	lr
    87c0:	ea7f 6222 	mvns.w	r2, r2, asr #24
    87c4:	bf16      	itet	ne
    87c6:	4608      	movne	r0, r1
    87c8:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
    87cc:	4601      	movne	r1, r0
    87ce:	0242      	lsls	r2, r0, #9
    87d0:	bf06      	itte	eq
    87d2:	ea5f 2341 	movseq.w	r3, r1, lsl #9
    87d6:	ea90 0f01 	teqeq	r0, r1
    87da:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
    87de:	4770      	bx	lr

000087e0 <__aeabi_ui2f>:
    87e0:	f04f 0300 	mov.w	r3, #0
    87e4:	e004      	b.n	87f0 <__aeabi_i2f+0x8>
    87e6:	bf00      	nop

000087e8 <__aeabi_i2f>:
    87e8:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
    87ec:	bf48      	it	mi
    87ee:	4240      	negmi	r0, r0
    87f0:	ea5f 0c00 	movs.w	ip, r0
    87f4:	bf08      	it	eq
    87f6:	4770      	bxeq	lr
    87f8:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
    87fc:	4601      	mov	r1, r0
    87fe:	f04f 0000 	mov.w	r0, #0
    8802:	e01c      	b.n	883e <__aeabi_l2f+0x2a>

00008804 <__aeabi_ul2f>:
    8804:	ea50 0201 	orrs.w	r2, r0, r1
    8808:	bf08      	it	eq
    880a:	4770      	bxeq	lr
    880c:	f04f 0300 	mov.w	r3, #0
    8810:	e00a      	b.n	8828 <__aeabi_l2f+0x14>
    8812:	bf00      	nop

00008814 <__aeabi_l2f>:
    8814:	ea50 0201 	orrs.w	r2, r0, r1
    8818:	bf08      	it	eq
    881a:	4770      	bxeq	lr
    881c:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
    8820:	d502      	bpl.n	8828 <__aeabi_l2f+0x14>
    8822:	4240      	negs	r0, r0
    8824:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    8828:	ea5f 0c01 	movs.w	ip, r1
    882c:	bf02      	ittt	eq
    882e:	4684      	moveq	ip, r0
    8830:	4601      	moveq	r1, r0
    8832:	2000      	moveq	r0, #0
    8834:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
    8838:	bf08      	it	eq
    883a:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
    883e:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
    8842:	fabc f28c 	clz	r2, ip
    8846:	3a08      	subs	r2, #8
    8848:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
    884c:	db10      	blt.n	8870 <__aeabi_l2f+0x5c>
    884e:	fa01 fc02 	lsl.w	ip, r1, r2
    8852:	4463      	add	r3, ip
    8854:	fa00 fc02 	lsl.w	ip, r0, r2
    8858:	f1c2 0220 	rsb	r2, r2, #32
    885c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
    8860:	fa20 f202 	lsr.w	r2, r0, r2
    8864:	eb43 0002 	adc.w	r0, r3, r2
    8868:	bf08      	it	eq
    886a:	f020 0001 	biceq.w	r0, r0, #1
    886e:	4770      	bx	lr
    8870:	f102 0220 	add.w	r2, r2, #32
    8874:	fa01 fc02 	lsl.w	ip, r1, r2
    8878:	f1c2 0220 	rsb	r2, r2, #32
    887c:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
    8880:	fa21 f202 	lsr.w	r2, r1, r2
    8884:	eb43 0002 	adc.w	r0, r3, r2
    8888:	bf08      	it	eq
    888a:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
    888e:	4770      	bx	lr

00008890 <__aeabi_fmul>:
    8890:	f04f 0cff 	mov.w	ip, #255	; 0xff
    8894:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
    8898:	bf1e      	ittt	ne
    889a:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
    889e:	ea92 0f0c 	teqne	r2, ip
    88a2:	ea93 0f0c 	teqne	r3, ip
    88a6:	d06f      	beq.n	8988 <__aeabi_fmul+0xf8>
    88a8:	441a      	add	r2, r3
    88aa:	ea80 0c01 	eor.w	ip, r0, r1
    88ae:	0240      	lsls	r0, r0, #9
    88b0:	bf18      	it	ne
    88b2:	ea5f 2141 	movsne.w	r1, r1, lsl #9
    88b6:	d01e      	beq.n	88f6 <__aeabi_fmul+0x66>
    88b8:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    88bc:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
    88c0:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
    88c4:	fba0 3101 	umull	r3, r1, r0, r1
    88c8:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
    88cc:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
    88d0:	bf3e      	ittt	cc
    88d2:	0049      	lslcc	r1, r1, #1
    88d4:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
    88d8:	005b      	lslcc	r3, r3, #1
    88da:	ea40 0001 	orr.w	r0, r0, r1
    88de:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
    88e2:	2afd      	cmp	r2, #253	; 0xfd
    88e4:	d81d      	bhi.n	8922 <__aeabi_fmul+0x92>
    88e6:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
    88ea:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
    88ee:	bf08      	it	eq
    88f0:	f020 0001 	biceq.w	r0, r0, #1
    88f4:	4770      	bx	lr
    88f6:	f090 0f00 	teq	r0, #0
    88fa:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
    88fe:	bf08      	it	eq
    8900:	0249      	lsleq	r1, r1, #9
    8902:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
    8906:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
    890a:	3a7f      	subs	r2, #127	; 0x7f
    890c:	bfc2      	ittt	gt
    890e:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
    8912:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
    8916:	4770      	bxgt	lr
    8918:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    891c:	f04f 0300 	mov.w	r3, #0
    8920:	3a01      	subs	r2, #1
    8922:	dc5d      	bgt.n	89e0 <__aeabi_fmul+0x150>
    8924:	f112 0f19 	cmn.w	r2, #25
    8928:	bfdc      	itt	le
    892a:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
    892e:	4770      	bxle	lr
    8930:	f1c2 0200 	rsb	r2, r2, #0
    8934:	0041      	lsls	r1, r0, #1
    8936:	fa21 f102 	lsr.w	r1, r1, r2
    893a:	f1c2 0220 	rsb	r2, r2, #32
    893e:	fa00 fc02 	lsl.w	ip, r0, r2
    8942:	ea5f 0031 	movs.w	r0, r1, rrx
    8946:	f140 0000 	adc.w	r0, r0, #0
    894a:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
    894e:	bf08      	it	eq
    8950:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
    8954:	4770      	bx	lr
    8956:	f092 0f00 	teq	r2, #0
    895a:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
    895e:	bf02      	ittt	eq
    8960:	0040      	lsleq	r0, r0, #1
    8962:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
    8966:	3a01      	subeq	r2, #1
    8968:	d0f9      	beq.n	895e <__aeabi_fmul+0xce>
    896a:	ea40 000c 	orr.w	r0, r0, ip
    896e:	f093 0f00 	teq	r3, #0
    8972:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    8976:	bf02      	ittt	eq
    8978:	0049      	lsleq	r1, r1, #1
    897a:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
    897e:	3b01      	subeq	r3, #1
    8980:	d0f9      	beq.n	8976 <__aeabi_fmul+0xe6>
    8982:	ea41 010c 	orr.w	r1, r1, ip
    8986:	e78f      	b.n	88a8 <__aeabi_fmul+0x18>
    8988:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
    898c:	ea92 0f0c 	teq	r2, ip
    8990:	bf18      	it	ne
    8992:	ea93 0f0c 	teqne	r3, ip
    8996:	d00a      	beq.n	89ae <__aeabi_fmul+0x11e>
    8998:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
    899c:	bf18      	it	ne
    899e:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
    89a2:	d1d8      	bne.n	8956 <__aeabi_fmul+0xc6>
    89a4:	ea80 0001 	eor.w	r0, r0, r1
    89a8:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
    89ac:	4770      	bx	lr
    89ae:	f090 0f00 	teq	r0, #0
    89b2:	bf17      	itett	ne
    89b4:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
    89b8:	4608      	moveq	r0, r1
    89ba:	f091 0f00 	teqne	r1, #0
    89be:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
    89c2:	d014      	beq.n	89ee <__aeabi_fmul+0x15e>
    89c4:	ea92 0f0c 	teq	r2, ip
    89c8:	d101      	bne.n	89ce <__aeabi_fmul+0x13e>
    89ca:	0242      	lsls	r2, r0, #9
    89cc:	d10f      	bne.n	89ee <__aeabi_fmul+0x15e>
    89ce:	ea93 0f0c 	teq	r3, ip
    89d2:	d103      	bne.n	89dc <__aeabi_fmul+0x14c>
    89d4:	024b      	lsls	r3, r1, #9
    89d6:	bf18      	it	ne
    89d8:	4608      	movne	r0, r1
    89da:	d108      	bne.n	89ee <__aeabi_fmul+0x15e>
    89dc:	ea80 0001 	eor.w	r0, r0, r1
    89e0:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
    89e4:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    89e8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    89ec:	4770      	bx	lr
    89ee:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    89f2:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
    89f6:	4770      	bx	lr

000089f8 <__aeabi_fdiv>:
    89f8:	f04f 0cff 	mov.w	ip, #255	; 0xff
    89fc:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
    8a00:	bf1e      	ittt	ne
    8a02:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
    8a06:	ea92 0f0c 	teqne	r2, ip
    8a0a:	ea93 0f0c 	teqne	r3, ip
    8a0e:	d069      	beq.n	8ae4 <__aeabi_fdiv+0xec>
    8a10:	eba2 0203 	sub.w	r2, r2, r3
    8a14:	ea80 0c01 	eor.w	ip, r0, r1
    8a18:	0249      	lsls	r1, r1, #9
    8a1a:	ea4f 2040 	mov.w	r0, r0, lsl #9
    8a1e:	d037      	beq.n	8a90 <__aeabi_fdiv+0x98>
    8a20:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    8a24:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
    8a28:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
    8a2c:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
    8a30:	428b      	cmp	r3, r1
    8a32:	bf38      	it	cc
    8a34:	005b      	lslcc	r3, r3, #1
    8a36:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
    8a3a:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
    8a3e:	428b      	cmp	r3, r1
    8a40:	bf24      	itt	cs
    8a42:	1a5b      	subcs	r3, r3, r1
    8a44:	ea40 000c 	orrcs.w	r0, r0, ip
    8a48:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
    8a4c:	bf24      	itt	cs
    8a4e:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
    8a52:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
    8a56:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
    8a5a:	bf24      	itt	cs
    8a5c:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
    8a60:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
    8a64:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
    8a68:	bf24      	itt	cs
    8a6a:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
    8a6e:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
    8a72:	011b      	lsls	r3, r3, #4
    8a74:	bf18      	it	ne
    8a76:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
    8a7a:	d1e0      	bne.n	8a3e <__aeabi_fdiv+0x46>
    8a7c:	2afd      	cmp	r2, #253	; 0xfd
    8a7e:	f63f af50 	bhi.w	8922 <__aeabi_fmul+0x92>
    8a82:	428b      	cmp	r3, r1
    8a84:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
    8a88:	bf08      	it	eq
    8a8a:	f020 0001 	biceq.w	r0, r0, #1
    8a8e:	4770      	bx	lr
    8a90:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
    8a94:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
    8a98:	327f      	adds	r2, #127	; 0x7f
    8a9a:	bfc2      	ittt	gt
    8a9c:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
    8aa0:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
    8aa4:	4770      	bxgt	lr
    8aa6:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    8aaa:	f04f 0300 	mov.w	r3, #0
    8aae:	3a01      	subs	r2, #1
    8ab0:	e737      	b.n	8922 <__aeabi_fmul+0x92>
    8ab2:	f092 0f00 	teq	r2, #0
    8ab6:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
    8aba:	bf02      	ittt	eq
    8abc:	0040      	lsleq	r0, r0, #1
    8abe:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
    8ac2:	3a01      	subeq	r2, #1
    8ac4:	d0f9      	beq.n	8aba <__aeabi_fdiv+0xc2>
    8ac6:	ea40 000c 	orr.w	r0, r0, ip
    8aca:	f093 0f00 	teq	r3, #0
    8ace:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    8ad2:	bf02      	ittt	eq
    8ad4:	0049      	lsleq	r1, r1, #1
    8ad6:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
    8ada:	3b01      	subeq	r3, #1
    8adc:	d0f9      	beq.n	8ad2 <__aeabi_fdiv+0xda>
    8ade:	ea41 010c 	orr.w	r1, r1, ip
    8ae2:	e795      	b.n	8a10 <__aeabi_fdiv+0x18>
    8ae4:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
    8ae8:	ea92 0f0c 	teq	r2, ip
    8aec:	d108      	bne.n	8b00 <__aeabi_fdiv+0x108>
    8aee:	0242      	lsls	r2, r0, #9
    8af0:	f47f af7d 	bne.w	89ee <__aeabi_fmul+0x15e>
    8af4:	ea93 0f0c 	teq	r3, ip
    8af8:	f47f af70 	bne.w	89dc <__aeabi_fmul+0x14c>
    8afc:	4608      	mov	r0, r1
    8afe:	e776      	b.n	89ee <__aeabi_fmul+0x15e>
    8b00:	ea93 0f0c 	teq	r3, ip
    8b04:	d104      	bne.n	8b10 <__aeabi_fdiv+0x118>
    8b06:	024b      	lsls	r3, r1, #9
    8b08:	f43f af4c 	beq.w	89a4 <__aeabi_fmul+0x114>
    8b0c:	4608      	mov	r0, r1
    8b0e:	e76e      	b.n	89ee <__aeabi_fmul+0x15e>
    8b10:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
    8b14:	bf18      	it	ne
    8b16:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
    8b1a:	d1ca      	bne.n	8ab2 <__aeabi_fdiv+0xba>
    8b1c:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
    8b20:	f47f af5c 	bne.w	89dc <__aeabi_fmul+0x14c>
    8b24:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
    8b28:	f47f af3c 	bne.w	89a4 <__aeabi_fmul+0x114>
    8b2c:	e75f      	b.n	89ee <__aeabi_fmul+0x15e>
    8b2e:	bf00      	nop

00008b30 <__aeabi_f2uiz>:
    8b30:	0042      	lsls	r2, r0, #1
    8b32:	d20e      	bcs.n	8b52 <__aeabi_f2uiz+0x22>
    8b34:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
    8b38:	d30b      	bcc.n	8b52 <__aeabi_f2uiz+0x22>
    8b3a:	f04f 039e 	mov.w	r3, #158	; 0x9e
    8b3e:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
    8b42:	d409      	bmi.n	8b58 <__aeabi_f2uiz+0x28>
    8b44:	ea4f 2300 	mov.w	r3, r0, lsl #8
    8b48:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    8b4c:	fa23 f002 	lsr.w	r0, r3, r2
    8b50:	4770      	bx	lr
    8b52:	f04f 0000 	mov.w	r0, #0
    8b56:	4770      	bx	lr
    8b58:	f112 0f61 	cmn.w	r2, #97	; 0x61
    8b5c:	d101      	bne.n	8b62 <__aeabi_f2uiz+0x32>
    8b5e:	0242      	lsls	r2, r0, #9
    8b60:	d102      	bne.n	8b68 <__aeabi_f2uiz+0x38>
    8b62:	f04f 30ff 	mov.w	r0, #4294967295
    8b66:	4770      	bx	lr
    8b68:	f04f 0000 	mov.w	r0, #0
    8b6c:	4770      	bx	lr
    8b6e:	bf00      	nop

00008b70 <strlen>:
    8b70:	f020 0103 	bic.w	r1, r0, #3
    8b74:	f010 0003 	ands.w	r0, r0, #3
    8b78:	f1c0 0000 	rsb	r0, r0, #0
    8b7c:	f851 3b04 	ldr.w	r3, [r1], #4
    8b80:	f100 0c04 	add.w	ip, r0, #4
    8b84:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
    8b88:	f06f 0200 	mvn.w	r2, #0
    8b8c:	bf1c      	itt	ne
    8b8e:	fa22 f20c 	lsrne.w	r2, r2, ip
    8b92:	4313      	orrne	r3, r2
    8b94:	f04f 0c01 	mov.w	ip, #1
    8b98:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
    8b9c:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
    8ba0:	eba3 020c 	sub.w	r2, r3, ip
    8ba4:	ea22 0203 	bic.w	r2, r2, r3
    8ba8:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
    8bac:	bf04      	itt	eq
    8bae:	f851 3b04 	ldreq.w	r3, [r1], #4
    8bb2:	3004      	addeq	r0, #4
    8bb4:	d0f4      	beq.n	8ba0 <strlen+0x30>
    8bb6:	f013 0fff 	tst.w	r3, #255	; 0xff
    8bba:	bf1f      	itttt	ne
    8bbc:	3001      	addne	r0, #1
    8bbe:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
    8bc2:	3001      	addne	r0, #1
    8bc4:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
    8bc8:	bf18      	it	ne
    8bca:	3001      	addne	r0, #1
    8bcc:	4770      	bx	lr
    8bce:	bf00      	nop
    8bd0:	2a2a200a 	bcs	a90c00 <_etext+0xa87f58>
    8bd4:	2a2a2a2a 	bcs	a93484 <_etext+0xa8a7dc>
    8bd8:	2a2a2a2a 	bcs	a93488 <_etext+0xa8a7e0>
    8bdc:	2a2a2a2a 	bcs	a9348c <_etext+0xa8a7e4>
    8be0:	2a2a2a2a 	bcs	a93490 <_etext+0xa8a7e8>
    8be4:	0000000a 	andeq	r0, r0, sl
    8be8:	61666544 	cmnvs	r6, r4, asr #10
    8bec:	20746c75 	rsbscs	r6, r4, r5, ror ip
    8bf0:	646e6148 	strbtvs	r6, [lr], #-328	; 0x148
    8bf4:	2072656c 	rsbscs	r6, r2, ip, ror #10
    8bf8:	6f727245 	svcvs	0x00727245
    8bfc:	00000a72 	andeq	r0, r0, r2, ror sl
    8c00:	76206e4f 	strtvc	r6, [r0], -pc, asr #28
    8c04:	6f746365 	svcvs	0x00746365
    8c08:	64252072 	strtvs	r2, [r5], #-114	; 0x72
    8c0c:	2a2a2a20 	bcs	a93494 <_etext+0xa8a7ec>
    8c10:	6e49202a 	cdpvs	0, 4, cr2, cr9, cr10, {1}
    8c14:	72726574 	rsbsvc	r6, r2, #486539264	; 0x1d000000
    8c18:	0a747075 	beq	1d24df4 <_etext+0x1d1c14c>
    8c1c:	00000000 	andeq	r0, r0, r0
    8c20:	20756f59 	rsbscs	r6, r5, r9, asr pc
    8c24:	20746567 	rsbscs	r6, r4, r7, ror #10
    8c28:	73204449 	teqvc	r0, #1224736768	; 0x49000000
    8c2c:	65636375 	strbvs	r6, [r3, #-885]!	; 0x375
    8c30:	202c7373 	eorcs	r7, ip, r3, ror r3
    8c34:	534e4553 	movtpl	r4, #58707	; 0xe553
    8c38:	4920524f 	stmdbmi	r0!, {r0, r1, r2, r3, r6, r9, ip, lr}
    8c3c:	73692044 	cmnvc	r9, #68	; 0x44
    8c40:	25783020 	ldrbcs	r3, [r8, #-32]!
    8c44:	00000078 	andeq	r0, r0, r8, ror r0
    8c48:	6e6f636e 	cdpvs	3, 6, cr6, cr15, cr14, {3}
    8c4c:	20676966 	rsbcs	r6, r7, r6, ror #18
    8c50:	69676572 	stmdbvs	r7!, {r1, r4, r5, r6, r8, sl, sp, lr}^
    8c54:	72657473 	rsbvc	r7, r5, #1929379840	; 0x73000000
    8c58:	6d754e20 	ldclvs	14, cr4, [r5, #-128]!	; 0xffffff80
    8c5c:	20726562 	rsbscs	r6, r2, r2, ror #10
    8c60:	25207369 	strcs	r7, [r0, #-873]!	; 0x369
    8c64:	00000a64 	andeq	r0, r0, r4, ror #20
    8c68:	6f727265 	svcvs	0x00727265
    8c6c:	77203a72 			; <UNDEFINED> instruction: 0x77203a72
    8c70:	65746972 	ldrbvs	r6, [r4, #-2418]!	; 0x972
    8c74:	20676552 	rsbcs	r6, r7, r2, asr r5
    8c78:	6f727265 	svcvs	0x00727265
    8c7c:	78302072 	ldmdavc	r0!, {r1, r4, r5, r6, sp}
    8c80:	000a7825 	andeq	r7, sl, r5, lsr #16
    8c84:	74697277 	strbtvc	r7, [r9], #-631	; 0x277
    8c88:	20655265 	rsbcs	r5, r5, r5, ror #4
    8c8c:	78257830 	stmdavc	r5!, {r4, r5, fp, ip, sp, lr}
    8c90:	63757320 	cmnvs	r5, #-2147483648	; 0x80000000
    8c94:	73736563 	cmnvc	r3, #415236096	; 0x18c00000
    8c98:	7830203a 	ldmdavc	r0!, {r1, r3, r4, r5, sp}
    8c9c:	000a7825 	andeq	r7, sl, r5, lsr #16
    8ca0:	0001ff00 	andeq	pc, r1, r0, lsl #30

00008ca4 <pdb_sc_mults>:
    8ca4:	28140a01 	ldmdacs	r4, {r0, r9, fp}

Disassembly of section .data:

1fff0000 <SystemCoreClock>:
1fff0000:	05f5e100 	ldrbeq	lr, [r5, #256]!	; 0x100

1fff0004 <ov7725_eagle_reg>:
1fff0004:	0011c10d 	andseq	ip, r1, sp, lsl #2
1fff0008:	d00c0309 	andle	r0, ip, r9, lsl #6
1fff000c:	3f174012 	svccc	0x00174012
1fff0010:	03195018 	tsteq	r9, #24
1fff0014:	0032781a 	eorseq	r7, r2, sl, lsl r8
1fff0018:	e0630aa0 	rsb	r0, r3, r0, lsr #21
1fff001c:	0c65ffac 	stcleq	15, cr15, [r5], #-688	; 0xfffffd50
1fff0020:	00670066 	rsbeq	r0, r7, r6, rrx
1fff0024:	1e2c1429 	cdpne	4, 2, cr1, cr12, cr9, {1}
1fff0028:	0c7e002a 	ldcleq	0, cr0, [lr], #-168	; 0xffffff58
1fff002c:	2a80167f 	bcs	1dff5a30 <__etext+0x1dfecd88>
1fff0030:	61824e81 	orrvs	r4, r2, r1, lsl #29
1fff0034:	7b846f83 	blvc	1e10be48 <__etext+0x1e1031a0>
1fff0038:	8e868685 	cdphi	6, 8, cr8, cr6, cr5, {4}
1fff003c:	a4889787 	strge	r9, [r8], #1927	; 0x787
1fff0040:	c58aaf89 	strgt	sl, [sl, #3977]	; 0xf89
1fff0044:	e88cd78b 	stm	ip, {r0, r1, r3, r7, r8, r9, sl, ip, lr, pc}
1fff0048:	004a208d 	subeq	r2, sl, sp, lsl #1
1fff004c:	08471349 	stmdaeq	r7, {r0, r3, r6, r8, r9, ip}^
1fff0050:	174c144b 	strbne	r1, [ip, -fp, asr #8]
1fff0054:	99220546 	stmdbls	r2!, {r1, r2, r6, r8, sl}
1fff0058:	04a60323 	strteq	r0, [r6], #803	; 0x323
1fff005c:	ff9c009b 			; <UNDEFINED> instruction: 0xff9c009b
1fff0060:	119e06ab 	orrsne	r0, lr, fp, lsr #13
1fff0064:	0131029f 			; <UNDEFINED> instruction: 0x0131029f

1fff0066 <ov7725_eagle_cfgnum>:
1fff0066:	ffff0131 			; <UNDEFINED> instruction: 0xffff0131

1fff0067 <ov7725_eagle_img_flag>:
1fff0067:	ffffff01 			; <UNDEFINED> instruction: 0xffffff01

1fff0068 <g_core_clock>:
1fff0068:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff

1fff006c <g_bus_clock>:
1fff006c:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff

1fff0070 <g_flash_clock>:
1fff0070:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff

1fff0074 <g_flexbus_clock>:
1fff0074:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff

Disassembly of section .bss:

1fff0078 <_sbss>:
1fff0078:	00000000 	andeq	r0, r0, r0

1fff007c <img>:
	...

1fff02d4 <Pix_Data>:
	...

1fff1594 <OV_PTD_init>:
	...

1fff15a8 <OV_PTA_init>:
	...

1fff15bc <OV_PTB_init>:
	...

1fff15d0 <OV_dma_init>:
	...

1fff15fc <ADC_ISR>:
	...

1fff1604 <DMA_ISR>:
	...

1fff1644 <FTM_ISR>:
	...

1fff1650 <GPIO_ISR>:
	...

1fff1664 <LPTMR_ISR>:
1fff1664:	00000000 	andeq	r0, r0, r0

1fff1668 <PDB_SE_ISR>:
1fff1668:	00000000 	andeq	r0, r0, r0

1fff166c <PDB_ISR>:
1fff166c:	00000000 	andeq	r0, r0, r0

1fff1670 <PIT_ISR>:
	...

1fff1680 <SPI2_ISR>:
	...

1fff1698 <SPI0_ISR>:
	...

1fff16b0 <SPI1_ISR>:
	...

1fff16c8 <UART_T_ISR>:
	...

1fff16e0 <UART_R_ISR>:
	...

Disassembly of section .ARM.attributes:

00000000 <__HeapLimit-0x1fff16f8>:
   0:	00003241 	andeq	r3, r0, r1, asr #4
   4:	61656100 	cmnvs	r5, r0, lsl #2
   8:	01006962 	tsteq	r0, r2, ror #18
   c:	00000028 	andeq	r0, r0, r8, lsr #32
  10:	726f4305 	rsbvc	r4, pc, #335544320	; 0x14000000
  14:	2d786574 	cfldr64cs	mvdx6, [r8, #-464]!	; 0xfffffe30
  18:	0600344d 	streq	r3, [r0], -sp, asr #8
  1c:	094d070d 	stmdbeq	sp, {r0, r2, r3, r8, r9, sl}^
  20:	14041202 	strne	r1, [r4], #-514	; 0x202
  24:	17011501 	strne	r1, [r1, -r1, lsl #10]
  28:	19011803 	stmdbne	r1, {r0, r1, fp, ip}
  2c:	1e011a01 	vmlane.f32	s2, s2, s2
  30:	Address 0x00000030 is out of bounds.


Disassembly of section .debug_info:

00000000 <.debug_info>:
       0:	00000a81 	andeq	r0, r0, r1, lsl #21
       4:	00000002 	andeq	r0, r0, r2
       8:	01040000 	mrseq	r0, (UNDEF: 4)
       c:	00000234 	andeq	r0, r0, r4, lsr r2
      10:	00078801 	andeq	r8, r7, r1, lsl #16
      14:	00082700 	andeq	r2, r8, r0, lsl #14
      18:	00080000 	andeq	r0, r8, r0
      1c:	0008d600 	andeq	sp, r8, r0, lsl #12
      20:	00000000 	andeq	r0, r0, r0
      24:	06010200 	streq	r0, [r1], -r0, lsl #4
      28:	0000070b 	andeq	r0, r0, fp, lsl #14
      2c:	0009dd03 	andeq	sp, r9, r3, lsl #26
      30:	372a0200 	strcc	r0, [sl, -r0, lsl #4]!
      34:	02000000 	andeq	r0, r0, #0
      38:	07090801 	streq	r0, [r9, -r1, lsl #16]
      3c:	02020000 	andeq	r0, r2, #0
      40:	00073b05 	andeq	r3, r7, r5, lsl #22
      44:	03280300 	teqeq	r8, #0
      48:	36020000 	strcc	r0, [r2], -r0
      4c:	00000050 	andeq	r0, r0, r0, asr r0
      50:	92070202 	andls	r0, r7, #536870912	; 0x20000000
      54:	02000004 	andeq	r0, r0, #4
      58:	01960504 	orrseq	r0, r6, r4, lsl #10
      5c:	9b030000 	blls	c0064 <__etext+0xb73bc>
      60:	02000007 	andeq	r0, r0, #7
      64:	00006950 	andeq	r6, r0, r0, asr r9
      68:	07040200 	streq	r0, [r4, -r0, lsl #4]
      6c:	000001e4 	andeq	r0, r0, r4, ror #3
      70:	91050802 	tstls	r5, r2, lsl #16
      74:	02000001 	andeq	r0, r0, #1
      78:	01df0708 	bicseq	r0, pc, r8, lsl #14
      7c:	04040000 	streq	r0, [r4], #-0
      80:	746e6905 	strbtvc	r6, [lr], #-2309	; 0x905
      84:	07040200 	streq	r0, [r4, -r0, lsl #4]
      88:	000001e9 	andeq	r0, r0, r9, ror #3
      8c:	4b030105 	blmi	c04a8 <__etext+0xb7800>
      90:	000003ab 	andeq	r0, r0, fp, lsr #7
      94:	000aa506 	andeq	sl, sl, r6, lsl #10
      98:	9a060000 	bls	1800a0 <__etext+0x1773f8>
      9c:	01000006 	tsteq	r0, r6
      a0:	00020a06 	andeq	r0, r2, r6, lsl #20
      a4:	00060200 	andeq	r0, r6, r0, lsl #4
      a8:	03000000 	movweq	r0, #0
      ac:	0000c406 	andeq	ip, r0, r6, lsl #8
      b0:	bd060400 	cfstrslt	mvf0, [r6, #-0]
      b4:	05000001 	streq	r0, [r0, #-1]
      b8:	0008bf06 	andeq	fp, r8, r6, lsl #30
      bc:	7d060600 	stcvc	6, cr0, [r6, #-0]
      c0:	07000002 	streq	r0, [r0, -r2]
      c4:	00028b06 	andeq	r8, r2, r6, lsl #22
      c8:	99060800 	stmdbls	r6, {fp}
      cc:	09000002 	stmdbeq	r0, {r1}
      d0:	0009a406 	andeq	sl, r9, r6, lsl #8
      d4:	11060a00 	tstne	r6, r0, lsl #20
      d8:	0b00000a 	bleq	108 <__vector_table+0x108>
      dc:	00059a06 	andeq	r9, r5, r6, lsl #20
      e0:	c5060c00 	strgt	r0, [r6, #-3072]	; 0xc00
      e4:	0d000009 	stceq	0, cr0, [r0, #-36]	; 0xffffffdc
      e8:	00054b06 	andeq	r4, r5, r6, lsl #22
      ec:	de060e00 	cdple	14, 0, cr0, cr6, cr0, {0}
      f0:	0f000003 	svceq	0x00000003
      f4:	00010806 	andeq	r0, r1, r6, lsl #16
      f8:	8b061000 	blhi	184100 <__etext+0x17b458>
      fc:	11000006 	tstne	r0, r6
     100:	00014806 	andeq	r4, r1, r6, lsl #16
     104:	f1061200 			; <UNDEFINED> instruction: 0xf1061200
     108:	13000006 	movwne	r0, #6
     10c:	00037a06 	andeq	r7, r3, r6, lsl #20
     110:	18061400 	stmdane	r6, {sl, ip}
     114:	15000008 	strne	r0, [r0, #-8]
     118:	0003cf06 	andeq	ip, r3, r6, lsl #30
     11c:	b0061600 	andlt	r1, r6, r0, lsl #12
     120:	17000008 	strne	r0, [r0, -r8]
     124:	00042f06 	andeq	r2, r4, r6, lsl #30
     128:	39061800 	stmdbcc	r6, {fp, ip}
     12c:	19000001 	stmdbne	r0, {r0}
     130:	0003bf06 	andeq	fp, r3, r6, lsl #30
     134:	98061a00 	stmdals	r6, {r9, fp, ip}
     138:	1b000008 	blne	160 <__vector_table+0x160>
     13c:	00040d06 	andeq	r0, r4, r6, lsl #26
     140:	e8061c00 	stmda	r6, {sl, fp, ip}
     144:	1d000008 	stcne	0, cr0, [r0, #-32]	; 0xffffffe0
     148:	00051f06 	andeq	r1, r5, r6, lsl #30
     14c:	af061e00 	svcge	0x00061e00
     150:	1f000003 	svcne	0x00000003
     154:	0008cf06 	andeq	ip, r8, r6, lsl #30
     158:	12062000 	andne	r2, r6, #0
     15c:	21000002 	tstcs	r0, r2
     160:	0003f306 	andeq	pc, r3, r6, lsl #6
     164:	17062200 	strne	r2, [r6, -r0, lsl #4]
     168:	23000001 	movwcs	r0, #1
     16c:	0005e006 	andeq	lr, r5, r6
     170:	d3062400 	movwle	r2, #25600	; 0x6400
     174:	25000004 	strcs	r0, [r0, #-4]
     178:	000a3706 	andeq	r3, sl, r6, lsl #14
     17c:	53062600 	movwpl	r2, #26112	; 0x6600
     180:	27000006 	strcs	r0, [r0, -r6]
     184:	00075e06 	andeq	r5, r7, r6, lsl #28
     188:	53062800 	movwpl	r2, #26624	; 0x6800
     18c:	2900000a 	stmdbcs	r0, {r1, r3}
     190:	000a6706 	andeq	r6, sl, r6, lsl #14
     194:	7f062a00 	svcvc	0x00062a00
     198:	2b000007 	blcs	1bc <__vector_table+0x1bc>
     19c:	000a7006 	andeq	r7, sl, r6
     1a0:	89062c00 	stmdbhi	r6, {sl, fp, sp}
     1a4:	2d000000 	stccs	0, cr0, [r0, #-0]
     1a8:	00016606 	andeq	r6, r1, r6, lsl #12
     1ac:	8b062e00 	blhi	18b9b4 <__etext+0x182d0c>
     1b0:	2f000005 	svccs	0x00000005
     1b4:	00087706 	andeq	r7, r8, r6, lsl #14
     1b8:	63063000 	movwvs	r3, #24576	; 0x6000
     1bc:	31000008 	tstcc	r0, r8
     1c0:	0002b706 	andeq	fp, r2, r6, lsl #14
     1c4:	68063200 	stmdavs	r6, {r9, ip, sp}
     1c8:	33000003 	movwcc	r0, #3
     1cc:	000a8e06 	andeq	r8, sl, r6, lsl #28
     1d0:	6c063400 	cfstrsvs	mvf3, [r6], {-0}
     1d4:	35000000 	strcc	r0, [r0, #-0]
     1d8:	00039906 	andeq	r9, r3, r6, lsl #18
     1dc:	ae063600 	cfmadd32ge	mvax0, mvfx3, mvfx6, mvfx0
     1e0:	37000001 	strcc	r0, [r0, -r1]
     1e4:	0001f606 	andeq	pc, r1, r6, lsl #12
     1e8:	cb063800 	blgt	18e1f0 <__etext+0x185548>
     1ec:	39000001 	stmdbcc	r0, {r0}
     1f0:	00043e06 	andeq	r3, r4, r6, lsl #28
     1f4:	db063a00 	blle	18e9fc <__etext+0x185d54>
     1f8:	3b000004 	blcc	210 <__vector_table+0x210>
     1fc:	00074506 	andeq	r4, r7, r6, lsl #10
     200:	18063c00 	stmdane	r6, {sl, fp, ip, sp}
     204:	3d000009 	stccc	0, cr0, [r0, #-36]	; 0xffffffdc
     208:	00045406 	andeq	r5, r4, r6, lsl #8
     20c:	6a063e00 	bvs	18fa14 <__etext+0x186d6c>
     210:	3f000004 	svccc	0x00000004
     214:	000a7906 	andeq	r7, sl, r6, lsl #18
     218:	0600c000 	streq	ip, [r0], -r0
     21c:	00000994 	muleq	r0, r4, r9
     220:	7d0600c1 	stcvc	0, cr0, [r6, #-772]	; 0xfffffcfc
     224:	c2000005 	andgt	r0, r0, #5
     228:	04a50600 	strteq	r0, [r5], #1536	; 0x600
     22c:	00c30000 	sbceq	r0, r3, r0
     230:	000a2106 	andeq	r2, sl, r6, lsl #2
     234:	0600c400 	streq	ip, [r0], -r0, lsl #8
     238:	000009f8 	strdeq	r0, [r0], -r8
     23c:	7a0600c5 	bvc	180558 <__etext+0x1778b0>
     240:	c6000009 	strgt	r0, [r0], -r9
     244:	04c30600 	strbeq	r0, [r3], #1536	; 0x600
     248:	00c70000 	sbceq	r0, r7, r0
     24c:	00053d06 	andeq	r3, r5, r6, lsl #26
     250:	0600c800 	streq	ip, [r0], -r0, lsl #16
     254:	00000404 	andeq	r0, r0, r4, lsl #8
     258:	2b0600c9 	blcs	180584 <__etext+0x1778dc>
     25c:	ca000002 	bgt	26c <__vector_table+0x26c>
     260:	09b30600 	ldmibeq	r3!, {r9, sl}
     264:	00cb0000 	sbceq	r0, fp, r0
     268:	00066f06 	andeq	r6, r6, r6, lsl #30
     26c:	0600cc00 	streq	ip, [r0], -r0, lsl #24
     270:	00000678 	andeq	r0, r0, r8, ror r6
     274:	cd0600cd 	stcgt	0, cr0, [r6, #-820]	; 0xfffffccc
     278:	ce000002 	cdpgt	0, 0, cr0, cr0, cr2, {0}
     27c:	02d60600 	sbcseq	r0, r6, #0
     280:	00cf0000 	sbceq	r0, pc, r0
     284:	0002df06 	andeq	sp, r2, r6, lsl #30
     288:	0600d000 	streq	sp, [r0], -r0
     28c:	0000021a 	andeq	r0, r0, sl, lsl r2
     290:	620600d1 	andvs	r0, r6, #209	; 0xd1
     294:	d2000004 	andle	r0, r0, #4
     298:	03890600 	orreq	r0, r9, #0
     29c:	00d30000 	sbcseq	r0, r3, r0
     2a0:	00047a06 	andeq	r7, r4, r6, lsl #20
     2a4:	0600d400 	streq	sp, [r0], -r0, lsl #8
     2a8:	0000002e 	andeq	r0, r0, lr, lsr #32
     2ac:	cb0600d5 	blgt	180608 <__etext+0x177960>
     2b0:	d6000007 	strle	r0, [r0], -r7
     2b4:	00450600 	subeq	r0, r5, r0, lsl #12
     2b8:	00d70000 	sbcseq	r0, r7, r0
     2bc:	0005ec06 	andeq	lr, r5, r6, lsl #24
     2c0:	0600d800 	streq	sp, [r0], -r0, lsl #16
     2c4:	00000222 	andeq	r0, r0, r2, lsr #4
     2c8:	530600d9 	movwpl	r0, #24793	; 0x60d9
     2cc:	da000007 	ble	2f0 <__vector_table+0x2f0>
     2d0:	09040600 	stmdbeq	r4, {r9, sl}
     2d4:	00db0000 	sbcseq	r0, fp, r0
     2d8:	0000de06 	andeq	sp, r0, r6, lsl #28
     2dc:	0600dc00 	streq	sp, [r0], -r0, lsl #24
     2e0:	00000056 	andeq	r0, r0, r6, asr r0
     2e4:	9f0600dd 	svcls	0x000600dd
     2e8:	de000001 	cdple	0, 0, cr0, cr0, cr1, {0}
     2ec:	0a440600 	beq	1101af4 <__etext+0x10f8e4c>
     2f0:	00df0000 	sbcseq	r0, pc, r0
     2f4:	0000a606 	andeq	sl, r0, r6, lsl #12
     2f8:	0600e000 	streq	lr, [r0], -r0
     2fc:	000005d7 	ldrdeq	r0, [r0], -r7
     300:	ea0600e1 	b	18068c <__etext+0x1779e4>
     304:	e2000004 	and	r0, r0, #4
     308:	03ea0600 	mvneq	r0, #0
     30c:	00e30000 	rsceq	r0, r3, r0
     310:	00004e06 	andeq	r4, r0, r6, lsl #28
     314:	0600e400 	streq	lr, [r0], -r0, lsl #8
     318:	00000306 	andeq	r0, r0, r6, lsl #6
     31c:	b40600e5 	strlt	r0, [r6], #-229	; 0xe5
     320:	e6000000 	str	r0, [r0], -r0
     324:	05f50600 	ldrbeq	r0, [r5, #1536]!	; 0x600
     328:	00e70000 	rsceq	r0, r7, r0
     32c:	00012a06 	andeq	r2, r1, r6, lsl #20
     330:	0600e800 	streq	lr, [r0], -r0, lsl #16
     334:	00000610 	andeq	r0, r0, r0, lsl r6
     338:	310600e9 	smlattcc	r6, r9, r0, r0
     33c:	ea000007 	b	360 <__vector_table+0x360>
     340:	062c0600 	strteq	r0, [ip], -r0, lsl #12
     344:	00eb0000 	rsceq	r0, fp, r0
     348:	00063606 	andeq	r3, r6, r6, lsl #12
     34c:	0600ec00 	streq	lr, [r0], -r0, lsl #24
     350:	00000890 	muleq	r0, r0, r8
     354:	610600ed 	smlattvs	r6, sp, r0, r0
     358:	ee000006 	cdp	0, 0, cr0, cr0, cr6, {0}
     35c:	05c30600 	strbeq	r0, [r3, #1536]	; 0x600
     360:	00ef0000 	rsceq	r0, pc, r0
     364:	00068106 	andeq	r8, r6, r6, lsl #2
     368:	0600f000 	streq	pc, [r0], -r0
     36c:	000000f8 	strdeq	r0, [r0], -r8
     370:	e50600f1 	str	r0, [r6, #-241]	; 0xf1
     374:	f2000009 	vhadd.s8	d0, d0, d9
     378:	035d0600 	cmpeq	sp, #0
     37c:	00f30000 	rscseq	r0, r3, r0
     380:	0002a706 	andeq	sl, r2, r6, lsl #14
     384:	0600f400 	streq	pc, [r0], -r0, lsl #8
     388:	000002e8 	andeq	r0, r0, r8, ror #5
     38c:	1d0600f5 	stcne	0, cr0, [r6, #-980]	; 0xfffffc2c
     390:	f6000004 			; <UNDEFINED> instruction: 0xf6000004
     394:	04260600 	strteq	r0, [r6], #-1536	; 0x600
     398:	00f70000 	rscseq	r0, r7, r0
     39c:	00018506 	andeq	r8, r1, r6, lsl #10
     3a0:	0600f800 	streq	pc, [r0], -r0, lsl #16
     3a4:	00000988 	andeq	r0, r0, r8, lsl #19
     3a8:	020000f9 	andeq	r0, r0, #249	; 0xf9
     3ac:	05740704 	ldrbeq	r0, [r4, #-1796]!	; 0x704
     3b0:	2c070000 	stccs	0, cr0, [r7], {-0}
     3b4:	c2000000 	andgt	r0, r0, #0
     3b8:	08000003 	stmdaeq	r0, {r0, r1}
     3bc:	000003ab 	andeq	r0, r0, fp, lsr #7
     3c0:	04090003 	streq	r0, [r9], #-3
     3c4:	f0118003 			; <UNDEFINED> instruction: 0xf0118003
     3c8:	0a000003 	beq	3dc <__vector_table+0x3dc>
     3cc:	0000078f 	andeq	r0, r0, pc, lsl #15
     3d0:	5e118103 	mnfpls	f0, f3
     3d4:	0a000000 	beq	3dc <__vector_table+0x3dc>
     3d8:	0000001f 	andeq	r0, r0, pc, lsl r0
     3dc:	5e118203 	cdppl	2, 1, cr8, cr1, cr3, {0}
     3e0:	0a000000 	beq	3e8 <__vector_table+0x3e8>
     3e4:	000007b2 			; <UNDEFINED> instruction: 0x000007b2
     3e8:	5e118303 	cdppl	3, 1, cr8, cr1, cr3, {0}
     3ec:	00000000 	andeq	r0, r0, r0
     3f0:	88030209 	stmdahi	r3, {r0, r3, r9}
     3f4:	00041211 	andeq	r1, r4, r1, lsl r2
     3f8:	00370a00 	eorseq	r0, r7, r0, lsl #20
     3fc:	89030000 	stmdbhi	r3, {}	; <UNPREDICTABLE>
     400:	00004511 	andeq	r4, r0, r1, lsl r5
     404:	07700a00 	ldrbeq	r0, [r0, -r0, lsl #20]!
     408:	8a030000 	bhi	c0410 <__etext+0xb7768>
     40c:	00004511 	andeq	r4, r0, r1, lsl r5
     410:	02090000 	andeq	r0, r9, #0
     414:	34118e03 	ldrcc	r8, [r1], #-3587	; 0xe03
     418:	0a000004 	beq	430 <__vector_table+0x430>
     41c:	000007d4 	ldrdeq	r0, [r0], -r4
     420:	45118f03 	ldrmi	r8, [r1, #-3843]	; 0xf03
     424:	0a000000 	beq	42c <__vector_table+0x42c>
     428:	0000095b 	andeq	r0, r0, fp, asr r9
     42c:	45119003 	ldrmi	r9, [r1, #-3]
     430:	00000000 	andeq	r0, r0, r0
     434:	7c03200b 	stcvc	0, cr2, [r3], {11}
     438:	0004ce11 	andeq	ip, r4, r1, lsl lr
     43c:	03740c00 	cmneq	r4, #0
     440:	7d030000 	stcvc	0, cr0, [r3, #-0]
     444:	00005e11 	andeq	r5, r0, r1, lsl lr
     448:	00230200 	eoreq	r0, r3, r0, lsl #4
     44c:	0004be0c 	andeq	fp, r4, ip, lsl #28
     450:	117e0300 	cmnne	lr, r0, lsl #6
     454:	00000045 	andeq	r0, r0, r5, asr #32
     458:	0c042302 	stceq	3, cr2, [r4], {2}
     45c:	0000044f 	andeq	r0, r0, pc, asr #8
     460:	45117f03 	ldrmi	r7, [r1, #-3843]	; 0xf03
     464:	02000000 	andeq	r0, r0, #0
     468:	c20d0623 	andgt	r0, sp, #36700160	; 0x2300000
     46c:	02000003 	andeq	r0, r0, #3
     470:	5b0c0823 	blpl	302504 <__etext+0x2f985c>
     474:	03000006 	movweq	r0, #6
     478:	005e1185 	subseq	r1, lr, r5, lsl #3
     47c:	23020000 	movwcs	r0, #8192	; 0x2000
     480:	08dd0c0c 	ldmeq	sp, {r2, r3, sl, fp}^
     484:	86030000 	strhi	r0, [r3], -r0
     488:	00005e11 	andeq	r5, r0, r1, lsl lr
     48c:	10230200 	eorne	r0, r3, r0, lsl #4
     490:	0000af0c 	andeq	sl, r0, ip, lsl #30
     494:	11870300 	orrne	r0, r7, r0, lsl #6
     498:	00000045 	andeq	r0, r0, r5, asr #32
     49c:	0d142302 	ldceq	3, cr2, [r4, #-8]
     4a0:	000003f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     4a4:	0c162302 	ldceq	3, cr2, [r6], {2}
     4a8:	000005b4 			; <UNDEFINED> instruction: 0x000005b4
     4ac:	5e118c03 	cdppl	12, 1, cr8, cr1, cr3, {0}
     4b0:	02000000 	andeq	r0, r0, #0
     4b4:	430e1823 	movwmi	r1, #59427	; 0xe823
     4b8:	03005253 	movweq	r5, #595	; 0x253
     4bc:	0045118d 	subeq	r1, r5, sp, lsl #3
     4c0:	23020000 	movwcs	r0, #8192	; 0x2000
     4c4:	04120d1c 	ldreq	r0, [r2], #-3356	; 0xd1c
     4c8:	23020000 	movwcs	r0, #8192	; 0x2000
     4cc:	480f001e 	stmdami	pc, {r1, r2, r3, r4}	; <UNPREDICTABLE>
     4d0:	00000009 	andeq	r0, r0, r9
     4d4:	11450314 	cmpne	r5, r4, lsl r3
     4d8:	00000836 	andeq	r0, r0, r6, lsr r8
     4dc:	0052430e 	subseq	r4, r2, lr, lsl #6
     4e0:	5e114603 	cfmsub32pl	mvax0, mvfx4, mvfx1, mvfx3
     4e4:	02000000 	andeq	r0, r0, #0
     4e8:	450e0023 	strmi	r0, [lr, #-35]	; 0x23
     4ec:	47030053 	smlsdmi	r3, r3, r0, r0
     4f0:	00005e11 	andeq	r5, r0, r1, lsl lr
     4f4:	04230200 	strteq	r0, [r3], #-512	; 0x200
     4f8:	0003120c 	andeq	r1, r3, ip, lsl #4
     4fc:	11480300 	mrsne	r0, (UNDEF: 120)
     500:	000003b2 			; <UNDEFINED> instruction: 0x000003b2
     504:	0e082302 	cdpeq	3, 0, cr2, cr8, cr2, {0}
     508:	00515245 	subseq	r5, r1, r5, asr #4
     50c:	5e114903 	cdppl	9, 1, cr4, cr1, cr3, {0}
     510:	02000000 	andeq	r0, r0, #0
     514:	1d0c0c23 	stcne	12, cr0, [ip, #-140]	; 0xffffff74
     518:	03000003 	movweq	r0, #3
     51c:	03b2114a 			; <UNDEFINED> instruction: 0x03b2114a
     520:	23020000 	movwcs	r0, #8192	; 0x2000
     524:	45450e10 	strbmi	r0, [r5, #-3600]	; 0xe10
     528:	4b030049 	blmi	c0654 <__etext+0xb79ac>
     52c:	00005e11 	andeq	r5, r0, r1, lsl lr
     530:	14230200 	strtne	r0, [r3], #-512	; 0x200
     534:	0008e30c 	andeq	lr, r8, ip, lsl #6
     538:	114c0300 	mrsne	r0, SPSR_mon
     53c:	0000002c 	andeq	r0, r0, ip, lsr #32
     540:	0c182302 	ldceq	3, cr2, [r8], {2}
     544:	000000d9 	ldrdeq	r0, [r0], -r9
     548:	2c114d03 	ldccs	13, cr4, [r1], {3}
     54c:	02000000 	andeq	r0, r0, #0
     550:	490c1923 	stmdbmi	ip, {r0, r1, r5, r8, fp, ip}
     554:	03000006 	movweq	r0, #6
     558:	002c114e 	eoreq	r1, ip, lr, asr #2
     55c:	23020000 	movwcs	r0, #8192	; 0x2000
     560:	088b0c1a 	stmeq	fp, {r1, r3, r4, sl, fp}
     564:	4f030000 	svcmi	0x00030000
     568:	00002c11 	andeq	r2, r0, r1, lsl ip
     56c:	1b230200 	blne	8c0d74 <__etext+0x8b80cc>
     570:	0002c80c 	andeq	ip, r2, ip, lsl #16
     574:	11500300 	cmpne	r0, r0, lsl #6
     578:	0000002c 	andeq	r0, r0, ip, lsr #32
     57c:	0c1c2302 	ldceq	3, cr2, [ip], {2}
     580:	000003aa 	andeq	r0, r0, sl, lsr #7
     584:	2c115103 	ldfcss	f5, [r1], {3}
     588:	02000000 	andeq	r0, r0, #0
     58c:	4e0c1d23 	cdpmi	13, 0, cr1, cr12, cr3, {1}
     590:	03000006 	movweq	r0, #6
     594:	002c1152 	eoreq	r1, ip, r2, asr r1
     598:	23020000 	movwcs	r0, #8192	; 0x2000
     59c:	06b60c1e 	ssateq	r0, #23, lr, lsl #24
     5a0:	53030000 	movwpl	r0, #12288	; 0x3000
     5a4:	00002c11 	andeq	r2, r0, r1, lsl ip
     5a8:	1f230200 	svcne	0x00230200
     5ac:	000a9a0c 	andeq	r9, sl, ip, lsl #20
     5b0:	11540300 	cmpne	r4, r0, lsl #6
     5b4:	000003b2 			; <UNDEFINED> instruction: 0x000003b2
     5b8:	0e202302 	cdpeq	3, 2, cr2, cr0, cr2, {0}
     5bc:	00544e49 	subseq	r4, r4, r9, asr #28
     5c0:	5e115503 	cfmul32pl	mvfx5, mvfx1, mvfx3
     5c4:	02000000 	andeq	r0, r0, #0
     5c8:	310c2423 	tstcc	ip, r3, lsr #8
     5cc:	03000003 	movweq	r0, #3
     5d0:	03b21156 			; <UNDEFINED> instruction: 0x03b21156
     5d4:	23020000 	movwcs	r0, #8192	; 0x2000
     5d8:	52450e28 	subpl	r0, r5, #640	; 0x280
     5dc:	57030052 	smlsdpl	r3, r2, r0, r0
     5e0:	00005e11 	andeq	r5, r0, r1, lsl lr
     5e4:	2c230200 	sfmcs	f0, 4, [r3], #-0
     5e8:	00033c0c 	andeq	r3, r3, ip, lsl #24
     5ec:	11580300 	cmpne	r8, r0, lsl #6
     5f0:	000003b2 			; <UNDEFINED> instruction: 0x000003b2
     5f4:	0e302302 	cdpeq	3, 3, cr2, cr0, cr2, {0}
     5f8:	00535248 	subseq	r5, r3, r8, asr #4
     5fc:	5e115903 	cdppl	9, 1, cr5, cr1, cr3, {0}
     600:	02000000 	andeq	r0, r0, #0
     604:	470c3423 	strmi	r3, [ip, -r3, lsr #8]
     608:	03000003 	movweq	r0, #3
     60c:	0836115a 	ldmdaeq	r6!, {r1, r3, r4, r6, r8, ip}
     610:	23020000 	movwcs	r0, #8192	; 0x2000
     614:	09400c38 	stmdbeq	r0, {r3, r4, r5, sl, fp}^
     618:	5b030000 	blpl	c0620 <__etext+0xb7978>
     61c:	00002c11 	andeq	r2, r0, r1, lsl ip
     620:	80230300 	eorhi	r0, r3, r0, lsl #6
     624:	09380c02 	ldmdbeq	r8!, {r1, sl, fp}
     628:	5c030000 	stcpl	0, cr0, [r3], {-0}
     62c:	00002c11 	andeq	r2, r0, r1, lsl ip
     630:	81230300 	teqhi	r3, r0, lsl #6
     634:	09300c02 	ldmdbeq	r0!, {r1, sl, fp}
     638:	5d030000 	stcpl	0, cr0, [r3, #-0]
     63c:	00002c11 	andeq	r2, r0, r1, lsl ip
     640:	82230300 	eorhi	r0, r3, #0
     644:	09280c02 	stmdbeq	r8!, {r1, sl, fp}
     648:	5e030000 	cdppl	0, 0, cr0, cr3, cr0, {0}
     64c:	00002c11 	andeq	r2, r0, r1, lsl ip
     650:	83230300 	teqhi	r3, #0
     654:	096a0c02 	stmdbeq	sl!, {r1, sl, fp}^
     658:	5f030000 	svcpl	0x00030000
     65c:	00002c11 	andeq	r2, r0, r1, lsl ip
     660:	84230300 	strthi	r0, [r3], #-768	; 0x300
     664:	03fc0c02 	mvnseq	r0, #512	; 0x200
     668:	60030000 	andvs	r0, r3, r0
     66c:	00002c11 	andeq	r2, r0, r1, lsl ip
     670:	85230300 	strhi	r0, [r3, #-768]!	; 0x300
     674:	09530c02 	ldmdbeq	r3, {r1, sl, fp}^
     678:	61030000 	mrsvs	r0, (UNDEF: 3)
     67c:	00002c11 	andeq	r2, r0, r1, lsl ip
     680:	86230300 	strthi	r0, [r3], -r0, lsl #6
     684:	00f00c02 	rscseq	r0, r0, r2, lsl #24
     688:	62030000 	andvs	r0, r3, #0
     68c:	00002c11 	andeq	r2, r0, r1, lsl ip
     690:	87230300 	strhi	r0, [r3, -r0, lsl #6]!
     694:	06c40c02 	strbeq	r0, [r4], r2, lsl #24
     698:	63030000 	movwvs	r0, #12288	; 0x3000
     69c:	00002c11 	andeq	r2, r0, r1, lsl ip
     6a0:	88230300 	stmdahi	r3!, {r8, r9}
     6a4:	06bb0c02 	ldrteq	r0, [fp], r2, lsl #24
     6a8:	64030000 	strvs	r0, [r3], #-0
     6ac:	00002c11 	andeq	r2, r0, r1, lsl ip
     6b0:	89230300 	stmdbhi	r3!, {r8, r9}
     6b4:	08a80c02 	stmiaeq	r8!, {r1, sl, fp}
     6b8:	65030000 	strvs	r0, [r3, #-0]
     6bc:	00002c11 	andeq	r2, r0, r1, lsl ip
     6c0:	8a230300 	bhi	8c12c8 <__etext+0x8b8620>
     6c4:	09720c02 	ldmdbeq	r2!, {r1, sl, fp}^
     6c8:	66030000 	strvs	r0, [r3], -r0
     6cc:	00002c11 	andeq	r2, r0, r1, lsl ip
     6d0:	8b230300 	blhi	8c12d8 <__etext+0x8b8630>
     6d4:	06e80c02 	strbteq	r0, [r8], r2, lsl #24
     6d8:	67030000 	strvs	r0, [r3, -r0]
     6dc:	00002c11 	andeq	r2, r0, r1, lsl ip
     6e0:	8c230300 	stchi	3, cr0, [r3], #-0
     6e4:	06df0c02 	ldrbeq	r0, [pc], r2, lsl #24
     6e8:	68030000 	stmdavs	r3, {}	; <UNPREDICTABLE>
     6ec:	00002c11 	andeq	r2, r0, r1, lsl ip
     6f0:	8d230300 	stchi	3, cr0, [r3, #-0]
     6f4:	06d60c02 	ldrbeq	r0, [r6], r2, lsl #24
     6f8:	69030000 	stmdbvs	r3, {}	; <UNPREDICTABLE>
     6fc:	00002c11 	andeq	r2, r0, r1, lsl ip
     700:	8e230300 	cdphi	3, 2, cr0, cr3, cr0, {0}
     704:	06cd0c02 	strbeq	r0, [sp], r2, lsl #24
     708:	6a030000 	bvs	c0710 <__etext+0xb7a68>
     70c:	00002c11 	andeq	r2, r0, r1, lsl ip
     710:	8f230300 	svchi	0x00230300
     714:	07170c02 	ldreq	r0, [r7, -r2, lsl #24]
     718:	6b030000 	blvs	c0720 <__etext+0xb7a78>
     71c:	00002c11 	andeq	r2, r0, r1, lsl ip
     720:	90230300 	eorls	r0, r3, r0, lsl #6
     724:	04b50c02 	ldrteq	r0, [r5], #3074	; 0xc02
     728:	6c030000 	stcvs	0, cr0, [r3], {-0}
     72c:	00002c11 	andeq	r2, r0, r1, lsl ip
     730:	91230300 	teqls	r3, r0, lsl #6
     734:	07000c02 	streq	r0, [r0, -r2, lsl #24]
     738:	6d030000 	stcvs	0, cr0, [r3, #-0]
     73c:	00002c11 	andeq	r2, r0, r1, lsl ip
     740:	92230300 	eorls	r0, r3, #0
     744:	017c0c02 	cmneq	ip, r2, lsl #24
     748:	6e030000 	cdpvs	0, 0, cr0, cr3, cr0, {0}
     74c:	00002c11 	andeq	r2, r0, r1, lsl ip
     750:	93230300 	teqls	r3, #0
     754:	05ab0c02 	streq	r0, [fp, #3074]!	; 0xc02
     758:	6f030000 	svcvs	0x00030000
     75c:	00002c11 	andeq	r2, r0, r1, lsl ip
     760:	94230300 	strtls	r0, [r3], #-768	; 0x300
     764:	04890c02 	streq	r0, [r9], #3074	; 0xc02
     768:	70030000 	andvc	r0, r3, r0
     76c:	00002c11 	andeq	r2, r0, r1, lsl ip
     770:	95230300 	strls	r0, [r3, #-768]!	; 0x300
     774:	07c20c02 	strbeq	r0, [r2, r2, lsl #24]
     778:	71030000 	mrsvc	r0, (UNDEF: 3)
     77c:	00002c11 	andeq	r2, r0, r1, lsl ip
     780:	96230300 	strtls	r0, [r3], -r0, lsl #6
     784:	056b0c02 	strbeq	r0, [fp, #-3074]!	; 0xc02
     788:	72030000 	andvc	r0, r3, #0
     78c:	00002c11 	andeq	r2, r0, r1, lsl ip
     790:	97230300 	strls	r0, [r3, -r0, lsl #6]!
     794:	07fd0c02 	ldrbeq	r0, [sp, r2, lsl #24]!
     798:	73030000 	movwvc	r0, #12288	; 0x3000
     79c:	00002c11 	andeq	r2, r0, r1, lsl ip
     7a0:	98230300 	stmdals	r3!, {r8, r9}
     7a4:	07f40c02 	ldrbeq	r0, [r4, r2, lsl #24]!
     7a8:	74030000 	strvc	r0, [r3], #-0
     7ac:	00002c11 	andeq	r2, r0, r1, lsl ip
     7b0:	99230300 	stmdbls	r3!, {r8, r9}
     7b4:	07eb0c02 	strbeq	r0, [fp, r2, lsl #24]!
     7b8:	75030000 	strvc	r0, [r3, #-0]
     7bc:	00002c11 	andeq	r2, r0, r1, lsl ip
     7c0:	9a230300 	bls	8c13c8 <__etext+0x8b8720>
     7c4:	07e20c02 	strbeq	r0, [r2, r2, lsl #24]!
     7c8:	76030000 	strvc	r0, [r3], -r0
     7cc:	00002c11 	andeq	r2, r0, r1, lsl ip
     7d0:	9b230300 	blls	8c13d8 <__etext+0x8b8730>
     7d4:	0a080c02 	beq	2037e4 <__etext+0x1fab3c>
     7d8:	77030000 	strvc	r0, [r3, -r0]
     7dc:	00002c11 	andeq	r2, r0, r1, lsl ip
     7e0:	9c230300 	stcls	3, cr0, [r3], #-0
     7e4:	09bc0c02 	ldmibeq	ip!, {r1, sl, fp}
     7e8:	78030000 	stmdavc	r3, {}	; <UNPREDICTABLE>
     7ec:	00002c11 	andeq	r2, r0, r1, lsl ip
     7f0:	9d230300 	stcls	3, cr0, [r3, #-0]
     7f4:	080f0c02 	stmdaeq	pc, {r1, sl, fp}	; <UNPREDICTABLE>
     7f8:	79030000 	stmdbvc	r3, {}	; <UNPREDICTABLE>
     7fc:	00002c11 	andeq	r2, r0, r1, lsl ip
extern GPIO_InitTypeDef OV_PTA_init;

extern char ready_send_flag;

int main (void)
{
     800:	9e230300 	cdpls	3, 2, cr0, cr3, cr0, {0}
     804:	08060c02 	stmdaeq	r6, {r1, sl, fp}

    Ov7725_Init ();
     808:	7a030000 	bvc	c0810 <__etext+0xb7b68>
    Ov7725_Delay();
     80c:	00002c11 	andeq	r2, r0, r1, lsl ip

    //Ov7725_Dma_Init();
    Ov7725_Gpio_Init ();
     810:	9f230300 	svcls	0x00230300
    dma_portx2buff_init (DMA_CH0, (void *)(&GPIOB_PDIR), (void *)img,PORTA_DMAREQ ,DMA_BYTE1, PHOTO_SIZE / 8, DADDR_KEEPON);
     814:	03520c02 	cmpeq	r2, #512	; 0x200
     818:	7b030000 	blvc	c0820 <__etext+0xb7b78>
     81c:	00084611 	andeq	r4, r8, r1, lsl r6
     820:	a0230300 	eorge	r0, r3, r0, lsl #6
     824:	43540e02 	cmpmi	r4, #32
     828:	92030044 	andls	r0, r3, #68	; 0x44
     82c:	00085711 	andeq	r5, r8, r1, lsl r7
     830:	80230300 	eorhi	r0, r3, r0, lsl #6
     834:	2c070020 	stccs	0, cr0, [r7], {32}
     838:	46000000 	strmi	r0, [r0], -r0
     83c:	08000008 	stmdaeq	r0, {r3}
    //装载DMA中断
    DMA_ISR[DMA_CH0] = Ov7725_eagle_dma;
     840:	000003ab 	andeq	r0, r0, fp, lsr #7
     844:	2c0700c7 	stccs	0, cr0, [r7], {199}	; 0xc7
     848:	57000000 	strpl	r0, [r0, -r0]
     84c:	10000008 	andne	r0, r0, r8
     850:	000003ab 	andeq	r0, r0, fp, lsr #7
    //关闭DMA通道
    DMA_DIS(DMA_CH0);
     854:	07000edf 			; <UNDEFINED> instruction: 0x07000edf
     858:	00000434 	andeq	r0, r0, r4, lsr r4
     85c:	00000867 	andeq	r0, r0, r7, ror #16
     860:	0003ab08 	andeq	sl, r3, r8, lsl #22
     864:	11001f00 	tstne	r0, r0, lsl #30
     868:	00000511 	andeq	r0, r0, r1, lsl r5
    //关GPIO中断
    disable_irq(INT_PORTA - 16);
     86c:	73119303 	tstvc	r1, #201326592	; 0xc000000
     870:	12000008 	andne	r0, r0, #8
    //清DMA中断置为标志
    DMA_IRQ_CLEAN(DMA_CH0);
     874:	00087904 	andeq	r7, r8, r4, lsl #18
     878:	04ce1300 	strbeq	r1, [lr], #768	; 0x300
     87c:	f8140000 			; <UNDEFINED> instruction: 0xf8140000
     880:	18000008 	stmdane	r0, {r3}
     884:	e625bf03 	strt	fp, [r5], -r3, lsl #30
     888:	0c000008 	stceq	0, cr0, [r0], {8}
    //使能DMA中断
    DMA_IRQ_EN (DMA_CH0);
     88c:	00000a1c 	andeq	r0, r0, ip, lsl sl
     890:	5e25c003 	cdppl	0, 2, cr12, cr5, cr3, {0}
    //开启GPIO中断
    LPLD_GPIO_EnableIrq(OV_PTA_init);
     894:	02000000 	andeq	r0, r0, #0
     898:	f10c0023 			; <UNDEFINED> instruction: 0xf10c0023
     89c:	03000002 	movweq	r0, #2
     8a0:	005e25c1 	subseq	r2, lr, r1, asr #11
     8a4:	23020000 	movwcs	r0, #8192	; 0x2000
    {
        //获取图像
        //Ov7725_eagle_get_img ();
        //解压图像
        //Ov7725_img_extract (Pix_Data, img, PHOTO_SIZE/8);
        if(ready_send_flag)
     8a8:	01340c04 	teqeq	r4, r4, lsl #24
     8ac:	c2030000 	andgt	r0, r3, #0
     8b0:	00005e25 	andeq	r5, r0, r5, lsr #28
     8b4:	08230200 	stmdaeq	r3!, {r9}
        {
            //发送图片到上位机
            //get_midline(Pix_Data, 60, 80);
            Ov7725_sendimg (Pix_Data, PHOTO_SIZE);
     8b8:	0000670c 	andeq	r6, r0, ip, lsl #14
     8bc:	25c30300 	strbcs	r0, [r3, #768]	; 0x300
     8c0:	0000005e 	andeq	r0, r0, lr, asr r0
     8c4:	0c0c2302 	stceq	3, cr2, [ip], {2}
            ready_send_flag = 0;
     8c8:	00000177 	andeq	r0, r0, r7, ror r1
     8cc:	5e25c403 	cdppl	4, 2, cr12, cr5, cr3, {0}
     8d0:	02000000 	andeq	r0, r0, #0
        }
    }
     8d4:	2f0c1023 	svccs	0x000c1023
 * \param  void
 *
 * \return void
 */
void Default_Handler(void)
{
     8d8:	03000005 	movweq	r0, #5
     8dc:	005e25c5 	subseq	r2, lr, r5, asr #11
#define VECTORNUM       (*(volatile char *) (0xE000ED04))
  //while (1);
  char vtr = VECTORNUM;
     8e0:	23020000 	movwcs	r0, #8192	; 0x2000
     8e4:	57110014 			; <UNDEFINED> instruction: 0x57110014
     8e8:	03000001 	movweq	r0, #1
  printf ("\n ******************\n");
     8ec:	08f225c6 	ldmeq	r2!, {r1, r2, r6, r7, r8, sl, sp}^
     8f0:	04120000 	ldreq	r0, [r2], #-0
     8f4:	000008f8 	strdeq	r0, [r0], -r8
  printf ("Default Handler Error\n");
     8f8:	00087e13 	andeq	r7, r8, r3, lsl lr
     8fc:	04830300 	streq	r0, [r3], #768	; 0x300
     900:	1b040000 	blne	100908 <__etext+0xf7c60>
  printf ("On vector %d **** Interrupt\n", vtr);
     904:	00000037 	andeq	r0, r0, r7, lsr r0
     908:	001d7b03 	andseq	r7, sp, r3, lsl #22
     90c:	691d0400 	ldmdbvs	sp, {sl}
     910:	02000000 	andeq	r0, r0, #0
 * \param  void
 *
 * \return void
 */
void Reset_Handler(void)
{
     914:	06690404 	strbteq	r0, [r9], -r4, lsl #8
     918:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
  unsigned char *source;
  unsigned char *destination;

  /* watchdog disable */
  *((volatile unsigned short *)0x4005200E) = 0xC520;
     91c:	000a8704 	andeq	r8, sl, r4, lsl #14
     920:	061a1100 	ldreq	r1, [sl], -r0, lsl #2
     924:	a7050000 	strge	r0, [r5, -r0]
  *((volatile unsigned short *)0x4005200E) = 0xD928;
     928:	00092d01 	andeq	r2, r9, r1, lsl #26
     92c:	33041200 	movwcc	r1, #16896	; 0x4200
     930:	15000009 	strne	r0, [r0, #-9]
     934:	05140b01 	ldreq	r0, [r4, #-2817]	; 0xb01
  *((volatile unsigned short *)0x40052000) = 0x01D2;
     938:	099901aa 	ldmibeq	r9, {r1, r3, r5, r7, r8}
     93c:	400c0000 	andmi	r0, ip, r0
     940:	05000006 	streq	r0, [r0, #-6]

  /* copy data values from ROM to RAM */
  source = (unsigned char *)&_etext;
     944:	08e601af 	stmiaeq	r6!, {r0, r1, r2, r3, r5, r7, r8}^
     948:	23020000 	movwcs	r0, #8192	; 0x2000
     94c:	09ee0c00 	stmibeq	lr!, {sl, fp}^
  destination = (unsigned char *)&_sdata;
     950:	b3050000 	movwlt	r0, #20480	; 0x5000
     954:	00090801 	andeq	r0, r9, r1, lsl #16
  while (destination < (unsigned char*)&_edata) {
     958:	04230200 	strteq	r0, [r3], #-512	; 0x200
    *(destination++) = *(source++);
     95c:	0002f60c 	andeq	pc, r2, ip, lsl #12
     960:	01b70500 			; <UNDEFINED> instruction: 0x01b70500
     964:	00000908 	andeq	r0, r0, r8, lsl #18
     968:	0c082302 	stceq	3, cr2, [r8], {2}
     96c:	00000534 	andeq	r0, r0, r4, lsr r5
     970:	fd01bb05 	stc2	11, cr11, [r1, #-20]	; 0xffffffec
  *((volatile unsigned short *)0x40052000) = 0x01D2;

  /* copy data values from ROM to RAM */
  source = (unsigned char *)&_etext;
  destination = (unsigned char *)&_sdata;
  while (destination < (unsigned char*)&_edata) {
     974:	02000008 	andeq	r0, r0, #8
     978:	280c0c23 	stmdacs	ip, {r0, r1, r5, sl, fp}
     97c:	05000020 	streq	r0, [r0, #-32]
    *(destination++) = *(source++);
  }

  /* clear bss section */
  source = (unsigned char *)&_sbss;
     980:	08fd01bf 	ldmeq	sp!, {r0, r1, r2, r3, r4, r5, r7, r8}^
     984:	23020000 	movwcs	r0, #8192	; 0x2000
     988:	09d40c0d 	ldmibeq	r4, {r0, r2, r3, sl, fp}^
  destination = (unsigned char *)&_ebss;
     98c:	c9050000 	stmdbgt	r5, {}	; <UNPREDICTABLE>
     990:	00092101 	andeq	r2, r9, r1, lsl #2
  while (source < destination ) {
     994:	10230200 	eorne	r0, r3, r0, lsl #4
    *source++ = 0;
     998:	05ff1100 	ldrbeq	r1, [pc, #256]!	; aa0 <SystemInit+0xe8>
     99c:	ca050000 	bgt	1409a4 <__etext+0x137cfc>
     9a0:	00093501 	andeq	r3, r9, r1, lsl #10
     9a4:	08010200 	stmdaeq	r1, {r9}
  }

  /* clear bss section */
  source = (unsigned char *)&_sbss;
  destination = (unsigned char *)&_ebss;
  while (source < destination ) {
     9a8:	00000712 	andeq	r0, r0, r2, lsl r7
     9ac:	00072003 	andeq	r2, r7, r3
    *source++ = 0;
  }
 //进入系统初始化函数
  SystemInit();
     9b0:	2d220600 	stccs	6, cr0, [r2, #-0]
 //进入用户函数
  main();
     9b4:	05000009 	streq	r0, [r0, #-9]
 * \param  void
 *
 * \return void
 */
void SystemInit(void)
{
     9b8:	ccdf0701 	ldclgt	7, cr0, [pc], {1}
  //使能所有IO口时钟
  SIM_SCGC5 |= (SIM_SCGC5_PORTA_MASK | SIM_SCGC5_PORTB_MASK
     9bc:	06000009 	streq	r0, [r0], -r9
     9c0:	000007a4 	andeq	r0, r0, r4, lsr #15
     9c4:	055e0600 	ldrbeq	r0, [lr, #-1536]	; 0x600
     9c8:	00010000 	andeq	r0, r1, r0
     9cc:	e5070105 	str	r0, [r7, #-261]	; 0x105
     9d0:	000009ed 	andeq	r0, r0, sp, ror #19
     9d4:	0004f306 	andeq	pc, r4, r6, lsl #6
     9d8:	fd060000 	stc2	0, cr0, [r6, #-0]
     9dc:	01000004 	tsteq	r0, r4
     9e0:	00050706 	andeq	r0, r5, r6, lsl #14
              | SIM_SCGC5_PORTC_MASK | SIM_SCGC5_PORTD_MASK
              | SIM_SCGC5_PORTE_MASK);
  //初始化各部分时钟：系统内核主频、总线时钟、FlexBus时钟、Flash时钟
  LPLD_PLL_Setup(CORE_CLK_MHZ);
     9e4:	5c060200 	sfmpl	f0, 4, [r6], {-0}
     9e8:	0400000a 	streq	r0, [r0], #-10
  
  //更新内核主频
  SystemCoreClockUpdate();
     9ec:	be011600 	cfmadd32lt	mvax0, mvfx1, mvfx1, mvfx0
  
  //获取各部分时钟
  g_core_clock = SystemCoreClock;
     9f0:	01000005 	tsteq	r0, r5
     9f4:	007e0110 	rsbseq	r0, lr, r0, lsl r1
     9f8:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
     9fc:	08d60000 	ldmeq	r6, {}^	; <UNPREDICTABLE>
     a00:	00000000 	andeq	r0, r0, r0
  g_bus_clock = g_core_clock / ((uint32_t)((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV2_MASK) >> SIM_CLKDIV1_OUTDIV2_SHIFT)+ 1u);
     a04:	07010000 	streq	r0, [r1, -r0]
     a08:	000008fd 	strdeq	r0, [r0], -sp
     a0c:	00000a18 	andeq	r0, r0, r8, lsl sl
     a10:	0003ab10 	andeq	sl, r3, r0, lsl fp
     a14:	0012bf00 	andseq	fp, r2, r0, lsl #30
     a18:	00076717 	andeq	r6, r7, r7, lsl r7
     a1c:	07aa0700 	streq	r0, [sl, r0, lsl #14]!
     a20:	0100000a 	tsteq	r0, sl
     a24:	02d40305 	sbcseq	r0, r4, #335544320	; 0x14000000
     a28:	fd071fff 	stc2	15, cr1, [r7, #-1020]	; 0xfffffc04
     a2c:	3b000008 	blcc	a54 <SystemInit+0x9c>
     a30:	1000000a 	andne	r0, r0, sl
     a34:	000003ab 	andeq	r0, r0, fp, lsr #7
     a38:	18000257 	stmdane	r0, {r0, r1, r2, r4, r6, r9}
  g_flexbus_clock =  g_core_clock / ((uint32_t)((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV3_MASK) >> SIM_CLKDIV1_OUTDIV3_SHIFT)+ 1u);
     a3c:	00676d69 	rsbeq	r6, r7, r9, ror #26
     a40:	0a2aab07 	beq	aab664 <__etext+0xaa29bc>
     a44:	05010000 	streq	r0, [r1, #-0]
     a48:	ff007c03 			; <UNDEFINED> instruction: 0xff007c03
     a4c:	09ac071f 	stmibeq	ip!, {r0, r1, r2, r3, r4, r8, r9, sl}
     a50:	0a5d0000 	beq	1740a58 <__etext+0x1737db0>
     a54:	ab080000 	blge	200a5c <__etext+0x1f7db4>
     a58:	0f000003 	svceq	0x00000003
     a5c:	0a2f1900 	beq	bc6e64 <__etext+0xbbe1bc>
     a60:	0b010000 	bleq	40a68 <__etext+0x37dc0>
     a64:	00000a4d 	andeq	r0, r0, sp, asr #20
     a68:	cb190101 	blgt	640e74 <__etext+0x6381cc>
     a6c:	01000005 	tsteq	r0, r5
  g_flash_clock =  g_core_clock / ((uint32_t)((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV4_MASK) >> SIM_CLKDIV1_OUTDIV4_SHIFT)+ 1u);
     a70:	0009990c 	andeq	r9, r9, ip, lsl #18
     a74:	19010100 	stmdbne	r1, {r8}
     a78:	0000000f 	andeq	r0, r0, pc
     a7c:	09a50e01 	stmibeq	r5!, {r0, r9, sl, fp}
     a80:	01010000 	mrseq	r0, (UNDEF: 1)
     a84:	00016000 	andeq	r6, r1, r0
     a88:	45000200 	strmi	r0, [r0, #-512]	; 0x200
     a8c:	04000001 	streq	r0, [r0], #-1
     a90:	00023401 	andeq	r3, r2, r1, lsl #8
     a94:	0abf0100 	beq	fefc0e9c <__StackLimit+0xdefc0e9c>
     a98:	08270000 	stmdaeq	r7!, {}	; <UNPREDICTABLE>
     a9c:	08d80000 	ldmeq	r8, {}^	; <UNPREDICTABLE>
     aa0:	09b80000 	ldmibeq	r8!, {}	; <UNPREDICTABLE>
     aa4:	01480000 	mrseq	r0, (UNDEF: 72)
 
    //初始化系统终端
  systemTerm ();
     aa8:	01020000 	mrseq	r0, (UNDEF: 2)
 *
 * @brief  更新全局变量SystemCoreClock的值，以便获取最新的系统内核频率。
 *         
 */
void SystemCoreClockUpdate (void) 
{
     aac:	00070b06 	andeq	r0, r7, r6, lsl #22
     ab0:	08010200 	stmdaeq	r1, {r9}
    uint32_t temp;
    temp =  CPU_XTAL_CLK_HZ *((uint32_t)(MCG_C6 & MCG_C6_VDIV_MASK) + 16u );
     ab4:	00000709 	andeq	r0, r0, r9, lsl #14
     ab8:	3b050202 	blcc	1412c8 <__etext+0x138620>
     abc:	02000007 	andeq	r0, r0, #7
     ac0:	04920702 	ldreq	r0, [r2], #1794	; 0x702
     ac4:	04020000 	streq	r0, [r2], #-0
     ac8:	00019605 	andeq	r9, r1, r5, lsl #12
     acc:	07040200 	streq	r0, [r4, -r0, lsl #4]
     ad0:	000001e4 	andeq	r0, r0, r4, ror #3
     ad4:	91050802 	tstls	r5, r2, lsl #16
     ad8:	02000001 	andeq	r0, r0, #1
    temp = (uint32_t)(temp/((uint32_t)(MCG_C5 & MCG_C5_PRDIV_MASK) +1u ))/2;
     adc:	01df0708 	bicseq	r0, pc, r8, lsl #14
     ae0:	04030000 	streq	r0, [r3], #-0
     ae4:	746e6905 	strbtvc	r6, [lr], #-2309	; 0x905
     ae8:	07040200 	streq	r0, [r4, -r0, lsl #4]
     aec:	000001e9 	andeq	r0, r0, r9, ror #3
     af0:	74070402 	strvc	r0, [r7], #-1026	; 0x402
     af4:	02000005 	andeq	r0, r0, #5
     af8:	06690404 	strbteq	r0, [r9], -r4, lsl #8
    SystemCoreClock = temp;
     afc:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
     b00:	000a8704 	andeq	r8, sl, r4, lsl #14
     b04:	86040400 	strhi	r0, [r4], -r0, lsl #8
}
     b08:	05000000 	streq	r0, [r0, #-0]
     b0c:	2c040401 	cfstrscs	mvf0, [r4], {1}
/*
 * 使能中断
 */

void enable_irq (int irq)
{
     b10:	02000000 	andeq	r0, r0, #0
     b14:	07120801 	ldreq	r0, [r2, -r1, lsl #16]
    int div;
    if (irq > 105)
     b18:	01060000 	mrseq	r0, (UNDEF: 6)
     b1c:	00000afc 	strdeq	r0, [r0], -ip
        irq = 105;
     b20:	01019701 	tsteq	r1, r1, lsl #14
    div = irq / 32;
     b24:	000008d8 	ldrdeq	r0, [r0], -r8
     b28:	00000914 	andeq	r0, r0, r4, lsl r9
     b2c:	00000038 	andeq	r0, r0, r8, lsr r0
     b30:	0000c001 	andeq	ip, r0, r1
    switch (div)
     b34:	74760700 	ldrbtvc	r0, [r6], #-1792	; 0x700
     b38:	9b010072 	blls	40d08 <__etext+0x38060>
     b3c:	00008e01 	andeq	r8, r0, r1, lsl #28
     b40:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
     b44:	ee010600 	cfmadd32	mvax0, mvfx0, mvfx1, mvfx0
     b48:	0100000a 	tsteq	r0, sl
     b4c:	140101a9 	strne	r0, [r1], #-425	; 0x1a9
     b50:	b8000009 	stmdalt	r0, {r0, r3}
    {
        case 0x0:
            NVICICPR0 |= 1 << (irq & 0x1F);
     b54:	70000009 	andvc	r0, r0, r9
     b58:	01000000 	mrseq	r0, (UNDEF: 0)
     b5c:	000000fa 	strdeq	r0, [r0], -sl
     b60:	000b1908 	andeq	r1, fp, r8, lsl #18
     b64:	01ab0100 			; <UNDEFINED> instruction: 0x01ab0100
     b68:	00000088 	andeq	r0, r0, r8, lsl #1
     b6c:	08749102 	ldmdaeq	r4!, {r1, r8, ip, pc}^
     b70:	00000ae2 	andeq	r0, r0, r2, ror #21
     b74:	8801ac01 	stmdahi	r1, {r0, sl, fp, sp, pc}
     b78:	02000000 	andeq	r0, r0, #0
            NVICISER0 |= 1 << (irq & 0x1F);
     b7c:	09007091 	stmdbeq	r0, {r0, r4, r7, ip, sp, lr}
     b80:	00000b0c 	andeq	r0, r0, ip, lsl #22
     b84:	00480e01 	subeq	r0, r8, r1, lsl #28
     b88:	01010000 	mrseq	r0, (UNDEF: 1)
     b8c:	000adb09 	andeq	sp, sl, r9, lsl #22
     b90:	480f0100 	stmdami	pc, {r8}	; <UNPREDICTABLE>
     b94:	01000000 	mrseq	r0, (UNDEF: 0)
     b98:	0b200901 	bleq	802fa4 <__etext+0x7fa2fc>
     b9c:	10010000 	andne	r0, r1, r0
            break;
     ba0:	00000048 	andeq	r0, r0, r8, asr #32
        case 0x1:
            NVICICPR1 |= 1 << (irq & 0x1F);
     ba4:	34090101 	strcc	r0, [r9], #-257	; 0x101
     ba8:	0100000b 	tsteq	r0, fp
     bac:	00004811 	andeq	r4, r0, r1, lsl r8
     bb0:	09010100 	stmdbeq	r1, {r8}
     bb4:	00000b13 	andeq	r0, r0, r3, lsl fp
     bb8:	00481201 	subeq	r1, r8, r1, lsl #4
     bbc:	01010000 	mrseq	r0, (UNDEF: 1)
     bc0:	0000800a 	andeq	r8, r0, sl
     bc4:	00014c00 	andeq	r4, r1, r0, lsl #24
     bc8:	006b0b00 	rsbeq	r0, fp, r0, lsl #22
            NVICISER1 |= 1 << (irq & 0x1F);
     bcc:	01030000 	mrseq	r0, (UNDEF: 3)
     bd0:	0b270c00 	bleq	9c3bd8 <__etext+0x9baf30>
     bd4:	89010000 	stmdbhi	r1, {}	; <UNPREDICTABLE>
     bd8:	0000015e 	andeq	r0, r0, lr, asr r1
     bdc:	00030501 	andeq	r0, r3, r1, lsl #10
     be0:	0d000000 	stceq	0, cr0, [r0, #-0]
     be4:	0000013b 	andeq	r0, r0, fp, lsr r1
     be8:	000d2300 	andeq	r2, sp, r0, lsl #6
     bec:	f2000200 	vhsub.s8	d0, d0, d0
            break;
        case 0x2:
            NVICICPR2 |= 1 << (irq & 0x1F);
     bf0:	04000001 	streq	r0, [r0], #-1
     bf4:	00023401 	andeq	r3, r2, r1, lsl #8
     bf8:	0c120100 	ldfeqs	f0, [r2], {-0}
     bfc:	08270000 	stmdaeq	r7!, {}	; <UNPREDICTABLE>
     c00:	09b80000 	ldmibeq	r8!, {}	; <UNPREDICTABLE>
     c04:	0dd00000 	ldcleq	0, cr0, [r0]
     c08:	01bc0000 			; <UNDEFINED> instruction: 0x01bc0000
     c0c:	01020000 	mrseq	r0, (UNDEF: 2)
     c10:	00070b06 	andeq	r0, r7, r6, lsl #22
     c14:	09dd0300 	ldmibeq	sp, {r8, r9}^
            NVICISER2 |= 1 << (irq & 0x1F);
     c18:	2a020000 	bcs	80c20 <__etext+0x77f78>
     c1c:	00000037 	andeq	r0, r0, r7, lsr r0
     c20:	09080102 	stmdbeq	r8, {r1, r8}
     c24:	02000007 	andeq	r0, r0, #7
     c28:	073b0502 	ldreq	r0, [fp, -r2, lsl #10]!
     c2c:	02020000 	andeq	r0, r2, #0
     c30:	00049207 	andeq	r9, r4, r7, lsl #4
     c34:	05040200 	streq	r0, [r4, #-512]	; 0x200
     c38:	00000196 	muleq	r0, r6, r1
            break;
     c3c:	00079b03 	andeq	r9, r7, r3, lsl #22
        case 0x3:
            NVICICPR3 |= 1 << (irq & 0x1F);
     c40:	5e500200 	cdppl	2, 5, cr0, cr0, cr0, {0}
     c44:	02000000 	andeq	r0, r0, #0
     c48:	01e40704 	mvneq	r0, r4, lsl #14
     c4c:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
     c50:	00019105 	andeq	r9, r1, r5, lsl #2
     c54:	07080200 	streq	r0, [r8, -r0, lsl #4]
     c58:	000001df 	ldrdeq	r0, [r0], -pc	; <UNPREDICTABLE>
     c5c:	69050404 	stmdbvs	r5, {r2, sl}
     c60:	0200746e 	andeq	r7, r0, #1845493760	; 0x6e000000
     c64:	01e90704 	mvneq	r0, r4, lsl #14
            NVICISER3 |= 1 << (irq & 0x1F);
     c68:	04020000 	streq	r0, [r2], #-0
     c6c:	00057407 	andeq	r7, r5, r7, lsl #8
     c70:	002c0500 	eoreq	r0, ip, r0, lsl #10
     c74:	00980000 	addseq	r0, r8, r0
     c78:	81060000 	mrshi	r0, (UNDEF: 6)
     c7c:	03000000 	movweq	r0, #0
     c80:	002c0500 	eoreq	r0, ip, r0, lsl #10
     c84:	00a80000 	adceq	r0, r8, r0
     c88:	81060000 	mrshi	r0, (UNDEF: 6)
            break;
    }
}
     c8c:	07000000 	streq	r0, [r0, -r0]
     c90:	0ffc0700 	svceq	0x00fc0700
     c94:	03130000 	tsteq	r3, #0
/*
 * 关闭中断
 */

void disable_irq (int irq)
{
     c98:	01c62c37 	biceq	r2, r6, r7, lsr ip
     c9c:	43080000 	movwmi	r0, #32768	; 0x8000
    int div;
    if (irq > 105)
     ca0:	38030031 	stmdacc	r3, {r0, r4, r5}
     ca4:	00002c2c 	andeq	r2, r0, ip, lsr #24
        irq = 105;
     ca8:	00230200 	eoreq	r0, r3, r0, lsl #4
    div = irq / 32;
     cac:	00324308 	eorseq	r4, r2, r8, lsl #6
     cb0:	2c2c3903 	stccs	9, cr3, [ip], #-12
     cb4:	02000000 	andeq	r0, r0, #0
     cb8:	43080123 	movwmi	r0, #33059	; 0x8123
    switch (div)
     cbc:	3a030033 	bcc	c0d90 <__etext+0xb80e8>
     cc0:	00002c2c 	andeq	r2, r0, ip, lsr #24
     cc4:	02230200 	eoreq	r0, r3, #0
     cc8:	00344308 	eorseq	r4, r4, r8, lsl #6
     ccc:	2c2c3b03 	stccs	11, cr3, [ip], #-12
     cd0:	02000000 	andeq	r0, r0, #0
     cd4:	43080323 	movwmi	r0, #33571	; 0x8323
    {
        case 0x0:
            NVICICPR0 |= 1 << (irq & 0x1F);
     cd8:	3c030035 	stccc	0, cr0, [r3], {53}	; 0x35
     cdc:	00002c2c 	andeq	r2, r0, ip, lsr #24
     ce0:	04230200 	strteq	r0, [r3], #-512	; 0x200
     ce4:	00364308 	eorseq	r4, r6, r8, lsl #6
     ce8:	2c2c3d03 	stccs	13, cr3, [ip], #-12
     cec:	02000000 	andeq	r0, r0, #0
     cf0:	53080523 	movwpl	r0, #34083	; 0x8523
     cf4:	2c3e0300 	ldccs	3, cr0, [lr], #-0
     cf8:	0000002c 	andeq	r0, r0, ip, lsr #32
     cfc:	09062302 	stmdbeq	r6, {r1, r8, r9, sp}
            break;
     d00:	00000312 	andeq	r0, r0, r2, lsl r3
        case 0x1:
            NVICICPR1 |= 1 << (irq & 0x1F);
     d04:	c62c3f03 	strtgt	r3, [ip], -r3, lsl #30
     d08:	02000001 	andeq	r0, r0, #1
     d0c:	53080723 	movwpl	r0, #34595	; 0x8723
     d10:	40030043 	andmi	r0, r3, r3, asr #32
     d14:	00002c2c 	andeq	r2, r0, ip, lsr #24
     d18:	08230200 	stmdaeq	r3!, {r9}
     d1c:	00031d09 	andeq	r1, r3, r9, lsl #26
     d20:	2c410300 	mcrrcs	3, 0, r0, r1, cr0
     d24:	000001c6 	andeq	r0, r0, r6, asr #3
     d28:	09092302 	stmdbeq	r9, {r1, r8, r9, sp}
            break;
        case 0x2:
            NVICICPR2 |= 1 << (irq & 0x1F);
     d2c:	00000ba2 	andeq	r0, r0, r2, lsr #23
     d30:	2c2c4203 	sfmcs	f4, 4, [ip], #-12
     d34:	02000000 	andeq	r0, r0, #0
     d38:	af090a23 	svcge	0x00090a23
     d3c:	0300000b 	movweq	r0, #11
     d40:	002c2c43 	eoreq	r2, ip, r3, asr #24
     d44:	23020000 	movwcs	r0, #8192	; 0x2000
     d48:	3743080b 	strbcc	r0, [r3, -fp, lsl #16]
     d4c:	2c440300 	mcrrcs	3, 0, r0, r4, cr0
     d50:	0000002c 	andeq	r0, r0, ip, lsr #32
            break;
     d54:	080c2302 	stmdaeq	ip, {r1, r8, r9, sp}
        case 0x3:
            NVICICPR3 |= 1 << (irq & 0x1F);
     d58:	03003843 	movweq	r3, #2115	; 0x843
     d5c:	002c2c45 	eoreq	r2, ip, r5, asr #24
     d60:	23020000 	movwcs	r0, #8192	; 0x2000
     d64:	3943080d 	stmdbcc	r3, {r0, r2, r3, fp}^
     d68:	2c460300 	mcrrcs	3, 0, r0, r6, cr0
     d6c:	0000002c 	andeq	r0, r0, ip, lsr #32
     d70:	080e2302 	stmdaeq	lr, {r1, r8, r9, sp}
     d74:	00303143 	eorseq	r3, r0, r3, asr #2
     d78:	2c2c4703 	stccs	7, cr4, [ip], #-12
     d7c:	02000000 	andeq	r0, r0, #0
            break;
    }
}
     d80:	43080f23 	movwmi	r0, #36643	; 0x8f23
     d84:	03003131 	movweq	r3, #305	; 0x131
     d88:	002c2c48 	eoreq	r2, ip, r8, asr #24
/*
 * 系统终端初始化函数
 */

 void systemTerm (void)
 {
     d8c:	23020000 	movwcs	r0, #8192	; 0x2000
     d90:	31430810 	cmpcc	r3, r0, lsl r8
     UART_InitTypeDef uart_init_struct;
     uart_init_struct.UART_Uartx = TERM_PORT;
     d94:	49030032 	stmdbmi	r3, {r1, r4, r5}
     d98:	00002c2c 	andeq	r2, r0, ip, lsr #24
     uart_init_struct.UART_BaudRate = TERM_BAUD;
     d9c:	11230200 	teqne	r3, r0, lsl #4
     da0:	00325308 	eorseq	r5, r2, r8, lsl #6
     uart_init_struct.UART_RxPin = TERM_RX;
     da4:	2c2c4a03 	stccs	10, cr4, [ip], #-12
     uart_init_struct.UART_TxPin = TERM_TX;
     da8:	02000000 	andeq	r0, r0, #0
     dac:	05001223 	streq	r1, [r0, #-547]	; 0x223
     uart_init_struct.UART_RxIntEnable = TERM_RX_IRQ;
     db0:	0000002c 	andeq	r0, r0, ip, lsr #32
     uart_init_struct.UART_RxIsr = TERM_RX_FUN;
     db4:	000001d6 	ldrdeq	r0, [r0], -r6
     db8:	00008106 	andeq	r8, r0, r6, lsl #2

     LPLD_UART_Init (uart_init_struct);
     dbc:	0a000000 	beq	dc4 <systemTerm+0x38>
     dc0:	00000fba 			; <UNDEFINED> instruction: 0x00000fba
     dc4:	e22c4b03 	eor	r4, ip, #3072	; 0xc00
#if (TERM_RX_IRQ == TRUE)
     LPLD_UART_EnableIrq (uart_init_struct);
#endif

 }
     dc8:	0b000001 	bleq	dd4 <Ov7725_Init+0x4>
     dcc:	0001e804 	andeq	lr, r1, r4, lsl #16
//图像状态
volatile IMG_STATUS_e ov7725_eagle_img_flag = IMG_FINISH;

//ov7725初始化 
uint8 Ov7725_Init (void)
{
     dd0:	00a80c00 	adceq	r0, r8, r0, lsl #24
     dd4:	b60d0000 	strlt	r0, [sp], -r0
    uint16 i = 0;
     dd8:	0400000c 	streq	r0, [r0], #-12
    uint8 device_Id = 0;
     ddc:	3141030e 	cmpcc	r1, lr, lsl #6
     de0:	000002c9 	andeq	r0, r0, r9, asr #5
    uint8 reg_Buff[50] = {0};
     de4:	000c2d09 	andeq	r2, ip, r9, lsl #26
     de8:	31420300 	mrscc	r0, SPSR_svc
     dec:	000002c9 	andeq	r0, r0, r9, asr #5
     df0:	09002302 	stmdbeq	r0, {r1, r8, r9, sp}
     df4:	00000312 	andeq	r0, r0, r2, lsl r3
     df8:	d9314303 	ldmdble	r1!, {r0, r1, r8, r9, lr}
     dfc:	02000002 	andeq	r0, r0, #2
     e00:	17091023 	strne	r1, [r9, -r3, lsr #32]
     e04:	03000010 	movweq	r0, #16
     e08:	02c93144 	sbceq	r3, r9, #17
     e0c:	23030000 	movwcs	r0, #12288	; 0x3000
     e10:	1d090180 	stfnes	f0, [r9, #-512]	; 0xfffffe00
     e14:	03000003 	movweq	r0, #3
     e18:	02d93145 	sbcseq	r3, r9, #1073741841	; 0x40000011
     e1c:	23030000 	movwcs	r0, #12288	; 0x3000
     e20:	a4090190 	strge	r0, [r9], #-400	; 0x190
     e24:	03000010 	movweq	r0, #16
     e28:	02c93146 	sbceq	r3, r9, #-2147483631	; 0x80000011
     e2c:	23030000 	movwcs	r0, #12288	; 0x3000
     e30:	9a090280 	bls	241838 <__etext+0x238b90>
     e34:	0300000a 	movweq	r0, #10
     e38:	02d93147 	sbcseq	r3, r9, #-1073741807	; 0xc0000011
     e3c:	23030000 	movwcs	r0, #12288	; 0x3000
     e40:	95090290 	strls	r0, [r9, #-656]	; 0x290
     e44:	0300000e 	movweq	r0, #14
     e48:	02c93148 	sbceq	r3, r9, #18
     e4c:	23030000 	movwcs	r0, #12288	; 0x3000
     e50:	31090380 	smlabbcc	r9, r0, r3, r0
     e54:	03000003 	movweq	r0, #3
     e58:	02d93149 	sbcseq	r3, r9, #1073741842	; 0x40000012
     e5c:	23030000 	movwcs	r0, #12288	; 0x3000
     e60:	9a090390 	bls	241ca8 <__etext+0x239000>
     e64:	0300000e 	movweq	r0, #14

    LPLD_SCCB_Init ();
     e68:	02c9314a 	sbceq	r3, r9, #-2147483630	; 0x80000012
    
    Ov7725_Delay();
     e6c:	23030000 	movwcs	r0, #12288	; 0x3000

    while (!LPLD_SCCB_WriteReg (OV7725_COM7, 0x80))
     e70:	3c090480 	cfstrscc	mvf0, [r9], {128}	; 0x80
    {
        if (i ++ >= 500)
     e74:	03000003 	movweq	r0, #3
     e78:	02e9314b 	rsceq	r3, r9, #-1073741806	; 0xc0000012
     e7c:	23030000 	movwcs	r0, #12288	; 0x3000
     e80:	49080490 	stmdbmi	r8, {r4, r7, sl}
     e84:	4c030050 	stcmi	0, cr0, [r3], {80}	; 0x50
     e88:	0002f931 	andeq	pc, r2, r1, lsr r9	; <UNPREDICTABLE>
     e8c:	80230300 	eorhi	r0, r3, r0, lsl #6
            return 0;
     e90:	03470906 	movteq	r0, #30982	; 0x7906

    LPLD_SCCB_Init ();
    
    Ov7725_Delay();

    while (!LPLD_SCCB_WriteReg (OV7725_COM7, 0x80))
     e94:	4d030000 	stcmi	0, cr0, [r3, #-0]
     e98:	00030931 	andeq	r0, r3, r1, lsr r9
     e9c:	ea230300 	b	8c1aa4 <__etext+0x8b8dfc>
     ea0:	0ef50906 	cdpeq	9, 15, cr0, cr5, cr6, {0}
     ea4:	4e030000 	cdpmi	0, 0, cr0, cr3, cr0, {0}
    {
        if (i ++ >= 500)
            return 0;
    }

    Ov7725_Delay();
     ea8:	00031a31 	andeq	r1, r3, r1, lsr sl
    
    while (0 == LPLD_SCCB_ReadReg (OV7725_VER, &device_Id, 1));
     eac:	80230300 	eorhi	r0, r3, r0, lsl #6
     eb0:	5305001c 	movwpl	r0, #20508	; 0x501c
     eb4:	d9000000 	stmdble	r0, {}	; <UNPREDICTABLE>
     eb8:	06000002 	streq	r0, [r0], -r2
     ebc:	00000081 	andeq	r0, r0, r1, lsl #1
     ec0:	2c050003 	stccs	0, cr0, [r5], {3}

    printf ("You get ID success, SENSOR ID is 0x%x", device_Id);
     ec4:	e9000000 	stmdb	r0, {}	; <UNPREDICTABLE>
     ec8:	06000002 	streq	r0, [r0], -r2
     ecc:	00000081 	andeq	r0, r0, r1, lsl #1
     ed0:	2c05006f 	stccs	0, cr0, [r5], {111}	; 0x6f
     ed4:	f9000000 			; <UNDEFINED> instruction: 0xf9000000
    printf ("nconfig register Number is %d\n", ov7725_eagle_cfgnum);
     ed8:	06000002 	streq	r0, [r0], -r2
     edc:	00000081 	andeq	r0, r0, r1, lsl #1
     ee0:	2c0500ef 	stccs	0, cr0, [r5], {239}	; 0xef
     ee4:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
     ee8:	06000003 	streq	r0, [r0], -r3
     eec:	00000081 	andeq	r0, r0, r1, lsl #1

    //判断摄像头是否为ov7725
    if (device_Id == OV7725_ID)
     ef0:	2c050069 	stccs	0, cr0, [r5], {105}	; 0x69
     ef4:	1a000000 	bne	efc <Ov7725_Init+0x12c>
    {
        for (i = 0; i < ov7725_eagle_cfgnum; i++)
     ef8:	0e000003 	cdpeq	0, 0, cr0, cr0, cr3, {0}
     efc:	00000081 	andeq	r0, r0, r1, lsl #1
        {
            if (0 == LPLD_SCCB_WriteReg(ov7725_eagle_reg[i].addr, ov7725_eagle_reg[i].val))
     f00:	05000a95 	streq	r0, [r0, #-2709]	; 0xa95
     f04:	00000053 	andeq	r0, r0, r3, asr r0
     f08:	0000032a 	andeq	r0, r0, sl, lsr #6
     f0c:	00008106 	andeq	r8, r0, r6, lsl #2
     f10:	0a000000 	beq	f18 <Ov7725_Init+0x148>
     f14:	0000108a 	andeq	r1, r0, sl, lsl #1
     f18:	36314f03 	ldrtcc	r4, [r1], -r3, lsl #30
     f1c:	0b000003 	bleq	f30 <Ov7725_Init+0x160>
     f20:	00033c04 	andeq	r3, r3, r4, lsl #24
     f24:	01ed0c00 	mvneq	r0, r0, lsl #24
     f28:	440d0000 	strmi	r0, [sp], #-0
     f2c:	70000010 	andvc	r0, r0, r0, lsl r0
            {
               printf ("error: writeReg error 0x%x\n", ov7725_eagle_reg[i].addr);
     f30:	3d950310 	ldccc	3, cr0, [r5, #64]	; 0x40
     f34:	0000051d 	andeq	r0, r0, sp, lsl r5
     f38:	00103809 	andseq	r3, r0, r9, lsl #16
     f3c:	3d960300 	ldccc	3, cr0, [r6]
     f40:	00000053 	andeq	r0, r0, r3, asr r0
     f44:	09002302 	stmdbeq	r0, {r1, r8, r9, sp}
     f48:	00000d02 	andeq	r0, r0, r2, lsl #26
                return 0;
     f4c:	533d9703 	teqpl	sp, #786432	; 0xc0000
            }
            if (LPLD_SCCB_ReadReg(ov7725_eagle_reg[i].addr, &reg_Buff[i], 1))
     f50:	02000000 	andeq	r0, r0, #0
     f54:	12090423 	andne	r0, r9, #587202560	; 0x23000000
     f58:	03000003 	movweq	r0, #3
     f5c:	051d3d98 	ldreq	r3, [sp, #-3480]	; 0xd98
     f60:	23020000 	movwcs	r0, #8192	; 0x2000
     f64:	103e0908 	eorsne	r0, lr, r8, lsl #18
     f68:	99030000 	stmdbls	r3, {}	; <UNPREDICTABLE>
     f6c:	0000533d 	andeq	r5, r0, sp, lsr r3
     f70:	84230300 	strthi	r0, [r3], #-768	; 0x300
     f74:	031d0920 	tsteq	sp, #524288	; 0x80000
            {
                printf ("writeRe 0x%x success: 0x%x\n", ov7725_eagle_reg[i].addr, reg_Buff[i]);
     f78:	9a030000 	bls	c0f80 <__etext+0xb82d8>
     f7c:	0000883d 	andeq	r8, r0, sp, lsr r8
     f80:	88230300 	stmdahi	r3!, {r8, r9}
     f84:	104f0920 	subne	r0, pc, r0, lsr #18
     f88:	9b030000 	blls	c0f90 <__etext+0xb82e8>
     f8c:	0000533d 	andeq	r5, r0, sp, lsr r3
     f90:	8c230300 	stchi	3, cr0, [r3], #-0
     f94:	10550920 	subsne	r0, r5, r0, lsr #18
     f98:	9c030000 	stcls	0, cr0, [r3], {-0}
     f9c:	0000533d 	andeq	r5, r0, sp, lsr r3
     fa0:	90230300 	eorls	r0, r3, r0, lsl #6
    printf ("nconfig register Number is %d\n", ov7725_eagle_cfgnum);

    //判断摄像头是否为ov7725
    if (device_Id == OV7725_ID)
    {
        for (i = 0; i < ov7725_eagle_cfgnum; i++)
     fa4:	105b0920 	subsne	r0, fp, r0, lsr #18
     fa8:	9d030000 	stcls	0, cr0, [r3, #-0]
     fac:	0000533d 	andeq	r5, r0, sp, lsr r3
     fb0:	94230300 	strtls	r0, [r3], #-768	; 0x300
     fb4:	10610920 	rsbne	r0, r1, r0, lsr #18
     fb8:	9e030000 	cdpls	0, 0, cr0, cr3, cr0, {0}
            }
        }
    }
    else
    {
        return 0;
     fbc:	0000533d 	andeq	r5, r0, sp, lsr r3
     fc0:	98230300 	stmdals	r3!, {r8, r9}
    }
    return 1;
     fc4:	0a9a0920 	beq	fe68344c <__StackLimit+0xde68344c>

}
     fc8:	9f030000 	svcls	0x00030000
     fcc:	0000983d 	andeq	r9, r0, sp, lsr r8

//ov7725延时函数
void Ov7725_Delay(void)
{
     fd0:	9c230300 	stcls	3, cr0, [r3], #-0
     fd4:	0c640920 	stcleq	9, cr0, [r4], #-128	; 0xffffff80
    uint16 i, n;
    for (i = 0; i < 3000; i++)
     fd8:	a0030000 	andge	r0, r3, r0
     fdc:	0000533d 	andeq	r5, r0, sp, lsr r3
    {
        for (n = 0; n < 200; n++)
     fe0:	a4230300 	strtge	r0, [r3], #-768	; 0x300
     fe4:	0c690920 	stcleq	9, cr0, [r9], #-128	; 0xffffff80
     fe8:	a1030000 	mrsge	r0, (UNDEF: 3)
     fec:	0000533d 	andeq	r5, r0, sp, lsr r3
     ff0:	a8230300 	stmdage	r3!, {r8, r9}
     ff4:	0c6f0920 	stcleq	9, cr0, [pc], #-128	; f7c <Ov7725_Init+0x1ac>

//ov7725延时函数
void Ov7725_Delay(void)
{
    uint16 i, n;
    for (i = 0; i < 3000; i++)
     ff8:	a2030000 	andge	r0, r3, #0
     ffc:	0000533d 	andeq	r5, r0, sp, lsr r3
    1000:	ac230300 	stcge	3, cr0, [r3], #-0
    1004:	0c750920 	ldcleq	9, cr0, [r5], #-128	; 0xffffff80
        for (n = 0; n < 200; n++)
        {
            asm("nop");
        }
    }
}
    1008:	a3030000 	movwge	r0, #12288	; 0x3000
    100c:	0000533d 	andeq	r5, r0, sp, lsr r3
    1010:	b0230300 	eorlt	r0, r3, r0, lsl #6

//DMA中断触发函数
void Ov7725_eagle_dma (void)
{
    1014:	0c7b0920 	ldcleq	9, cr0, [fp], #-128	; 0xffffff80
    1018:	a4030000 	strge	r0, [r3], #-0
    ov7725_eagle_img_flag = IMG_FINISH;
    101c:	0000533d 	andeq	r5, r0, sp, lsr r3
    1020:	b4230300 	strtlt	r0, [r3], #-768	; 0x300
    1024:	0c810920 	stceq	9, cr0, [r1], {32}
    //关闭DMA通道
    DMA_DIS(DMA_CH0);
    1028:	a5030000 	strge	r0, [r3, #-0]
    102c:	0000533d 	andeq	r5, r0, sp, lsr r3
    1030:	b8230300 	stmdalt	r3!, {r8, r9}
    1034:	0c870920 	stceq	9, cr0, [r7], {32}
    1038:	a6030000 	strge	r0, [r3], -r0
    103c:	0000533d 	andeq	r5, r0, sp, lsr r3
    //DMA0->INT |= 0x1u << 0;
    //enable_irq(INT_PORTA - 16);
    //图片进行解压
    Ov7725_img_extract(Pix_Data, img, PHOTO_SIZE/8);
    1040:	bc230300 	stclt	3, cr0, [r3], #-0
    1044:	0c8d0920 	stceq	9, cr0, [sp], {32}
    1048:	a7030000 	strge	r0, [r3, -r0]
    104c:	0000533d 	andeq	r5, r0, sp, lsr r3
    1050:	c0230300 	eorgt	r0, r3, r0, lsl #6
    1054:	0fec0920 	svceq	0x00ec0920
    //解压完成标志置位
    ready_send_flag = 1;
    1058:	a8030000 	stmdage	r3, {}	; <UNPREDICTABLE>
    105c:	0000533d 	andeq	r5, r0, sp, lsr r3
    1060:	c4230300 	strtgt	r0, [r3], #-768	; 0x300
    1064:	0ff40920 	svceq	0x00f40920
    get_midline(Pix_Data, 60, 80);
    1068:	a9030000 	stmdbge	r3, {}	; <UNPREDICTABLE>
    106c:	0000533d 	andeq	r5, r0, sp, lsr r3
    1070:	c8230300 	stmdagt	r3!, {r8, r9}
    1074:	0f290920 	svceq	0x00290920
    1078:	aa030000 	bge	c1080 <__etext+0xb83d8>
         //重新装载DMA目标地址
        DMA_DADDR(DMA_CH0) = (uint32)img;
    107c:	0000533d 	andeq	r5, r0, sp, lsr r3
    1080:	cc230300 	stcgt	3, cr0, [r3], #-0
    1084:	0f2f0920 	svceq	0x002f0920
    1088:	ab030000 	blge	c1090 <__etext+0xb83e8>
    108c:	0000533d 	andeq	r5, r0, sp, lsr r3
    1090:	d0230300 	eorle	r0, r3, r0, lsl #6
   //Ov7725_sendimg(Pix_Data, PHOTO_SIZE);
    //clear PORTA isr set bit
    PORTA_ISFR = ~0;
    1094:	0bcb0920 	bleq	ff2c351c <__StackLimit+0xdf2c351c>
    1098:	ac030000 	stcge	0, cr0, [r3], {-0}
    109c:	0000533d 	andeq	r5, r0, sp, lsr r3
    10a0:	d4230300 	strtle	r0, [r3], #-768	; 0x300
    LPLD_GPIO_EnableIrq(OV_PTA_init);
    10a4:	0e090920 	cdpeq	9, 0, cr0, cr9, cr0, {1}
    10a8:	ad030000 	stcge	0, cr0, [r3, #-0]
    10ac:	0000533d 	andeq	r5, r0, sp, lsr r3
    10b0:	d8230300 	stmdale	r3!, {r8, r9}
    10b4:	0e0f0920 	cdpeq	9, 0, cr0, cr15, cr0, {1}
    //DMA0->INT |= 0x1u << 0;
}
    10b8:	ae030000 	cdpge	0, 0, cr0, cr3, cr0, {0}

//场中断开始判断函数
void Ov7725_eagle_vsync(void)
{
    10bc:	0000533d 	andeq	r5, r0, sp, lsr r3
    //printf ("runing eagle_vsync\n");
    //判断场中断是否开始
    if (ov7725_eagle_img_flag == IMG_START)
    10c0:	dc230300 	stcle	3, cr0, [r3], #-0
    10c4:	0bd00920 	bleq	ff40354c <__StackLimit+0xdf40354c>
    10c8:	af030000 	svcge	0x00030000
    10cc:	0000533d 	andeq	r5, r0, sp, lsr r3
    {
        ov7725_eagle_img_flag = IMG_GATHER;
    10d0:	e0230300 	eor	r0, r3, r0, lsl #6
    10d4:	03310920 	teqeq	r1, #524288	; 0x80000
    10d8:	b0030000 	andlt	r0, r3, r0
    10dc:	0000883d 	andeq	r8, r0, sp, lsr r8
        disable_irq (INT_PORTA - 16);
    10e0:	e4230300 	strt	r0, [r3], #-768	; 0x300
    10e4:	0e9f0920 	cdpeq	9, 9, cr0, cr15, cr0, {1}
        //LPLD_GPIO_DisableIrq(OV_PTA_init);
        //enable_irq (DMA_CH0 + INT_DMA0_DMA16 - 16);
        DMA_EN(DMA_CH0);
    10e8:	b1030000 	mrslt	r0, (UNDEF: 3)
    10ec:	0000533d 	andeq	r5, r0, sp, lsr r3
    10f0:	e8230300 	stmda	r3!, {r8, r9}
    10f4:	434d0820 	movtmi	r0, #55328	; 0xd820
    10f8:	b2030052 	andlt	r0, r3, #82	; 0x52
    10fc:	0000533d 	andeq	r5, r0, sp, lsr r3
        //LPLD_DMA_EnableIrq(OV_dma_init);
        //重新装载DMA目标地址
        DMA_DADDR(DMA_CH0) = (uint32)img;
    1100:	ec230300 	stc	3, cr0, [r3], #-0
    1104:	2c050020 	stccs	0, cr0, [r5], {32}
    1108:	2e000000 	cdpcs	0, 0, cr0, cr0, cr0, {0}
    110c:	0e000005 	cdpeq	0, 0, cr0, cr0, cr5, {0}
    1110:	00000081 	andeq	r0, r0, r1, lsl #1
    1114:	0a000ffb 	beq	5108 <PORTB_IRQHandler+0x10>
    1118:	00000f47 	andeq	r0, r0, r7, asr #30
    }
    else
    {
        //disable_irq (INT_PORTA);
        //LPLD_GPIO_DisableIrq(OV_PTA_init);
        disable_irq (INT_PORTA - 16);
    111c:	3a3db303 	bcc	f6dd30 <__etext+0xf65088>
    1120:	0b000005 	bleq	113c <Ov7725_eagle_get_img+0x8>
        ov7725_eagle_img_flag = IMG_FAIL;
    1124:	00054004 	andeq	r4, r5, r4
    1128:	03410c00 	movteq	r0, #7168	; 0x1c00
    112c:	010f0000 	mrseq	r0, CPSR
    }
}
    1130:	6743d203 	strbvs	sp, [r3, -r3, lsl #4]

//ov7725开始采集图像
void Ov7725_eagle_get_img(void)
{
    1134:	10000005 	andne	r0, r0, r5
    1138:	00000d23 	andeq	r0, r0, r3, lsr #26
    ov7725_eagle_img_flag = IMG_START;
    113c:	2c43d303 	mcrrcs	3, 0, sp, r3, cr3
    1140:	10000000 	andne	r0, r0, r0
    1144:	00000d32 	andeq	r0, r0, r2, lsr sp
    //write 1 clear int 
    PORTA_ISFR = ~0;
    1148:	2c43d403 	cfstrdcs	mvd13, [r3], {3}
    114c:	00000000 	andeq	r0, r0, r0
    1150:	00102c07 	andseq	r2, r0, r7, lsl #24
    1154:	b6033200 	strlt	r3, [r3], -r0, lsl #4
    DMA_DADDR(DMA_CH0) = (uint32)img;
    1158:	00084c43 	andeq	r4, r8, r3, asr #24
    115c:	44420800 	strbmi	r0, [r2], #-2048	; 0x800
    1160:	b7030048 	strlt	r0, [r3, -r8, asr #32]
    1164:	00002c43 	andeq	r2, r0, r3, asr #24
    1168:	00230200 	eoreq	r0, r3, r0, lsl #4
    116c:	4c444208 	sfmmi	f4, 2, [r4], {8}
    1170:	43b80300 			; <UNDEFINED> instruction: 0x43b80300
    LPLD_GPIO_EnableIrq(OV_PTA_init);
    1174:	0000002c 	andeq	r0, r0, ip, lsr #32
    1178:	08012302 	stmdaeq	r1, {r1, r8, r9, sp}
    117c:	03003143 	movweq	r3, #323	; 0x143
    1180:	002c43b9 			; <UNDEFINED> instruction: 0x002c43b9
}
    1184:	23020000 	movwcs	r0, #8192	; 0x2000
 *  @param      srclen          二值化图像的占用空间大小
 *  @since      v5.0            img_extract(img, imgbuff,CAMERA_SIZE);
 *  Sample usage:   sendimg(imgbuff, CAMERA_W * CAMERA_H);                    //发送到上位机
 */
void Ov7725_img_extract(uint8 *dst, uint8 *src, uint32 srclen)
{
    1188:	32430802 	subcc	r0, r3, #131072	; 0x20000
    118c:	43ba0300 			; <UNDEFINED> instruction: 0x43ba0300
    1190:	0000002c 	andeq	r0, r0, ip, lsr #32
    uint8 colour[2] = {255, 0}; //0 和 1 分别对应的颜色
    1194:	08032302 	stmdaeq	r3, {r1, r8, r9, sp}
    1198:	03003153 	movweq	r3, #339	; 0x153
    119c:	002c43bb 			; <UNDEFINED> instruction: 0x002c43bb
    //注：野火的摄像头 1(or255)表示 白色，0表示 黑色
    uint8 tmpsrc;
    while(srclen --)
    11a0:	23020000 	movwcs	r0, #8192	; 0x2000
    {
        tmpsrc = *src++;
    11a4:	32530804 	subscc	r0, r3, #262144	; 0x40000
    11a8:	43bc0300 			; <UNDEFINED> instruction: 0x43bc0300
    11ac:	0000002c 	andeq	r0, r0, ip, lsr #32
        *dst++ = colour[(tmpsrc >> 7) & 0x01];
    11b0:	08052302 	stmdaeq	r5, {r1, r8, r9, sp}
    11b4:	03003343 	movweq	r3, #835	; 0x343
    11b8:	002c43bd 			; <UNDEFINED> instruction: 0x002c43bd
    11bc:	23020000 	movwcs	r0, #8192	; 0x2000
    11c0:	00440806 	subeq	r0, r4, r6, lsl #16
    11c4:	2c43be03 	mcrrcs	14, 0, fp, r3, cr3
    11c8:	02000000 	andeq	r0, r0, #0
    11cc:	4d080723 	stcmi	7, cr0, [r8, #-140]	; 0xffffff74
    11d0:	03003141 	movweq	r3, #321	; 0x141
        *dst++ = colour[(tmpsrc >> 6) & 0x01];
    11d4:	002c43bf 			; <UNDEFINED> instruction: 0x002c43bf
    11d8:	23020000 	movwcs	r0, #8192	; 0x2000
    11dc:	414d0808 	cmpmi	sp, r8, lsl #16
    11e0:	c0030032 	andgt	r0, r3, r2, lsr r0
    11e4:	00002c43 	andeq	r2, r0, r3, asr #24
    11e8:	09230200 	stmdbeq	r3!, {r9}
    11ec:	00344308 	eorseq	r4, r4, r8, lsl #6
    11f0:	2c43c103 	stfcsp	f4, [r3], {3}
        *dst++ = colour[(tmpsrc >> 5) & 0x01];
    11f4:	02000000 	andeq	r0, r0, #0
    11f8:	43080a23 	movwmi	r0, #35363	; 0x8a23
    11fc:	c2030035 	andgt	r0, r3, #53	; 0x35
    1200:	00002c43 	andeq	r2, r0, r3, asr #24
    1204:	0b230200 	bleq	8c1a0c <__etext+0x8b8d64>
    1208:	00444508 	subeq	r4, r4, r8, lsl #10
    120c:	2c43c303 	mcrrcs	3, 0, ip, r3, cr3
    1210:	02000000 	andeq	r0, r0, #0
    1214:	57090c23 	strpl	r0, [r9, -r3, lsr #24]
        *dst++ = colour[(tmpsrc >> 4) & 0x01];
    1218:	0300000c 	movweq	r0, #12
    121c:	002c43c4 	eoreq	r4, ip, r4, asr #7
    1220:	23020000 	movwcs	r0, #8192	; 0x2000
    1224:	5249080d 	subpl	r0, r9, #851968	; 0xd0000
    1228:	43c50300 	bicmi	r0, r5, #0
    122c:	0000002c 	andeq	r0, r0, ip, lsr #32
    1230:	090e2302 	stmdbeq	lr, {r1, r8, r9, sp}
    1234:	00000312 	andeq	r0, r0, r2, lsl r3
        *dst++ = colour[(tmpsrc >> 3) & 0x01];
    1238:	c643c603 	strbgt	ip, [r3], -r3, lsl #12
    123c:	02000001 	andeq	r0, r0, #1
    1240:	b5090f23 	strlt	r0, [r9, #-3875]	; 0xf23
    1244:	0300000b 	movweq	r0, #11
    1248:	002c43c7 	eoreq	r4, ip, r7, asr #7
    124c:	23020000 	movwcs	r0, #8192	; 0x2000
    1250:	0f980910 	svceq	0x00980910
    1254:	c8030000 	stmdagt	r3, {}	; <UNPREDICTABLE>
    1258:	00002c43 	andeq	r2, r0, r3, asr #24
        *dst++ = colour[(tmpsrc >> 2) & 0x01];
    125c:	11230200 	teqne	r3, r0, lsl #4
    1260:	000b7709 	andeq	r7, fp, r9, lsl #14
    1264:	43c90300 	bicmi	r0, r9, #0
    1268:	0000002c 	andeq	r0, r0, ip, lsr #32
    126c:	09122302 	ldmdbeq	r2, {r1, r8, r9, sp}
    1270:	00000ba8 	andeq	r0, r0, r8, lsr #23
    1274:	2c43ca03 	mcrrcs	10, 0, ip, r3, cr3
    1278:	02000000 	andeq	r0, r0, #0
        *dst++ = colour[(tmpsrc >> 1) & 0x01];
    127c:	9b091323 	blls	245f10 <__etext+0x23d268>
    1280:	0300000b 	movweq	r0, #11
    1284:	002c43cb 	eoreq	r4, ip, fp, asr #7
    1288:	23020000 	movwcs	r0, #8192	; 0x2000
    128c:	0fb30914 	svceq	0x00b30914
    1290:	cc030000 	stcgt	0, cr0, [r3], {-0}
    1294:	00002c43 	andeq	r2, r0, r3, asr #24
    1298:	15230200 	strne	r0, [r3, #-512]!	; 0x200
    129c:	000f9709 	andeq	r9, pc, r9, lsl #14
        *dst++ = colour[(tmpsrc >> 0) & 0x01];
    12a0:	43cd0300 	bicmi	r0, sp, #0
    12a4:	0000002c 	andeq	r0, r0, ip, lsr #32
    12a8:	09162302 	ldmdbeq	r6, {r1, r8, r9, sp}
    12ac:	0000031d 	andeq	r0, r0, sp, lsl r3
    12b0:	c643ce03 	strbgt	ip, [r3], -r3, lsl #28
    12b4:	02000001 	andeq	r0, r0, #1
    12b8:	c8091723 	stmdagt	r9, {r0, r1, r5, r8, r9, sl, ip}
void Ov7725_img_extract(uint8 *dst, uint8 *src, uint32 srclen)
{
    uint8 colour[2] = {255, 0}; //0 和 1 分别对应的颜色
    //注：野火的摄像头 1(or255)表示 白色，0表示 黑色
    uint8 tmpsrc;
    while(srclen --)
    12bc:	0300000f 	movweq	r0, #15
    12c0:	002c43cf 	eoreq	r4, ip, pc, asr #7
    12c4:	23020000 	movwcs	r0, #8192	; 0x2000
    12c8:	0c5d0918 	mrrceq	9, 1, r0, sp, cr8
    12cc:	d0030000 	andle	r0, r3, r0
    12d0:	00002c43 	andeq	r2, r0, r3, asr #24
        *dst++ = colour[(tmpsrc >> 3) & 0x01];
        *dst++ = colour[(tmpsrc >> 2) & 0x01];
        *dst++ = colour[(tmpsrc >> 1) & 0x01];
        *dst++ = colour[(tmpsrc >> 0) & 0x01];
    }
}
    12d4:	19230200 	stmdbne	r3!, {r9}
    12d8:	0010a909 	andseq	sl, r0, r9, lsl #18
    12dc:	43d10300 	bicsmi	r0, r1, #0
 *  @note       不同的上位机，不同的命令，这里使用 eSmartCameraCar软件，
                如果使用其他上位机，则需要修改代码。
 *  Sample usage:   sendimg(imgbuff, CAMERA_W * CAMERA_H);                    //发送到上位机
 */
void Ov7725_sendimg(uint8 *imgaddr, uint32 imgsize)
{
    12e0:	0000002c 	andeq	r0, r0, ip, lsr #32
    12e4:	111a2302 	tstne	sl, r2, lsl #6
    12e8:	00000545 	andeq	r0, r0, r5, asr #10
    uint8 cmd[4] = {0, 255, 1, 0 };    //yy_摄像头串口调试 使用的命令
    12ec:	091b2302 	ldmdbeq	fp, {r1, r8, r9, sp}
    12f0:	00000c32 	andeq	r0, r0, r2, lsr ip
    12f4:	2c43d603 	mcrrcs	6, 0, sp, r3, cr3
    12f8:	02000000 	andeq	r0, r0, #0
    
    LPLD_UART_PutCharArr(TERM_PORT, (char *)cmd, sizeof(cmd));
    12fc:	52091c23 	andpl	r1, r9, #8960	; 0x2300
    1300:	0300000b 	movweq	r0, #11
    1304:	002c43d7 	ldrdeq	r4, [ip], -r7	; <UNPREDICTABLE>
    1308:	23020000 	movwcs	r0, #8192	; 0x2000
    130c:	0be8091d 	bleq	ffa03788 <__StackLimit+0xdfa03788>
    LPLD_UART_PutCharArr(TERM_PORT, (char *)imgaddr, imgsize);
    1310:	d8030000 	stmdale	r3, {}	; <UNPREDICTABLE>
    1314:	00002c43 	andeq	r2, r0, r3, asr #24
    1318:	1e230200 	cdpne	2, 2, cr0, cr3, cr0, {0}
    131c:	000bd509 	andeq	sp, fp, r9, lsl #10
    1320:	43d90300 	bicsmi	r0, r9, #0

    //uart_putbuff(FIRE_PORT, cmd, sizeof(cmd));    //先发送命令

    //uart_putbuff(FIRE_PORT, imgaddr, imgsize); //再发送图像
}
    1324:	0000002c 	andeq	r0, r0, ip, lsr #32
    1328:	091f2302 	ldmdbeq	pc, {r1, r8, r9, sp}	; <UNPREDICTABLE>

//OV7725GPIO口初始化
void Ov7725_Gpio_Init(void)
{
    132c:	00000a9a 	muleq	r0, sl, sl
    1330:	c643da03 	strbgt	sp, [r3], -r3, lsl #20
    //OV数据口初始化 B0～B7
    OV_PTB_init.GPIO_PTx = PTB;
    1334:	02000001 	andeq	r0, r0, #1
    1338:	43082023 	movwmi	r2, #32803	; 0x8023
    133c:	db030036 	blle	c141c <__etext+0xb8774>
    1340:	00002c43 	andeq	r2, r0, r3, asr #24
    OV_PTB_init.GPIO_Dir = DIR_INPUT;
    1344:	21230200 	teqcs	r3, r0, lsl #4
    1348:	000f2409 	andeq	r2, pc, r9, lsl #8
    134c:	43dc0300 	bicsmi	r0, ip, #0
    1350:	0000002c 	andeq	r0, r0, ip, lsr #32
    OV_PTB_init.GPIO_Pins = GPIO_Pin0_7;
    1354:	09222302 	stmdbeq	r2!, {r1, r8, r9, sp}
    1358:	00001027 	andeq	r1, r0, r7, lsr #32
    135c:	2c43dd03 	mcrrcs	13, 0, sp, r3, cr3
    //禁止中断和DMA请求 禁用PULL 输入源下拉
    OV_PTB_init.GPIO_PinControl = IRQC_DIS |
    1360:	02000000 	andeq	r0, r0, #0
    1364:	42082323 	andmi	r2, r8, #-1946157056	; 0x8c000000
    1368:	03005431 	movweq	r5, #1073	; 0x431
    136c:	002c43de 	ldrdeq	r4, [ip], -lr	; <UNPREDICTABLE>
                                  INPUT_PULL_DIS|
                                  INPUT_PULL_DOWN;
    LPLD_GPIO_Init (OV_PTB_init);
    1370:	23020000 	movwcs	r0, #8192	; 0x2000
    1374:	0b3a0924 	bleq	e8380c <__etext+0xe7ab64>
    1378:	df030000 	svcle	0x00030000
    137c:	00002c43 	andeq	r2, r0, r3, asr #24

    //OV场信号接口初始化 A29 
    OV_PTA_init.GPIO_PTx = PTA;
    1380:	25230200 	strcs	r0, [r3, #-512]!	; 0x200
    1384:	000b3f09 	andeq	r3, fp, r9, lsl #30
    1388:	43e00300 	mvnmi	r0, #0
    138c:	0000002c 	andeq	r0, r0, ip, lsr #32
    1390:	08262302 	stmdaeq	r6!, {r1, r8, r9, sp}
    OV_PTA_init.GPIO_Dir = DIR_INPUT;
    1394:	00455250 	subeq	r5, r5, r0, asr r2
    1398:	2c43e103 	stfcsp	f6, [r3], {3}
    139c:	02000000 	andeq	r0, r0, #0
    OV_PTA_init.GPIO_Pins = GPIO_Pin29;
    13a0:	54082723 	strpl	r2, [r8], #-1827	; 0x723
    13a4:	03004c50 	movweq	r4, #3152	; 0xc50
    13a8:	002c43e2 	eoreq	r4, ip, r2, ror #7
    13ac:	23020000 	movwcs	r0, #8192	; 0x2000
    //场中断IO设置，上升沿触发IR，输入上拉，使能滤波
    OV_PTA_init.GPIO_PinControl = IRQC_RI |
    13b0:	45490828 	strbmi	r0, [r9, #-2088]	; 0x828
    13b4:	43e30300 	mvnmi	r0, #0
    13b8:	0000002c 	andeq	r0, r0, ip, lsr #32
    13bc:	08292302 	stmdaeq	r9!, {r1, r8, r9, sp}
                                    INPUT_PULL_UP|
                                    INPUT_PF_EN;
    OV_PTA_init.GPIO_Isr = Ov7725_isr;
    13c0:	03004257 	movweq	r4, #599	; 0x257
    13c4:	002c43e4 	eoreq	r4, ip, r4, ror #7
    13c8:	23020000 	movwcs	r0, #8192	; 0x2000
    13cc:	3353082a 	cmpcc	r3, #2752512	; 0x2a0000
    13d0:	43e50300 	mvnmi	r0, #0
    LPLD_GPIO_Init (OV_PTA_init);
    13d4:	0000002c 	andeq	r0, r0, ip, lsr #32
    13d8:	082b2302 	stmdaeq	fp!, {r1, r8, r9, sp}
    13dc:	03003453 	movweq	r3, #1107	; 0x453
    13e0:	002c43e6 	eoreq	r4, ip, r6, ror #7

    //OV PCLK信号接口初始化: PTA27-PCLK 
    OV_PTD_init.GPIO_PTx = PTA;
    13e4:	23020000 	movwcs	r0, #8192	; 0x2000
    13e8:	5052082c 	subspl	r0, r2, ip, lsr #16
    13ec:	e703004c 	str	r0, [r3, -ip, asr #32]
    13f0:	00002c43 	andeq	r2, r0, r3, asr #24
    13f4:	2d230200 	sfmcs	f0, 4, [r3, #-0]
    OV_PTD_init.GPIO_Pins = GPIO_Pin27;
    13f8:	000f1e09 	andeq	r1, pc, r9, lsl #28
    13fc:	43e80300 	mvnmi	r0, #0
    1400:	0000002c 	andeq	r0, r0, ip, lsr #32
    OV_PTD_init.GPIO_Dir = DIR_INPUT;
    1404:	082e2302 	stmdaeq	lr!, {r1, r8, r9, sp}
    1408:	00575043 	subseq	r5, r7, r3, asr #32
    140c:	2c43e903 	mcrrcs	9, 0, lr, r3, cr3
    1410:	02000000 	andeq	r0, r0, #0
    //PCLK信号，下降沿触发DMA，输入上拉
    OV_PTD_init.GPIO_PinControl = IRQC_DMAFA | INPUT_PULL_UP;
    1414:	07092f23 	streq	r2, [r9, -r3, lsr #30]
    1418:	03000010 	movweq	r0, #16
    141c:	002c43ea 	eoreq	r4, ip, sl, ror #7
    1420:	23020000 	movwcs	r0, #8192	; 0x2000
    LPLD_GPIO_Init (OV_PTD_init);
    1424:	0e040930 	mcreq	9, 0, r0, cr4, cr0, {1}
    1428:	eb030000 	bl	c1430 <__etext+0xb8788>
    142c:	00002c43 	andeq	r2, r0, r3, asr #24
    1430:	31230200 	teqcc	r3, r0, lsl #4
    1434:	0c030a00 	stceq	10, cr0, [r3], {-0}

}
    1438:	ec030000 	stc	0, cr0, [r3], {-0}
 
//OV7725 DMA初始化 
void Ov7725_Dma_Init (void)
{
    143c:	00085843 	andeq	r5, r8, r3, asr #16
    1440:	5e040b00 	vmlapl.f64	d0, d4, d0
    OV_dma_init.DMA_CHx = DMA_CH0;
    1444:	0c000008 	stceq	0, cr0, [r0], {8}
    1448:	00000567 	andeq	r0, r0, r7, ror #10
    144c:	001d7b03 	andseq	r7, sp, r3, lsl #22
    OV_dma_init.DMA_Req = PORTA_DMAREQ;
    1450:	5e1d0400 	cfmulspl	mvf0, mvf13, mvf0
    1454:	02000000 	andeq	r0, r0, #0
    1458:	06690404 	strbteq	r0, [r9], -r4, lsl #8
    145c:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
    OV_dma_init.DMA_MajorLoopCnt = PHOTO_SIZE / 8;
    1460:	000a8704 	andeq	r8, sl, r4, lsl #14
    1464:	0dc80300 	stcleq	3, cr0, [r8]
    1468:	2e040000 	cdpcs	0, 0, cr0, cr4, cr0, {0}
    OV_dma_init.DMA_MinorByteCnt = 1;
    146c:	00000037 	andeq	r0, r0, r7, lsr r0
    1470:	000f3512 	andeq	r3, pc, r2, lsl r5	; <UNPREDICTABLE>
    1474:	0f050100 	svceq	0x00050100
    1478:	00000b1e 	andeq	r0, r0, lr, lsl fp
    
    OV_dma_init.DMA_SourceAddr = (uint32)(&GPIOB_PDIR);
    147c:	000cc213 	andeq	ip, ip, r3, lsl r2
    1480:	c7130000 	ldrgt	r0, [r3, -r0]
    1484:	0100000c 	tsteq	r0, ip
    1488:	000ccc13 	andeq	ip, ip, r3, lsl ip
    OV_dma_init.DMA_DestAddr = (uint32)img;
    148c:	d1130200 	tstle	r3, r0, lsl #4
    1490:	0300000c 	movweq	r0, #12
    1494:	000cd613 	andeq	sp, ip, r3, lsl r6
    1498:	db130400 	blle	4c24a0 <__etext+0x4b97f8>
    149c:	0500000c 	streq	r0, [r0, #-12]
    OV_dma_init.DMA_DestAddrOffset = 1;
    14a0:	000ce013 	andeq	lr, ip, r3, lsl r0
    14a4:	e5130600 	ldr	r0, [r3, #-1536]	; 0x600
    14a8:	0700000c 	streq	r0, [r0, -ip]
    OV_dma_init.DMA_Isr = Ov7725_eagle_dma;
    14ac:	000cea13 	andeq	lr, ip, r3, lsl sl
    14b0:	ef130800 	svc	0x00130800
    14b4:	0900000c 	stmdbeq	r0, {r2, r3}
    14b8:	000e5f13 	andeq	r5, lr, r3, lsl pc
    14bc:	65130a00 	ldrvs	r0, [r3, #-2560]	; 0xa00
    LPLD_DMA_Init (OV_dma_init);
    14c0:	0b00000e 	bleq	1500 <Ov7725_Dma_Init+0xc4>
    14c4:	000e6b13 	andeq	r6, lr, r3, lsl fp
    14c8:	71130c00 	tstvc	r3, r0, lsl #24
    14cc:	0d00000e 	stceq	0, cr0, [r0, #-56]	; 0xffffffc8
    14d0:	000e7713 	andeq	r7, lr, r3, lsl r7
    14d4:	7d130e00 	ldcvc	14, cr0, [r3, #-0]
    14d8:	0f00000e 	svceq	0x0000000e
    14dc:	000e8313 	andeq	r8, lr, r3, lsl r3

    LPLD_DMA_DisableReq(DMA_CH0);
    14e0:	89131000 	ldmdbhi	r3, {ip}
    14e4:	1100000e 	tstne	r0, lr
    14e8:	000e8f13 	andeq	r8, lr, r3, lsl pc
    14ec:	7d131200 	lfmvc	f1, 4, [r3, #-0]
    14f0:	1300000b 	movwne	r0, #11
    14f4:	000efa13 	andeq	pc, lr, r3, lsl sl	; <UNPREDICTABLE>
    //disable_irq (INT_PORTA - 16);
    LPLD_GPIO_EnableIrq (OV_PTA_init);
    14f8:	00131800 	andseq	r1, r3, r0, lsl #16
    14fc:	1900000f 	stmdbne	r0, {r0, r1, r2, r3}
    1500:	000f0613 	andeq	r0, pc, r3, lsl r6	; <UNPREDICTABLE>
    1504:	0c131a00 	ldceq	10, cr1, [r3], {-0}
    1508:	1b00000f 	blne	154c <Ov7725_isr>
    DMA0->INT |= 0x1u <<0;
    150c:	000f1213 	andeq	r1, pc, r3, lsl r2	; <UNPREDICTABLE>
    1510:	18131c00 	ldmdane	r3, {sl, fp, ip}
    1514:	1d00000f 	stcne	0, cr0, [r0, #-60]	; 0xffffffc4
    1518:	000d5913 	andeq	r5, sp, r3, lsl r9
    151c:	5e132000 	cdppl	0, 1, cr2, cr3, cr0, {0}
    1520:	2100000d 	tstcs	r0, sp
    //允许DMA通道传输完成中断
    //enable_irq (DMA_CH0);
    LPLD_DMA_EnableIrq (OV_dma_init);
    1524:	000d6313 	andeq	r6, sp, r3, lsl r3
    1528:	68132200 	ldmdavs	r3, {r9, sp}
    152c:	2300000d 	movwcs	r0, #13
    1530:	000d6d13 	andeq	r6, sp, r3, lsl sp
    1534:	72132400 	andsvc	r2, r3, #0
    1538:	2500000d 	strcs	r0, [r0, #-13]
    153c:	000d7713 	andeq	r7, sp, r3, lsl r7
    1540:	7c132600 	ldcvc	6, cr2, [r3], {-0}
    //使能通道x的DMA请求
    //LPLD_DMA_EnableReq(DMA_CH0);
}
    1544:	2700000d 	strcs	r0, [r0, -sp]
    1548:	000d8113 	andeq	r8, sp, r3, lsl r1

//ov7725中断
void Ov7725_isr (void)
{
    154c:	86132800 	ldrhi	r2, [r3], -r0, lsl #16
    1550:	2900000d 	stmdbcs	r0, {r0, r2, r3}
    uint8 n = 0;
    1554:	0010bb13 	andseq	fp, r0, r3, lsl fp
    while (!PORTA_ISFR);
    1558:	c1132a00 	tstgt	r3, r0, lsl #20
    155c:	2b000010 	blcs	15a4 <Ov7725_isr+0x58>
    1560:	0010c713 	andseq	ip, r0, r3, lsl r7
    1564:	cd133000 	ldcgt	0, cr3, [r3, #-0]
    1568:	31000010 	tstcc	r0, r0, lsl r0
    uint32 flag = (PORTA->ISFR);
    156c:	0010d313 	andseq	sp, r0, r3, lsl r3
    1570:	d9133200 	ldmdble	r3, {r9, ip, sp}
    1574:	33000010 	movwcc	r0, #16
    (PORTA -> ISFR) = ~0;
    1578:	000b8313 	andeq	r8, fp, r3, lsl r3
    157c:	89133400 	ldmdbhi	r3, {sl, ip, sp}
    1580:	3500000b 	strcc	r0, [r0, #-11]
    1584:	000b8f13 	andeq	r8, fp, r3, lsl pc
   
    n = 29;
    1588:	95133600 	ldrls	r3, [r3, #-1536]	; 0x600
    158c:	3700000b 	strcc	r0, [r0, -fp]
    //printf ("flag = %x\n", flag);
    if (flag & (1<<n))
    1590:	000dd013 	andeq	sp, sp, r3, lsl r0
    1594:	d5133c00 	ldrle	r3, [r3, #-3072]	; 0xc00
    1598:	3d00000d 	stccc	0, cr0, [r0, #-52]	; 0xffffffcc
    159c:	000dda13 	andeq	sp, sp, r3, lsl sl
    15a0:	df133e00 	svcle	0x00133e00
    {
        //场中断开始 
        //set 場中断
        ov7725_eagle_img_flag = IMG_START;
    15a4:	3f00000d 	svccc	0x0000000d
    15a8:	000de413 	andeq	lr, sp, r3, lsl r4
    15ac:	1300c000 	movwne	ip, #0
        //关闭PORTA中断
        disable_irq (INT_PORTA - 16);
    15b0:	00000de9 	andeq	r0, r0, r9, ror #27
    15b4:	ee1300c1 	cdp	0, 1, cr0, cr3, cr1, {6}
        //LPLD_GPIO_DisableIrq(OV_PTA_init);
        //enable_irq (DMA_CH0 + INT_DMA0_DMA16 - 16);
        //重新装载DMA目标地址
        //DMA_DADDR(DMA_CH0) = (uint32)img;
        //开启DMA通道
        DMA_EN(DMA_CH0);
    15b8:	c200000d 	andgt	r0, r0, #13
    15bc:	0df31300 	ldcleq	3, cr1, [r3]
    15c0:	00c30000 	sbceq	r0, r3, r0
    15c4:	000e5a13 	andeq	r5, lr, r3, lsl sl
    15c8:	1300c400 	movwne	ip, #1024	; 0x400
    15cc:	00000df8 	strdeq	r0, [r0], -r8
        //LPLD_DMA_EnableIrq(OV_dma_init);
    }
}
    15d0:	0b1300c5 	bleq	4c18ec <__etext+0x4b8c44>
    15d4:	c600000d 	strgt	r0, [r0], -sp

//移植野火的函数
void dma_portx2buff_init(uint8 CHn, void *SADDR, void *DADDR, uint8 dma_req, DMA_BYTEn byten, uint32 count, uint32 cfg)
{
    15d8:	0d111300 	ldceq	3, cr1, [r1, #-0]
    15dc:	00c70000 	sbceq	r0, r7, r0
    15e0:	000d1713 	andeq	r1, sp, r3, lsl r7
    15e4:	1300c800 	movwne	ip, #2048	; 0x800
    uint8 BYTEs = (byten == DMA_BYTE1 ? 1 : (byten == DMA_BYTE2 ? 2 : (byten == DMA_BYTE4 ? 4 : 16)));
    15e8:	00000d1d 	andeq	r0, r0, sp, lsl sp
    15ec:	e91300c9 	ldmdb	r3, {r0, r3, r6, r7}
    15f0:	ca00000e 	bgt	1630 <dma_portx2buff_init+0x58>
    15f4:	0eef1300 	cdpeq	3, 14, cr1, cr15, cr0, {0}
    15f8:	00cb0000 	sbceq	r0, fp, r0
    15fc:	000d4113 	andeq	r4, sp, r3, lsl r1
    1600:	1300cc00 	movwne	ip, #3072	; 0xc00
    1604:	00000d47 	andeq	r0, r0, r7, asr #26
    1608:	4d1300cd 	ldcmi	0, cr0, [r3, #-820]	; 0xfffffccc
    160c:	ce00000d 	cdpgt	0, 0, cr0, cr0, cr13, {0}
    1610:	0d531300 	ldcleq	3, cr1, [r3, #-0]
    1614:	00cf0000 	sbceq	r0, pc, r0
    
    SIM_SCGC7 |= SIM_SCGC7_DMA_MASK;
    1618:	000e1513 	andeq	r1, lr, r3, lsl r5
    161c:	1300dc00 	movwne	sp, #3072	; 0xc00
    1620:	00000e1a 	andeq	r0, r0, sl, lsl lr
    1624:	1f1300dd 	svcne	0x001300dd
    1628:	de00000e 	cdple	0, 0, cr0, cr0, cr14, {0}
    162c:	0e241300 	cdpeq	3, 2, cr1, cr4, cr0, {0}
    1630:	00df0000 	sbcseq	r0, pc, r0
    1634:	000e2913 	andeq	r2, lr, r3, lsl r9
    SIM_SCGC6 |= SIM_SCGC6_DMAMUX0_MASK;
    1638:	1300e000 	movwne	lr, #0
    163c:	00000e2e 	andeq	r0, r0, lr, lsr #28
    1640:	331300e1 	tstcc	r3, #225	; 0xe1
    1644:	e200000e 	and	r0, r0, #14
    1648:	0e381300 	cdpeq	3, 3, cr1, cr8, cr0, {0}
    164c:	00e30000 	rsceq	r0, r3, r0
    1650:	000e3d13 	andeq	r3, lr, r3, lsl sp
    1654:	1300e400 	movwne	lr, #1024	; 0x400
    1658:	00000e42 	andeq	r0, r0, r2, asr #28
    165c:	7f1300e5 	svcvc	0x001300e5

    DMA_SADDR(CHn) = (uint32) SADDR;
    1660:	e600000f 	str	r0, [r0], -pc
    1664:	0f851300 	svceq	0x00851300
    1668:	00e70000 	rsceq	r0, r7, r0
    166c:	000f8b13 	andeq	r8, pc, r3, lsl fp	; <UNPREDICTABLE>
    1670:	1300e800 	movwne	lr, #2048	; 0x800
    1674:	00000f91 	muleq	r0, r1, pc	; <UNPREDICTABLE>
    DMA_DADDR(CHn) = (uint32) DADDR;
    1678:	931300e9 	tstls	r3, #233	; 0xe9
    167c:	ea00000d 	b	16b8 <dma_portx2buff_init+0xe0>
    1680:	0d991300 	ldceq	3, cr1, [r9]
    1684:	00eb0000 	rsceq	r0, fp, r0
    1688:	000ea713 	andeq	sl, lr, r3, lsl r7
    168c:	1300fc00 	movwne	pc, #3072	; 0xc00	; <UNPREDICTABLE>
    1690:	00000eac 	andeq	r0, r0, ip, lsr #29
    DMA_SOFF(CHn) = 0x00u;
    1694:	b11300fd 	ldrshlt	r0, [r3, -sp]
    1698:	fe00000e 	cdp2	0, 0, cr0, cr0, cr14, {0}
    169c:	0eb61300 	cdpeq	3, 11, cr1, cr6, cr0, {0}
    16a0:	00ff0000 	rscseq	r0, pc, r0
    16a4:	000ebb13 	andeq	fp, lr, r3, lsl fp
    16a8:	13018000 	movwne	r8, #4096	; 0x1000
    16ac:	00000ec0 	andeq	r0, r0, r0, asr #29
    DMA_DOFF(CHn) = BYTEs;
    16b0:	c5130181 	ldrgt	r0, [r3, #-385]	; 0x181
    16b4:	8200000e 	andhi	r0, r0, #14
    16b8:	0eca1301 	cdpeq	3, 12, cr1, cr10, cr1, {0}
    16bc:	01830000 	orreq	r0, r3, r0
    16c0:	000ecf13 	andeq	ip, lr, r3, lsl pc
    16c4:	13018400 	movwne	r8, #5120	; 0x1400
    16c8:	00000ed4 	ldrdeq	r0, [r0], -r4
    DMA_ATTR(CHn) = (0
    16cc:	dc130185 	ldfles	f0, [r3], {133}	; 0x85
    16d0:	8600000b 	strhi	r0, [r0], -fp
    16d4:	0be21301 	bleq	ff8862e0 <__StackLimit+0xdf8862e0>
                     |DMA_ATTR_SMOD(0x0)
                     |DMA_ATTR_SSIZE(byten)
    16d8:	01870000 	orreq	r0, r7, r0
    16dc:	000c3913 	andeq	r3, ip, r3, lsl r9
    16e0:	13018800 	movwne	r8, #6144	; 0x1800

    DMA_SADDR(CHn) = (uint32) SADDR;
    DMA_DADDR(CHn) = (uint32) DADDR;
    DMA_SOFF(CHn) = 0x00u;
    DMA_DOFF(CHn) = BYTEs;
    DMA_ATTR(CHn) = (0
    16e4:	00000cfc 	strdeq	r0, [r0], -ip
    16e8:	3f130194 	svccc	0x00130194
    16ec:	9500000c 	strls	r0, [r0, #-12]
    16f0:	0c451301 	mcrreq	3, 0, r1, r5, cr1
    16f4:	01960000 	orrseq	r0, r6, r0
    16f8:	000c4b13 	andeq	r4, ip, r3, lsl fp
    16fc:	13019700 	movwne	r9, #5888	; 0x1700
    1700:	00000c51 	andeq	r0, r0, r1, asr ip
                     |DMA_ATTR_SMOD(0x0)
                     |DMA_ATTR_SSIZE(byten)
                     |DMA_ATTR_DMOD(0x0)
                     |DMA_ATTR_DSIZE(byten)
                    );
    DMA_CITER_ELINKNO(CHn) = DMA_CITER_ELINKNO_CITER(count);
    1704:	03000198 	movweq	r0, #408	; 0x198
    1708:	00001067 	andeq	r1, r0, r7, rrx
    170c:	08874505 	stmeq	r7, {r0, r2, r8, sl, lr}
    1710:	040b0000 	streq	r0, [fp], #-0
    1714:	00000b2f 	andeq	r0, r0, pc, lsr #22
    1718:	a5120114 	ldrge	r0, [r2, #-276]	; 0x114
    171c:	0100000f 	tsteq	r0, pc
    1720:	0b740d06 	bleq	1d04b40 <__etext+0x1cfbe98>
    1724:	aa130000 	bge	4c172c <__etext+0x4b8a84>
    1728:	3000000d 	andcc	r0, r0, sp
    DMA_BITER_ELINKNO(CHn) = DMA_BITER_ELINKNO_BITER(count);
    172c:	000dfd13 	andeq	pc, sp, r3, lsl sp	; <UNPREDICTABLE>
    1730:	9e133200 	cdpls	2, 1, cr3, cr3, cr0, {0}
    1734:	e000000f 	and	r0, r0, pc
    1738:	0b6f1300 	bleq	1bc6340 <__etext+0x1bbd698>
    173c:	00e40000 	rsceq	r0, r4, r0
    1740:	000bef13 	andeq	lr, fp, r3, lsl pc
    1744:	1300f800 	movwne	pc, #2048	; 0x800	; <UNPREDICTABLE>
    1748:	00000cf4 	strdeq	r0, [r0], -r4
    174c:	52130196 	andspl	r0, r3, #-2147483611	; 0x80000025
    1750:	b400000e 	strlt	r0, [r0], #-14

    DMA_CR &= ~DMA_CR_EMLM_MASK;
    1754:	0d8b1301 	stceq	3, cr1, [fp, #4]
    1758:	01c80000 	biceq	r0, r8, r0
    175c:	08010200 	stmdaeq	r1, {r9}
    1760:	00000712 	andeq	r0, r0, r2, lsl r7
    1764:	000ca403 	andeq	sl, ip, r3, lsl #8
    1768:	29150700 	ldmdbcs	r5, {r8, r9, sl}

    DMA_NBYTES_MLNO(CHn) = DMA_NBYTES_MLNO_NBYTES(BYTEs);
    176c:	1500000b 	strne	r0, [r0, #-11]
    1770:	ff180714 			; <UNDEFINED> instruction: 0xff180714
    1774:	1600000b 	strne	r0, [r0], -fp
    1778:	00000db1 			; <UNDEFINED> instruction: 0x00000db1
    177c:	084c2207 	stmdaeq	ip, {r0, r1, r2, r9, sp}^
    1780:	23020000 	movwcs	r0, #8192	; 0x2000
    1784:	0f551600 	svceq	0x00551600

    DMA_SLAST(CHn) = 0;
    1788:	2c070000 	stccs	0, cr0, [r7], {-0}
    178c:	00000863 	andeq	r0, r0, r3, ror #16
    1790:	16042302 	strne	r2, [r4], -r2, lsl #6
    1794:	0000100c 	andeq	r1, r0, ip
    1798:	0b1e3b07 	bleq	7903bc <__etext+0x787714>
    179c:	23020000 	movwcs	r0, #8192	; 0x2000
    17a0:	0e471608 	cdpeq	6, 4, cr1, cr7, cr8, {0}
    17a4:	4a070000 	bmi	1c17ac <__etext+0x1b8b04>
    DMA_DLAST_SGA(CHn) = (uint32)((cfg & DADDR_KEEPON) == 0 ? (-count) : 0);
    17a8:	00000b1e 	andeq	r0, r0, lr, lsl fp
    17ac:	16092302 	strne	r2, [r9], -r2, lsl #6
    17b0:	00000fdb 	ldrdeq	r0, [r0], -fp
    17b4:	087c5507 	ldmdaeq	ip!, {r0, r1, r2, r8, sl, ip, lr}^
    17b8:	23020000 	movwcs	r0, #8192	; 0x2000
    17bc:	0f6e160a 	svceq	0x006e160a
    17c0:	60070000 	andvs	r0, r7, r0
    17c4:	0000087c 	andeq	r0, r0, ip, ror r8
    17c8:	160b2302 	strne	r2, [fp], -r2, lsl #6
    17cc:	00000d9f 	muleq	r0, pc, sp	; <UNPREDICTABLE>
    17d0:	0b7b6a07 	bleq	1edbff4 <__etext+0x1ed334c>
    17d4:	23020000 	movwcs	r0, #8192	; 0x2000
    DMA_CSR(CHn) = (0
    17d8:	0f63160c 	svceq	0x0063160c
    17dc:	74070000 	strvc	r0, [r7], #-0
    17e0:	00000b7b 	andeq	r0, r0, fp, ror fp
    17e4:	00102302 	andseq	r2, r0, r2, lsl #6
    17e8:	000c9303 	andeq	r9, ip, r3, lsl #6
    17ec:	86750700 	ldrbthi	r0, [r5], -r0, lsl #14
    17f0:	1700000b 	strne	r0, [r0, -fp]
                    |DMA_CSR_BWC(3)
                    |DMA_CSR_DREQ_MASK
                    |DMA_CSR_INTMAJOR_MASK
                   );

    DMAMUX_CHCFG_REG(DMAMUX0_BASE_PTR, CHn) = (0                
    17f4:	0010b001 	andseq	fp, r0, r1
    17f8:	01290100 	teqeq	r9, r0, lsl #2
    17fc:	000009b8 			; <UNDEFINED> instruction: 0x000009b8
    1800:	00000aac 	andeq	r0, r0, ip, lsr #21
    1804:	000000a8 	andeq	r0, r0, r8, lsr #1
    1808:	59011801 	stmdbpl	r1, {r0, fp, ip}
    180c:	0100000b 	tsteq	r0, fp
    |DMAMUX_CHCFG_ENBL_MASK
    |DMAMUX_CHCFG_SOURCE(dma_req));
    DMA_DIS(CHn);
    1810:	0aac0148 	beq	feb01d38 <__StackLimit+0xdeb01d38>
    1814:	0b100000 	bleq	40181c <__etext+0x3f8b74>
    1818:	00d40000 	sbcseq	r0, r4, r0
    181c:	49010000 	stmdbmi	r1, {}	; <UNPREDICTABLE>
    1820:	1900000c 	stmdbne	r0, {r2, r3}
    1824:	00000f42 	andeq	r0, r0, r2, asr #30
    1828:	00534a01 	subseq	r4, r3, r1, lsl #20
    182c:	91020000 	mrsls	r0, (UNDEF: 2)
    1830:	01180074 	tsteq	r8, r4, ror r0
    DMA_IRQ_CLEAN(CHn);
    1834:	0000101c 	andeq	r1, r0, ip, lsl r0
    1838:	10015401 	andne	r5, r1, r1, lsl #8
    183c:	9600000b 	strls	r0, [r0], -fp
    1840:	0c00000c 	stceq	0, cr0, [r0], {12}
    1844:	01000001 	tsteq	r0, r1
    1848:	00000c80 	andeq	r0, r0, r0, lsl #25
    184c:	7172691a 	cmnvc	r2, sl, lsl r9
    1850:	73540100 	cmpvc	r4, #0
}
    1854:	02000000 	andeq	r0, r0, #0
    1858:	641b6c91 	ldrvs	r6, [fp], #-3217	; 0xc91


//提取中线
void get_midline(uint8 *img, uint8 h, uint8 w)
{
    185c:	01007669 	tsteq	r0, r9, ror #12
    1860:	00007356 	andeq	r7, r0, r6, asr r3
    1864:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    1868:	bc011800 	stclt	8, cr1, [r1], {-0}
    int16 p = 0, i = 0, line_mid = 39;
    186c:	0100000d 	tsteq	r0, sp
    1870:	0c980173 	ldfeqs	f0, [r8], {115}	; 0x73
    1874:	0d8a0000 	stceq	0, cr0, [sl]
    1878:	01440000 	mrseq	r0, (UNDEF: 68)
    187c:	b7010000 	strlt	r0, [r1, -r0]
    int8 side_left = 0, side_right = 79;
    1880:	1a00000c 	bne	18b8 <get_midline+0x5c>
    1884:	00717269 	rsbseq	r7, r1, r9, ror #4
    1888:	00737301 	rsbseq	r7, r3, r1, lsl #6

    if (img[(h-1)*w + line_mid] == 0xff)
    188c:	91020000 	mrsls	r0, (UNDEF: 2)
    1890:	69641b6c 	stmdbvs	r4!, {r2, r3, r5, r6, r8, r9, fp, ip}^
    1894:	75010076 	strvc	r0, [r1, #-118]	; 0x76
    1898:	00000073 	andeq	r0, r0, r3, ror r0
    189c:	00749102 	rsbseq	r9, r4, r2, lsl #2
    18a0:	1099011c 	addsne	r0, r9, ip, lsl r1
    18a4:	8e010000 	cdphi	0, 0, cr0, cr1, cr0, {0}
    {
        for (i = h - 1; i >= 0; i --)
    18a8:	000d8c01 	andeq	r8, sp, r1, lsl #24
    18ac:	000dd000 	andeq	sp, sp, r0
    18b0:	00017c00 	andeq	r7, r1, r0, lsl #24
    18b4:	0ce00100 	stfeqe	f0, [r0]
        {
            for (p = line_mid - 1; p > 0; p --)
    18b8:	79190000 	ldmdbvc	r9, {}	; <UNPREDICTABLE>
    18bc:	01000010 	tsteq	r0, r0, lsl r0
    18c0:	000bff90 	muleq	fp, r0, pc	; <UNPREDICTABLE>
            {
                if (img[i * w + p] == 0)
    18c4:	64910200 	ldrvs	r0, [r1], #512	; 0x200
    18c8:	0ed91d00 	cdpeq	13, 13, cr1, cr9, cr0, {0}
    18cc:	20010000 	andcs	r0, r1, r0
    18d0:	00000053 	andeq	r0, r0, r3, asr r0
    18d4:	00030501 	andeq	r0, r3, r1, lsl #10
    18d8:	1e1fff00 	cdpne	15, 1, cr15, cr15, cr0, {0}
                    if ((img[i * w + p - 1] == 0) 
    18dc:	00000fce 	andeq	r0, r0, lr, asr #31
    18e0:	08631f06 	stmdaeq	r3!, {r1, r2, r8, r9, sl, fp, ip}^
    18e4:	01010000 	mrseq	r0, (UNDEF: 1)
    18e8:	000bf71e 	andeq	pc, fp, lr, lsl r7	; <UNPREDICTABLE>
    18ec:	63200600 	teqvs	r0, #0
    18f0:	01000008 	tsteq	r0, r8
    18f4:	0b441e01 	bleq	1109100 <__etext+0x1100458>
    18f8:	21060000 	mrscs	r0, (UNDEF: 6)
                            && (line_mid-p-1>= 0))
    18fc:	00000863 	andeq	r0, r0, r3, ror #16
    1900:	bb1e0101 	bllt	781d0c <__etext+0x779064>
    1904:	0600000b 	streq	r0, [r0], -fp
    1908:	00086322 	andeq	r6, r8, r2, lsr #6
                    {
                        side_left = p;
    190c:	00010100 	andeq	r0, r1, r0, lsl #2
                        p = p - 2;
    1910:	0000172d 	andeq	r1, r0, sp, lsr #14
    1914:	03960002 	orrseq	r0, r6, #2
    1918:	01040000 	mrseq	r0, (UNDEF: 4)
                        for (; p >= 0; p --)
                            img[i * w + p] = 0;
    191c:	00000234 	andeq	r0, r0, r4, lsr r2
    1920:	0011e401 	andseq	lr, r1, r1, lsl #8
    1924:	00082700 	andeq	r2, r8, r0, lsl #14
    1928:	000dd000 	andeq	sp, sp, r0
    192c:	001a4600 	andseq	r4, sl, r0, lsl #12
    1930:	00034f00 	andeq	r4, r3, r0, lsl #30
    1934:	06010200 	streq	r0, [r1], -r0, lsl #4
                    if ((img[i * w + p - 1] == 0) 
                            && (line_mid-p-1>= 0))
                    {
                        side_left = p;
                        p = p - 2;
                        for (; p >= 0; p --)
    1938:	0000070b 	andeq	r0, r0, fp, lsl #14
    193c:	0009dd03 	andeq	sp, r9, r3, lsl #26
    1940:	372a0200 	strcc	r0, [sl, -r0, lsl #4]!
    1944:	02000000 	andeq	r0, r0, #0

    if (img[(h-1)*w + line_mid] == 0xff)
    {
        for (i = h - 1; i >= 0; i --)
        {
            for (p = line_mid - 1; p > 0; p --)
    1948:	07090801 	streq	r0, [r9, -r1, lsl #16]
    194c:	02020000 	andeq	r0, r2, #0
    1950:	00073b05 	andeq	r3, r7, r5, lsl #22
    1954:	03280300 	teqeq	r8, #0
                        p = p - 2;
                        for (; p >= 0; p --)
                            img[i * w + p] = 0;
                    }
            }
            for (p = line_mid + 1; p < w -1; p ++)
    1958:	36020000 	strcc	r0, [r2], -r0
    195c:	00000050 	andeq	r0, r0, r0, asr r0
    1960:	92070202 	andls	r0, r7, #536870912	; 0x20000000
            {
                if (img[i * w + p] == 0)
    1964:	02000004 	andeq	r0, r0, #4
    1968:	01960504 	orrseq	r0, r6, r4, lsl #10
    196c:	9b030000 	blls	c1974 <__etext+0xb8ccc>
    1970:	02000007 	andeq	r0, r0, #7
    1974:	00006950 	andeq	r6, r0, r0, asr r9
    1978:	07040200 	streq	r0, [r4, -r0, lsl #4]
                {
                    if ((img[i * w + p + 1] == 0)&&(p+1<w))
    197c:	000001e4 	andeq	r0, r0, r4, ror #3
    1980:	91050802 	tstls	r5, r2, lsl #16
    1984:	02000001 	andeq	r0, r0, #1
    1988:	01df0708 	bicseq	r0, pc, r8, lsl #14
    198c:	04040000 	streq	r0, [r4], #-0
    1990:	746e6905 	strbtvc	r6, [lr], #-2309	; 0x905
    1994:	07040200 	streq	r0, [r4, -r0, lsl #4]
    1998:	000001e9 	andeq	r0, r0, r9, ror #3
    199c:	4b030105 	blmi	c1db8 <__etext+0xb9110>
    19a0:	000003ab 	andeq	r0, r0, fp, lsr #7
    19a4:	000aa506 	andeq	sl, sl, r6, lsl #10
                    {
                        side_right = p;
    19a8:	9a060000 	bls	1819b0 <__etext+0x178d08>
                        p = p + 2;
    19ac:	01000006 	tsteq	r0, r6
    19b0:	00020a06 	andeq	r0, r2, r6, lsl #20
    19b4:	00060200 	andeq	r0, r6, r0, lsl #4
                        for (; p < w; p ++)
                            img[i * w + p] = 0;
    19b8:	03000000 	movweq	r0, #0
    19bc:	0000c406 	andeq	ip, r0, r6, lsl #8
    19c0:	bd060400 	cfstrslt	mvf0, [r6, #-0]
    19c4:	05000001 	streq	r0, [r0, #-1]
    19c8:	0008bf06 	andeq	fp, r8, r6, lsl #30
    19cc:	7d060600 	stcvc	6, cr0, [r6, #-0]
    19d0:	07000002 	streq	r0, [r0, -r2]
                {
                    if ((img[i * w + p + 1] == 0)&&(p+1<w))
                    {
                        side_right = p;
                        p = p + 2;
                        for (; p < w; p ++)
    19d4:	00028b06 	andeq	r8, r2, r6, lsl #22
    19d8:	99060800 	stmdbls	r6, {fp}
    19dc:	09000002 	stmdbeq	r0, {r1}
    19e0:	0009a406 	andeq	sl, r9, r6, lsl #8
                        p = p - 2;
                        for (; p >= 0; p --)
                            img[i * w + p] = 0;
                    }
            }
            for (p = line_mid + 1; p < w -1; p ++)
    19e4:	11060a00 	tstne	r6, r0, lsl #20
    19e8:	0b00000a 	bleq	1a18 <get_midline+0x1bc>
    19ec:	00059a06 	andeq	r9, r5, r6, lsl #20
    19f0:	c5060c00 	strgt	r0, [r6, #-3072]	; 0xc00
    19f4:	0d000009 	stceq	0, cr0, [r0, #-36]	; 0xffffffdc
    19f8:	00054b06 	andeq	r4, r5, r6, lsl #22
                        for (; p < w; p ++)
                            img[i * w + p] = 0;
                    }
                }
            }
            line_mid = (side_left + side_right) / 2;
    19fc:	de060e00 	cdple	14, 0, cr0, cr6, cr0, {0}
    1a00:	0f000003 	svceq	0x00000003
    1a04:	00010806 	andeq	r0, r1, r6, lsl #16
    1a08:	8b061000 	blhi	185a10 <__etext+0x17cd68>
    1a0c:	11000006 	tstne	r0, r6
            img[i * w + line_mid] = 0;
    1a10:	00014806 	andeq	r4, r1, r6, lsl #16
    1a14:	f1061200 			; <UNDEFINED> instruction: 0xf1061200
    1a18:	13000006 	movwne	r0, #6
    1a1c:	00037a06 	andeq	r7, r3, r6, lsl #20
    1a20:	18061400 	stmdane	r6, {sl, ip}
    1a24:	15000008 	strne	r0, [r0, #-8]
    1a28:	0003cf06 	andeq	ip, r3, r6, lsl #30
    int16 p = 0, i = 0, line_mid = 39;
    int8 side_left = 0, side_right = 79;

    if (img[(h-1)*w + line_mid] == 0xff)
    {
        for (i = h - 1; i >= 0; i --)
    1a2c:	b0061600 	andlt	r1, r6, r0, lsl #12
    1a30:	17000008 	strne	r0, [r0, -r8]
    1a34:	00042f06 	andeq	r2, r4, r6, lsl #30
    1a38:	39061800 	stmdbcc	r6, {fp, ip}
            }
            line_mid = (side_left + side_right) / 2;
            img[i * w + line_mid] = 0;
        }
    }
}
    1a3c:	19000001 	stmdbne	r0, {r0}
    1a40:	0003bf06 	andeq	fp, r3, r6, lsl #30
    1a44:	98061a00 	stmdals	r6, {r9, fp, ip}
  ptb.GPIO_PinControl = NULL;
  LPLD_GPIO_Init(ptb);
}*/

void LPLD_SCCB_Init(void)
{
    1a48:	1b000008 	blne	1a70 <LPLD_SCCB_Init+0x28>
    1a4c:	00040d06 	andeq	r0, r4, r6, lsl #26
  GPIO_InitTypeDef ptb;
  /********û޸ֵ ʼ***********/
  ptb.GPIO_PTx = PTA;
    1a50:	e8061c00 	stmda	r6, {sl, fp, ip}
    1a54:	1d000008 	stcne	0, cr0, [r0, #-32]	; 0xffffffe0
  ptb.GPIO_Pins = GPIO_Pin25 | GPIO_Pin26;
    1a58:	00051f06 	andeq	r1, r5, r6, lsl #30
    1a5c:	af061e00 	svcge	0x00061e00
  /********û޸ֵ ***********/
  ptb.GPIO_Dir = DIR_OUTPUT;
    1a60:	1f000003 	svcne	0x00000003
  ptb.GPIO_Output = OUTPUT_H;
    1a64:	0008cf06 	andeq	ip, r8, r6, lsl #30
    1a68:	12062000 	andne	r2, r6, #0
  ptb.GPIO_PinControl = INPUT_PULL_UP;
    1a6c:	21000002 	tstcs	r0, r2
  LPLD_GPIO_Init(ptb);
    1a70:	0003f306 	andeq	pc, r3, r6, lsl #6
    1a74:	17062200 	strne	r2, [r6, -r0, lsl #4]
    1a78:	23000001 	movwcs	r0, #1
    1a7c:	0005e006 	andeq	lr, r5, r6
}
    1a80:	d3062400 	movwle	r2, #25600	; 0x6400
    1a84:	25000004 	strcs	r0, [r0, #-4]
 * :
 *    1-ɹ
 *    0-ʧ
 */
uint8 LPLD_SCCB_WriteReg(uint16 reg_addr , uint8 data)
{		
    1a88:	000a3706 	andeq	r3, sl, r6, lsl #14
    1a8c:	53062600 	movwpl	r2, #26112	; 0x6600
    1a90:	27000006 	strcs	r0, [r0, -r6]
    1a94:	00075e06 	andeq	r5, r7, r6, lsl #28
  if(!LPLD_SCCB_Start())
    1a98:	53062800 	movwpl	r2, #26624	; 0x6800
    1a9c:	2900000a 	stmdbcs	r0, {r1, r3}
  {
    return 0;
    1aa0:	000a6706 	andeq	r6, sl, r6, lsl #14
    1aa4:	7f062a00 	svcvc	0x00062a00
  }
  LPLD_SCCB_SendByte(SCCB_DEV_ADR ); 
    1aa8:	2b000007 	blcs	1acc <LPLD_SCCB_WriteReg+0x44>
    1aac:	000a7006 	andeq	r7, sl, r6
  if(!LPLD_SCCB_WaitAck())
    1ab0:	89062c00 	stmdbhi	r6, {sl, fp, sp}
    1ab4:	2d000000 	stccs	0, cr0, [r0, #-0]
  {
    LPLD_SCCB_Stop(); 
    1ab8:	00016606 	andeq	r6, r1, r6, lsl #12
    return 0;
    1abc:	8b062e00 	blhi	18d2c4 <__etext+0x18461c>
    1ac0:	2f000005 	svccs	0x00000005
  }
  LPLD_SCCB_SendByte((uint8)(reg_addr & 0x00FF));   
    1ac4:	00087706 	andeq	r7, r8, r6, lsl #14
    1ac8:	63063000 	movwvs	r3, #24576	; 0x6000
  LPLD_SCCB_WaitAck();	
    1acc:	31000008 	tstcc	r0, r8
  LPLD_SCCB_SendByte(data);
    1ad0:	0002b706 	andeq	fp, r2, r6, lsl #14
    1ad4:	68063200 	stmdavs	r6, {r9, ip, sp}
  LPLD_SCCB_WaitAck();   
    1ad8:	33000003 	movwcc	r0, #3
  LPLD_SCCB_Stop(); 
    1adc:	000a8e06 	andeq	r8, sl, r6, lsl #28
  return 1;
    1ae0:	6c063400 	cfstrsvs	mvf3, [r6], {-0}
}									 
    1ae4:	35000000 	strcc	r0, [r0, #-0]
    1ae8:	00039906 	andeq	r9, r3, r6, lsl #18
    1aec:	ae063600 	cfmadd32ge	mvax0, mvfx3, mvfx6, mvfx0
 * :
 *    1-ɹ
 *    0-ʧ
 */          
uint8 LPLD_SCCB_ReadReg(uint8 reg_addr, uint8* data, uint16 length)
{	
    1af0:	37000001 	strcc	r0, [r0, -r1]
    1af4:	0001f606 	andeq	pc, r1, r6, lsl #12
    1af8:	cb063800 	blgt	18fb00 <__etext+0x186e58>
    1afc:	39000001 	stmdbcc	r0, {r0}
  if(!LPLD_SCCB_Start())
    1b00:	00043e06 	andeq	r3, r4, r6, lsl #28
    1b04:	db063a00 	blle	19030c <__etext+0x187664>
    1b08:	3b000004 	blcc	1b20 <LPLD_SCCB_ReadReg+0x30>
  {
    return 0;
    1b0c:	00074506 	andeq	r4, r7, r6, lsl #10
  }
  LPLD_SCCB_SendByte( SCCB_DEV_ADR ); 
    1b10:	18063c00 	stmdane	r6, {sl, fp, ip, sp}
    1b14:	3d000009 	stccc	0, cr0, [r0, #-36]	; 0xffffffdc
  if( !LPLD_SCCB_WaitAck() )
    1b18:	00045406 	andeq	r5, r4, r6, lsl #8
    1b1c:	6a063e00 	bvs	191324 <__etext+0x18867c>
    1b20:	3f000004 	svccc	0x00000004
  {
    LPLD_SCCB_Stop(); 
    1b24:	000a7906 	andeq	r7, sl, r6, lsl #18
    return 0;
    1b28:	0600c000 	streq	ip, [r0], -r0
  }
  LPLD_SCCB_SendByte( reg_addr ); 
    1b2c:	00000994 	muleq	r0, r4, r9
    1b30:	7d0600c1 	stcvc	0, cr0, [r6, #-772]	; 0xfffffcfc
  LPLD_SCCB_WaitAck();	
    1b34:	c2000005 	andgt	r0, r0, #5
  LPLD_SCCB_Stop(); 
    1b38:	04a50600 	strteq	r0, [r5], #1536	; 0x600
  
  if(!LPLD_SCCB_Start())
    1b3c:	00c30000 	sbceq	r0, r3, r0
    1b40:	000a2106 	andeq	r2, sl, r6, lsl #2
    1b44:	0600c400 	streq	ip, [r0], -r0, lsl #8
  {
    return 0;
    1b48:	000009f8 	strdeq	r0, [r0], -r8
  }
  LPLD_SCCB_SendByte( SCCB_DEV_ADR + 1 );
    1b4c:	7a0600c5 	bvc	181e68 <__etext+0x1791c0>
    1b50:	c6000009 	strgt	r0, [r0], -r9
  
  if(!LPLD_SCCB_WaitAck())
    1b54:	04c30600 	strbeq	r0, [r3], #1536	; 0x600
    1b58:	00c70000 	sbceq	r0, r7, r0
    1b5c:	00053d06 	andeq	r3, r5, r6, lsl #26
  {
    LPLD_SCCB_Stop(); 
    1b60:	0600c800 	streq	ip, [r0], -r0, lsl #16
    return 0;
    1b64:	00000404 	andeq	r0, r0, r4, lsl #8
  }
  while(length)
  {
    *data = LPLD_SCCB_ReceiveByte();
    1b68:	2b0600c9 	blcs	181e94 <__etext+0x1791ec>
    1b6c:	ca000002 	bgt	1b7c <LPLD_SCCB_ReadReg+0x8c>
    1b70:	09b30600 	ldmibeq	r3!, {r9, sl}
    if(length == 1)
    1b74:	00cb0000 	sbceq	r0, fp, r0
    1b78:	00066f06 	andeq	r6, r6, r6, lsl #30
    {
      LPLD_SCCB_NoAck();
    1b7c:	0600cc00 	streq	ip, [r0], -r0, lsl #24
    }
    else
    {
      LPLD_SCCB_Ack(); 
    1b80:	00000678 	andeq	r0, r0, r8, ror r6
    }
    data++;
    1b84:	cd0600cd 	stcgt	0, cr0, [r6, #-820]	; 0xfffffccc
    1b88:	ce000002 	cdpgt	0, 0, cr0, cr0, cr2, {0}
    length--;
    1b8c:	02d60600 	sbcseq	r0, r6, #0
    1b90:	00cf0000 	sbceq	r0, pc, r0
  if(!LPLD_SCCB_WaitAck())
  {
    LPLD_SCCB_Stop(); 
    return 0;
  }
  while(length)
    1b94:	0002df06 	andeq	sp, r2, r6, lsl #30
    1b98:	0600d000 	streq	sp, [r0], -r0
      LPLD_SCCB_Ack(); 
    }
    data++;
    length--;
  }
  LPLD_SCCB_Stop();
    1b9c:	0000021a 	andeq	r0, r0, sl, lsl r2
  return 1;
    1ba0:	620600d1 	andvs	r0, r6, #209	; 0xd1
}
    1ba4:	d2000004 	andle	r0, r0, #4
    1ba8:	03890600 	orreq	r0, r9, #0
/*
 * LPLD_SCCB_Start
 * SCCBʼźţڲ
 */
uint8 LPLD_SCCB_Start(void)
{
    1bac:	00d30000 	sbcseq	r0, r3, r0
  SCCB_SDA_O=1;//ߵƽ
    1bb0:	00047a06 	andeq	r7, r4, r6, lsl #20
    1bb4:	0600d400 	streq	sp, [r0], -r0, lsl #8
    1bb8:	0000002e 	andeq	r0, r0, lr, lsr #32
    1bbc:	cb0600d5 	blgt	181f18 <__etext+0x179270>
  SCCB_SCL=1;   //ʱߵƽ 
    1bc0:	d6000007 	strle	r0, [r0], -r7
    1bc4:	00450600 	subeq	r0, r5, r0, lsl #12
    1bc8:	00d70000 	sbcseq	r0, r7, r0
  SCCB_DELAY();
    1bcc:	0005ec06 	andeq	lr, r5, r6, lsl #24
    1bd0:	0600d800 	streq	sp, [r0], -r0, lsl #16
  
  SCCB_SDA_IN();//Ϊ
    1bd4:	00000222 	andeq	r0, r0, r2, lsr #4
    1bd8:	530600d9 	movwpl	r0, #24793	; 0x60d9
    1bdc:	da000007 	ble	1c00 <LPLD_SCCB_Start+0x54>
    1be0:	09040600 	stmdbeq	r4, {r9, sl}
  if(!SCCB_SDA_I)
    1be4:	00db0000 	sbcseq	r0, fp, r0
    1be8:	0000de06 	andeq	sp, r0, r6, lsl #28
    1bec:	0600dc00 	streq	sp, [r0], -r0, lsl #24
  {
    SCCB_SDA_OUT();	
    1bf0:	00000056 	andeq	r0, r0, r6, asr r0
    1bf4:	9f0600dd 	svcls	0x000600dd
    1bf8:	de000001 	cdple	0, 0, cr0, cr0, cr1, {0}
    1bfc:	0a440600 	beq	1103404 <__etext+0x10fa75c>
    return 0;
    1c00:	00df0000 	sbcseq	r0, pc, r0
  }
  SCCB_SDA_OUT();//Ϊ;	
    1c04:	0000a606 	andeq	sl, r0, r6, lsl #12
    1c08:	0600e000 	streq	lr, [r0], -r0
    1c0c:	000005d7 	ldrdeq	r0, [r0], -r7
    1c10:	ea0600e1 	b	181f9c <__etext+0x1792f4>
  SCCB_SDA_O=0; //͵ƽ
    1c14:	e2000004 	and	r0, r0, #4
    1c18:	03ea0600 	mvneq	r0, #0
    1c1c:	00e30000 	rsceq	r0, r3, r0
  
  SCCB_DELAY();
    1c20:	00004e06 	andeq	r4, r0, r6, lsl #28
    1c24:	0600e400 	streq	lr, [r0], -r0, lsl #8
  
  SCCB_SDA_IN();//Ϊ
    1c28:	00000306 	andeq	r0, r0, r6, lsl #6
    1c2c:	b40600e5 	strlt	r0, [r6], #-229	; 0xe5
    1c30:	e6000000 	str	r0, [r0], -r0
    1c34:	05f50600 	ldrbeq	r0, [r5, #1536]!	; 0x600
  if(SCCB_SDA_I) 
    1c38:	00e70000 	rsceq	r0, r7, r0
    1c3c:	00012a06 	andeq	r2, r1, r6, lsl #20
    1c40:	0600e800 	streq	lr, [r0], -r0, lsl #16
  {
    SCCB_SDA_OUT();
    1c44:	00000610 	andeq	r0, r0, r0, lsl r6
    1c48:	310600e9 	smlattcc	r6, r9, r0, r0
    1c4c:	ea000007 	b	1c70 <LPLD_SCCB_Start+0xc4>
    1c50:	062c0600 	strteq	r0, [ip], -r0, lsl #12
    return 0;
    1c54:	00eb0000 	rsceq	r0, fp, r0
  }
  SCCB_SDA_OUT();//Ϊ
    1c58:	00063606 	andeq	r3, r6, r6, lsl #12
    1c5c:	0600ec00 	streq	lr, [r0], -r0, lsl #24
    1c60:	00000890 	muleq	r0, r0, r8
    1c64:	610600ed 	smlattvs	r6, sp, r0, r0
  SCCB_SDA_O=0;//͵ƽ
    1c68:	ee000006 	cdp	0, 0, cr0, cr0, cr6, {0}
    1c6c:	05c30600 	strbeq	r0, [r3, #1536]	; 0x600
    1c70:	00ef0000 	rsceq	r0, pc, r0
  return 1;
    1c74:	00068106 	andeq	r8, r6, r6, lsl #2
}
    1c78:	0600f000 	streq	pc, [r0], -r0
/*
 * LPLD_SCCB_Stop
 * SCCBֹͣźţڲ
 */
static void LPLD_SCCB_Stop(void)
{
    1c7c:	000000f8 	strdeq	r0, [r0], -r8
  SCCB_SCL=0;
    1c80:	e50600f1 	str	r0, [r6, #-241]	; 0xf1
    1c84:	f2000009 	vhadd.s8	d0, d0, d9
    1c88:	035d0600 	cmpeq	sp, #0
    1c8c:	00f30000 	rscseq	r0, r3, r0
  SCCB_SDA_O=0;
    1c90:	0002a706 	andeq	sl, r2, r6, lsl #14
    1c94:	0600f400 	streq	pc, [r0], -r0, lsl #8
    1c98:	000002e8 	andeq	r0, r0, r8, ror #5
  SCCB_DELAY();
    1c9c:	1d0600f5 	stcne	0, cr0, [r6, #-980]	; 0xfffffc2c
    1ca0:	f6000004 			; <UNDEFINED> instruction: 0xf6000004
  
  SCCB_SCL=1;
    1ca4:	04260600 	strteq	r0, [r6], #-1536	; 0x600
    1ca8:	00f70000 	rscseq	r0, r7, r0
    1cac:	00018506 	andeq	r8, r1, r6, lsl #10
    1cb0:	0600f800 	streq	pc, [r0], -r0, lsl #16
  SCCB_SDA_O=1;
    1cb4:	00000988 	andeq	r0, r0, r8, lsl #19
    1cb8:	020000f9 	andeq	r0, r0, #249	; 0xf9
    1cbc:	05740704 	ldrbeq	r0, [r4, #-1796]!	; 0x704
  SCCB_DELAY();
    1cc0:	2c070000 	stccs	0, cr0, [r7], {-0}
    1cc4:	c2000000 	andgt	r0, r0, #0
}
    1cc8:	08000003 	stmdaeq	r0, {r0, r1}
/*
 * LPLD_SCCB_Stop
 * SCCBӦźţڲ
 */
static void LPLD_SCCB_Ack(void)
{	
    1ccc:	000003ab 	andeq	r0, r0, fp, lsr #7
  SCCB_SCL=0;
    1cd0:	2c07001b 	stccs	0, cr0, [r7], {27}
    1cd4:	d2000000 	andle	r0, r0, #0
    1cd8:	08000003 	stmdaeq	r0, {r0, r1}
    1cdc:	000003ab 	andeq	r0, r0, fp, lsr #7
  SCCB_DELAY();
    1ce0:	2c07000f 	stccs	0, cr0, [r7], {15}
    1ce4:	e2000000 	and	r0, r0, #0
  
  SCCB_SDA_O=0;
    1ce8:	08000003 	stmdaeq	r0, {r0, r1}
    1cec:	000003ab 	andeq	r0, r0, fp, lsr #7
    1cf0:	2c070003 	stccs	0, cr0, [r7], {3}
  SCCB_DELAY();
    1cf4:	f2000000 	vhadd.s8	d0, d0, d0
    1cf8:	08000003 	stmdaeq	r0, {r0, r1}
  
  SCCB_SCL=1;
    1cfc:	000003ab 	andeq	r0, r0, fp, lsr #7
    1d00:	04090007 	streq	r0, [r9], #-7
    1d04:	20118003 	andscs	r8, r1, r3
    1d08:	0a000004 	beq	1d20 <LPLD_SCCB_Ack+0x54>
  SCCB_DELAY();
    1d0c:	0000078f 	andeq	r0, r0, pc, lsl #15
    1d10:	5e118103 	mnfpls	f0, f3
  
  SCCB_SCL=0;
    1d14:	0a000000 	beq	1d1c <LPLD_SCCB_Ack+0x50>
    1d18:	0000001f 	andeq	r0, r0, pc, lsl r0
    1d1c:	5e118203 	cdppl	2, 1, cr8, cr1, cr3, {0}
  SCCB_DELAY();
    1d20:	0a000000 	beq	1d28 <LPLD_SCCB_Ack+0x5c>
    1d24:	000007b2 			; <UNDEFINED> instruction: 0x000007b2
}
    1d28:	5e118303 	cdppl	3, 1, cr8, cr1, cr3, {0}
/*
 * LPLD_SCCB_NoAck
 * SCCBӦźţڲ
 */
static void LPLD_SCCB_NoAck(void)
{	
    1d2c:	00000000 	andeq	r0, r0, r0
  SCCB_SCL=0;
    1d30:	88030209 	stmdahi	r3, {r0, r3, r9}
    1d34:	00044211 	andeq	r4, r4, r1, lsl r2
    1d38:	00370a00 	eorseq	r0, r7, r0, lsl #20
    1d3c:	89030000 	stmdbhi	r3, {}	; <UNPREDICTABLE>
  SCCB_DELAY();
    1d40:	00004511 	andeq	r4, r0, r1, lsl r5
    1d44:	07700a00 	ldrbeq	r0, [r0, -r0, lsl #20]!
  SCCB_SDA_O=1;
    1d48:	8a030000 	bhi	c1d50 <__etext+0xb90a8>
    1d4c:	00004511 	andeq	r4, r0, r1, lsl r5
    1d50:	02090000 	andeq	r0, r9, #0
  SCCB_DELAY();
    1d54:	64118e03 	ldrvs	r8, [r1], #-3587	; 0xe03
    1d58:	0a000004 	beq	1d70 <LPLD_SCCB_NoAck+0x44>
  SCCB_SCL=1;
    1d5c:	000007d4 	ldrdeq	r0, [r0], -r4
    1d60:	45118f03 	ldrmi	r8, [r1, #-3843]	; 0xf03
    1d64:	0a000000 	beq	1d6c <LPLD_SCCB_NoAck+0x40>
    1d68:	0000095b 	andeq	r0, r0, fp, asr r9
  SCCB_DELAY();
    1d6c:	45119003 	ldrmi	r9, [r1, #-3]
    1d70:	00000000 	andeq	r0, r0, r0
  SCCB_SCL=0;
    1d74:	7c03200b 	stcvc	0, cr2, [r3], {11}
    1d78:	0004fe11 	andeq	pc, r4, r1, lsl lr	; <UNPREDICTABLE>
    1d7c:	03740c00 	cmneq	r4, #0
  SCCB_DELAY();
    1d80:	7d030000 	stcvc	0, cr0, [r3, #-0]
    1d84:	00005e11 	andeq	r5, r0, r1, lsl lr
}
    1d88:	00230200 	eoreq	r0, r3, r0, lsl #4
/*
 * LPLD_SCCB_WaitAck
 * SCCBȴӦźţڲ
 */
static uint8 LPLD_SCCB_WaitAck(void) 	
{
    1d8c:	0004be0c 	andeq	fp, r4, ip, lsl #28
  SCCB_SCL=0;//ʱߵ͵ƽ
    1d90:	117e0300 	cmnne	lr, r0, lsl #6
    1d94:	00000045 	andeq	r0, r0, r5, asr #32
    1d98:	0c042302 	stceq	3, cr2, [r4], {2}
    1d9c:	0000044f 	andeq	r0, r0, pc, asr #8
  SCCB_DELAY(); 
    1da0:	45117f03 	ldrmi	r7, [r1, #-3843]	; 0xf03
    1da4:	02000000 	andeq	r0, r0, #0
  
 SCCB_SDA_IN();//Ϊ**
    1da8:	f20d0623 	vmax.s8	d0, d13, d19
    1dac:	02000003 	andeq	r0, r0, #3
    1db0:	5b0c0823 	blpl	303e44 <__etext+0x2fb19c>
  SCCB_DELAY();
    1db4:	03000006 	movweq	r0, #6
    1db8:	005e1185 	subseq	r1, lr, r5, lsl #3
  
  SCCB_SCL=1;//ʱ߸ߵƽ
    1dbc:	23020000 	movwcs	r0, #8192	; 0x2000
    1dc0:	08dd0c0c 	ldmeq	sp, {r2, r3, sl, fp}^
    1dc4:	86030000 	strhi	r0, [r3], -r0
    1dc8:	00005e11 	andeq	r5, r0, r1, lsl lr
  
  SCCB_DELAY();
    1dcc:	10230200 	eorne	r0, r3, r0, lsl #4
    1dd0:	0000af0c 	andeq	sl, r0, ip, lsl #30
  
  if(SCCB_SDA_I)
    1dd4:	11870300 	orrne	r0, r7, r0, lsl #6
    1dd8:	00000045 	andeq	r0, r0, r5, asr #32
    1ddc:	0d142302 	ldceq	3, cr2, [r4, #-8]
  {
    SCCB_SDA_OUT();
    1de0:	00000420 	andeq	r0, r0, r0, lsr #8
    1de4:	0c162302 	ldceq	3, cr2, [r6], {2}
    1de8:	000005b4 			; <UNDEFINED> instruction: 0x000005b4
    1dec:	5e118c03 	cdppl	12, 1, cr8, cr1, cr3, {0}
    SCCB_SCL=0;
    1df0:	02000000 	andeq	r0, r0, #0
    1df4:	430e1823 	movwmi	r1, #59427	; 0xe823
    1df8:	03005253 	movweq	r5, #595	; 0x253
    return 0;
    1dfc:	0045118d 	subeq	r1, r5, sp, lsl #3
    1e00:	23020000 	movwcs	r0, #8192	; 0x2000
  }
  SCCB_SDA_OUT();//Ϊ
    1e04:	04420d1c 	strbeq	r0, [r2], #-3356	; 0xd1c
    1e08:	23020000 	movwcs	r0, #8192	; 0x2000
    1e0c:	480f001e 	stmdami	pc, {r1, r2, r3, r4}	; <UNPREDICTABLE>
  SCCB_SCL=0; //ʱߵ͵ƽ
    1e10:	00000009 	andeq	r0, r0, r9
    1e14:	11450314 	cmpne	r5, r4, lsl r3
    1e18:	00000866 	andeq	r0, r0, r6, ror #16
    1e1c:	0052430e 	subseq	r4, r2, lr, lsl #6
  return 1;
    1e20:	5e114603 	cfmsub32pl	mvax0, mvfx4, mvfx1, mvfx3
}
    1e24:	02000000 	andeq	r0, r0, #0
/*
 * LPLD_SCCB_SendByte
 * SCCBݣڲ
 */
static void LPLD_SCCB_SendByte(uint8 data) 
{
    1e28:	450e0023 	strmi	r0, [lr, #-35]	; 0x23
    1e2c:	47030053 	smlsdmi	r3, r3, r0, r0
    1e30:	00005e11 	andeq	r5, r0, r1, lsl lr
  uint8 i=8;
    1e34:	04230200 	strteq	r0, [r3], #-512	; 0x200
  while(i--)
    1e38:	0003120c 	andeq	r1, r3, ip, lsl #4
  {
    SCCB_SCL=0;
    1e3c:	11480300 	mrsne	r0, (UNDEF: 120)
    1e40:	000003d2 	ldrdeq	r0, [r0], -r2
    1e44:	0e082302 	cdpeq	3, 0, cr2, cr8, cr2, {0}
    SCCB_DELAY();
    1e48:	00515245 	subseq	r5, r1, r5, asr #4
    1e4c:	5e114903 	cdppl	9, 1, cr4, cr1, cr3, {0}
    if(data&0x80)
    1e50:	02000000 	andeq	r0, r0, #0
    1e54:	1d0c0c23 	stcne	12, cr0, [ip, #-140]	; 0xffffff74
    {
      SCCB_SDA_O=1; 
    1e58:	03000003 	movweq	r0, #3
    1e5c:	03d2114a 	bicseq	r1, r2, #-2147483630	; 0x80000012
    1e60:	23020000 	movwcs	r0, #8192	; 0x2000
    1e64:	45450e10 	strbmi	r0, [r5, #-3600]	; 0xe10
    }
    else 
    {
      SCCB_SDA_O=0;   
    1e68:	4b030049 	blmi	c1f94 <__etext+0xb92ec>
    1e6c:	00005e11 	andeq	r5, r0, r1, lsl lr
    1e70:	14230200 	strtne	r0, [r3], #-512	; 0x200
    1e74:	0008e30c 	andeq	lr, r8, ip, lsl #6
    }
    data<<=1;
    1e78:	114c0300 	mrsne	r0, SPSR_mon
    1e7c:	0000002c 	andeq	r0, r0, ip, lsr #32
    SCCB_DELAY();
    1e80:	0c182302 	ldceq	3, cr2, [r8], {2}
    1e84:	000000d9 	ldrdeq	r0, [r0], -r9
    SCCB_SCL=1;
    1e88:	2c114d03 	ldccs	13, cr4, [r1], {3}
    1e8c:	02000000 	andeq	r0, r0, #0
    1e90:	490c1923 	stmdbmi	ip, {r0, r1, r5, r8, fp, ip}
    SCCB_DELAY();
    1e94:	03000006 	movweq	r0, #6
    1e98:	002c114e 	eoreq	r1, ip, lr, asr #2
 * SCCBݣڲ
 */
static void LPLD_SCCB_SendByte(uint8 data) 
{
  uint8 i=8;
  while(i--)
    1e9c:	23020000 	movwcs	r0, #8192	; 0x2000
    1ea0:	088b0c1a 	stmeq	fp, {r1, r3, r4, sl, fp}
    1ea4:	4f030000 	svcmi	0x00030000
    1ea8:	00002c11 	andeq	r2, r0, r1, lsl ip
    1eac:	1b230200 	blne	8c26b4 <__etext+0x8b9a0c>
    1eb0:	0002c80c 	andeq	ip, r2, ip, lsl #16
    data<<=1;
    SCCB_DELAY();
    SCCB_SCL=1;
    SCCB_DELAY();
  }
  SCCB_SCL=0;
    1eb4:	11500300 	cmpne	r0, r0, lsl #6
    1eb8:	0000002c 	andeq	r0, r0, ip, lsr #32
    1ebc:	0c1c2302 	ldceq	3, cr2, [ip], {2}
    1ec0:	000003aa 	andeq	r0, r0, sl, lsr #7
}
    1ec4:	2c115103 	ldfcss	f5, [r1], {3}
    1ec8:	02000000 	andeq	r0, r0, #0
/*
 * LPLD_SCCB_SendByte
 * SCCBݣڲ
 */
static uint8 LPLD_SCCB_ReceiveByte(void)  
{ 
    1ecc:	4e0c1d23 	cdpmi	13, 0, cr1, cr12, cr3, {1}
    1ed0:	03000006 	movweq	r0, #6
  uint8 i=8;
    1ed4:	002c1152 	eoreq	r1, ip, r2, asr r1
  uint8 ReceiveByte=0;
    1ed8:	23020000 	movwcs	r0, #8192	; 0x2000
    1edc:	06b60c1e 	ssateq	r0, #23, lr, lsl #24
  
  SCCB_SDA_O=1;	
    1ee0:	53030000 	movwpl	r0, #12288	; 0x3000
    1ee4:	00002c11 	andeq	r2, r0, r1, lsl ip
    1ee8:	1f230200 	svcne	0x00230200
  SCCB_DELAY();
    1eec:	000a9a0c 	andeq	r9, sl, ip, lsl #20
    1ef0:	11540300 	cmpne	r4, r0, lsl #6
  
  SCCB_SDA_IN();	
    1ef4:	000003d2 	ldrdeq	r0, [r0], -r2
    1ef8:	0e202302 	cdpeq	3, 2, cr2, cr0, cr2, {0}
    1efc:	00544e49 	subseq	r4, r4, r9, asr #28
    1f00:	5e115503 	cfmul32pl	mvfx5, mvfx1, mvfx3
  
  while(i--)
  {
    ReceiveByte<<=1;      
    1f04:	02000000 	andeq	r0, r0, #0
    1f08:	310c2423 	tstcc	ip, r3, lsr #8
    SCCB_SCL=0;
    1f0c:	03000003 	movweq	r0, #3
    1f10:	03d21156 	bicseq	r1, r2, #-2147483627	; 0x80000015
    1f14:	23020000 	movwcs	r0, #8192	; 0x2000
    1f18:	52450e28 	subpl	r0, r5, #640	; 0x280
    SCCB_DELAY();
    1f1c:	57030052 	smlsdpl	r3, r2, r0, r0
    1f20:	00005e11 	andeq	r5, r0, r1, lsl lr
    
    SCCB_SCL=1;
    1f24:	2c230200 	sfmcs	f0, 4, [r3], #-0
    1f28:	00033c0c 	andeq	r3, r3, ip, lsl #24
    1f2c:	11580300 	cmpne	r8, r0, lsl #6
    SCCB_DELAY();	
    1f30:	000003d2 	ldrdeq	r0, [r0], -r2
    1f34:	0e302302 	cdpeq	3, 3, cr2, cr0, cr2, {0}
    
    if(SCCB_SDA_I)
    1f38:	00535248 	subseq	r5, r3, r8, asr #4
    1f3c:	5e115903 	cdppl	9, 1, cr5, cr1, cr3, {0}
    1f40:	02000000 	andeq	r0, r0, #0
    1f44:	470c3423 	strmi	r3, [ip, -r3, lsr #8]
    {
      ReceiveByte|=0x01;
    1f48:	03000003 	movweq	r0, #3
    1f4c:	0866115a 	stmdaeq	r6!, {r1, r3, r4, r6, r8, ip}^
  SCCB_SDA_O=1;	
  SCCB_DELAY();
  
  SCCB_SDA_IN();	
  
  while(i--)
    1f50:	23020000 	movwcs	r0, #8192	; 0x2000
    1f54:	09400c38 	stmdbeq	r0, {r3, r4, r5, sl, fp}^
    1f58:	5b030000 	blpl	c1f60 <__etext+0xb92b8>
    1f5c:	00002c11 	andeq	r2, r0, r1, lsl ip
    1f60:	80230300 	eorhi	r0, r3, r0, lsl #6
    1f64:	09380c02 	ldmdbeq	r8!, {r1, sl, fp}
    {
      ReceiveByte|=0x01;
    }
    
  }
  SCCB_SDA_OUT();
    1f68:	5c030000 	stcpl	0, cr0, [r3], {-0}
    1f6c:	00002c11 	andeq	r2, r0, r1, lsl ip
    1f70:	81230300 	teqhi	r3, r0, lsl #6
  SCCB_SCL=0;
    1f74:	09300c02 	ldmdbeq	r0!, {r1, sl, fp}
    1f78:	5d030000 	stcpl	0, cr0, [r3, #-0]
    1f7c:	00002c11 	andeq	r2, r0, r1, lsl ip
    1f80:	82230300 	eorhi	r0, r3, #0
  
  return ReceiveByte;
}
    1f84:	09280c02 	stmdbeq	r8!, {r1, sl, fp}
    1f88:	5e030000 	cdppl	0, 0, cr0, cr3, cr0, {0}
    1f8c:	00002c11 	andeq	r2, r0, r1, lsl ip
/*
 * LPLD_SCCB_SendByte
 * SCCBʱڲ
 */
static void LPLD_SCCB_Delay(uint16 i)
{	
    1f90:	83230300 	teqhi	r3, #0
    1f94:	096a0c02 	stmdbeq	sl!, {r1, sl, fp}^
    1f98:	5f030000 	svcpl	0x00030000
  while(i) 
    i--; 
    1f9c:	00002c11 	andeq	r2, r0, r1, lsl ip
    1fa0:	84230300 	strthi	r0, [r3], #-768	; 0x300
 * LPLD_SCCB_SendByte
 * SCCBʱڲ
 */
static void LPLD_SCCB_Delay(uint16 i)
{	
  while(i) 
    1fa4:	03fc0c02 	mvnseq	r0, #512	; 0x200
    1fa8:	60030000 	andvs	r0, r3, r0
    i--; 
}
    1fac:	00002c11 	andeq	r2, r0, r1, lsl ip
    1fb0:	85230300 	strhi	r0, [r3, #-768]!	; 0x300
 * 输出:
 *    0--配置错误
 *    1--配置成功
 */
uint8 LPLD_ADC_Init(ADC_InitTypeDef adc_init_structure)
{
    1fb4:	09530c02 	ldmdbeq	r3, {r1, sl, fp}^
    1fb8:	61030000 	mrsvs	r0, (UNDEF: 3)
    1fbc:	00002c11 	andeq	r2, r0, r1, lsl ip
    1fc0:	86230300 	strthi	r0, [r3], -r0, lsl #6
  uint8 i;
  ADC_MemMapPtr adcx = adc_init_structure.ADC_Adcx;
    1fc4:	00f00c02 	rscseq	r0, r0, r2, lsl #24
  uint8 diff = adc_init_structure.ADC_DiffMode;
    1fc8:	62030000 	andvs	r0, r3, #0
    1fcc:	00002c11 	andeq	r2, r0, r1, lsl ip
  uint8 mode = adc_init_structure.ADC_BitMode;
    1fd0:	87230300 	strhi	r0, [r3, -r0, lsl #6]!
  uint8 time = adc_init_structure.ADC_SampleTimeCfg;
    1fd4:	06c40c02 	strbeq	r0, [r4], r2, lsl #24
    1fd8:	63030000 	movwvs	r0, #12288	; 0x3000
  uint8 ltime = adc_init_structure.ADC_LongSampleTimeSel;
    1fdc:	00002c11 	andeq	r2, r0, r1, lsl ip
  uint8 avg = adc_init_structure.ADC_HwAvgSel;
    1fe0:	88230300 	stmdahi	r3!, {r8, r9}
    1fe4:	06bb0c02 	ldrteq	r0, [fp], r2, lsl #24
  uint8 muxab = adc_init_structure.ADC_MuxSel;
    1fe8:	64030000 	strvs	r0, [r3], #-0
  uint8 pga = adc_init_structure.ADC_PgaGain;
    1fec:	00002c11 	andeq	r2, r0, r1, lsl ip
    1ff0:	89230300 	stmdbhi	r3!, {r8, r9}
  uint8 hwtrg = adc_init_structure.ADC_HwTrgCfg;
    1ff4:	08a80c02 	stmiaeq	r8!, {r1, sl, fp}
  ADC_ISR_CALLBACK isr_func = adc_init_structure.ADC_Isr;
    1ff8:	65030000 	strvs	r0, [r3, #-0]
 
  //配置ADC时钟 //这里貌似只配置了两个还要另行配置其他的几个
  if(adcx == ADC0)
    1ffc:	00002c11 	andeq	r2, r0, r1, lsl ip
    2000:	8a230300 	bhi	8c2c08 <__etext+0x8b9f60>
    2004:	09720c02 	ldmdbeq	r2!, {r1, sl, fp}^
    2008:	66030000 	strvs	r0, [r3], -r0
  {
    i=0;
    200c:	00002c11 	andeq	r2, r0, r1, lsl ip
    SIM_SCGC6 |= SIM_SCGC6_ADC0_MASK;   // 开启ADC0时钟
    2010:	8b230300 	blhi	8c2c18 <__etext+0x8b9f70>
    2014:	06e80c02 	strbteq	r0, [r8], r2, lsl #24
    2018:	67030000 	strvs	r0, [r3, -r0]
    201c:	00002c11 	andeq	r2, r0, r1, lsl ip
    2020:	8c230300 	stchi	3, cr0, [r3], #-0
    2024:	06df0c02 	ldrbeq	r0, [pc], r2, lsl #24
    2028:	68030000 	stmdavs	r3, {}	; <UNPREDICTABLE>
    202c:	00002c11 	andeq	r2, r0, r1, lsl ip
    2030:	8d230300 	stchi	3, cr0, [r3, #-0]
    2034:	06d60c02 	ldrbeq	r0, [r6], r2, lsl #24
    2038:	69030000 	stmdbvs	r3, {}	; <UNPREDICTABLE>
  }
  else if(adcx == ADC1)
    203c:	00002c11 	andeq	r2, r0, r1, lsl ip
    2040:	8e230300 	cdphi	3, 2, cr0, cr3, cr0, {0}
    2044:	06cd0c02 	strbeq	r0, [sp], r2, lsl #24
  {
    i=1;
    2048:	6a030000 	bvs	c2050 <__etext+0xb93a8>
    204c:	00002c11 	andeq	r2, r0, r1, lsl ip
    SIM_SCGC3 |= SIM_SCGC3_ADC1_MASK;   // 开启ADC1时钟
    2050:	8f230300 	svchi	0x00230300
    2054:	07170c02 	ldreq	r0, [r7, -r2, lsl #24]
    2058:	6b030000 	blvs	c2060 <__etext+0xb93b8>
    205c:	00002c11 	andeq	r2, r0, r1, lsl ip
    2060:	90230300 	eorls	r0, r3, r0, lsl #6
    2064:	04b50c02 	ldrteq	r0, [r5], #3074	; 0xc02
    2068:	6c030000 	stcvs	0, cr0, [r3], {-0}
    206c:	00002c11 	andeq	r2, r0, r1, lsl ip
    2070:	91230300 	teqls	r3, r0, lsl #6
    2074:	07000c02 	streq	r0, [r0, -r2, lsl #24]
  }
  else 
  {
    return 0;
    2078:	6d030000 	stcvs	0, cr0, [r3, #-0]
    207c:	00002c11 	andeq	r2, r0, r1, lsl ip
  }

  if(adc_init_structure.ADC_CalEnable == TRUE)
    2080:	92230300 	eorls	r0, r3, #0
    2084:	017c0c02 	cmneq	ip, r2, lsl #24
    LPLD_ADC_Cal(adcx);  //进行ADC校准
    2088:	6e030000 	cdpvs	0, 0, cr0, cr3, cr0, {0}
  
  //设置ADCCFG1寄存器
  adcx->CFG1  &=   (~ADC_CFG1_ADLPC_MASK);         // 重新为正常使用进行配置
    208c:	00002c11 	andeq	r2, r0, r1, lsl ip
    2090:	93230300 	teqls	r3, #0
    2094:	05ab0c02 	streq	r0, [fp, #3074]!	; 0xc02
  adcx->CFG1  |=    ADC_CFG1_ADIV(ADIV_1)          // ADC输入时钟分频为 1
    2098:	6f030000 	svcvs	0x00030000
                  | (time)                           // 设置长短时间采样模式
                  | ADC_CFG1_ADICLK(ADICLK_BUS_2)  // ADC输入时钟源为 BusClk
    209c:	00002c11 	andeq	r2, r0, r1, lsl ip
    20a0:	94230300 	strtls	r0, [r3], #-768	; 0x300
    20a4:	04890c02 	streq	r0, [r9], #3074	; 0xc02
                  | ADC_CFG1_MODE(mode);           //设置ADC转换精度
    20a8:	70030000 	andvc	r0, r3, r0
    20ac:	00002c11 	andeq	r2, r0, r1, lsl ip
    20b0:	95230300 	strls	r0, [r3, #-768]!	; 0x300
  if(adc_init_structure.ADC_CalEnable == TRUE)
    LPLD_ADC_Cal(adcx);  //进行ADC校准
  
  //设置ADCCFG1寄存器
  adcx->CFG1  &=   (~ADC_CFG1_ADLPC_MASK);         // 重新为正常使用进行配置
  adcx->CFG1  |=    ADC_CFG1_ADIV(ADIV_1)          // ADC输入时钟分频为 1
    20b4:	07c20c02 	strbeq	r0, [r2, r2, lsl #24]
                  | (time)                           // 设置长短时间采样模式
                  | ADC_CFG1_ADICLK(ADICLK_BUS_2)  // ADC输入时钟源为 BusClk
                  | ADC_CFG1_MODE(mode);           //设置ADC转换精度

  //设置ADCCFG2寄存器
  adcx->CFG2 &=  (~ADC_CFG2_ADACKEN_MASK);   //禁用异步时钟输出
    20b8:	71030000 	mrsvc	r0, (UNDEF: 3)
    20bc:	00002c11 	andeq	r2, r0, r1, lsl ip
    20c0:	96230300 	strtls	r0, [r3], -r0, lsl #6
  adcx->CFG2 |=    (muxab)                      // ADC复用选择
    20c4:	056b0c02 	strbeq	r0, [fp, #-3074]!	; 0xc02
                 | (ADC_CFG2_ADHSC_MASK)        // 高速转换
                 | ADC_CFG2_ADLSTS(ltime);    // 长采样时间时钟周期选择
    20c8:	72030000 	andvc	r0, r3, #0
    20cc:	00002c11 	andeq	r2, r0, r1, lsl ip
    20d0:	97230300 	strls	r0, [r3, -r0, lsl #6]!
    20d4:	07fd0c02 	ldrbeq	r0, [sp, r2, lsl #24]!
    20d8:	73030000 	movwvc	r0, #12288	; 0x3000
                  | ADC_CFG1_ADICLK(ADICLK_BUS_2)  // ADC输入时钟源为 BusClk
                  | ADC_CFG1_MODE(mode);           //设置ADC转换精度

  //设置ADCCFG2寄存器
  adcx->CFG2 &=  (~ADC_CFG2_ADACKEN_MASK);   //禁用异步时钟输出
  adcx->CFG2 |=    (muxab)                      // ADC复用选择
    20dc:	00002c11 	andeq	r2, r0, r1, lsl ip
                 | (ADC_CFG2_ADHSC_MASK)        // 高速转换
                 | ADC_CFG2_ADLSTS(ltime);    // 长采样时间时钟周期选择
                                              // 总采样周期见K60技术文档 page:840
  //用于设定阈值
  adcx->CV1  = 0x1234u ; 
    20e0:	98230300 	stmdals	r3!, {r8, r9}
    20e4:	07f40c02 	ldrbeq	r0, [r4, r2, lsl #24]!
  adcx->CV2  = 0x5678u ;
    20e8:	74030000 	strvc	r0, [r3], #-0
    20ec:	00002c11 	andeq	r2, r0, r1, lsl ip
 
  adcx->SC2  &= ((~ADC_SC2_ACFE_MASK)     //关闭比较功能 
    20f0:	99230300 	stmdbls	r3!, {r8, r9}
    20f4:	07eb0c02 	strbeq	r0, [fp, r2, lsl #24]!
    20f8:	75030000 	strvc	r0, [r3, #-0]
                 & (~ADC_SC2_DMAEN_MASK)); //关闭DMA
  adcx->SC2  |=  (hwtrg & ADC_SC2_ADTRG_MASK) //设置触发方式
    20fc:	00002c11 	andeq	r2, r0, r1, lsl ip
    2100:	9a230300 	bls	8c2d08 <__etext+0x8ba060>
    2104:	07e20c02 	strbeq	r0, [r2, r2, lsl #24]!
    2108:	76030000 	strvc	r0, [r3], -r0
    210c:	00002c11 	andeq	r2, r0, r1, lsl ip
                 |  ADC_SC2_ACREN_MASK          //使能范围比较
                 |  ADC_SC2_ACFGT_MASK          //使能大于比较功能
                 |  ADC_SC2_REFSEL(REFSEL_EXT); //选择外部参考源VREFH和VREFL
  
  if(adc_init_structure.ADC_DmaEnable == TRUE) 
    2110:	9b230300 	blls	8c2d18 <__etext+0x8ba070>
    2114:	0a080c02 	beq	205124 <__etext+0x1fc47c>
    adcx->SC2  |= ADC_SC2_DMAEN_MASK;           //使能DMA
    2118:	77030000 	strvc	r0, [r3, -r0]
    211c:	00002c11 	andeq	r2, r0, r1, lsl ip
    2120:	9c230300 	stcls	3, cr0, [r3], #-0

  adcx->SC3  &=  (~ADC_SC3_CAL_MASK)          //关闭校准
    2124:	09bc0c02 	ldmibeq	ip!, {r1, sl, fp}
    2128:	78030000 	stmdavc	r3, {}	; <UNPREDICTABLE>
    212c:	00002c11 	andeq	r2, r0, r1, lsl ip
                 & (~ADC_SC3_ADCO_MASK);         //选择一次转换
  adcx->SC3  |=  avg;                        //硬件平均
    2130:	9d230300 	stcls	3, cr0, [r3, #-0]
    2134:	080f0c02 	stmdaeq	pc, {r1, sl, fp}	; <UNPREDICTABLE>
    2138:	79030000 	stmdbvc	r3, {}	; <UNPREDICTABLE>
  
  adcx->PGA  = pga<<ADC_PGA_PGAG_SHIFT; 
    213c:	00002c11 	andeq	r2, r0, r1, lsl ip
    2140:	9e230300 	cdpls	3, 2, cr0, cr3, cr0, {0}
    2144:	08060c02 	stmdaeq	r6, {r1, sl, fp}
  
  //校准完毕后再重新初始化ADC寄存器
  //adcx->SC1[0] = ADC_SC1_ADCH(AD31);    //复位SC1
  adcx->SC1[hwtrg & 0x01] = diff;         //设置单端、差分输入
    2148:	7a030000 	bvc	c2150 <__etext+0xb94a8>
    214c:	00002c11 	andeq	r2, r0, r1, lsl ip
    2150:	9f230300 	svcls	0x00230300
    2154:	03520c02 	cmpeq	r2, #512	; 0x200
  
  if(isr_func!= NULL)
    2158:	7b030000 	blvc	c2160 <__etext+0xb94b8>
  {
    ADC_ISR[i] = isr_func;
    215c:	00087611 	andeq	r7, r8, r1, lsl r6
    2160:	a0230300 	eorge	r0, r3, r0, lsl #6
    2164:	43540e02 	cmpmi	r4, #32
    2168:	92030044 	andls	r0, r3, #68	; 0x44
  }
  
  return 1;
    216c:	00088711 	andeq	r8, r8, r1, lsl r7
}
    2170:	80230300 	eorhi	r0, r3, r0, lsl #6
    2174:	2c070020 	stccs	0, cr0, [r7], {32}
    2178:	76000000 	strvc	r0, [r0], -r0
    217c:	08000008 	stmdaeq	r0, {r3}
 * 输出:
 *    0--配置错误
 *    1--配置成功
 */
uint8 LPLD_ADC_Deinit(ADC_InitTypeDef adc_init_structure)
{
    2180:	000003ab 	andeq	r0, r0, fp, lsr #7
    2184:	2c0700c7 	stccs	0, cr0, [r7], {199}	; 0xc7
    2188:	87000000 	strhi	r0, [r0, -r0]
    218c:	10000008 	andne	r0, r0, r8
  ADC_MemMapPtr adcx = adc_init_structure.ADC_Adcx;
    2190:	000003ab 	andeq	r0, r0, fp, lsr #7
  uint8 hwtrg = adc_init_structure.ADC_HwTrgCfg;
    2194:	07000edf 			; <UNDEFINED> instruction: 0x07000edf
  
  adcx->SC1[hwtrg & 0x01] = ADC_SC1_ADCH(AD31);    //复位SC1
    2198:	00000464 	andeq	r0, r0, r4, ror #8
    219c:	00000897 	muleq	r0, r7, r8
    21a0:	0003ab08 	andeq	sl, r3, r8, lsl #22
    21a4:	11001f00 	tstne	r0, r0, lsl #30
  
  //配置ADC时钟
  if(adcx == ADC0)
    21a8:	00000511 	andeq	r0, r0, r1, lsl r5
    21ac:	a3119303 	tstge	r1, #201326592	; 0xc000000
    21b0:	12000008 	andne	r0, r0, #8
    21b4:	0008a904 	andeq	sl, r8, r4, lsl #18
  {
    SIM_SCGC6 &= ~(SIM_SCGC6_ADC0_MASK);   // 关闭ADC0时钟
    21b8:	04fe1300 	ldrbteq	r1, [lr], #768	; 0x300
    21bc:	31140000 	tstcc	r4, r0
    21c0:	10000014 	andne	r0, r0, r4, lsl r0
    21c4:	cb17c303 	blgt	5f2dd8 <__etext+0x5ea130>
    21c8:	0c000008 	stceq	0, cr0, [r0], {8}
    21cc:	000012a9 	andeq	r1, r0, r9, lsr #5
    21d0:	c217c403 	andsgt	ip, r7, #50331648	; 0x3000000
    21d4:	02000003 	andeq	r0, r0, #3
    21d8:	11000023 	tstne	r0, r3, lsr #32
    21dc:	0000153f 	andeq	r1, r0, pc, lsr r5
  }
  else if(adcx == ADC1)
    21e0:	d717c503 	ldrle	ip, [r7, -r3, lsl #10]
    21e4:	12000008 	andne	r0, r0, #8
    21e8:	0008dd04 	andeq	sp, r8, r4, lsl #26
    21ec:	08ae1300 	stmiaeq	lr!, {r8, r9, ip}
  {
    SIM_SCGC3 &= ~(SIM_SCGC3_ADC1_MASK);   // 关闭ADC1时钟
    21f0:	2c070000 	stccs	0, cr0, [r7], {-0}
    21f4:	f2000000 	vhadd.s8	d0, d0, d0
    21f8:	08000008 	stmdaeq	r0, {r3}
    21fc:	000003ab 	andeq	r0, r0, fp, lsr #7
    2200:	f8140017 			; <UNDEFINED> instruction: 0xf8140017
    2204:	18000008 	stmdane	r0, {r3}
    2208:	5a25bf03 	bpl	971e1c <__etext+0x969174>
    220c:	0c000009 	stceq	0, cr0, [r0], {9}
    2210:	00000a1c 	andeq	r0, r0, ip, lsl sl
    2214:	5e25c003 	cdppl	0, 2, cr12, cr5, cr3, {0}
  }
  else 
  {
    return 0;
    2218:	02000000 	andeq	r0, r0, #0
    221c:	f10c0023 			; <UNDEFINED> instruction: 0xf10c0023
  }
  
  return 1;
    2220:	03000002 	movweq	r0, #2
}
    2224:	005e25c1 	subseq	r2, lr, r1, asr #11
    2228:	23020000 	movwcs	r0, #8192	; 0x2000
    222c:	01340c04 	teqeq	r4, r4, lsl #24
 * 输出:
 *    AD通道转换值(右对齐)，若为差分转换结果，则为二进制补码格式(需强制转换为int16)
 *
 */
uint16 LPLD_ADC_Get(ADC_MemMapPtr adcx, AdcChnEnum_Type chn)
{
    2230:	c2030000 	andgt	r0, r3, #0
    2234:	00005e25 	andeq	r5, r0, r5, lsr #28
    2238:	08230200 	stmdaeq	r3!, {r9}
  adcx->SC1[0] &= ~(ADC_SC1_AIEN_MASK);
    223c:	0000670c 	andeq	r6, r0, ip, lsl #14
    2240:	25c30300 	strbcs	r0, [r3, #768]	; 0x300
    2244:	0000005e 	andeq	r0, r0, lr, asr r0
  adcx->SC1[0] &= ~(ADC_SC1_ADCH_MASK);
    2248:	0c0c2302 	stceq	3, cr2, [ip], {2}
    224c:	00000177 	andeq	r0, r0, r7, ror r1
    2250:	5e25c403 	cdppl	4, 2, cr12, cr5, cr3, {0}
  adcx->SC1[0] |= ADC_SC1_ADCH(chn);
    2254:	02000000 	andeq	r0, r0, #0
    2258:	2f0c1023 	svccs	0x000c1023
    225c:	03000005 	movweq	r0, #5
    2260:	005e25c5 	subseq	r2, lr, r5, asr #11
  while((adcx->SC1[0]&ADC_SC1_COCO_MASK) == 0); //等待转换完成  
    2264:	23020000 	movwcs	r0, #8192	; 0x2000
    2268:	57110014 			; <UNDEFINED> instruction: 0x57110014
    226c:	03000001 	movweq	r0, #1
    2270:	096625c6 	stmdbeq	r6!, {r1, r2, r6, r7, r8, sl, sp}^
  return adcx->R[0];
    2274:	04120000 	ldreq	r0, [r2], #-0
}
    2278:	0000096c 	andeq	r0, r0, ip, ror #18
    227c:	0008f213 	andeq	pc, r8, r3, lsl r2	; <UNPREDICTABLE>
    2280:	005e0700 	subseq	r0, lr, r0, lsl #14
 * 输出:
 *    无
 *
 */
void LPLD_ADC_EnableConversion(ADC_MemMapPtr adcx, AdcChnEnum_Type chn, uint8 ab, boolean irq)
{
    2284:	09810000 	stmibeq	r1, {}	; <UNPREDICTABLE>
    2288:	ab080000 	blge	202290 <__etext+0x1f95e8>
    228c:	1f000003 	svcne	0x00000003
    2290:	002c0700 	eoreq	r0, ip, r0, lsl #14
  if(irq == TRUE)
    2294:	09910000 	ldmibeq	r1, {}	; <UNPREDICTABLE>
  {
    adcx->SC1[ab] |= (ADC_SC1_AIEN_MASK);
    2298:	ab080000 	blge	2022a0 <__etext+0x1f95f8>
    229c:	00000003 	andeq	r0, r0, r3
    22a0:	12611400 	rsbne	r1, r1, #0
    22a4:	03cc0000 	biceq	r0, ip, #0
    22a8:	0a2e35a5 	beq	b8f944 <__etext+0xb86c9c>
  }
  adcx->SC1[ab] &= ~(ADC_SC1_ADCH_MASK);
    22ac:	500e0000 	andpl	r0, lr, r0
    22b0:	03005243 	movweq	r5, #579	; 0x243
    22b4:	097135a6 	ldmdbeq	r1!, {r1, r2, r5, r7, r8, sl, ip, sp}^
    22b8:	23020000 	movwcs	r0, #8192	; 0x2000
    22bc:	11110c00 	tstne	r1, r0, lsl #24
  adcx->SC1[ab] |= ADC_SC1_ADCH(chn);
    22c0:	a7030000 	strge	r0, [r3, -r0]
    22c4:	00005e35 	andeq	r5, r0, r5, lsr lr
    22c8:	80230300 	eorhi	r0, r3, r0, lsl #6
    22cc:	145a0c01 	ldrbne	r0, [sl], #-3073	; 0xc01
    22d0:	a8030000 	stmdage	r3, {}	; <UNPREDICTABLE>
    22d4:	00005e35 	andeq	r5, r0, r5, lsr lr
}
    22d8:	84230300 	strthi	r0, [r3], #-768	; 0x300
    22dc:	03120c01 	tsteq	r2, #256	; 0x100
    22e0:	a9030000 	stmdbge	r3, {}	; <UNPREDICTABLE>
 * 输出:
 *    AD通道转换值(右对齐)，若为差分转换结果，则为二进制补码格式(需强制转换为int16)
 *
 */
uint16 LPLD_ADC_GetResult(ADC_MemMapPtr adcx, uint8 ab)
{
    22e4:	0008e235 	andeq	lr, r8, r5, lsr r2
    22e8:	88230300 	stmdahi	r3!, {r8, r9}
    22ec:	12380c01 	eorsne	r0, r8, #256	; 0x100
  //参数检查
  return adcx->R[ab];
    22f0:	aa030000 	bge	c22f8 <__etext+0xb9650>
    22f4:	00005e35 	andeq	r5, r0, r5, lsr lr
    22f8:	a0230300 	eorge	r0, r3, r0, lsl #6
    22fc:	031d0c01 	tsteq	sp, #256	; 0x100
}
    2300:	ab030000 	blge	c2308 <__etext+0xb9660>
    2304:	0003b235 	andeq	fp, r3, r5, lsr r2
    2308:	a4230300 	strtge	r0, [r3], #-768	; 0x300
*    0--SC1A寄存器COCO位置1
*    1--SC1B寄存器COCO位置1
 *
 */
uint8 LPLD_ADC_GetSC1nCOCO(ADC_MemMapPtr adcx)
{
    230c:	126d0c01 	rsbne	r0, sp, #256	; 0x100
    2310:	ac030000 	stcge	0, cr0, [r3], {-0}
  if(adcx->SC1[0] & ADC_SC1_COCO_MASK)
    2314:	00005e35 	andeq	r5, r0, r5, lsr lr
    2318:	c0230300 	eorgt	r0, r3, r0, lsl #6
    231c:	114a0c01 	cmpne	sl, r1, lsl #24
    return 0;
    2320:	ad030000 	stcge	0, cr0, [r3, #-0]
    2324:	00005e35 	andeq	r5, r0, r5, lsr lr
  if(adcx->SC1[1] & ADC_SC1_COCO_MASK)
    2328:	c4230300 	strtgt	r0, [r3], #-768	; 0x300
    232c:	12950c01 	addsne	r0, r5, #256	; 0x100
    2330:	ae030000 	cdpge	0, 0, cr0, cr3, cr0, {0}
    return 1;
    2334:	00005e35 	andeq	r5, r0, r5, lsr lr
  return -1;
    2338:	c8230300 	stmdagt	r3!, {r8, r9}
}
    233c:	b1110001 	tstlt	r1, r1
    2340:	03000011 	movweq	r0, #17
    2344:	0a3a35af 	beq	e8fa08 <__etext+0xe86d60>
 *    0--配置错误
 *    1--配置成功
 *
 */
uint8 LPLD_ADC_EnableIrq(ADC_InitTypeDef adc_init_structure)
{
    2348:	04120000 	ldreq	r0, [r2], #-0
    234c:	00000a40 	andeq	r0, r0, r0, asr #20
    2350:	00099113 	andeq	r9, r9, r3, lsl r1
    2354:	10440f00 	subne	r0, r4, r0, lsl #30
  ADC_MemMapPtr adcx = adc_init_structure.ADC_Adcx;
    2358:	10700000 	rsbsne	r0, r0, r0
  
  if(adcx == ADC0)
    235c:	213d9503 	teqcs	sp, r3, lsl #10
    2360:	0c00000c 	stceq	0, cr0, [r0], {12}
    2364:	00001038 	andeq	r1, r0, r8, lsr r0
    2368:	5e3d9603 	cfmsuba32pl	mvax0, mvax9, mvfx13, mvfx3
    enable_irq(INT_ADC0 - 16);
    236c:	02000000 	andeq	r0, r0, #0
    2370:	020c0023 	andeq	r0, ip, #35	; 0x23
  else if(adcx == ADC1)
    2374:	0300000d 	movweq	r0, #13
    2378:	005e3d97 			; <UNDEFINED> instruction: 0x005e3d97
    237c:	23020000 	movwcs	r0, #8192	; 0x2000
    2380:	03120c04 	tsteq	r2, #1024	; 0x400
    enable_irq (INT_ADC1 - 16);
    2384:	98030000 	stmdals	r3, {}	; <UNPREDICTABLE>
    2388:	000c213d 	andeq	r2, ip, sp, lsr r1
  else
    return 0;
    238c:	08230200 	stmdaeq	r3!, {r9}
    2390:	00103e0c 	andseq	r3, r0, ip, lsl #28
  return 1;
    2394:	3d990300 	ldccc	3, cr0, [r9]
}
    2398:	0000005e 	andeq	r0, r0, lr, asr r0
    239c:	20842303 	addcs	r2, r4, r3, lsl #6
    23a0:	00031d0c 	andeq	r1, r3, ip, lsl #26
    23a4:	3d9a0300 	ldccc	3, cr0, [sl]
 *    0--配置错误
 *    1--配置成功
 *
 */
uint8 LPLD_ADC_DisableIrq(ADC_InitTypeDef adc_init_structure)
{
    23a8:	000003d2 	ldrdeq	r0, [r0], -r2
    23ac:	20882303 	addcs	r2, r8, r3, lsl #6
    23b0:	00104f0c 	andseq	r4, r0, ip, lsl #30
    23b4:	3d9b0300 	ldccc	3, cr0, [fp]
  ADC_MemMapPtr adcx = adc_init_structure.ADC_Adcx;
    23b8:	0000005e 	andeq	r0, r0, lr, asr r0
  
  if(adcx == ADC0)
    23bc:	208c2303 	addcs	r2, ip, r3, lsl #6
    23c0:	0010550c 	andseq	r5, r0, ip, lsl #10
    23c4:	3d9c0300 	ldccc	3, cr0, [ip]
    23c8:	0000005e 	andeq	r0, r0, lr, asr r0
      disable_irq(INT_ADC0 - 16);
    23cc:	20902303 	addscs	r2, r0, r3, lsl #6
    23d0:	00105b0c 	andseq	r5, r0, ip, lsl #22
  else if(adcx == ADC1)
    23d4:	3d9d0300 	ldccc	3, cr0, [sp]
    23d8:	0000005e 	andeq	r0, r0, lr, asr r0
    23dc:	20942303 	addscs	r2, r4, r3, lsl #6
    23e0:	0010610c 	andseq	r6, r0, ip, lsl #2
      disable_irq(INT_ADC1 - 16);
    23e4:	3d9e0300 	ldccc	3, cr0, [lr]
    23e8:	0000005e 	andeq	r0, r0, lr, asr r0
  else
    return 0;
    23ec:	20982303 	addscs	r2, r8, r3, lsl #6
    23f0:	000a9a0c 	andeq	r9, sl, ip, lsl #20

  return 1;
    23f4:	3d9f0300 	ldccc	3, cr0, [pc]	; 23fc <LPLD_ADC_DisableIrq+0x54>
}
    23f8:	000003e2 	andeq	r0, r0, r2, ror #7
    23fc:	209c2303 	addscs	r2, ip, r3, lsl #6
    2400:	000c640c 	andeq	r6, ip, ip, lsl #8
    2404:	3da00300 	stccc	3, cr0, [r0]
 *    0--配置错误
 *    1--配置成功
 *
 */
uint8 LPLD_ADC_Chn_Enable(ADC_MemMapPtr adcx, AdcChnEnum_Type chn)
{
    2408:	0000005e 	andeq	r0, r0, lr, asr r0
    240c:	20a42303 	adccs	r2, r4, r3, lsl #6
    2410:	000c690c 	andeq	r6, ip, ip, lsl #18
  //判断复用引脚是a或b
  uint8 mux = (adcx->CFG2 & ADC_CFG2_MUXSEL_MASK)>>ADC_CFG2_MUXSEL_SHIFT;
    2414:	3da10300 	stccc	3, cr0, [r1]
    2418:	0000005e 	andeq	r0, r0, lr, asr r0
    241c:	20a82303 	adccs	r2, r8, r3, lsl #6
    2420:	000c6f0c 	andeq	r6, ip, ip, lsl #30
    
  if(chn > AD30)
    2424:	3da20300 	stccc	3, cr0, [r2]
    return 0;
    2428:	0000005e 	andeq	r0, r0, lr, asr r0
    242c:	20ac2303 	adccs	r2, ip, r3, lsl #6
  
  //不同的通道对应不同的引脚，因此需要判断并配置
  if(adcx == ADC0)
    2430:	000c750c 	andeq	r7, ip, ip, lsl #10
    2434:	3da30300 	stccc	3, cr0, [r3]
    2438:	0000005e 	andeq	r0, r0, lr, asr r0
    243c:	20b02303 	adcscs	r2, r0, r3, lsl #6
  {
    switch(chn)
    2440:	000c7b0c 	andeq	r7, ip, ip, lsl #22
    2444:	3da40300 	stccc	3, cr0, [r4]
    2448:	0000005e 	andeq	r0, r0, lr, asr r0
    244c:	20b42303 	adcscs	r2, r4, r3, lsl #6
    2450:	000c810c 	andeq	r8, ip, ip, lsl #2
    2454:	3da50300 	stccc	3, cr0, [r5]
    2458:	0000005e 	andeq	r0, r0, lr, asr r0
    245c:	20b82303 	adcscs	r2, r8, r3, lsl #6
    2460:	000c870c 	andeq	r8, ip, ip, lsl #14
    2464:	3da60300 	stccc	3, cr0, [r6]
    2468:	0000005e 	andeq	r0, r0, lr, asr r0
    246c:	20bc2303 	adcscs	r2, ip, r3, lsl #6
    2470:	000c8d0c 	andeq	r8, ip, ip, lsl #26
    2474:	3da70300 	stccc	3, cr0, [r7]
    2478:	0000005e 	andeq	r0, r0, lr, asr r0
    247c:	20c02303 	sbccs	r2, r0, r3, lsl #6
    2480:	000fec0c 	andeq	lr, pc, ip, lsl #24
    2484:	3da80300 	stccc	3, cr0, [r8]
    2488:	0000005e 	andeq	r0, r0, lr, asr r0
    248c:	20c42303 	sbccs	r2, r4, r3, lsl #6
    2490:	000ff40c 	andeq	pc, pc, ip, lsl #8
    2494:	3da90300 	stccc	3, cr0, [r9]
    2498:	0000005e 	andeq	r0, r0, lr, asr r0
    249c:	20c82303 	sbccs	r2, r8, r3, lsl #6
    24a0:	000f290c 	andeq	r2, pc, ip, lsl #18
    24a4:	3daa0300 	stccc	3, cr0, [sl]
    24a8:	0000005e 	andeq	r0, r0, lr, asr r0
    24ac:	20cc2303 	sbccs	r2, ip, r3, lsl #6
    24b0:	000f2f0c 	andeq	r2, pc, ip, lsl #30
    24b4:	3dab0300 	stccc	3, cr0, [fp]
    24b8:	0000005e 	andeq	r0, r0, lr, asr r0
    24bc:	20d02303 	sbcscs	r2, r0, r3, lsl #6
    24c0:	000bcb0c 	andeq	ip, fp, ip, lsl #22
    24c4:	3dac0300 	stccc	3, cr0, [ip]
      case DAD1:   //ADC0_DP1 -- PGA2_DP
      case DAD2:   //PGA0_DP
      case DAD3:   //ADC0_DP3 -- PGA1_DP
        break;
      case AD4:   //ADC0_SE4b -- PTC2     
        if(mux == 1)    //b
    24c8:	0000005e 	andeq	r0, r0, lr, asr r0
    24cc:	20d42303 	sbcscs	r2, r4, r3, lsl #6
          PORTC->PCR[2] =  PORT_PCR_MUX(0);
    24d0:	000e090c 	andeq	r0, lr, ip, lsl #18
    24d4:	3dad0300 	stccc	3, cr0, [sp]
    24d8:	0000005e 	andeq	r0, r0, lr, asr r0
    24dc:	20d82303 	sbcscs	r2, r8, r3, lsl #6
        break;
      case AD5:   //ADC0_SE5b -- PTD1     
        if(mux == 1)    //b
    24e0:	000e0f0c 	andeq	r0, lr, ip, lsl #30
    24e4:	3dae0300 	stccc	3, cr0, [lr]
          PORTD->PCR[1] =  PORT_PCR_MUX(0);
    24e8:	0000005e 	andeq	r0, r0, lr, asr r0
    24ec:	20dc2303 	sbcscs	r2, ip, r3, lsl #6
    24f0:	000bd00c 	andeq	sp, fp, ip
    24f4:	3daf0300 	stccc	3, cr0, [pc]	; 24fc <LPLD_ADC_Chn_Enable+0xf4>
        break;
      case AD6:   //ADC0_SE6b -- PTD5
      case AD7:   //ADC0_SE7b -- PTD6     
        if(mux == 1)    //b
    24f8:	0000005e 	andeq	r0, r0, lr, asr r0
    24fc:	20e02303 	rsccs	r2, r0, r3, lsl #6
          PORTD->PCR[chn-1] =  PORT_PCR_MUX(0);
    2500:	0003310c 	andeq	r3, r3, ip, lsl #2
    2504:	3db00300 	ldccc	3, cr0, [r0]
    2508:	000003d2 	ldrdeq	r0, [r0], -r2
    250c:	20e42303 	rsccs	r2, r4, r3, lsl #6
    2510:	000e9f0c 	andeq	r9, lr, ip, lsl #30
    2514:	3db10300 	ldccc	3, cr0, [r1]
        break;
      case AD8:  //ADC0_SE8 -- PTB0
      case AD9:  //ADC0_SE9 -- PTB1
        PORTB->PCR[chn-8] =  PORT_PCR_MUX(0);
    2518:	0000005e 	andeq	r0, r0, lr, asr r0
    251c:	20e82303 	rsccs	r2, r8, r3, lsl #6
    2520:	52434d0e 	subpl	r4, r3, #896	; 0x380
    2524:	3db20300 	ldccc	3, cr0, [r2]
    2528:	0000005e 	andeq	r0, r0, lr, asr r0
    252c:	20ec2303 	rsccs	r2, ip, r3, lsl #6
        break;
      case AD10:  //ADC0_SE10 -- PTA7
      case AD11:  //ADC0_SE11 -- PTA8
        PORTA->PCR[chn-3] =  PORT_PCR_MUX(0);
    2530:	002c0700 	eoreq	r0, ip, r0, lsl #14
    2534:	0c320000 	ldceq	0, cr0, [r2], #-0
    2538:	ab100000 	blge	402540 <__etext+0x3f9898>
    253c:	fb000003 	blx	2552 <LPLD_ADC_Chn_Enable+0x14a>
    2540:	4711000f 	ldrmi	r0, [r1, -pc]
    2544:	0300000f 	movweq	r0, #15
        break;
      case AD12:  //ADC0_SE12 -- PTB2
      case AD13:  //ADC0_SE13 -- PTB3
        PORTB->PCR[chn-10] =  PORT_PCR_MUX(0);
    2548:	0c3e3db3 	ldceq	13, cr3, [lr], #-716	; 0xfffffd34
    254c:	04120000 	ldreq	r0, [r2], #-0
    2550:	00000c44 	andeq	r0, r0, r4, asr #24
    2554:	000a4513 	andeq	r4, sl, r3, lsl r5
    2558:	03010900 	movweq	r0, #6400	; 0x1900
    255c:	0c6b43d2 	stcleq	3, cr4, [fp], #-840	; 0xfffffcb8
        break;
      case AD14:  //ADC0_SE14 -- PTC0
      case AD15:  //ADC0_SE15 -- PTC1
        PORTC->PCR[chn-14] =  PORT_PCR_MUX(0);
    2560:	230a0000 	movwcs	r0, #40960	; 0xa000
    2564:	0300000d 	movweq	r0, #13
    2568:	002c43d3 	ldrdeq	r4, [ip], -r3	; <UNPREDICTABLE>
    256c:	320a0000 	andcc	r0, sl, #0
    2570:	0300000d 	movweq	r0, #13
    2574:	002c43d4 	ldrdeq	r4, [ip], -r4	; <UNPREDICTABLE>
        break;
      case AD16:   //ADC0_SE16
        break;
      case AD17:   //ADC0_SE17 -- PTE24
      case AD18:   //ADC0_SE18 -- PTE25
        PORTE->PCR[chn+7] =  PORT_PCR_MUX(0);
    2578:	14000000 	strne	r0, [r0], #-0
    257c:	0000102c 	andeq	r1, r0, ip, lsr #32
    2580:	43b60332 			; <UNDEFINED> instruction: 0x43b60332
    2584:	00000f50 	andeq	r0, r0, r0, asr pc
    2588:	4844420e 	stmdami	r4, {r1, r2, r3, r9, lr}^
    258c:	43b70300 			; <UNDEFINED> instruction: 0x43b70300
        break;
    2590:	0000002c 	andeq	r0, r0, ip, lsr #32
      case AD27:   //Bandgap (S.E)
      case AD29:   //VREFH (S.E)
      case AD30:   //VREFL
        break;
      default:
        return 0;  
    2594:	0e002302 	cdpeq	3, 0, cr2, cr0, cr2, {0}
    }
  }
  else if(adcx == ADC1)
    2598:	004c4442 	subeq	r4, ip, r2, asr #8
    259c:	2c43b803 	mcrrcs	8, 0, fp, r3, cr3
    25a0:	02000000 	andeq	r0, r0, #0
    25a4:	430e0123 	movwmi	r0, #57635	; 0xe123
  {
    switch(chn)
    25a8:	b9030031 	stmdblt	r3, {r0, r4, r5}
    25ac:	00002c43 	andeq	r2, r0, r3, asr #24
    25b0:	02230200 	eoreq	r0, r3, #0
    25b4:	0032430e 	eorseq	r4, r2, lr, lsl #6
    25b8:	2c43ba03 	mcrrcs	10, 0, fp, r3, cr3
    25bc:	02000000 	andeq	r0, r0, #0
    25c0:	530e0323 	movwpl	r0, #58147	; 0xe323
    25c4:	bb030031 	bllt	c2690 <__etext+0xb99e8>
    25c8:	00002c43 	andeq	r2, r0, r3, asr #24
    25cc:	04230200 	strteq	r0, [r3], #-512	; 0x200
    25d0:	0032530e 	eorseq	r5, r2, lr, lsl #6
    25d4:	2c43bc03 	mcrrcs	12, 0, fp, r3, cr3
    25d8:	02000000 	andeq	r0, r0, #0
    25dc:	430e0523 	movwmi	r0, #58659	; 0xe523
    25e0:	bd030033 	stclt	0, cr0, [r3, #-204]	; 0xffffff34
    25e4:	00002c43 	andeq	r2, r0, r3, asr #24
    25e8:	06230200 	strteq	r0, [r3], -r0, lsl #4
    25ec:	0300440e 	movweq	r4, #1038	; 0x40e
    25f0:	002c43be 			; <UNDEFINED> instruction: 0x002c43be
    25f4:	23020000 	movwcs	r0, #8192	; 0x2000
    25f8:	414d0e07 	cmpmi	sp, r7, lsl #28
    25fc:	bf030031 	svclt	0x00030031
    2600:	00002c43 	andeq	r2, r0, r3, asr #24
    2604:	08230200 	stmdaeq	r3!, {r9}
    2608:	32414d0e 	subcc	r4, r1, #896	; 0x380
    260c:	43c00300 	bicmi	r0, r0, #0
    2610:	0000002c 	andeq	r0, r0, ip, lsr #32
    2614:	0e092302 	cdpeq	3, 0, cr2, cr9, cr2, {0}
    2618:	03003443 	movweq	r3, #1091	; 0x443
    261c:	002c43c1 	eoreq	r4, ip, r1, asr #7
    2620:	23020000 	movwcs	r0, #8192	; 0x2000
    2624:	35430e0a 	strbcc	r0, [r3, #-3594]	; 0xe0a
    2628:	43c20300 	bicmi	r0, r2, #0
    262c:	0000002c 	andeq	r0, r0, ip, lsr #32
    2630:	0e0b2302 	cdpeq	3, 0, cr2, cr11, cr2, {0}
        break;
      case AD4:   //ADC1_SE4a -- PTE0     //ADC1_SE4b -- PTC8
      case AD5:   //ADC1_SE5a -- PTE1     //ADC1_SE5b -- PTC9
      case AD6:   //ADC1_SE6a -- PTE2     //ADC1_SE6b -- PTC10
      case AD7:   //ADC1_SE7a -- PTE3     //ADC1_SE7b -- PTC11
        if(mux == 0)    //a
    2634:	03004445 	movweq	r4, #1093	; 0x445
    2638:	002c43c3 	eoreq	r4, ip, r3, asr #7
          PORTE->PCR[chn-4] =  PORT_PCR_MUX(0);
    263c:	23020000 	movwcs	r0, #8192	; 0x2000
    2640:	0c570c0c 	mrrceq	12, 0, r0, r7, cr12
    2644:	c4030000 	strgt	r0, [r3], #-0
    2648:	00002c43 	andeq	r2, r0, r3, asr #24
    264c:	0d230200 	sfmeq	f0, 4, [r3, #-0]
        else            //b
          PORTC->PCR[chn+4] =  PORT_PCR_MUX(0);
        break;
    2650:	0052490e 	subseq	r4, r2, lr, lsl #18
      case AD6:   //ADC1_SE6a -- PTE2     //ADC1_SE6b -- PTC10
      case AD7:   //ADC1_SE7a -- PTE3     //ADC1_SE7b -- PTC11
        if(mux == 0)    //a
          PORTE->PCR[chn-4] =  PORT_PCR_MUX(0);
        else            //b
          PORTC->PCR[chn+4] =  PORT_PCR_MUX(0);
    2654:	2c43c503 	cfstr64cs	mvdx12, [r3], {3}
    2658:	02000000 	andeq	r0, r0, #0
    265c:	120c0e23 	andne	r0, ip, #560	; 0x230
    2660:	03000003 	movweq	r0, #3
    2664:	098143c6 	stmibeq	r1, {r1, r2, r6, r7, r8, r9, lr}
        break;
    2668:	23020000 	movwcs	r0, #8192	; 0x2000
      case AD8:  //ADC1_SE8 -- PTB0
      case AD9:  //ADC1_SE9 -- PTB1
        PORTB->PCR[chn-8] =  PORT_PCR_MUX(0);
    266c:	0bb50c0f 	bleq	fed456b0 <__StackLimit+0xded456b0>
    2670:	c7030000 	strgt	r0, [r3, -r0]
    2674:	00002c43 	andeq	r2, r0, r3, asr #24
    2678:	10230200 	eorne	r0, r3, r0, lsl #4
    267c:	000f980c 	andeq	r9, pc, ip, lsl #16
        break;
    2680:	43c80300 	bicmi	r0, r8, #0
      case AD10:  //ADC1_SE10 -- PTB4
      case AD11:  //ADC1_SE11 -- PTB5
      case AD12:  //ADC1_SE12 -- PTB6
      case AD13:  //ADC1_SE13 -- PTB7
        PORTB->PCR[chn-6] =  PORT_PCR_MUX(0);
    2684:	0000002c 	andeq	r0, r0, ip, lsr #32
    2688:	0c112302 	ldceq	3, cr2, [r1], {2}
    268c:	00000b77 	andeq	r0, r0, r7, ror fp
    2690:	2c43c903 	mcrrcs	9, 0, ip, r3, cr3
    2694:	02000000 	andeq	r0, r0, #0
        break;
    2698:	a80c1223 	stmdage	ip, {r0, r1, r5, r9, ip}
      case AD14:  //ADC1_SE14 -- PTB10
      case AD15:  //ADC1_SE15 -- PTB11
        PORTB->PCR[chn-4] =  PORT_PCR_MUX(0);
    269c:	0300000b 	movweq	r0, #11
    26a0:	002c43ca 	eoreq	r4, ip, sl, asr #7
    26a4:	23020000 	movwcs	r0, #8192	; 0x2000
    26a8:	0b9b0c13 	bleq	fe6c56fc <__StackLimit+0xde6c56fc>
    26ac:	cb030000 	blgt	c26b4 <__etext+0xb9a0c>
        break;
    26b0:	00002c43 	andeq	r2, r0, r3, asr #24
      case AD16:   //ADC1_SE16
        break;
      case AD17:  //ADC1_SE17 -- PTA17
        PORTA->PCR[chn] =  PORT_PCR_MUX(0);
    26b4:	14230200 	strtne	r0, [r3], #-512	; 0x200
    26b8:	000fb30c 	andeq	fp, pc, ip, lsl #6
    26bc:	43cc0300 	bicmi	r0, ip, #0
    26c0:	0000002c 	andeq	r0, r0, ip, lsr #32
        break;
    26c4:	0c152302 	ldceq	3, cr2, [r5], {2}
      case AD27:   //Bandgap (S.E)
      case AD29:   //VREFH (S.E)
      case AD30:   //VREFL
        break;
      default:
        return 0;  
    26c8:	00000f97 	muleq	r0, r7, pc	; <UNPREDICTABLE>
    26cc:	2c43cd03 	mcrrcs	13, 0, ip, r3, cr3
    }
  }
  else
  {
    return 0;
    26d0:	02000000 	andeq	r0, r0, #0
    {
      case DAD0:   //ADC0_DP0 -- PGA0_DP
      case DAD1:   //ADC0_DP1 -- PGA2_DP
      case DAD2:   //PGA0_DP
      case DAD3:   //ADC0_DP3 -- PGA1_DP
        break;
    26d4:	1d0c1623 	stcne	6, cr1, [ip, #-140]	; 0xffffff74
      case AD4:   //ADC0_SE4b -- PTC2     
        if(mux == 1)    //b
          PORTC->PCR[2] =  PORT_PCR_MUX(0);
        break;
    26d8:	03000003 	movweq	r0, #3
      case AD5:   //ADC0_SE5b -- PTD1     
        if(mux == 1)    //b
          PORTD->PCR[1] =  PORT_PCR_MUX(0);
        break;
    26dc:	098143ce 	stmibeq	r1, {r1, r2, r3, r6, r7, r8, r9, lr}
      case AD6:   //ADC0_SE6b -- PTD5
      case AD7:   //ADC0_SE7b -- PTD6     
        if(mux == 1)    //b
          PORTD->PCR[chn-1] =  PORT_PCR_MUX(0);
        break;
    26e0:	23020000 	movwcs	r0, #8192	; 0x2000
    {
      case DAD0:   //ADC1_DP0 -- PGA1_DP
      case DAD1:   //ADC1_DP1 -- PGA3_DP
      case DAD2:   //PGA1_DP 
      case DAD3:   //ADC1_DP3 -- PGA0_DP
        break;
    26e4:	0fc80c17 	svceq	0x00c80c17
  else
  {
    return 0;
  }
  
  return 1;
    26e8:	cf030000 	svcgt	0x00030000
}
    26ec:	00002c43 	andeq	r2, r0, r3, asr #24
    26f0:	18230200 	stmdane	r3!, {r9}
    26f4:	000c5d0c 	andeq	r5, ip, ip, lsl #26
 * 输出:
 *    0--配置错误
 *    1--配置成功
 */
static uint8 LPLD_ADC_Cal(ADC_MemMapPtr adcx)
{
    26f8:	43d00300 	bicsmi	r0, r0, #0
    26fc:	0000002c 	andeq	r0, r0, ip, lsr #32
  //32次硬件平均、ADCK不超过4MHz
  //参考高=Vdda、正常功耗模式
  //可忽略的配置：
  //输入通道、转换模式连续功能、比较功能、精度、差分单端
  //设置ADCCFG1寄存器
  adcx->CFG1  &= (~ADC_CFG1_ADLPC_MASK);          // 正常功耗配置
    2700:	0c192302 	ldceq	3, cr2, [r9], {2}
    2704:	000010a9 	andeq	r1, r0, r9, lsr #1
    2708:	2c43d103 	stfcsp	f5, [r3], {3}
  adcx->CFG1  |=  ADC_CFG1_ADIV(ADIV_8)          // ADC输入时钟分频为8
    270c:	02000000 	andeq	r0, r0, #0
    2710:	490d1a23 	stmdbmi	sp, {r0, r1, r5, r9, fp, ip}
    2714:	0200000c 	andeq	r0, r0, #12
                  | ADC_CFG1_ADLSMP_MASK           // 设置长时间采样模式
                  | ADC_CFG1_ADICLK(ADICLK_BUS_2); // ADC输入时钟源为 BusClk/2

  adcx->CFG2  &= (~ADC_CFG2_ADACKEN_MASK);
    2718:	320c1b23 	andcc	r1, ip, #35840	; 0x8c00
    271c:	0300000c 	movweq	r0, #12
    2720:	002c43d6 	ldrdeq	r4, [ip], -r6	; <UNPREDICTABLE>
  adcx->CFG1  |=  ADC_CFG2_ADHSC_MASK         // 高速转换
    2724:	23020000 	movwcs	r0, #8192	; 0x2000
    2728:	0b520c1c 	bleq	14857a0 <__etext+0x147caf8>
    272c:	d7030000 	strle	r0, [r3, -r0]
                 | ADC_CFG2_ADLSTS(LSAMTIME_20EX); // 长采样时间时钟周期选择 额外20个时钟周期，共24个ADCK周期
                                               // 总采样周期见K60技术文档 page:840
  //用于设定阈值
  adcx->CV1  = 0x1234u ; 
    2730:	00002c43 	andeq	r2, r0, r3, asr #24
    2734:	1d230200 	sfmne	f0, 4, [r3, #-0]
  adcx->CV2  = 0x5678u ;
    2738:	000be80c 	andeq	lr, fp, ip, lsl #16
    273c:	43d80300 	bicsmi	r0, r8, #0
  
  adcx->SC2 &=  (~ADC_SC2_ADTRG_MASK);        //使能软件触发作为校准
    2740:	0000002c 	andeq	r0, r0, ip, lsr #32
    2744:	0c1e2302 	ldceq	3, cr2, [lr], {2}
    2748:	00000bd5 	ldrdeq	r0, [r0], -r5
  adcx->SC2 |=  ADC_SC2_REFSEL(REFSEL_EXT);  //选择外部参考源VREFH和VREFL
    274c:	2c43d903 	mcrrcs	9, 0, sp, r3, cr3
    2750:	02000000 	andeq	r0, r0, #0
    
  adcx->SC3 &= ( ~ADC_SC3_ADCO_MASK & ~ADC_SC3_AVGS_MASK );  //设置单次转换，清除平均标志
    2754:	9a0c1f23 	bls	30a3e8 <__etext+0x301740>
    2758:	0300000a 	movweq	r0, #10
    275c:	098143da 	stmibeq	r1, {r1, r3, r4, r6, r7, r8, r9, lr}
  adcx->SC3 |= ( ADC_SC3_AVGE_MASK | ADC_SC3_AVGS(HW_32AVG) );//打开平均标志，设置到最大采样平准
    2760:	23020000 	movwcs	r0, #8192	; 0x2000
    2764:	36430e20 	strbcc	r0, [r3], -r0, lsr #28
    2768:	43db0300 	bicsmi	r0, fp, #0
  
  adcx->SC3 |= ADC_SC3_CAL_MASK ;                            //开始校准
    276c:	0000002c 	andeq	r0, r0, ip, lsr #32
    2770:	0c212302 	stceq	3, cr2, [r1], #-8
    2774:	00000f24 	andeq	r0, r0, r4, lsr #30
  
  while((adcx->SC1[0] & ADC_SC1_COCO_MASK)== 0x00 );         //等待校准完成
    2778:	2c43dc03 	mcrrcs	12, 0, sp, r3, cr3
    277c:	02000000 	andeq	r0, r0, #0
    2780:	270c2223 	strcs	r2, [ip, -r3, lsr #4]
    2784:	03000010 	movweq	r0, #16
  	
  if ((adcx->SC3& ADC_SC3_CALF_MASK) == ADC_SC3_CALF_MASK )
    2788:	002c43dd 	ldrdeq	r4, [ip], -sp	; <UNPREDICTABLE>
    278c:	23020000 	movwcs	r0, #8192	; 0x2000
    2790:	31420e23 	cmpcc	r2, r3, lsr #28
  {  
   return 0;    //检查到校准错误，返回错误
    2794:	de030054 	mcrle	0, 0, r0, cr3, cr4, {2}
  }
  // Calculate plus-side calibration
  cal_var  = 0x00;
    2798:	00002c43 	andeq	r2, r0, r3, asr #24
    279c:	24230200 	strtcs	r0, [r3], #-512	; 0x200
  cal_var  = adcx->CLP0;       
    27a0:	000b3a0c 	andeq	r3, fp, ip, lsl #20
  cal_var += adcx->CLP1;      
    27a4:	43df0300 	bicsmi	r0, pc, #0
    27a8:	0000002c 	andeq	r0, r0, ip, lsr #32
    27ac:	0c252302 	stceq	3, cr2, [r5], #-8
  cal_var += adcx->CLP2;      
    27b0:	00000b3f 	andeq	r0, r0, pc, lsr fp
    27b4:	2c43e003 	mcrrcs	0, 0, lr, r3, cr3
    27b8:	02000000 	andeq	r0, r0, #0
  cal_var += adcx->CLP3;      
    27bc:	500e2623 	andpl	r2, lr, r3, lsr #12
    27c0:	03004552 	movweq	r4, #1362	; 0x552
    27c4:	002c43e1 	eoreq	r4, ip, r1, ror #7
  cal_var += adcx->CLP4;      
    27c8:	23020000 	movwcs	r0, #8192	; 0x2000
    27cc:	50540e27 	subspl	r0, r4, r7, lsr #28
    27d0:	e203004c 	and	r0, r3, #76	; 0x4c
  cal_var += adcx->CLPS;      
    27d4:	00002c43 	andeq	r2, r0, r3, asr #24
    27d8:	28230200 	stmdacs	r3!, {r9}
    27dc:	0045490e 	subeq	r4, r5, lr, lsl #18
  cal_var  = cal_var/2;
    27e0:	2c43e303 	mcrrcs	3, 0, lr, r3, cr3
    27e4:	02000000 	andeq	r0, r0, #0
  cal_var |= 0x8000; // Set MSB
    27e8:	570e2923 	strpl	r2, [lr, -r3, lsr #18]
    27ec:	e4030042 	str	r0, [r3], #-66	; 0x42
    27f0:	00002c43 	andeq	r2, r0, r3, asr #24
  
  adcx->PG = ADC_PG_PG(cal_var);
    27f4:	2a230200 	bcs	8c2ffc <__etext+0x8ba354>
    27f8:	0033530e 	eorseq	r5, r3, lr, lsl #6

  // Calculate minus-side calibration
  cal_var = 0x00;
    27fc:	2c43e503 	cfstr64cs	mvdx14, [r3], {3}
  cal_var =  adcx->CLM0; 
    2800:	02000000 	andeq	r0, r0, #0
    2804:	530e2b23 	movwpl	r2, #60195	; 0xeb23
  cal_var += adcx->CLM1;
    2808:	e6030034 			; <UNDEFINED> instruction: 0xe6030034
    280c:	00002c43 	andeq	r2, r0, r3, asr #24
    2810:	2c230200 	sfmcs	f0, 4, [r3], #-0
  cal_var += adcx->CLM2;
    2814:	4c50520e 	lfmmi	f5, 2, [r0], {14}
    2818:	43e70300 	mvnmi	r0, #0
    281c:	0000002c 	andeq	r0, r0, ip, lsr #32
  cal_var += adcx->CLM3;
    2820:	0c2d2302 	stceq	3, cr2, [sp], #-8
    2824:	00000f1e 	andeq	r0, r0, lr, lsl pc
    2828:	2c43e803 	mcrrcs	8, 0, lr, r3, cr3
  cal_var += adcx->CLM4;
    282c:	02000000 	andeq	r0, r0, #0
    2830:	430e2e23 	movwmi	r2, #60963	; 0xee23
    2834:	03005750 	movweq	r5, #1872	; 0x750
  cal_var += adcx->CLMS;
    2838:	002c43e9 	eoreq	r4, ip, r9, ror #7
    283c:	23020000 	movwcs	r0, #8192	; 0x2000
    2840:	10070c2f 	andne	r0, r7, pc, lsr #24
  cal_var = cal_var/2;
    2844:	ea030000 	b	c284c <__etext+0xb9ba4>
    2848:	00002c43 	andeq	r2, r0, r3, asr #24
  cal_var |= 0x8000; // Set MSB
    284c:	30230200 	eorcc	r0, r3, r0, lsl #4
    2850:	000e040c 	andeq	r0, lr, ip, lsl #8
    2854:	43eb0300 	mvnmi	r0, #0

  adcx->MG   = ADC_MG_MG(cal_var); 
    2858:	0000002c 	andeq	r0, r0, ip, lsr #32
  adcx->SC3 &= ~ADC_SC3_CAL_MASK ; //清除校验标志
    285c:	00312302 	eorseq	r2, r1, r2, lsl #6
    2860:	000c0311 	andeq	r0, ip, r1, lsl r3
    2864:	43ec0300 	mvnmi	r0, #0
  
  return 1;
    2868:	00000f5c 	andeq	r0, r0, ip, asr pc
}
    286c:	0f620412 	svceq	0x00620412
    2870:	6b130000 	blvs	4c2878 <__etext+0x4b9bd0>
    2874:	0300000c 	movweq	r0, #12
 * 与启动文件startup_K60.s中的中断向量表关联
 * 用户无需修改，程序自动进入对应通道中断函数
 */

void ADC0_IRQHandler(void)
{
    2878:	00000483 	andeq	r0, r0, r3, lsl #9
    ADC_ISR[0]();
    287c:	00371b04 	eorseq	r1, r7, r4, lsl #22
    2880:	e0030000 	and	r0, r3, r0
    2884:	04000012 	streq	r0, [r0], #-18
}
    2888:	0000501c 	andeq	r5, r0, ip, lsl r0

void ADC1_IRQHandler(void)
{
    288c:	1d7b0300 	ldclne	3, cr0, [fp, #-0]
    ADC_ISR[1]();
    2890:	1d040000 	stcne	0, cr0, [r4, #-0]
    2894:	00000069 	andeq	r0, r0, r9, rrx
    2898:	0012e103 	andseq	lr, r2, r3, lsl #2
}
    289c:	3e200400 	cdpcc	4, 2, cr0, cr0, cr0, {0}
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_DMA_Init(DMA_InitTypeDef dma_init_struct)
{
    28a0:	02000000 	andeq	r0, r0, #0
    28a4:	06690404 	strbteq	r0, [r9], -r4, lsl #8
    28a8:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
    28ac:	000a8704 	andeq	r8, sl, r4, lsl #14
  uint8 chx = dma_init_struct.DMA_CHx;
    28b0:	0dc80300 	stcleq	3, cr0, [r8]
    28b4:	2e040000 	cdpcs	0, 0, cr0, cr4, cr0, {0}
  uint8 req = dma_init_struct.DMA_Req;
    28b8:	00000037 	andeq	r0, r0, r7, lsr r0
    28bc:	0014a115 	andseq	sl, r4, r5, lsl r1
  boolean periodic_trigg = dma_init_struct.DMA_PeriodicTriggerEnable;
    28c0:	0f050400 	svceq	0x00050400
    28c4:	000010d9 	ldrdeq	r1, [r0], -r9
  uint16 major_cnt = dma_init_struct.DMA_MajorLoopCnt;
    28c8:	00149706 	andseq	r9, r4, r6, lsl #14
  uint32 minor_cnt = dma_init_struct.DMA_MinorByteCnt;
    28cc:	df060100 	svcle	0x00060100
  uint32 src_addr = dma_init_struct.DMA_SourceAddr;
    28d0:	02000010 	andeq	r0, r0, #16
  uint8 src_dsize = dma_init_struct.DMA_SourceDataSize;
    28d4:	0010e906 	andseq	lr, r0, r6, lsl #18
    28d8:	f3060400 	vshl.u8	d0, d0, d6
  int16 src_addroffset = dma_init_struct.DMA_SourceAddrOffset;
    28dc:	08000010 	stmdaeq	r0, {r4}
  int32 src_lastadj = dma_init_struct.DMA_LastSourceAddrAdj;
    28e0:	00137806 	andseq	r7, r3, r6, lsl #16
  uint32 dst_addr = dma_init_struct.DMA_DestAddr;
    28e4:	fd061000 	stc2	0, cr1, [r6, #-0]
  uint8 dst_dsize = dma_init_struct.DMA_DestDataSize;
    28e8:	20000010 	andcs	r0, r0, r0, lsl r0
    28ec:	00110706 	andseq	r0, r1, r6, lsl #14
  int16 dst_addroffset = dma_init_struct.DMA_DestAddrOffset;
    28f0:	0600c000 	streq	ip, [r0], -r0
  int32 dst_lastadj = dma_init_struct.DMA_LastDestAddrAdj;
    28f4:	00001382 	andeq	r1, r0, r2, lsl #7
  boolean auto_disable = dma_init_struct.DMA_AutoDisableReq;
    28f8:	8c060180 	stfhis	f0, [r6], {128}	; 0x80
    28fc:	80000013 	andhi	r0, r0, r3, lsl r0
  //ASSERT( src_addr != NULL );      //Դַж
  //ASSERT( (src_dsize <= DMA_SRC_32BIT)||(src_dsize == DMA_SRC_16BYTE) );     //ԴݴСж
  //ASSERT( dst_addr != NULL );      //Ŀĵַж
  //ASSERT( (dst_dsize <= DMA_DST_32BIT)||(dst_dsize == DMA_DST_16BYTE) );     //ĿݴСж
 
  if (chx > DMA_CH15)
    2900:	13960602 	orrsne	r0, r6, #2097152	; 0x200000
    2904:	04800000 	streq	r0, [r0], #0
    return 0;
    2908:	0014ae06 	andseq	sl, r4, r6, lsl #28
  if (req > DMA_MUX_63)
    290c:	06088000 	streq	r8, [r8], -r0
    2910:	000014b9 			; <UNDEFINED> instruction: 0x000014b9
    return 0;
    2914:	c4061080 	strgt	r1, [r6], #-128	; 0x80
    2918:	80000014 	andhi	r0, r0, r4, lsl r0
  if (major_cnt > 0x7FFF)
    291c:	14cf0620 	strbne	r0, [pc], #1568	; 2924 <LPLD_DMA_Init+0x84>
    2920:	c0800000 	addgt	r0, r0, r0
    return 0;
    2924:	14da0600 	ldrbne	r0, [sl], #1536	; 0x600
  if (src_addr == 0)
    2928:	80800000 	addhi	r0, r0, r0
    292c:	14e50601 	strbtne	r0, [r5], #1537	; 0x601
    return 0;
    2930:	80800000 	addhi	r0, r0, r0
  if ((src_dsize > DMA_SRC_32BIT) || (src_dsize != DMA_SRC_16BYTE))
    2934:	14f00602 	ldrbtne	r0, [r0], #1538	; 0x602
    2938:	80800000 	addhi	r0, r0, r0
    293c:	14fb0604 	ldrbtne	r0, [fp], #1540	; 0x604
    return 0;
    2940:	80800000 	addhi	r0, r0, r0
    2944:	15060608 	strne	r0, [r6, #-1544]	; 0x608
  if (dst_addr == 0)
    2948:	80800000 	addhi	r0, r0, r0
    return 0;
    294c:	15110610 	ldrne	r0, [r1, #-1552]	; 0x610
    2950:	80800000 	addhi	r0, r0, r0
  if ((dst_dsize > DMA_DST_32BIT) || (dst_dsize != DMA_SRC_16BYTE))
    2954:	12f20620 	rscsne	r0, r2, #33554432	; 0x2000000
    2958:	80800000 	addhi	r0, r0, r0
    295c:	9b0600c0 	blls	182c64 <__etext+0x179fbc>
    return 0;
    2960:	80000015 	andhi	r0, r0, r5, lsl r0

  SIM_SCGC7 |= SIM_SCGC7_DMA_MASK;     //DMAģʱ
    2964:	06018080 	streq	r8, [r1], -r0, lsl #1
    2968:	000015a6 	andeq	r1, r0, r6, lsr #11
    296c:	02808080 	addeq	r8, r0, #128	; 0x80
    2970:	0015b106 	andseq	fp, r5, r6, lsl #2
    2974:	80808000 	addhi	r8, r0, r0
    2978:	15bc0604 	ldrne	r0, [ip, #1540]!	; 0x604
    297c:	80800000 	addhi	r0, r0, r0
    2980:	c7060880 	strgt	r0, [r6, -r0, lsl #17]
  SIM_SCGC6 |= SIM_SCGC6_DMAMUX0_MASK;  //DMAͨ·ʱ   
    2984:	80000015 	andhi	r0, r0, r5, lsl r0
    2988:	06108080 	ldreq	r8, [r0], -r0, lsl #1
    298c:	000015d2 	ldrdeq	r1, [r0], -r2
    2990:	20808080 	addcs	r8, r0, r0, lsl #1
    2994:	00132306 	andseq	r2, r3, r6, lsl #6
    2998:	80808000 	addhi	r8, r0, r0
    299c:	2e0600c0 	cdpcs	0, 0, cr0, cr6, cr0, {6}
    29a0:	80000013 	andhi	r0, r0, r3, lsl r0
    29a4:	01808080 	orreq	r8, r0, r0, lsl #1
    29a8:	00133906 	andseq	r3, r3, r6, lsl #18
  
  //رͨxӲDMA 
  DMA0->ERQ &= ~(1<<chx);
    29ac:	80808000 	addhi	r8, r0, r0
    29b0:	e8060280 	stmda	r6, {r7, r9}
    29b4:	80000015 	andhi	r0, r0, r5, lsl r0
    29b8:	04808080 	streq	r8, [r0], #128	; 0x80
    29bc:	0015f306 	andseq	pc, r5, r6, lsl #6
    29c0:	80808000 	addhi	r8, r0, r0
    29c4:	60060880 	andvs	r0, r6, r0, lsl #17
    29c8:	ff000014 			; <UNDEFINED> instruction: 0xff000014
    29cc:	13ec0601 	mvnne	r0, #1048576	; 0x100000
    29d0:	fe800000 	cdp2	0, 8, cr0, cr0, cr0, {0}
  
  //ѡ ͨx DMAԴ
  DMAMUX->CHCFG[chx] = DMAMUX_CHCFG_SOURCE(req);
    29d4:	12530603 	subsne	r0, r3, #3145728	; 0x300000
    29d8:	80800000 	addhi	r0, r0, r0
    29dc:	920607fc 	andls	r0, r6, #66060288	; 0x3f00000
    29e0:	80000011 	andhi	r0, r0, r1, lsl r0
    29e4:	0ff88080 	svceq	0x00f88080
    29e8:	061a1100 	ldreq	r1, [sl], -r0, lsl #2
  //Ƿʹڴ
  if(periodic_trigg == TRUE)
    29ec:	a7050000 	strge	r0, [r5, -r0]
    29f0:	0010e501 	andseq	lr, r0, r1, lsl #10
  {
    DMAMUX->CHCFG[chx] |= DMAMUX_CHCFG_TRIG_MASK;
    29f4:	eb041200 	bl	1071fc <__etext+0xfe554>
    29f8:	16000010 			; <UNDEFINED> instruction: 0x16000010
    29fc:	05140b01 	ldreq	r0, [r4, #-2817]	; 0xb01
    2a00:	115101aa 	cmpne	r1, sl, lsr #3
    2a04:	400c0000 	andmi	r0, ip, r0
    2a08:	05000006 	streq	r0, [r0, #-6]
    2a0c:	095a01af 	ldmdbeq	sl, {r0, r1, r2, r3, r5, r7, r8}^
    2a10:	23020000 	movwcs	r0, #8192	; 0x2000
    2a14:	09ee0c00 	stmibeq	lr!, {sl, fp}^
  }
  else
  {
    DMAMUX->CHCFG[chx] &= ~(DMAMUX_CHCFG_TRIG_MASK);
    2a18:	b3050000 	movwlt	r0, #20480	; 0x5000
    2a1c:	000f7d01 	andeq	r7, pc, r1, lsl #26
    2a20:	04230200 	strteq	r0, [r3], #-512	; 0x200
    2a24:	0002f60c 	andeq	pc, r2, ip, lsl #12
    2a28:	01b70500 			; <UNDEFINED> instruction: 0x01b70500
    2a2c:	00000f7d 	andeq	r0, r0, sp, ror pc
    2a30:	0c082302 	stceq	3, cr2, [r8], {2}
    2a34:	00000534 	andeq	r0, r0, r4, lsr r5
    2a38:	6701bb05 	strvs	fp, [r1, -r5, lsl #22]
  }
  
  
  //Դַ   
  DMA0->TCD[chx].SADDR = DMA_SADDR_SADDR(src_addr);
    2a3c:	0200000f 	andeq	r0, r0, #15
    2a40:	280c0c23 	stmdacs	ip, {r0, r1, r5, sl, fp}
    2a44:	05000020 	streq	r0, [r0, #-32]
    2a48:	0f6701bf 	svceq	0x006701bf
    2a4c:	23020000 	movwcs	r0, #8192	; 0x2000
    2a50:	09d40c0d 	ldmibeq	r4, {r0, r2, r3, sl, fp}^
    2a54:	c9050000 	stmdbgt	r5, {}	; <UNPREDICTABLE>
  //ִԴַĲ֮ԴַĻ/ƫƵַ
  DMA0->TCD[chx].SOFF = DMA_SOFF_SOFF(src_addroffset);
    2a58:	0010d901 	andseq	sp, r0, r1, lsl #18
    2a5c:	10230200 	eorne	r0, r3, r0, lsl #4
    2a60:	05ff1100 	ldrbeq	r1, [pc, #256]!	; 2b68 <LPLD_DMA_Init+0x2c8>
    2a64:	ca050000 	bgt	142a6c <__etext+0x139dc4>
    2a68:	0010ed01 	andseq	lr, r0, r1, lsl #26
    2a6c:	02041700 	andeq	r1, r4, #0
  //ԴַĴС
  DMA0->TCD[chx].ATTR = 0 | DMA_ATTR_SSIZE(src_dsize);
    2a70:	07120801 	ldreq	r0, [r2, -r1, lsl #16]
    2a74:	20030000 	andcs	r0, r3, r0
    2a78:	06000007 	streq	r0, [r0], -r7
    2a7c:	0010e522 	andseq	lr, r0, r2, lsr #10
    2a80:	062c1800 	strteq	r1, [ip], -r0, lsl #16
    2a84:	00126e89 	andseq	r6, r2, r9, lsl #29
    2a88:	13bb1900 			; <UNDEFINED> instruction: 0x13bb1900
    2a8c:	93060000 	movwls	r0, #24576	; 0x6000
    2a90:	00000f67 	andeq	r0, r0, r7, ror #30
    2a94:	19002302 	stmdbne	r0, {r1, r8, r9, sp}
  //ļmajor iteration countﵽµԴַ
  DMA0->TCD[chx].SLAST = DMA_SLAST_SLAST(src_lastadj);
    2a98:	0000131b 	andeq	r1, r0, fp, lsl r3
    2a9c:	0f679d06 	svceq	0x00679d06
    2aa0:	23020000 	movwcs	r0, #8192	; 0x2000
    2aa4:	11301901 	teqne	r0, r1, lsl #18
    2aa8:	a8060000 	stmdage	r6, {}	; <UNPREDICTABLE>
    2aac:	00000fa1 	andeq	r0, r0, r1, lsr #31
    2ab0:	19022302 	stmdbne	r2, {r1, r8, r9, sp}
    2ab4:	000011a0 	andeq	r1, r0, r0, lsr #3
  
  //Ŀĵַ 
  DMA0->TCD[chx].DADDR = DMA_DADDR_DADDR(dst_addr);
    2ab8:	0f72b206 	svceq	0x0072b206
    2abc:	23020000 	movwcs	r0, #8192	; 0x2000
    2ac0:	11d31904 	bicsne	r1, r3, r4, lsl #18
    2ac4:	bc060000 	stclt	0, cr0, [r6], {-0}
    2ac8:	00000f7d 	andeq	r0, r0, sp, ror pc
    2acc:	19082302 	stmdbne	r8, {r1, r8, r9, sp}
    2ad0:	000013f9 	strdeq	r1, [r0], -r9
  //ִĿĵַĲ֮ĿĵַĻ/ƫƵַ
  DMA0->TCD[chx].DOFF = DMA_DOFF_DOFF(dst_addroffset);
    2ad4:	0f7dc606 	svceq	0x007dc606
    2ad8:	23020000 	movwcs	r0, #8192	; 0x2000
    2adc:	1225190c 	eorne	r1, r5, #196608	; 0x30000
    2ae0:	d3060000 	movwle	r0, #24576	; 0x6000
    2ae4:	00000f67 	andeq	r0, r0, r7, ror #30
    2ae8:	19102302 	ldmdbne	r0, {r1, r8, r9, sp}
    2aec:	000012b7 			; <UNDEFINED> instruction: 0x000012b7
    2af0:	0f88dd06 	svceq	0x0088dd06
  //ĿĵַĴ
  DMA0->TCD[chx].ATTR |= DMA_ATTR_DSIZE(dst_dsize);
    2af4:	23020000 	movwcs	r0, #8192	; 0x2000
    2af8:	15fe1912 	ldrbne	r1, [lr, #2322]!	; 0x912
    2afc:	e7060000 	str	r0, [r6, -r0]
    2b00:	0000007e 	andeq	r0, r0, lr, ror r0
    2b04:	19142302 	ldmdbne	r4, {r1, r8, r9, sp}
    2b08:	00001350 	andeq	r1, r0, r0, asr r3
    2b0c:	0f7df106 	svceq	0x007df106
    2b10:	23020000 	movwcs	r0, #8192	; 0x2000
    2b14:	16141918 			; <UNDEFINED> instruction: 0x16141918
    2b18:	fe060000 	cdp2	0, 0, cr0, cr6, cr0, {0}
    2b1c:	00000f67 	andeq	r0, r0, r7, ror #30
    2b20:	0c1c2302 	ldceq	3, cr2, [ip], {2}
    2b24:	00001588 	andeq	r1, r0, r8, lsl #11
    2b28:	88010806 	stmdahi	r1, {r1, r2, fp}
    2b2c:	0200000f 	andeq	r0, r0, #15
    2b30:	460c1e23 	strmi	r1, [ip], -r3, lsr #28
  //ļmajor iteration countﵽµĿĵַ
  DMA0->TCD[chx].DLAST_SGA = DMA_DLAST_SGA_DLASTSGA(dst_lastadj);
    2b34:	06000014 			; <UNDEFINED> instruction: 0x06000014
    2b38:	007e0112 	rsbseq	r0, lr, r2, lsl r1
    2b3c:	23020000 	movwcs	r0, #8192	; 0x2000
    2b40:	156c0c20 	strbne	r0, [ip, #-3104]!	; 0xc20
    2b44:	1d060000 	stcne	0, cr0, [r6, #-0]
    2b48:	000fa101 	andeq	sl, pc, r1, lsl #2
    2b4c:	24230200 	strtcs	r0, [r3], #-512	; 0x200
  //ĬΪͨӹܣӴ˹
  if( 1 == 1)
  {
    //===============ȣѭ====================================
    //ѭ current major loop count
    DMA0->TCD[chx].CITER_ELINKNO = DMA_CITER_ELINKNO_CITER(major_cnt);
    2b50:	0013a00c 	andseq	sl, r3, ip
    2b54:	01280600 	teqeq	r8, r0, lsl #12
    2b58:	00000fa1 	andeq	r0, r0, r1, lsr #31
    2b5c:	0c252302 	stceq	3, cr2, [r5], #-8
    2b60:	000013cd 	andeq	r1, r0, sp, asr #7
    2b64:	a1013306 	tstge	r1, r6, lsl #6
    2b68:	0200000f 	andeq	r0, r0, #15
    2b6c:	2d0c2623 	stccs	6, cr2, [ip, #-140]	; 0xffffff74
    2b70:	06000015 			; <UNDEFINED> instruction: 0x06000015
    2b74:	1166013d 	cmnne	r6, sp, lsr r1
    //ʼѭѭΪʱ򣬽װʼѭֵ
    DMA0->TCD[chx].BITER_ELINKNO = DMA_CITER_ELINKNO_CITER(major_cnt);
    2b78:	23020000 	movwcs	r0, #8192	; 0x2000
    2b7c:	08110028 	ldmdaeq	r1, {r3, r5}
    2b80:	06000014 			; <UNDEFINED> instruction: 0x06000014
    2b84:	1171013f 	cmnne	r1, pc, lsr r1
    2b88:	02180000 	andseq	r0, r8, #0
    2b8c:	129f9c07 	addsne	r9, pc, #1792	; 0x700
    2b90:	f4190000 			; <UNDEFINED> instruction: 0xf4190000
    2b94:	0700001b 	smladeq	r0, fp, r0, r0
    2b98:	000f679e 	muleq	pc, lr, r7	; <UNPREDICTABLE>
    2b9c:	00230200 	eoreq	r0, r3, r0, lsl #4
  
  //ĬΪôѭַƫƹܣӴ˹
  if( 1 == 1)
  {
    //ѭһδֽڵĸ
    DMA0->TCD[chx].NBYTES_MLNO = DMA_NBYTES_MLNO_NBYTES(minor_cnt);
    2ba0:	6c61761a 	stclvs	6, cr7, [r1], #-104	; 0xffffff98
    2ba4:	679f0700 	ldrvs	r0, [pc, r0, lsl #14]
    2ba8:	0200000f 	andeq	r0, r0, #15
    2bac:	03000123 	movweq	r0, #291	; 0x123
    2bb0:	00001372 	andeq	r1, r0, r2, ror r3
    2bb4:	127aa007 	rsbsne	sl, sl, #7
    2bb8:	01050000 	mrseq	r0, (UNDEF: 5)
    2bbc:	12d7b407 	sbcsne	fp, r7, #117440512	; 0x7000000
  }
  
  //TCDƼĴ     
  DMA0->TCD[chx].CSR = 0;
    2bc0:	72060000 	andvc	r0, r6, #0
    2bc4:	00000012 	andeq	r0, r0, r2, lsl r0
    2bc8:	0015dd06 	andseq	sp, r5, r6, lsl #26
    2bcc:	7f060100 	svcvc	0x00060100
    2bd0:	02000015 	andeq	r0, r0, #21
    2bd4:	00117306 	andseq	r7, r1, r6, lsl #6
    2bd8:	35060300 	strcc	r0, [r6, #-768]	; 0x300
    2bdc:	04000015 	streq	r0, [r0], #-21
  
  //eDMAж
  if((dma_init_struct.DMA_Isr != NULL) && 
    2be0:	00116a06 	andseq	r6, r1, r6, lsl #20
     (dma_init_struct.DMA_MajorCompleteIntEnable == TRUE))
    2be4:	03000500 	movweq	r0, #1280	; 0x500
  
  //TCDƼĴ     
  DMA0->TCD[chx].CSR = 0;
  
  //eDMAж
  if((dma_init_struct.DMA_Isr != NULL) && 
    2be8:	00001117 	andeq	r1, r0, r7, lsl r1
     (dma_init_struct.DMA_MajorCompleteIntEnable == TRUE))
  {

       DMA0->TCD[chx].CSR |= DMA_CSR_INTMAJOR_MASK; //ʹDMA ѭ ж
    2bec:	12aabb07 	adcne	fp, sl, #7168	; 0x1c00
    2bf0:	01050000 	mrseq	r0, (UNDEF: 5)
    2bf4:	12f7df07 	rscsne	sp, r7, #28
    2bf8:	a4060000 	strge	r0, [r6], #-0
    2bfc:	00000007 	andeq	r0, r0, r7
    2c00:	00055e06 	andeq	r5, r5, r6, lsl #28
    2c04:	05000100 	streq	r0, [r0, #-256]	; 0x100
    2c08:	18e50701 	stmiane	r5!, {r0, r8, r9, sl}^
    2c0c:	06000013 			; <UNDEFINED> instruction: 0x06000013
    2c10:	000004f3 	strdeq	r0, [r0], -r3
    2c14:	04fd0600 	ldrbteq	r0, [sp], #1536	; 0x600
    2c18:	06010000 	streq	r0, [r1], -r0
    2c1c:	00000507 	andeq	r0, r0, r7, lsl #10
    2c20:	0a5c0602 	beq	1704430 <__etext+0x16fb788>
    2c24:	00040000 	andeq	r0, r4, r0
    2c28:	0013c303 	andseq	ip, r3, r3, lsl #6
       DMA_ISR[chx] = dma_init_struct.DMA_Isr;
    2c2c:	f7ea0700 			; <UNDEFINED> instruction: 0xf7ea0700
    2c30:	1b000012 	blne	2c80 <LPLD_DMA_Init+0x3e0>
    2c34:	00134401 	andseq	r4, r3, r1, lsl #8
    2c38:	016a0100 	cmneq	sl, r0, lsl #2
    2c3c:	00000f67 	andeq	r0, r0, r7, ror #30
  }
  if((dma_init_struct.DMA_Isr != NULL) && 
    2c40:	00000dd0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     (dma_init_struct.DMA_MajorHalfCompleteIntEnable == TRUE))
    2c44:	00000fd0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
  {

       DMA0->TCD[chx].CSR |= DMA_CSR_INTMAJOR_MASK; //ʹDMA ѭ ж
       DMA_ISR[chx] = dma_init_struct.DMA_Isr;
  }
  if((dma_init_struct.DMA_Isr != NULL) && 
    2c48:	000001b4 			; <UNDEFINED> instruction: 0x000001b4
     (dma_init_struct.DMA_MajorHalfCompleteIntEnable == TRUE))
  {

       DMA0->TCD[chx].CSR |= DMA_CSR_INTHALF_MASK; //ʹDMA ѭһ ж
    2c4c:	00136a01 	andseq	r6, r3, r1, lsl #20
    2c50:	00691c00 	rsbeq	r1, r9, r0, lsl #24
    2c54:	0f726c01 	svceq	0x00726c01
    2c58:	91020000 	mrsls	r0, (UNDEF: 2)
    2c5c:	11561d76 	cmpne	r6, r6, ror sp
    2c60:	6d010000 	stcvs	0, cr0, [r1, #-0]
    2c64:	00000f67 	andeq	r0, r0, r7, ror #30
    2c68:	1d759102 	ldfnep	f1, [r5, #-8]!
    2c6c:	00001369 	andeq	r1, r0, r9, ror #6
    2c70:	136a6e01 	cmnne	sl, #16
    2c74:	91020000 	mrsls	r0, (UNDEF: 2)
    2c78:	67070040 	strvs	r0, [r7, -r0, asr #32]
    2c7c:	7a00000f 	bvc	2cc0 <LPLD_DMA_Init+0x420>
    2c80:	08000013 	stmdaeq	r0, {r0, r1, r4}
    2c84:	000003ab 	andeq	r0, r0, fp, lsr #7
    2c88:	011e0031 	tsteq	lr, r1, lsr r0
       DMA_ISR[chx] = dma_init_struct.DMA_Isr;
    2c8c:	000012fd 	strdeq	r1, [r0], -sp
    2c90:	d0019a01 	andle	r9, r1, r1, lsl #20
    2c94:	1200000f 	andne	r0, r0, #15
    2c98:	ee000010 	mcr	0, 0, r0, cr0, cr0, {0}
    2c9c:	01000001 	tsteq	r0, r1
  }
    
  if(auto_disable == TRUE)
    2ca0:	000013ad 	andeq	r1, r0, sp, lsr #7
  {
     DMA0->TCD[chx].CSR |= DMA_CSR_DREQ_MASK; //ѭԶرDMA 
    2ca4:	0100691c 	tsteq	r0, ip, lsl r9
    2ca8:	000f729c 	muleq	pc, ip, r2	; <UNPREDICTABLE>
    2cac:	76910200 	ldrvc	r0, [r1], r0, lsl #4
    2cb0:	01006e1c 	tsteq	r0, ip, lsl lr
    2cb4:	000f729c 	muleq	pc, ip, r2	; <UNPREDICTABLE>
    2cb8:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    2cbc:	0a011f00 	beq	4a8c4 <__etext+0x41c1c>
    2cc0:	01000013 	tsteq	r0, r3, lsl r0
    2cc4:	101401a7 	andsne	r0, r4, r7, lsr #3
    2cc8:	10ba0000 	adcsne	r0, sl, r0
    2ccc:	02260000 	eoreq	r0, r6, #0
    2cd0:	1f010000 	svcne	0x00010000
    2cd4:	00146c01 	andseq	r6, r4, r1, lsl #24
    2cd8:	01bd0100 			; <UNDEFINED> instruction: 0x01bd0100
    2cdc:	000010bc 	strheq	r1, [r0], -ip
    2ce0:	00001132 	andeq	r1, r0, r2, lsr r1
    2ce4:	0000025e 	andeq	r0, r0, lr, asr r2
  }
  else
  {
     DMA0->TCD[chx].CSR &= ~(DMA_CSR_DREQ_MASK); //ѭ󣬲رDMA
    2ce8:	50011f01 	andpl	r1, r1, r1, lsl #30
    2cec:	01000015 	tsteq	r0, r5, lsl r0
    2cf0:	113401d6 			; <UNDEFINED> instruction: 0x113401d6
    2cf4:	11880000 	orrne	r0, r8, r0
    2cf8:	028a0000 	addeq	r0, sl, #0
    2cfc:	1e010000 	cdpne	0, 0, cr0, cr1, cr0, {0}
    2d00:	0011c001 	andseq	ip, r1, r1
    2d04:	01e70100 	mvneq	r0, r0, lsl #2
    2d08:	00001188 	andeq	r1, r0, r8, lsl #3
    2d0c:	000012de 	ldrdeq	r1, [r0], -lr
    2d10:	000002c2 	andeq	r0, r0, r2, asr #5
    2d14:	00145001 	andseq	r5, r4, r1
    2d18:	73642000 	cmnvc	r4, #0
    2d1c:	e7010074 	smlsdx	r1, r4, r0, r0
    2d20:	00001450 	andeq	r1, r0, r0, asr r4
    2d24:	206c9102 	rsbcs	r9, ip, r2, lsl #2
  } 
 
  //DMAͨʹ
  DMAMUX->CHCFG[chx] |= DMAMUX_CHCFG_ENBL_MASK;
    2d28:	00637273 	rsbeq	r7, r3, r3, ror r2
    2d2c:	1450e701 	ldrbne	lr, [r0], #-1793	; 0x701
    2d30:	91020000 	mrsls	r0, (UNDEF: 2)
    2d34:	114f2168 	cmpne	pc, r8, ror #2
    2d38:	e7010000 	str	r0, [r1, -r0]
    2d3c:	00000f7d 	andeq	r0, r0, sp, ror pc
    2d40:	1d649102 	stfnep	f1, [r4, #-8]!
    2d44:	0000143f 	andeq	r1, r0, pc, lsr r4
    2d48:	1456e901 	ldrbne	lr, [r6], #-2305	; 0x901
    
  return 1;
    2d4c:	91020000 	mrsls	r0, (UNDEF: 2)
}
    2d50:	15651d74 	strbne	r1, [r5, #-3444]!	; 0xd74
    2d54:	eb010000 	bl	42d5c <__etext+0x3a0b4>
    2d58:	00000f67 	andeq	r0, r0, r7, ror #30
 * :
 *    0--ʧ
 *    1--ɹ
 */
uint8 LPLD_DMA_EnableIrq(DMA_InitTypeDef dma_init_struct)
{
    2d5c:	00779102 	rsbseq	r9, r7, r2, lsl #2
    2d60:	0f670412 	svceq	0x00670412
    2d64:	67070000 	strvs	r0, [r7, -r0]
    2d68:	6600000f 	strvs	r0, [r0], -pc
  enable_irq(dma_init_struct.DMA_CHx + INT_DMA0_DMA16 - 16);  
    2d6c:	08000014 	stmdaeq	r0, {r2, r4}
    2d70:	000003ab 	andeq	r0, r0, fp, lsr #7
  return 1;
    2d74:	01220001 	teqeq	r2, r1
}
    2d78:	0000129a 	muleq	r0, sl, r2
    2d7c:	01010301 	tsteq	r1, r1, lsl #6
    2d80:	000012e0 	andeq	r1, r0, r0, ror #5
 * :
 *    0--ʧ
 *    1--ɹ
 */
uint8 LPLD_DMA_DisableIrq(DMA_InitTypeDef dma_init_struct)
{
    2d84:	0000132a 	andeq	r1, r0, sl, lsr #6
    2d88:	000002fa 	strdeq	r0, [r0], -sl
    2d8c:	0014af01 	andseq	sl, r4, r1, lsl #30
    2d90:	12af2300 	adcne	r2, pc, #0
  disable_irq(dma_init_struct.DMA_CHx + INT_DMA0_DMA16 - 16);
    2d94:	03010000 	movweq	r0, #4096	; 0x1000
    2d98:	00145001 	andseq	r5, r4, r1
  return 1;
    2d9c:	6c910200 	lfmvs	f0, 4, [r1], {0}
}
    2da0:	00120423 	andseq	r0, r2, r3, lsr #8
    2da4:	01030100 	mrseq	r0, (UNDEF: 19)
    2da8:	00000f7d 	andeq	r0, r0, sp, ror pc
 *
 * :
 *    
 */
void LPLD_DMA_SoftwareStartService(DMA_InitTypeDef dma_init_struct)
{
    2dac:	24689102 	strbtcs	r9, [r8], #-258	; 0x102
    2db0:	00646d63 	rsbeq	r6, r4, r3, ror #26
    2db4:	af010501 	svcge	0x00010501
    2db8:	02000014 	andeq	r0, r0, #20
  DMA0->TCD[dma_init_struct.DMA_CHx].CSR |= DMA_CSR_START_MASK; 
    2dbc:	07007491 			; <UNDEFINED> instruction: 0x07007491
    2dc0:	00000f67 	andeq	r0, r0, r7, ror #30
    2dc4:	000014bf 			; <UNDEFINED> instruction: 0x000014bf
    2dc8:	0003ab08 	andeq	sl, r3, r8, lsl #22
    2dcc:	25000300 	strcs	r0, [r0, #-768]	; 0x300
    2dd0:	00127e01 	andseq	r7, r2, r1, lsl #28
    2dd4:	01100100 	tsteq	r0, r0, lsl #2
    2dd8:	00132c01 	andseq	r2, r3, r1, lsl #24
    2ddc:	00143a00 	andseq	r3, r4, r0, lsl #20
    2de0:	00033200 	andeq	r3, r3, r0, lsl #4
    2de4:	01250100 	teqeq	r5, r0, lsl #2
    2de8:	00001421 	andeq	r1, r0, r1, lsr #8
    2dec:	01013201 	tsteq	r1, r1, lsl #4
    2df0:	0000143c 	andeq	r1, r0, ip, lsr r4
    2df4:	0000154c 	andeq	r1, r0, ip, asr #10
}
    2df8:	0000036a 	andeq	r0, r0, sl, ror #6
    2dfc:	e7012201 	str	r2, [r1, -r1, lsl #4]
 * eDMAжϴ
 * ļstartup_K60.sеж
 * û޸ģԶӦͨжϺ
 */
void DMA0_IRQHandler(void)
{
    2e00:	01000012 	tsteq	r0, r2, lsl r0
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[0]();
    2e04:	4c01014b 	stfmis	f0, [r1], {75}	; 0x4b
    2e08:	d8000015 	stmdale	r0, {r0, r2, r4}
    2e0c:	a2000015 	andge	r0, r0, #21
  //жϱ־λ
  DMA0->INT |= 0x1u<<0;
    2e10:	01000003 	tsteq	r0, r3
    2e14:	00001525 	andeq	r1, r0, r5, lsr #10
    2e18:	01006e24 	tsteq	r0, r4, lsr #28
    2e1c:	0f67014d 	svceq	0x0067014d
    2e20:	91020000 	mrsls	r0, (UNDEF: 2)
    2e24:	001a2677 	andseq	r2, sl, r7, ror r6
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2e28:	4f010000 	svcmi	0x00010000

void DMA1_IRQHandler(void)
{
    2e2c:	000f7d01 	andeq	r7, pc, r1, lsl #26
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[1]();
    2e30:	70910200 	addsvc	r0, r1, r0, lsl #4
    2e34:	7e012700 	cdpvc	7, 0, cr2, cr1, cr0, {0}
    2e38:	01000011 	tsteq	r0, r1, lsl r0
  //жϱ־λ
  DMA0->INT |= 0x1u<<1;
    2e3c:	d8010166 	stmdale	r1, {r1, r2, r5, r6, r8}
    2e40:	5c000015 	stcpl	0, cr0, [r0], {21}
    2e44:	da000018 	ble	2eac <DMA3_IRQHandler+0x28>
    2e48:	01000003 	tsteq	r0, r3
    2e4c:	000015b9 			; <UNDEFINED> instruction: 0x000015b9
    2e50:	6e484328 	cdpvs	3, 4, cr4, cr8, cr8, {1}
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2e54:	01660100 	cmneq	r6, r0, lsl #2

void DMA2_IRQHandler(void)
{
    2e58:	00000f67 	andeq	r0, r0, r7, ror #30
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[2]();
    2e5c:	236f9102 	cmncs	pc, #-2147483648	; 0x80000000
    2e60:	00000374 	andeq	r0, r0, r4, ror r3
    2e64:	5d016601 	stcpl	6, cr6, [r1, #-4]
  //жϱ־λ
  DMA0->INT |= 0x1u<<2;
    2e68:	02000011 	andeq	r0, r0, #17
    2e6c:	dd236891 	stcle	8, cr6, [r3, #-580]!	; 0xfffffdbc
    2e70:	01000008 	tsteq	r0, r8
    2e74:	115d0166 	cmpne	sp, r6, ror #2
    2e78:	91020000 	mrsls	r0, (UNDEF: 2)
    2e7c:	120c2364 	andne	r2, ip, #-1879048191	; 0x90000001
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2e80:	66010000 	strvs	r0, [r1], -r0

void DMA3_IRQHandler(void)
{
    2e84:	000f6701 	andeq	r6, pc, r1, lsl #14
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[3]();
    2e88:	6e910200 	cdpvs	2, 9, cr0, cr1, cr0, {0}
    2e8c:	00128f23 	andseq	r8, r2, r3, lsr #30
    2e90:	01660100 	cmneq	r6, r0, lsl #2
  //жϱ־λ
  DMA0->INT |= 0x1u<<3;
    2e94:	00001318 	andeq	r1, r0, r8, lsl r3
    2e98:	23009102 	movwcs	r9, #258	; 0x102
    2e9c:	000011fe 	strdeq	r1, [r0], -lr
    2ea0:	7d016601 	stcvc	6, cr6, [r1, #-4]
    2ea4:	0200000f 	andeq	r0, r0, #15
    2ea8:	63280491 	teqvs	r8, #-1862270976	; 0x91000000
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2eac:	01006766 	tsteq	r0, r6, ror #14

void DMA4_IRQHandler(void)
{
    2eb0:	0f7d0166 	svceq	0x007d0166
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[4]();
    2eb4:	91020000 	mrsls	r0, (UNDEF: 2)
    2eb8:	12142608 	andsne	r2, r4, #8388608	; 0x800000
    2ebc:	68010000 	stmdavs	r1, {}	; <UNPREDICTABLE>
  //жϱ־λ
  DMA0->INT |= 0x1u<<4;
    2ec0:	000f6701 	andeq	r6, pc, r1, lsl #14
    2ec4:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
    2ec8:	5d012700 	stcpl	7, cr2, [r1, #-0]
    2ecc:	01000013 	tsteq	r0, r3, lsl r0
    2ed0:	5c01018f 	stfpls	f0, [r1], {143}	; 0x8f
    2ed4:	46000018 			; <UNDEFINED> instruction: 0x46000018
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2ed8:	1200001a 	andne	r0, r0, #26

void DMA5_IRQHandler(void)
{
    2edc:	01000004 	tsteq	r0, r4
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[5]();
    2ee0:	00001645 	andeq	r1, r0, r5, asr #12
    2ee4:	676d6928 	strbvs	r6, [sp, -r8, lsr #18]!
    2ee8:	018f0100 	orreq	r0, pc, r0, lsl #2
  //жϱ־λ
  DMA0->INT |= 0x1u<<5;
    2eec:	00001450 	andeq	r1, r0, r0, asr r4
    2ef0:	286c9102 	stmdacs	ip!, {r1, r8, ip, pc}^
    2ef4:	8f010068 	svchi	0x00010068
    2ef8:	000f6701 	andeq	r6, pc, r1, lsl #14
    2efc:	6b910200 	blvs	fe443704 <__StackLimit+0xde443704>
    2f00:	01007728 	tsteq	r0, r8, lsr #14
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2f04:	0f67018f 	svceq	0x0067018f

void DMA6_IRQHandler(void)
{
    2f08:	91020000 	mrsls	r0, (UNDEF: 2)
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[6]();
    2f0c:	0070246a 	rsbseq	r2, r0, sl, ror #8
    2f10:	88019101 	stmdahi	r1, {r0, r8, ip, pc}
    2f14:	0200000f 	andeq	r0, r0, #15
  //жϱ־λ
  DMA0->INT |= 0x1u<<6;
    2f18:	69247691 	stmdbvs	r4!, {r0, r4, r7, r9, sl, ip, sp, lr}
    2f1c:	01910100 	orrseq	r0, r1, r0, lsl #2
    2f20:	00000f88 	andeq	r0, r0, r8, lsl #31
    2f24:	26749102 	ldrbtcs	r9, [r4], -r2, lsl #2
    2f28:	00001418 	andeq	r1, r0, r8, lsl r4
    2f2c:	88019101 	stmdahi	r1, {r0, r8, ip, pc}
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2f30:	0200000f 	andeq	r0, r0, #15

void DMA7_IRQHandler(void)
{
    2f34:	60267291 	mlavs	r6, r1, r2, r7
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[7]();
    2f38:	01000011 	tsteq	r0, r1, lsl r0
    2f3c:	00250192 	mlaeq	r5, r2, r1, r0
    2f40:	91020000 	mrsls	r0, (UNDEF: 2)
  //жϱ־λ
  DMA0->INT |= 0x1u<<7;
    2f44:	121a2671 	andsne	r2, sl, #118489088	; 0x7100000
    2f48:	92010000 	andls	r0, r1, #0
    2f4c:	00002501 	andeq	r2, r0, r1, lsl #10
    2f50:	70910200 	addsvc	r0, r1, r0, lsl #4
    2f54:	0f670700 	svceq	0x00670700
    2f58:	16560000 	ldrbne	r0, [r6], -r0
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2f5c:	ab100000 	blge	402f64 <__etext+0x3fa2bc>

void DMA8_IRQHandler(void)
{
    2f60:	bf000003 	svclt	0x00000003
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[8]();
    2f64:	67290012 			; <UNDEFINED> instruction: 0x67290012
    2f68:	07000007 	streq	r0, [r0, -r7]
    2f6c:	001645aa 	andseq	r4, r6, sl, lsr #11
  //жϱ־λ
  DMA0->INT |= 0x1u<<8;
    2f70:	03050100 	movweq	r0, #20736	; 0x5100
    2f74:	1fff02d4 	svcne	0x00ff02d4
    2f78:	000f6707 	andeq	r6, pc, r7, lsl #14
    2f7c:	00167900 	andseq	r7, r6, r0, lsl #18
    2f80:	03ab1000 			; <UNDEFINED> instruction: 0x03ab1000
    2f84:	02570000 	subseq	r0, r7, #0
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2f88:	6d692a00 	vstmdbvs	r9!, {s5-s4}

void DMA9_IRQHandler(void)
{
    2f8c:	ab070067 	blge	1c3130 <__etext+0x1ba488>
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[9]();
    2f90:	00001668 	andeq	r1, r0, r8, ror #12
    2f94:	7c030501 	cfstr32vc	mvfx0, [r3], {1}
    2f98:	291fff00 	ldmdbcs	pc, {r8, r9, sl, fp, ip, sp, lr, pc}	; <UNPREDICTABLE>
  //жϱ־λ
  DMA0->INT |= 0x1u<<9;
    2f9c:	0000000f 	andeq	r0, r0, pc
    2fa0:	115f0b01 	cmpne	pc, r1, lsl #22
    2fa4:	05010000 	streq	r0, [r1, #-0]
    2fa8:	ff007803 			; <UNDEFINED> instruction: 0xff007803
    2fac:	05cb291f 	strbeq	r2, [fp, #2335]	; 0x91f
    2fb0:	0d010000 	stceq	0, cr0, [r1, #-0]
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2fb4:	00001151 	andeq	r1, r0, r1, asr r1

void DMA10_IRQHandler(void)
{
    2fb8:	a8030501 	stmdage	r3, {r0, r8, sl}
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[10]();
    2fbc:	291fff15 	ldmdbcs	pc, {r0, r2, r4, r8, r9, sl, fp, ip, sp, lr, pc}	; <UNPREDICTABLE>
    2fc0:	0000147f 	andeq	r1, r0, pc, ror r4
    2fc4:	11510e01 	cmpne	r1, r1, lsl #28
  //жϱ־λ
  DMA0->INT |= 0x1u<10;
    2fc8:	05010000 	streq	r0, [r1, #-0]
    2fcc:	ff15bc03 			; <UNDEFINED> instruction: 0xff15bc03
    2fd0:	1124291f 	teqne	r4, pc, lsl r9
    2fd4:	10010000 	andne	r0, r1, r0
    2fd8:	00001151 	andeq	r1, r0, r1, asr r1
    2fdc:	94030501 	strls	r0, [r3], #-1281	; 0x501
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2fe0:	291fff15 	ldmdbcs	pc, {r0, r2, r4, r8, r9, sl, fp, ip, sp, lr, pc}	; <UNPREDICTABLE>

void DMA11_IRQHandler(void)
{
    2fe4:	0000148b 	andeq	r1, r0, fp, lsl #9
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[11]();
    2fe8:	126e1201 	rsbne	r1, lr, #268435456	; 0x10000000
    2fec:	05010000 	streq	r0, [r1, #-0]
    2ff0:	ff15d003 			; <UNDEFINED> instruction: 0xff15d003
  //жϱ־λ
  DMA0->INT |= 0x1u<<11;
    2ff4:	129f071f 	addsne	r0, pc, #8126464	; 0x7c0000
    2ff8:	16f50000 	ldrbtne	r0, [r5], r0
    2ffc:	ab080000 	blge	203004 <__etext+0x1fa35c>
    3000:	30000003 	andcc	r0, r0, r3
    3004:	151c2900 	ldrne	r2, [ip, #-2304]	; 0x900
    3008:	15010000 	strne	r0, [r1, #-0]
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    300c:	000016e5 	andeq	r1, r0, r5, ror #13

void DMA12_IRQHandler(void)
{
    3010:	04030501 	streq	r0, [r3], #-1281	; 0x501
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[12]();
    3014:	291fff00 	ldmdbcs	pc, {r8, r9, sl, fp, ip, sp, lr, pc}	; <UNPREDICTABLE>
    3018:	000012cc 	andeq	r1, r0, ip, asr #5
    301c:	0f676401 	svceq	0x00676401
  //жϱ־λ
  DMA0->INT |= 0x1u<<12;
    3020:	05010000 	streq	r0, [r1, #-0]
    3024:	ff006603 			; <UNDEFINED> instruction: 0xff006603
    3028:	123d291f 	eorsne	r2, sp, #507904	; 0x7c000
    302c:	67010000 	strvs	r0, [r1, -r0]
    3030:	0000172b 	andeq	r1, r0, fp, lsr #14
    3034:	67030501 	strvs	r0, [r3, -r1, lsl #10]
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    3038:	131fff00 	tstne	pc, #0

void DMA13_IRQHandler(void)
{
    303c:	000012d7 	ldrdeq	r1, [r0], -r7
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[13]();
    3040:	00049b00 	andeq	r9, r4, r0, lsl #22
    3044:	03000200 	movweq	r0, #512	; 0x200
    3048:	04000006 	streq	r0, [r0], #-6
  //жϱ־λ
  DMA0->INT |= 0x1u<<13;
    304c:	00023401 	andeq	r3, r2, r1, lsl #8
    3050:	16380100 	ldrtne	r0, [r8], -r0, lsl #2
    3054:	08270000 	stmdaeq	r7!, {}	; <UNPREDICTABLE>
    3058:	1a480000 	bne	1203060 <__etext+0x11fa3b8>
    305c:	1fb40000 	svcne	0x00b40000
    3060:	06520000 	ldrbeq	r0, [r2], -r0
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    3064:	01020000 	mrseq	r0, (UNDEF: 2)

void DMA14_IRQHandler(void)
{
    3068:	00070b06 	andeq	r0, r7, r6, lsl #22
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[14]();
    306c:	08010200 	stmdaeq	r1, {r9}
    3070:	00000709 	andeq	r0, r0, r9, lsl #14
    3074:	3b050202 	blcc	143884 <__etext+0x13abdc>
  //жϱ־λ
  DMA0->INT |= 0x1u<<14;
    3078:	02000007 	andeq	r0, r0, #7
    307c:	04920702 	ldreq	r0, [r2], #1794	; 0x702
    3080:	04020000 	streq	r0, [r2], #-0
    3084:	00019605 	andeq	r9, r1, r5, lsl #12
    3088:	079b0300 	ldreq	r0, [fp, r0, lsl #6]
    308c:	50030000 	andpl	r0, r3, r0
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    3090:	00000053 	andeq	r0, r0, r3, asr r0

void DMA15_IRQHandler(void)
{
    3094:	e4070402 	str	r0, [r7], #-1026	; 0x402
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[15]();
    3098:	02000001 	andeq	r0, r0, #1
    309c:	01910508 	orrseq	r0, r1, r8, lsl #10
    30a0:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
  //жϱ־λ
  DMA0->INT |= 0x1u<<15;
    30a4:	0001df07 	andeq	sp, r1, r7, lsl #30
    30a8:	05040400 	streq	r0, [r4, #-1024]	; 0x400
    30ac:	00746e69 	rsbseq	r6, r4, r9, ror #28
    30b0:	e9070402 	stmdb	r7, {r1, sl}
    30b4:	02000001 	andeq	r0, r0, #1
    30b8:	05740704 	ldrbeq	r0, [r4, #-1796]!	; 0x704
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    30bc:	f8050000 			; <UNDEFINED> instruction: 0xf8050000
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_FTM_Init(FTM_InitTypeDef ftm_init_structure)
{
    30c0:	18000008 	stmdane	r0, {r3}
    30c4:	e525bf02 	str	fp, [r5, #-3842]!	; 0xf02
    30c8:	06000000 	streq	r0, [r0], -r0
    30cc:	00000a1c 	andeq	r0, r0, ip, lsl sl
  uint8 result, i;
  
  // ʹFTMʱģ
  if(ftm_init_structure.FTM_Ftmx == FTM0)
    30d0:	4825c002 	stmdami	r5!, {r1, lr, pc}
    30d4:	02000000 	andeq	r0, r0, #0
    30d8:	f1060023 			; <UNDEFINED> instruction: 0xf1060023
    30dc:	02000002 	andeq	r0, r0, #2
  {
    i=0; 
    30e0:	004825c1 	subeq	r2, r8, r1, asr #11
    SIM_SCGC6 |= SIM_SCGC6_FTM0_MASK;
    30e4:	23020000 	movwcs	r0, #8192	; 0x2000
    30e8:	01340604 	teqeq	r4, r4, lsl #12
    30ec:	c2020000 	andgt	r0, r2, #0
    30f0:	00004825 	andeq	r4, r0, r5, lsr #16
    30f4:	08230200 	stmdaeq	r3!, {r9}
    30f8:	00006706 	andeq	r6, r0, r6, lsl #14
    30fc:	25c30200 	strbcs	r0, [r3, #512]	; 0x200
    3100:	00000048 	andeq	r0, r0, r8, asr #32
    3104:	060c2302 	streq	r2, [ip], -r2, lsl #6
    3108:	00000177 	andeq	r0, r0, r7, ror r1
    310c:	4825c402 	stmdami	r5!, {r1, sl, lr, pc}
  }
  else if(ftm_init_structure.FTM_Ftmx == FTM1)
    3110:	02000000 	andeq	r0, r0, #0
    3114:	2f061023 	svccs	0x00061023
    3118:	02000005 	andeq	r0, r0, #5
  {
    i=1;
    311c:	004825c5 	subeq	r2, r8, r5, asr #11
    3120:	23020000 	movwcs	r0, #8192	; 0x2000
    SIM_SCGC6 |= SIM_SCGC6_FTM1_MASK;
    3124:	57070014 	smladpl	r7, r4, r0, r0
    3128:	02000001 	andeq	r0, r0, #1
    312c:	00f125c6 	rscseq	r2, r1, r6, asr #11
    3130:	04080000 	streq	r0, [r8], #-0
    3134:	000000f7 	strdeq	r0, [r0], -r7
    3138:	00007d09 	andeq	r7, r0, r9, lsl #26
    313c:	04830300 	streq	r0, [r3], #768	; 0x300
    3140:	1b040000 	blne	103148 <__etext+0xfa4a0>
    3144:	0000002c 	andeq	r0, r0, ip, lsr #32
    3148:	0012e003 	andseq	lr, r2, r3
  }
  else if(ftm_init_structure.FTM_Ftmx == FTM2)
    314c:	3a1c0400 	bcc	704154 <__etext+0x6fb4ac>
    3150:	03000000 	movweq	r0, #0
    3154:	00001d7b 	andeq	r1, r0, fp, ror sp
    3158:	00531d04 	subseq	r1, r3, r4, lsl #26
  {
    i=2;
    315c:	04020000 	streq	r0, [r2], #-0
    SIM_SCGC3 |= SIM_SCGC3_FTM2_MASK;
    3160:	00066904 	andeq	r6, r6, r4, lsl #18
    3164:	04080200 	streq	r0, [r8], #-512	; 0x200
    3168:	00000a87 	andeq	r0, r0, r7, lsl #21
    316c:	0014a10a 	andseq	sl, r4, sl, lsl #2
    3170:	0f050400 	svceq	0x00050400
    3174:	00000258 	andeq	r0, r0, r8, asr r2
    3178:	0014970b 	andseq	r9, r4, fp, lsl #14
    317c:	df0b0100 	svcle	0x000b0100
    3180:	02000010 	andeq	r0, r0, #16
    3184:	0010e90b 	andseq	lr, r0, fp, lsl #18
    3188:	f30b0400 	vshl.u8	d0, d0, d11
  }
  else if (ftm_init_structure.FTM_Ftmx == FTM3)
    318c:	08000010 	stmdaeq	r0, {r4}
    3190:	0013780b 	andseq	r7, r3, fp, lsl #16
    3194:	fd0b1000 	stc2	0, cr1, [fp, #-0]
  {
    i = 3;
    3198:	20000010 	andcs	r0, r0, r0, lsl r0
    319c:	0011070b 	andseq	r0, r1, fp, lsl #14
    SIM_SCGC3 |= SIM_SCGC3_FTM3_MASK;
    31a0:	0b00c000 	bleq	331a8 <__etext+0x2a500>
    31a4:	00001382 	andeq	r1, r0, r2, lsl #7
    31a8:	8c0b0180 	stfhis	f0, [fp], {128}	; 0x80
    31ac:	80000013 	andhi	r0, r0, r3, lsl r0
    31b0:	13960b02 	orrsne	r0, r6, #2048	; 0x800
    31b4:	04800000 	streq	r0, [r0], #0
    31b8:	0014ae0b 	andseq	sl, r4, fp, lsl #28
    31bc:	0b088000 	bleq	2231c4 <__etext+0x21a51c>
    31c0:	000014b9 			; <UNDEFINED> instruction: 0x000014b9
    31c4:	c40b1080 	strgt	r1, [fp], #-128	; 0x80
  }
  else
  {
    return 0;
    31c8:	80000014 	andhi	r0, r0, r4, lsl r0
    31cc:	14cf0b20 	strbne	r0, [pc], #2848	; 31d4 <LPLD_FTM_Init+0x114>
  }
  
  if(ftm_init_structure.FTM_Mode & FTM_MODE_PWM)
    31d0:	c0800000 	addgt	r0, r0, r0
    31d4:	14da0b00 	ldrbne	r0, [sl], #2816	; 0xb00
  {
    result = LPLD_FTM_PWM_Init(ftm_init_structure);
    31d8:	80800000 	addhi	r0, r0, r0
    31dc:	14e50b01 	strbtne	r0, [r5], #2817	; 0xb01
    31e0:	80800000 	addhi	r0, r0, r0
    31e4:	14f00b02 	ldrbtne	r0, [r0], #2818	; 0xb02
    31e8:	80800000 	addhi	r0, r0, r0
    31ec:	14fb0b04 	ldrbtne	r0, [fp], #2820	; 0xb04
    31f0:	80800000 	addhi	r0, r0, r0
    31f4:	15060b08 	strne	r0, [r6, #-2824]	; 0xb08
  }
  else if(ftm_init_structure.FTM_Mode & FTM_MODE_IC)
    31f8:	80800000 	addhi	r0, r0, r0
    31fc:	15110b10 	ldrne	r0, [r1, #-2832]	; 0xb10
  {
    result = LPLD_FTM_IC_Init(ftm_init_structure);
    3200:	80800000 	addhi	r0, r0, r0
    3204:	12f20b20 	rscsne	r0, r2, #32768	; 0x8000
    3208:	80800000 	addhi	r0, r0, r0
    320c:	9b0b00c0 	blls	2c3514 <__etext+0x2ba86c>
    3210:	80000015 	andhi	r0, r0, r5, lsl r0
    3214:	0b018080 	bleq	6341c <__etext+0x5a774>
    3218:	000015a6 	andeq	r1, r0, r6, lsr #11
    321c:	02808080 	addeq	r8, r0, #128	; 0x80
  }
  else if(ftm_init_structure.FTM_Mode & FTM_MODE_QD)
    3220:	0015b10b 	andseq	fp, r5, fp, lsl #2
    3224:	80808000 	addhi	r8, r0, r0
  {
    result = LPLD_FTM_QD_Init(ftm_init_structure);
    3228:	15bc0b04 	ldrne	r0, [ip, #2820]!	; 0xb04
    322c:	80800000 	addhi	r0, r0, r0
    3230:	c70b0880 	strgt	r0, [fp, -r0, lsl #17]
    3234:	80000015 	andhi	r0, r0, r5, lsl r0
    3238:	0b108080 	bleq	423440 <__etext+0x41a798>
    323c:	000015d2 	ldrdeq	r1, [r0], -r2
    3240:	20808080 	addcs	r8, r0, r0, lsl #1
    3244:	0013230b 	andseq	r2, r3, fp, lsl #6
  }
  else if(ftm_init_structure.FTM_Mode & FTM_MODE_DEC)
    3248:	80808000 	addhi	r8, r0, r0
    324c:	2e0b00c0 	cdpcs	0, 0, cr0, cr11, cr0, {6}
  {
    result = LPLD_FTM_DEC_Init(ftm_init_structure);
    3250:	80000013 	andhi	r0, r0, r3, lsl r0
    3254:	01808080 	orreq	r8, r0, r0, lsl #1
    3258:	0013390b 	andseq	r3, r3, fp, lsl #18
    325c:	80808000 	addhi	r8, r0, r0
    3260:	e80b0280 	stmda	fp, {r7, r9}
    3264:	80000015 	andhi	r0, r0, r5, lsl r0
    3268:	04808080 	streq	r8, [r0], #128	; 0x80
  }
  
  if(result == 1)
    326c:	0015f30b 	andseq	pc, r5, fp, lsl #6
    3270:	80808000 	addhi	r8, r0, r0
  {    
    //жǷж
    if(ftm_init_structure.FTM_Isr!=NULL)
    3274:	600b0880 	andvs	r0, fp, r0, lsl #17
    {      
      FTM_ISR[i] = ftm_init_structure.FTM_Isr;
    3278:	ff000014 			; <UNDEFINED> instruction: 0xff000014
    327c:	13ec0b01 	mvnne	r0, #1024	; 0x400
    3280:	fe800000 	cdp2	0, 8, cr0, cr0, cr0, {0}
    3284:	12530b03 	subsne	r0, r3, #3072	; 0xc00
      if(ftm_init_structure.FTM_ToiEnable == TRUE)
    3288:	80800000 	addhi	r0, r0, r0
    328c:	920b07fc 	andls	r0, fp, #66060288	; 0x3f00000
      {
        ftm_init_structure.FTM_Ftmx->SC |= FTM_SC_TOIE_MASK;
    3290:	80000011 	andhi	r0, r0, r1, lsl r0
    3294:	0ff88080 	svceq	0x00f88080
    3298:	061a0700 	ldreq	r0, [sl], -r0, lsl #14
      }
    }
  }
  
  return result;
    329c:	a7050000 	strge	r0, [r5, -r0]
}
    32a0:	00026401 	andeq	r6, r2, r1, lsl #8
    32a4:	6a040800 	bvs	1052ac <__etext+0xfc604>
    32a8:	0c000002 	stceq	0, cr0, [r0], {2}
    32ac:	05140d01 	ldreq	r0, [r4, #-3329]	; 0xd01
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_FTM_Deinit(FTM_InitTypeDef ftm_init_structure)
{
    32b0:	02d001aa 	sbcseq	r0, r0, #-2147483606	; 0x8000002a
    32b4:	40060000 	andmi	r0, r6, r0
    32b8:	05000006 	streq	r0, [r0, #-6]
    32bc:	00e501af 	rsceq	r0, r5, pc, lsr #3
  if(ftm_init_structure.FTM_Ftmx == FTM0)
    32c0:	23020000 	movwcs	r0, #8192	; 0x2000
    32c4:	09ee0600 	stmibeq	lr!, {r9, sl}^
    32c8:	b3050000 	movwlt	r0, #20480	; 0x5000
    32cc:	00011201 	andeq	r1, r1, r1, lsl #4
  {
    SIM_SCGC6 &= ~SIM_SCGC6_FTM0_MASK;
    32d0:	04230200 	strteq	r0, [r3], #-512	; 0x200
    32d4:	0002f606 	andeq	pc, r2, r6, lsl #12
    32d8:	01b70500 			; <UNDEFINED> instruction: 0x01b70500
    32dc:	00000112 	andeq	r0, r0, r2, lsl r1
    32e0:	06082302 	streq	r2, [r8], -r2, lsl #6
    32e4:	00000534 	andeq	r0, r0, r4, lsr r5
    32e8:	fc01bb05 	stc2	11, cr11, [r1], {5}
    32ec:	02000000 	andeq	r0, r0, #0
    32f0:	28060c23 	stmdacs	r6, {r0, r1, r5, sl, fp}
    32f4:	05000020 	streq	r0, [r0, #-32]
  }
  else if(ftm_init_structure.FTM_Ftmx == FTM1)
    32f8:	00fc01bf 	ldrhteq	r0, [ip], #31
    32fc:	23020000 	movwcs	r0, #8192	; 0x2000
    3300:	09d4060d 	ldmibeq	r4, {r0, r2, r3, r9, sl}^
    3304:	c9050000 	stmdbgt	r5, {}	; <UNPREDICTABLE>
  {
    SIM_SCGC6 &= ~SIM_SCGC6_FTM1_MASK;
    3308:	00025801 	andeq	r5, r2, r1, lsl #16
    330c:	10230200 	eorne	r0, r3, r0, lsl #4
    3310:	05ff0700 	ldrbeq	r0, [pc, #1792]!	; 3a18 <LPLD_FTM_PWM_Init+0xac>
    3314:	ca050000 	bgt	14331c <__etext+0x13a674>
    3318:	00026c01 	andeq	r6, r2, r1, lsl #24
    331c:	08010200 	stmdaeq	r1, {r9}
    3320:	00000712 	andeq	r0, r0, r2, lsl r7
    3324:	169f010e 	ldrne	r0, [pc], lr, lsl #2
    3328:	31010000 	mrscc	r0, (UNDEF: 1)
    332c:	001a4801 	andseq	r4, sl, r1, lsl #16
  }
  else if(ftm_init_structure.FTM_Ftmx == FTM2)
    3330:	001a8600 	andseq	r8, sl, r0, lsl #12
    3334:	00044a00 	andeq	r4, r4, r0, lsl #20
    3338:	030c0100 	movweq	r0, #49408	; 0xc100
    333c:	700f0000 	andvc	r0, pc, r0
  {
    SIM_SCGC3 &= ~SIM_SCGC3_FTM2_MASK;
    3340:	01006274 	tsteq	r0, r4, ror r2
    3344:	0002d033 	andeq	sp, r2, r3, lsr r0
    3348:	64910200 	ldrvs	r0, [r1], #512	; 0x200
    334c:	25011000 	strcs	r1, [r1, #-0]
    3350:	01000016 	tsteq	r0, r6, lsl r0
    3354:	00fc014a 	rscseq	r0, ip, sl, asr #2
    3358:	1a880000 	bne	fe203360 <__StackLimit+0xde203360>
    335c:	1aee0000 	bne	ffb83364 <__StackLimit+0xdfb83364>
    3360:	04820000 	streq	r0, [r2], #0
    3364:	47010000 	strmi	r0, [r1, -r0]
  }
  else if (ftm_init_structure.FTM_Ftmx == FTM3)
    3368:	11000003 	tstne	r0, r3
    336c:	000016ae 	andeq	r1, r0, lr, lsr #13
    3370:	01074a01 	tsteq	r7, r1, lsl #20
    3374:	91020000 	mrsls	r0, (UNDEF: 2)
  {
      SIM_SCGC3 &= ~SIM_SCGC3_FTM3_MASK;
    3378:	0b221176 	bleq	887958 <__etext+0x87ecb0>
    337c:	4a010000 	bmi	43384 <__etext+0x3a6dc>
    3380:	000000fc 	strdeq	r0, [r0], -ip
    3384:	00759102 	rsbseq	r9, r5, r2, lsl #2
    3388:	16e80110 	usatne	r0, #8, r0, lsl #2
    338c:	75010000 	strvc	r0, [r1, #-0]
    3390:	0000fc01 	andeq	pc, r0, r1, lsl #24
    3394:	001af000 	andseq	pc, sl, r0
    3398:	001bac00 	andseq	sl, fp, r0, lsl #24
    339c:	0004ba00 	andeq	fp, r4, r0, lsl #20
  }
  else
  {
    return 0;
    33a0:	03900100 	orrseq	r0, r0, #0
    33a4:	ae110000 	cdpge	0, 1, cr0, cr1, cr0, {0}
  }
  
  return LPLD_FTM_DisableIrq(ftm_init_structure);
    33a8:	01000016 	tsteq	r0, r6, lsl r0
    33ac:	0000fc75 	andeq	pc, r0, r5, ror ip	; <UNPREDICTABLE>
    33b0:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
    33b4:	000b2211 	andeq	r2, fp, r1, lsl r2
    33b8:	90750100 	rsbsls	r0, r5, r0, lsl #2
    33bc:	02000003 	andeq	r0, r0, #3
}
    33c0:	98117091 	ldmdals	r1, {r0, r4, r7, ip, sp, lr}
    33c4:	01000016 	tsteq	r0, r6, lsl r0
    33c8:	00010775 	andeq	r0, r1, r5, ror r7
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_FTM_PWM_Enable(FTM_MemMapPtr  ftmx, FtmChnEnum_Type chn, uint32 duty, PortPinsEnum_Type pin, uint8 align)
{
    33cc:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    33d0:	fc040800 	stc2	8, cr0, [r4], {-0}
    33d4:	12000000 	andne	r0, r0, #0
    33d8:	00166601 	andseq	r6, r6, r1, lsl #12
  uint32 cv;
  vuint32 mod;
 
  if (duty > 10000)
    33dc:	01a60100 			; <UNDEFINED> instruction: 0x01a60100
    33e0:	000000fc 	strdeq	r0, [r0], -ip
    33e4:	00001bac 	andeq	r1, r0, ip, lsr #23
    return 0;
    33e8:	00001c7c 	andeq	r1, r0, ip, ror ip
  //
  //ASSERT( duty <= 10000 );                  //жռձ
  
  if(!LPLD_FTM_PinInit(ftmx, chn, pin))
    33ec:	000004f2 	strdeq	r0, [r0], -r2
    33f0:	16fa1301 	ldrbtne	r1, [sl], r1, lsl #6
    33f4:	c6010000 	strgt	r0, [r1], -r0
    33f8:	001c7c01 	andseq	r7, ip, r1, lsl #24
    33fc:	001cca00 	andseq	ip, ip, r0, lsl #20
    return 0;
    3400:	00051e00 	andeq	r1, r5, r0, lsl #28
    3404:	b7130100 	ldrlt	r0, [r3, -r0, lsl #2]
  
  //Ҷ룬100%-ռձ
  if(align == ALIGN_RIGHT)
    3408:	01000016 	tsteq	r0, r6, lsl r0
    340c:	1ccc01d5 	stfnee	f0, [ip], {213}	; 0xd5
  {
    duty = 10000 - duty;
    3410:	1d2a0000 	stcne	0, cr0, [sl, #-0]
    3414:	054a0000 	strbeq	r0, [sl, #-0]
    3418:	13010000 	movwne	r0, #4096	; 0x1000
  }
  
  //ռձ = (CnV-CNTIN)/(MOD-CNTIN+1)
  mod = ftmx->MOD;
    341c:	000016c5 	andeq	r1, r0, r5, asr #13
  cv = (duty*(mod-0+1)+0)/10000;
    3420:	2c01e801 	stccs	8, cr14, [r1], {1}
    3424:	8a00001d 	bhi	34a0 <LPLD_FTM_PWM_ChangeDuty+0x2c>
    3428:	7600001d 			; <UNDEFINED> instruction: 0x7600001d
    342c:	01000005 	tsteq	r0, r5
    3430:	00168614 	andseq	r8, r6, r4, lsl r6
    3434:	01f80100 	mvnseq	r0, r0, lsl #2
    3438:	000000fc 	strdeq	r0, [r0], -ip
    343c:	00001d8c 	andeq	r1, r0, ip, lsl #27
  
  // FTMͨƼĴ 
  // ͨģʽ MSB:MSA-1X, ͨԵѡ  ELSB:ELSA-10
  // ͨģʽ MSB:MSA-1X, ͨԵѡ Ҷ ELSB:ELSA-X1
  ftmx->CONTROLS[chn].CnSC = align;
    3440:	00001e26 	andeq	r1, r0, r6, lsr #28
    3444:	000005a2 	andeq	r0, r0, r2, lsr #11
    3448:	16d51501 	ldrbne	r1, [r5], r1, lsl #10
    344c:	13010000 	movwne	r0, #4096	; 0x1000
    3450:	1e280101 	sufnee	f0, f0, f1
  // FTMֵͨ
  ftmx->CONTROLS[chn].CnV  = cv;
    3454:	1eca0000 	cdpne	0, 12, cr0, cr10, cr0, {0}
    3458:	05ce0000 	strbeq	r0, [lr]
    345c:	3f010000 	svccc	0x00010000
    3460:	16000004 	strne	r0, [r0], -r4
  
  return 1;
    3464:	00000b22 	andeq	r0, r0, r2, lsr #22
}
    3468:	fc011301 	stc2	3, cr1, [r1], {1}
    346c:	02000000 	andeq	r0, r0, #0
    3470:	69176f91 	ldmdbvs	r7, {r0, r4, r7, r8, r9, sl, fp, sp, lr}
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_FTM_PWM_ChangeDuty(FTM_MemMapPtr  ftmx, FtmChnEnum_Type chn, uint32 duty)
{
    3474:	01150100 	tsteq	r5, r0, lsl #2
    3478:	000000fc 	strdeq	r0, [r0], -ip
    347c:	00779102 	rsbseq	r9, r7, r2, lsl #2
    3480:	00165018 	andseq	r5, r6, r8, lsl r0
  uint32 cv;
  vuint32 mod;
  
  if (duty > 10000)
    3484:	012e0100 	teqeq	lr, r0, lsl #2
    3488:	0000fc01 	andeq	pc, r0, r1, lsl #24
    return 0;
    348c:	001ecc00 	andseq	ip, lr, r0, lsl #24
    3490:	001f8e00 	andseq	r8, pc, r0, lsl #28
  //
  //ASSERT( duty <= 10000 );                  //жռձ
    
  //Ҷ룬100%-ռձ
  if(ftmx->CONTROLS[chn].CnSC & FTM_CnSC_ELSA_MASK)
    3494:	00060600 	andeq	r0, r6, r0, lsl #12
    3498:	047a0100 	ldrbteq	r0, [sl], #-256	; 0x100
    349c:	69170000 	ldmdbvs	r7, {}	; <UNPREDICTABLE>
    34a0:	01300100 	teqeq	r0, r0, lsl #2
    34a4:	000000fc 	strdeq	r0, [r0], -ip
    34a8:	19779102 	ldmdbne	r7!, {r1, r8, ip, pc}^
  {
    duty = 10000 - duty;
    34ac:	0000165a 	andeq	r1, r0, sl, asr r6
    34b0:	fc013101 	stc2	1, cr3, [r1], {1}
    34b4:	02000000 	andeq	r0, r0, #0
  }
  
  //ռձ = (CnV-CNTIN)/(MOD-CNTIN+1)
  mod = ftmx->MOD;
    34b8:	1a007691 	bne	20f04 <__etext+0x1825c>
  cv = (duty*(mod-0+1)+0)/10000;
    34bc:	00001676 	andeq	r1, r0, r6, ror r6
    34c0:	01015101 	tsteq	r1, r1, lsl #2
    34c4:	00001f90 	muleq	r0, r0, pc	; <UNPREDICTABLE>
    34c8:	00001fb4 			; <UNDEFINED> instruction: 0x00001fb4
    34cc:	0000063e 	andeq	r0, r0, lr, lsr r6
    34d0:	00691b01 	rsbeq	r1, r9, r1, lsl #22
    34d4:	07015101 	streq	r5, [r1, -r1, lsl #2]
    34d8:	02000001 	andeq	r0, r0, #1
 
  // FTMֵͨ
  ftmx->CONTROLS[chn].CnV = cv;
    34dc:	00007691 	muleq	r0, r1, r6
    34e0:	00000d90 	muleq	r0, r0, sp
    34e4:	07c10002 	strbeq	r0, [r1, r2]
    34e8:	01040000 	mrseq	r0, (UNDEF: 4)
  
  return 1;
    34ec:	00000234 	andeq	r0, r0, r4, lsr r2
}
    34f0:	0019e201 	andseq	lr, r9, r1, lsl #4
    34f4:	00082700 	andeq	r2, r8, r0, lsl #14
    34f8:	001fb400 	andseq	fp, pc, r0, lsl #8
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_FTM_DisableChn(FTM_MemMapPtr  ftmx, FtmChnEnum_Type chn)
{
    34fc:	00289e00 	eoreq	r9, r8, r0, lsl #28
    3500:	00082200 	andeq	r2, r8, r0, lsl #4
    3504:	06010200 	streq	r0, [r1], -r0, lsl #4
  LPLD_FTM_PinDeinit(ftmx, chn);
    3508:	0000070b 	andeq	r0, r0, fp, lsl #14
    350c:	0009dd03 	andeq	sp, r9, r3, lsl #26
    3510:	372a0200 	strcc	r0, [sl, -r0, lsl #4]!
  ftmx->CONTROLS[chn].CnSC = 0;
    3514:	02000000 	andeq	r0, r0, #0
    3518:	07090801 	streq	r0, [r9, -r1, lsl #16]
    351c:	02020000 	andeq	r0, r2, #0
    3520:	00073b05 	andeq	r3, r7, r5, lsl #22
    3524:	07020200 	streq	r0, [r2, -r0, lsl #4]
  ftmx->CONTROLS[chn].CnV  = 0;
    3528:	00000492 	muleq	r0, r2, r4
    352c:	96050402 	strls	r0, [r5], -r2, lsl #8
    3530:	03000001 	movweq	r0, #1
    3534:	0000079b 	muleq	r0, fp, r7
    3538:	005e5002 	subseq	r5, lr, r2
  
  return 1;
    353c:	04020000 	streq	r0, [r2], #-0
}
    3540:	0001e407 	andeq	lr, r1, r7, lsl #8
    3544:	05080200 	streq	r0, [r8, #-512]	; 0x200
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_FTM_IC_Enable(FTM_MemMapPtr  ftmx, FtmChnEnum_Type chn, PortPinsEnum_Type pin, uint8 capture_edge)
{
    3548:	00000191 	muleq	r0, r1, r1
    354c:	df070802 	svcle	0x00070802
    3550:	04000001 	streq	r0, [r0], #-1
    3554:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
  if(!LPLD_FTM_PinInit(ftmx, chn, pin))
    3558:	04020074 	streq	r0, [r2], #-116	; 0x74
    355c:	0001e907 	andeq	lr, r1, r7, lsl #18
    3560:	03010500 	movweq	r0, #5376	; 0x1500
    3564:	0003a04b 	andeq	sl, r3, fp, asr #32
    3568:	0aa50600 	beq	fe944d70 <__StackLimit+0xde944d70>
    return 0;
    356c:	06000000 	streq	r0, [r0], -r0
  
  ftmx->CONTROLS[chn].CnSC = 0x00;
    3570:	0000069a 	muleq	r0, sl, r6
    3574:	020a0601 	andeq	r0, sl, #1048576	; 0x100000
    3578:	06020000 	streq	r0, [r2], -r0
    357c:	00000000 	andeq	r0, r0, r0
    3580:	00c40603 	sbceq	r0, r4, r3, lsl #12
  
  ftmx->CONTROLS[chn].CnSC |= capture_edge;        
    3584:	06040000 	streq	r0, [r4], -r0
    3588:	000001bd 			; <UNDEFINED> instruction: 0x000001bd
    358c:	08bf0605 	ldmeq	pc!, {r0, r2, r9, sl}	; <UNPREDICTABLE>
    3590:	06060000 	streq	r0, [r6], -r0
    3594:	0000027d 	andeq	r0, r0, sp, ror r2
    3598:	028b0607 	addeq	r0, fp, #7340032	; 0x700000
    359c:	06080000 	streq	r0, [r8], -r0
    35a0:	00000299 	muleq	r0, r9, r2
    35a4:	09a40609 	stmibeq	r4!, {r0, r3, r9, sl}
  
  ftmx->CONTROLS[chn].CnSC &= (~FTM_CnSC_CHF_MASK);
    35a8:	060a0000 	streq	r0, [sl], -r0
    35ac:	00000a11 	andeq	r0, r0, r1, lsl sl
    35b0:	059a060b 	ldreq	r0, [sl, #1547]	; 0x60b
    35b4:	060c0000 	streq	r0, [ip], -r0
    35b8:	000009c5 	andeq	r0, r0, r5, asr #19
    35bc:	054b060d 	strbeq	r0, [fp, #-1549]	; 0x60d
    35c0:	060e0000 	streq	r0, [lr], -r0
    35c4:	000003de 	ldrdeq	r0, [r0], -lr
    35c8:	0108060f 	tsteq	r8, pc, lsl #12
  ftmx->CONTROLS[chn].CnSC |= FTM_CnSC_CHIE_MASK;         //ʹͨж
    35cc:	06100000 	ldreq	r0, [r0], -r0
    35d0:	0000068b 	andeq	r0, r0, fp, lsl #13
    35d4:	01480611 	cmpeq	r8, r1, lsl r6
    35d8:	06120000 	ldreq	r0, [r2], -r0
    35dc:	000006f1 	strdeq	r0, [r0], -r1
    35e0:	037a0613 	cmneq	sl, #19922944	; 0x1300000
    35e4:	06140000 	ldreq	r0, [r4], -r0
    35e8:	00000818 	andeq	r0, r0, r8, lsl r8
    35ec:	03cf0615 	biceq	r0, pc, #22020096	; 0x1500000
  
  ftmx->CONTROLS[chn].CnSC &= (~FTM_CnSC_MSB_MASK);
    35f0:	06160000 	ldreq	r0, [r6], -r0
    35f4:	000008b0 			; <UNDEFINED> instruction: 0x000008b0
    35f8:	042f0617 	strteq	r0, [pc], #-1559	; 3600 <LPLD_FTM_IC_Enable+0xb8>
    35fc:	06180000 	ldreq	r0, [r8], -r0
    3600:	00000139 	andeq	r0, r0, r9, lsr r1
    3604:	03bf0619 			; <UNDEFINED> instruction: 0x03bf0619
    3608:	061a0000 	ldreq	r0, [sl], -r0
    360c:	00000898 	muleq	r0, r8, r8
    3610:	040d061b 	streq	r0, [sp], #-1563	; 0x61b
  ftmx->CONTROLS[chn].CnSC &= (~FTM_CnSC_MSA_MASK);       //óInput captureģʽ
    3614:	061c0000 	ldreq	r0, [ip], -r0
    3618:	000008e8 	andeq	r0, r0, r8, ror #17
    361c:	051f061d 	ldreq	r0, [pc, #-1565]	; 3007 <DMA11_IRQHandler+0x23>
    3620:	061e0000 	ldreq	r0, [lr], -r0
    3624:	000003af 	andeq	r0, r0, pc, lsr #7
    3628:	08cf061f 	stmiaeq	pc, {r0, r1, r2, r3, r4, r9, sl}^	; <UNPREDICTABLE>
    362c:	06200000 	strteq	r0, [r0], -r0
    3630:	00000212 	andeq	r0, r0, r2, lsl r2
    3634:	03f30621 	mvnseq	r0, #34603008	; 0x2100000
  
  ftmx->CONTROLS[chn].CnSC &= (~FTM_CnSC_DMA_MASK);       //رDMA
    3638:	06220000 	strteq	r0, [r2], -r0
    363c:	00000117 	andeq	r0, r0, r7, lsl r1
    3640:	05e00623 	strbeq	r0, [r0, #1571]!	; 0x623
    3644:	06240000 	strteq	r0, [r4], -r0
    3648:	000004d3 	ldrdeq	r0, [r0], -r3
    364c:	0a370625 	beq	dc4ee8 <__etext+0xdbc240>
    3650:	06260000 	strteq	r0, [r6], -r0
    3654:	00000653 	andeq	r0, r0, r3, asr r6
    3658:	075e0627 	ldrbeq	r0, [lr, -r7, lsr #12]
  
  return 1;
    365c:	06280000 	strteq	r0, [r8], -r0
}
    3660:	00000a53 	andeq	r0, r0, r3, asr sl
    3664:	0a670629 	beq	19c4f10 <__etext+0x19bc268>
    3668:	062a0000 	strteq	r0, [sl], -r0
 * :
 *    TRUEFALSE
 *
 */
boolean LPLD_FTM_IsTOF(FTM_MemMapPtr  ftmx)
{
    366c:	0000077f 	andeq	r0, r0, pc, ror r7
    3670:	0a70062b 	beq	1c04f24 <__etext+0x1bfc27c>
  return (boolean)((ftmx->SC & FTM_SC_TOF_MASK)>>FTM_SC_TOF_SHIFT);
    3674:	062c0000 	strteq	r0, [ip], -r0
    3678:	00000089 	andeq	r0, r0, r9, lsl #1
    367c:	0166062d 	cmneq	r6, sp, lsr #12
    3680:	062e0000 	strteq	r0, [lr], -r0
}
    3684:	0000058b 	andeq	r0, r0, fp, lsl #11
    3688:	0877062f 	ldmdaeq	r7!, {r0, r1, r2, r3, r5, r9, sl}^
    368c:	06300000 	ldrteq	r0, [r0], -r0
 * :
 *    
 *
 */
void LPLD_FTM_ClearTOF(FTM_MemMapPtr  ftmx)
{
    3690:	00000863 	andeq	r0, r0, r3, ror #16
    3694:	02b70631 	adcseq	r0, r7, #51380224	; 0x3100000
  ftmx->SC = ftmx->SC & ~FTM_SC_TOF_MASK;
    3698:	06320000 	ldrteq	r0, [r2], -r0
    369c:	00000368 	andeq	r0, r0, r8, ror #6
    36a0:	0a8e0633 	beq	fe384f74 <__StackLimit+0xde384f74>
}
    36a4:	06340000 	ldrteq	r0, [r4], -r0
    36a8:	0000006c 	andeq	r0, r0, ip, rrx
    36ac:	03990635 	orrseq	r0, r9, #55574528	; 0x3500000
 * :
 *    TRUEFALSE
 *
 */
boolean LPLD_FTM_IsCHnF(FTM_MemMapPtr  ftmx, FtmChnEnum_Type chn)
{
    36b0:	06360000 	ldrteq	r0, [r6], -r0
    36b4:	000001ae 	andeq	r0, r0, lr, lsr #3
    36b8:	01f60637 	mvnseq	r0, r7, lsr r6
  return (boolean)((ftmx->CONTROLS[chn].CnSC & FTM_CnSC_CHF_MASK)>>FTM_CnSC_CHF_SHIFT);
    36bc:	06380000 	ldrteq	r0, [r8], -r0
    36c0:	000001cb 	andeq	r0, r0, fp, asr #3
    36c4:	043e0639 	ldrteq	r0, [lr], #-1593	; 0x639
    36c8:	063a0000 	ldrteq	r0, [sl], -r0
    36cc:	000004db 	ldrdeq	r0, [r0], -fp
    36d0:	0745063b 	smlaldxeq	r0, r5, fp, r6
    36d4:	063c0000 	ldrteq	r0, [ip], -r0
}
    36d8:	00000918 	andeq	r0, r0, r8, lsl r9
    36dc:	0454063d 	ldrbeq	r0, [r4], #-1597	; 0x63d
    36e0:	063e0000 	ldrteq	r0, [lr], -r0
 * :
 *    
 *
 */
void LPLD_FTM_ClearCHnF(FTM_MemMapPtr  ftmx, FtmChnEnum_Type chn)
{
    36e4:	0000046a 	andeq	r0, r0, sl, ror #8
    36e8:	0a79063f 	beq	1e44fec <__etext+0x1e3c344>
    36ec:	00c00000 	sbceq	r0, r0, r0
  ftmx->CONTROLS[chn].CnSC = ftmx->CONTROLS[chn].CnSC & ~FTM_CnSC_CHF_MASK;
    36f0:	00099406 	andeq	r9, r9, r6, lsl #8
    36f4:	0600c100 	streq	ip, [r0], -r0, lsl #2
    36f8:	0000057d 	andeq	r0, r0, sp, ror r5
    36fc:	a50600c2 	strge	r0, [r6, #-194]	; 0xc2
    3700:	c3000004 	movwgt	r0, #4
    3704:	0a210600 	beq	844f0c <__etext+0x83c264>
    3708:	00c40000 	sbceq	r0, r4, r0
    370c:	0009f806 	andeq	pc, r9, r6, lsl #16
    3710:	0600c500 	streq	ip, [r0], -r0, lsl #10
}
    3714:	0000097a 	andeq	r0, r0, sl, ror r9
    3718:	c30600c6 	movwgt	r0, #24774	; 0x60c6
    371c:	c7000004 	strgt	r0, [r0, -r4]
 * :
 *    0x1~0xFFFF
 *
 */
uint16 LPLD_FTM_GetChVal(FTM_MemMapPtr  ftmx, FtmChnEnum_Type chn)
{
    3720:	053d0600 	ldreq	r0, [sp, #-1536]!	; 0x600
    3724:	00c80000 	sbceq	r0, r8, r0
    3728:	00040406 	andeq	r0, r4, r6, lsl #8
  return ftmx->CONTROLS[chn].CnV;    //ȡӦͨ񵽵FTMֵ
    372c:	0600c900 	streq	ip, [r0], -r0, lsl #18
    3730:	0000022b 	andeq	r0, r0, fp, lsr #4
    3734:	b30600ca 	movwlt	r0, #24778	; 0x60ca
    3738:	cb000009 	blgt	3764 <LPLD_FTM_GetClkDiv+0x18>
    373c:	066f0600 	strbteq	r0, [pc], -r0, lsl #12
}
    3740:	00cc0000 	sbceq	r0, ip, r0
    3744:	00067806 	andeq	r7, r6, r6, lsl #16
    3748:	0600cd00 	streq	ip, [r0], -r0, lsl #26
 * :
 *    1248163264128
 *
 */
uint8 LPLD_FTM_GetClkDiv(FTM_MemMapPtr  ftmx)
{
    374c:	000002cd 	andeq	r0, r0, sp, asr #5
    3750:	d60600ce 	strle	r0, [r6], -lr, asr #1
  return 1u<<((ftmx->SC & FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT);    //ʱӷƵϵ
    3754:	cf000002 	svcgt	0x00000002
    3758:	02df0600 	sbcseq	r0, pc, #0
    375c:	00d00000 	sbcseq	r0, r0, r0
    3760:	00021a06 	andeq	r1, r2, r6, lsl #20
    3764:	0600d100 	streq	sp, [r0], -r0, lsl #2
}
    3768:	00000462 	andeq	r0, r0, r2, ror #8
    376c:	890600d2 	stmdbhi	r6, {r1, r4, r6, r7}
    3770:	d3000003 	movwle	r0, #3
 * :
 *    
 *
 */
uint16 LPLD_FTM_GetCounter(FTM_MemMapPtr  ftmx)
{
    3774:	047a0600 	ldrbteq	r0, [sl], #-1536	; 0x600
    3778:	00d40000 	sbcseq	r0, r4, r0
  return ftmx->CNT;        //ȡFTMxֵ
    377c:	00002e06 	andeq	r2, r0, r6, lsl #28
    3780:	0600d500 	streq	sp, [r0], -r0, lsl #10
}
    3784:	000007cb 	andeq	r0, r0, fp, asr #15
    3788:	450600d6 	strmi	r0, [r6, #-214]	; 0xd6
    378c:	d7000000 	strle	r0, [r0, -r0]
 * :
 *    
 *
 */
void LPLD_FTM_ClearCounter(FTM_MemMapPtr  ftmx)
{
    3790:	05ec0600 	strbeq	r0, [ip, #1536]!	; 0x600
    3794:	00d80000 	sbcseq	r0, r8, r0
  ftmx->CNT = 0;        //FTMxֵ
    3798:	00022206 	andeq	r2, r2, r6, lsl #4
    379c:	0600d900 	streq	sp, [r0], -r0, lsl #18
}
    37a0:	00000753 	andeq	r0, r0, r3, asr r7
    37a4:	040600da 	streq	r0, [r6], #-218	; 0xda
    37a8:	db000009 	blle	37d4 <LPLD_FTM_EnableIrq+0x28>
 *    0--ô
 *    1--óɹ
 *
 */
uint8 LPLD_FTM_EnableIrq(FTM_InitTypeDef ftm_init_structure)
{
    37ac:	00de0600 	sbcseq	r0, lr, r0, lsl #12
    37b0:	00dc0000 	sbcseq	r0, ip, r0
    37b4:	00005606 	andeq	r5, r0, r6, lsl #12
    37b8:	0600dd00 	streq	sp, [r0], -r0, lsl #26
  uint8 i;
  FTM_MemMapPtr  ftmx = ftm_init_structure.FTM_Ftmx;
    37bc:	0000019f 	muleq	r0, pc, r1	; <UNPREDICTABLE>
  
  if(ftmx == FTM0)
    37c0:	440600de 	strmi	r0, [r6], #-222	; 0xde
    37c4:	df00000a 	svcle	0x0000000a
    37c8:	00a60600 	adceq	r0, r6, r0, lsl #12
    37cc:	00e00000 	rsceq	r0, r0, r0
    i=0;
    37d0:	0005d706 	andeq	sp, r5, r6, lsl #14
    37d4:	0600e100 	streq	lr, [r0], -r0, lsl #2
  else if(ftmx == FTM1)
    37d8:	000004ea 	andeq	r0, r0, sl, ror #9
    37dc:	ea0600e2 	b	183b6c <__etext+0x17aec4>
    37e0:	e3000003 	movw	r0, #3
    i=1;
    37e4:	004e0600 	subeq	r0, lr, r0, lsl #12
    37e8:	00e40000 	rsceq	r0, r4, r0
  else if(ftmx == FTM2)
    37ec:	00030606 	andeq	r0, r3, r6, lsl #12
    37f0:	0600e500 	streq	lr, [r0], -r0, lsl #10
    37f4:	000000b4 	strheq	r0, [r0], -r4
    37f8:	f50600e6 			; <UNDEFINED> instruction: 0xf50600e6
    i=2;
    37fc:	e7000005 	str	r0, [r0, -r5]
    3800:	012a0600 	teqeq	sl, r0, lsl #12
  else if (ftmx == FTM3)
    3804:	00e80000 	rsceq	r0, r8, r0
    3808:	00061006 	andeq	r1, r6, r6
    380c:	0600e900 	streq	lr, [r0], -r0, lsl #18
    i = 3;
    3810:	00000731 	andeq	r0, r0, r1, lsr r7
    3814:	2c0600ea 	stccs	0, cr0, [r6], {234}	; 0xea
  else
    return 0;
    3818:	eb000006 	bl	3838 <LPLD_FTM_EnableIrq+0x8c>
    381c:	06360600 	ldrteq	r0, [r6], -r0, lsl #12

  enable_irq(62 + i);
    3820:	00ec0000 	rsceq	r0, ip, r0
    3824:	00089006 	andeq	r9, r8, r6
    3828:	0600ed00 	streq	lr, [r0], -r0, lsl #26
  
  return 1;
    382c:	00000661 	andeq	r0, r0, r1, ror #12
}
    3830:	c30600ee 	movwgt	r0, #24814	; 0x60ee
    3834:	ef000005 	svc	0x00000005
    3838:	06810600 	streq	r0, [r1], r0, lsl #12
    383c:	00f00000 	rscseq	r0, r0, r0
 *    0--ô
 *    1--óɹ
 *
 */
uint8 LPLD_FTM_DisableIrq(FTM_InitTypeDef ftm_init_structure)
{
    3840:	0000f806 	andeq	pc, r0, r6, lsl #16
    3844:	0600f100 	streq	pc, [r0], -r0, lsl #2
    3848:	000009e5 	andeq	r0, r0, r5, ror #19
    384c:	5d0600f2 	stcpl	0, cr0, [r6, #-968]	; 0xfffffc38
  uint8 i;
  FTM_MemMapPtr  ftmx = ftm_init_structure.FTM_Ftmx;
    3850:	f3000003 	vhadd.u8	d0, d0, d3
  
  if(ftmx == FTM0)
    3854:	02a70600 	adceq	r0, r7, #0
    3858:	00f40000 	rscseq	r0, r4, r0
    385c:	0002e806 	andeq	lr, r2, r6, lsl #16
    3860:	0600f500 	streq	pc, [r0], -r0, lsl #10
    i=0;
    3864:	0000041d 	andeq	r0, r0, sp, lsl r4
    3868:	260600f6 			; <UNDEFINED> instruction: 0x260600f6
  else if(ftmx == FTM1)
    386c:	f7000004 			; <UNDEFINED> instruction: 0xf7000004
    3870:	01850600 	orreq	r0, r5, r0, lsl #12
    3874:	00f80000 	rscseq	r0, r8, r0
    i=1;
    3878:	00098806 	andeq	r8, r9, r6, lsl #16
    387c:	0000f900 	andeq	pc, r0, r0, lsl #18
  else if(ftmx == FTM2)
    3880:	00198707 	andseq	r8, r9, r7, lsl #14
    3884:	f0037000 			; <UNDEFINED> instruction: 0xf0037000
    3888:	00000520 	andeq	r0, r0, r0, lsr #10
    388c:	31435308 	cmpcc	r3, r8, lsl #6
    i=2;
    3890:	20f10300 	rscscs	r0, r1, r0, lsl #6
    3894:	02000005 	andeq	r0, r0, #5
  else if (ftmx == FTM3)
    3898:	2a090023 	bcs	24392c <__etext+0x23ac84>
    389c:	0300000f 	movweq	r0, #15
    38a0:	000053f2 	strdeq	r5, [r0], -r2
      i = 3;
    38a4:	08230200 	stmdaeq	r3!, {r9}
    38a8:	000f3009 	andeq	r3, pc, r9
  else
    return 0;
    38ac:	53f30300 	mvnspl	r0, #0
    38b0:	02000000 	andeq	r0, r0, #0

  disable_irq(62 + i);
    38b4:	52080c23 	andpl	r0, r8, #8960	; 0x2300
    38b8:	20f40300 	rscscs	r0, r4, r0, lsl #6
    38bc:	02000005 	andeq	r0, r0, #5
  
  return 1;
    38c0:	43081023 	movwmi	r1, #32803	; 0x8023
}
    38c4:	03003156 	movweq	r3, #342	; 0x156
    38c8:	000053f5 	strdeq	r5, [r0], -r5	; <UNPREDICTABLE>
    38cc:	18230200 	stmdane	r3!, {r9}
    38d0:	32564308 	subscc	r4, r6, #536870912	; 0x20000000
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_FTM_QD_Enable(FTM_MemMapPtr  ftmx, PortPinsEnum_Type pha, PortPinsEnum_Type phb)
{
    38d4:	53f60300 	mvnspl	r0, #0
    38d8:	02000000 	andeq	r0, r0, #0
    38dc:	53081c23 	movwpl	r1, #35875	; 0x8c23
    38e0:	03003243 	movweq	r3, #579	; 0x243
  if(!LPLD_FTM_PinInit(ftmx, FTM_PhA, pha))
    38e4:	000053f7 	strdeq	r5, [r0], -r7
    38e8:	20230200 	eorcs	r0, r3, r0, lsl #4
    38ec:	33435308 	movtcc	r5, #13064	; 0x3308
    38f0:	53f80300 	mvnspl	r0, #0
    38f4:	02000000 	andeq	r0, r0, #0
    return 0;
    38f8:	4f082423 	svcmi	0x00082423
    38fc:	03005346 	movweq	r5, #838	; 0x346
  if(!LPLD_FTM_PinInit(ftmx, FTM_PhB, phb))
    3900:	000053f9 	strdeq	r5, [r0], -r9
    3904:	28230200 	stmdacs	r3!, {r9}
    3908:	00475008 	subeq	r5, r7, r8
    390c:	0053fa03 	subseq	pc, r3, r3, lsl #20
    3910:	23020000 	movwcs	r0, #8192	; 0x2000
    return 0;
    3914:	474d082c 	strbmi	r0, [sp, -ip, lsr #16]
  
  return 1;
    3918:	53fb0300 	mvnspl	r0, #0
}
    391c:	02000000 	andeq	r0, r0, #0
    3920:	18093023 	stmdane	r9, {r0, r1, r5, ip, sp}
    3924:	03000019 	movweq	r0, #25
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_FTM_QD_Disable(FTM_MemMapPtr  ftmx)
{
    3928:	000053fc 	strdeq	r5, [r0], -ip
    392c:	34230200 	strtcc	r0, [r3], #-512	; 0x200
  if(!LPLD_FTM_PinDeinit(ftmx, FTM_PhA))
    3930:	00191d09 	andseq	r1, r9, r9, lsl #26
    3934:	53fd0300 	mvnspl	r0, #0
    3938:	02000000 	andeq	r0, r0, #0
    393c:	13093823 	movwne	r3, #38947	; 0x9823
    return 0;
    3940:	03000019 	movweq	r0, #25
    3944:	000053fe 	strdeq	r5, [r0], -lr
  if(!LPLD_FTM_PinDeinit(ftmx, FTM_PhB))
    3948:	3c230200 	sfmcc	f0, 4, [r3], #-0
    394c:	00190e09 	andseq	r0, r9, r9, lsl #28
    3950:	53ff0300 	mvnspl	r0, #0
    3954:	02000000 	andeq	r0, r0, #0
    return 0;
    3958:	090a4023 	stmdbeq	sl, {r0, r1, r5, lr}
  
  return 1;
    395c:	03000019 	movweq	r0, #25
}
    3960:	00530100 	subseq	r0, r3, r0, lsl #2
    3964:	23020000 	movwcs	r0, #8192	; 0x2000
    3968:	19040a44 	stmdbne	r4, {r2, r6, r9, fp}
/*
 * LPLD_FTM_PWM_Init
 * FTMģPWMģʽʼڲ
 */
static uint8 LPLD_FTM_PWM_Init(FTM_InitTypeDef ftm_init_structure)
{
    396c:	01030000 	mrseq	r0, (UNDEF: 3)
    3970:	00005301 	andeq	r5, r0, r1, lsl #6
    3974:	48230200 	stmdami	r3!, {r9}
    3978:	0018ff0a 	andseq	pc, r8, sl, lsl #30
  uint32 bus_clk_hz;
  uint32 mod, mod2;
  uint8 ps;
  uint32 freq = ftm_init_structure.FTM_PwmFreq;
    397c:	01020300 	mrseq	r0, LR_svc
  uint32 dt_en = ftm_init_structure.FTM_PwmDeadtimeCfg;
    3980:	00000053 	andeq	r0, r0, r3, asr r0
  uint8 dt_div = ftm_init_structure.FTM_PwmDeadtimeDiv;
    3984:	0b4c2302 	bleq	130c594 <__etext+0x13038ec>
    3988:	00414750 	subeq	r4, r1, r0, asr r7
  uint8 dt_val = ftm_init_structure.FTM_PwmDeadtimeVal;
    398c:	53010303 	movwpl	r0, #4867	; 0x1303
  FTM_MemMapPtr ftmx = ftm_init_structure.FTM_Ftmx;
    3990:	02000000 	andeq	r0, r0, #0
  
  //
  //ASSERT( freq );                  //жƵ
  //ASSERT( dt_val<=63 );            //жֵ
  if (dt_val > 63)
    3994:	a10a5023 	tstge	sl, r3, lsr #32
    3998:	03000018 	movweq	r0, #24
    return 0;
    399c:	00530104 	subseq	r0, r3, r4, lsl #2
  
  bus_clk_hz = g_bus_clock;
    39a0:	23020000 	movwcs	r0, #8192	; 0x2000
    39a4:	18a60a54 	stmiane	r6!, {r2, r4, r6, r9, fp}
    39a8:	05030000 	streq	r0, [r3, #-0]
  
  if(freq>bus_clk_hz) return 0;
    39ac:	00005301 	andeq	r5, r0, r1, lsl #6
    39b0:	58230200 	stmdapl	r3!, {r9}
    39b4:	00187b0a 	andseq	r7, r8, sl, lsl #22
    39b8:	01060300 	mrseq	r0, LR_und
 //δдıȽȤ... 
  if((mod=bus_clk_hz/(freq*128)) < 0xFFFFu)
    39bc:	00000053 	andeq	r0, r0, r3, asr r0
    39c0:	0a5c2302 	beq	170c5d0 <__etext+0x1703928>
    39c4:	00001876 	andeq	r1, r0, r6, ror r8
    39c8:	53010703 	movwpl	r0, #5891	; 0x1703
    39cc:	02000000 	andeq	r0, r0, #0
    39d0:	710a6023 	tstvc	sl, r3, lsr #32
  {
    ps = 7;
    39d4:	03000018 	movweq	r0, #24
    mod2=mod;
    39d8:	00530108 	subseq	r0, r3, r8, lsl #2
    if((mod=bus_clk_hz/(freq*64)) < 0xFFFFu)
    39dc:	23020000 	movwcs	r0, #8192	; 0x2000
    39e0:	186c0a64 	stmdane	ip!, {r2, r5, r6, r9, fp}^
    39e4:	09030000 	stmdbeq	r3, {}	; <UNPREDICTABLE>
    39e8:	00005301 	andeq	r5, r0, r1, lsl #6
    39ec:	68230200 	stmdavs	r3!, {r9}
    39f0:	0018670a 	andseq	r6, r8, sl, lsl #14
    {
      ps = 6;  
    39f4:	010a0300 	mrseq	r0, (UNDEF: 58)
    39f8:	00000053 	andeq	r0, r0, r3, asr r0
      mod2=mod;  
    39fc:	006c2302 	rsbeq	r2, ip, r2, lsl #6
      if((mod=bus_clk_hz/(freq*32)) < 0xFFFFu)
    3a00:	0000530c 	andeq	r5, r0, ip, lsl #6
    3a04:	00053000 	andeq	r3, r5, r0
    3a08:	05300d00 	ldreq	r0, [r0, #-3328]!	; 0xd00
    3a0c:	00010000 	andeq	r0, r1, r0
    3a10:	74070402 	strvc	r0, [r7], #-1026	; 0x402
    3a14:	0e000005 	cdpeq	0, 0, cr0, cr0, cr5, {0}
      {
        ps = 5;  
    3a18:	0000194f 	andeq	r1, r0, pc, asr #18
        mod2=mod;
    3a1c:	43010b03 	movwmi	r0, #6915	; 0x1b03
        if((mod=bus_clk_hz/(freq*16)) < 0xFFFFu)
    3a20:	0f000005 	svceq	0x00000005
    3a24:	00054904 	andeq	r4, r5, r4, lsl #18
    3a28:	03a01000 	moveq	r1, #0
    3a2c:	2c0c0000 	stccs	0, cr0, [ip], {-0}
    3a30:	5e000000 	cdppl	0, 0, cr0, cr0, cr0, {0}
    3a34:	0d000005 	stceq	0, cr0, [r0, #-20]	; 0xffffffec
        {
          ps = 4;  
    3a38:	00000530 	andeq	r0, r0, r0, lsr r5
    3a3c:	2c0c001b 	stccs	0, cr0, [ip], {27}
          mod2=mod;   
    3a40:	6e000000 	cdpvs	0, 0, cr0, cr0, cr0, {0}
          if((mod=bus_clk_hz/(freq*8)) < 0xFFFFu)
    3a44:	0d000005 	stceq	0, cr0, [r0, #-20]	; 0xffffffec
    3a48:	00000530 	andeq	r0, r0, r0, lsr r5
    3a4c:	2c0c0003 	stccs	0, cr0, [ip], {3}
    3a50:	7e000000 	cdpvc	0, 0, cr0, cr0, cr0, {0}
    3a54:	0d000005 	stceq	0, cr0, [r0, #-20]	; 0xffffffec
    3a58:	00000530 	andeq	r0, r0, r0, lsr r5
          {
            ps = 3;
    3a5c:	2c0c0007 	stccs	0, cr0, [ip], {7}
            mod2=mod;
    3a60:	8e000000 	cdphi	0, 0, cr0, cr0, cr0, {0}
            if((mod=bus_clk_hz/(freq*4)) < 0xFFFFu)
    3a64:	0d000005 	stceq	0, cr0, [r0, #-20]	; 0xffffffec
    3a68:	00000530 	andeq	r0, r0, r0, lsr r5
    3a6c:	530c0017 	movwpl	r0, #49175	; 0xc017
    3a70:	9e000000 	cdpls	0, 0, cr0, cr0, cr0, {0}
    3a74:	0d000005 	stceq	0, cr0, [r0, #-20]	; 0xffffffec
    3a78:	00000530 	andeq	r0, r0, r0, lsr r5
            {
              ps = 2;
    3a7c:	6111001f 	tstvs	r1, pc, lsl r0
    3a80:	cc000012 	stcgt	0, cr0, [r0], {18}
              mod2=mod;
    3a84:	3b35a503 	blcc	d6ce98 <__etext+0xd641f0>
              if((mod=bus_clk_hz/(freq*2)) < 0xFFFFu)
    3a88:	0b000006 	bleq	3aa8 <LPLD_FTM_PWM_Init+0x13c>
    3a8c:	00524350 	subseq	r4, r2, r0, asr r3
    3a90:	8e35a603 	cfmsuba32hi	mvax0, mvax10, mvfx5, mvfx3
    3a94:	02000005 	andeq	r0, r0, #5
    3a98:	110a0023 	tstne	sl, r3, lsr #32
    3a9c:	03000011 	movweq	r0, #17
              {
                ps = 1;
    3aa0:	005335a7 	subseq	r3, r3, r7, lsr #11
                mod2=mod;
    3aa4:	23030000 	movwcs	r0, #12288	; 0x3000
                if((mod=bus_clk_hz/(freq*1)) < 0xFFFFu)
    3aa8:	5a0a0180 	bpl	2840b0 <__etext+0x27b408>
    3aac:	03000014 	movweq	r0, #20
    3ab0:	005335a8 	subseq	r3, r3, r8, lsr #11
    3ab4:	23030000 	movwcs	r0, #12288	; 0x3000
    3ab8:	120a0184 	andne	r0, sl, #33	; 0x21
                {
                  ps = 0;
    3abc:	03000003 	movweq	r0, #3
    3ac0:	057e35a9 	ldrbeq	r3, [lr, #-1449]!	; 0x5a9
                  mod2=mod;
    3ac4:	23030000 	movwcs	r0, #12288	; 0x3000
      }
    }
  }
  else
  {
    return 0;
    3ac8:	380a0188 	stmdacc	sl, {r3, r7, r8}
    3acc:	03000012 	movweq	r0, #18
  }
  
  ftmx->SC = 0;
    3ad0:	005335aa 	subseq	r3, r3, sl, lsr #11
    3ad4:	23030000 	movwcs	r0, #12288	; 0x3000
  
  // PWMڼռձ
  //    PWM = (MOD-CNTIN+1)*FTMʱ :
  // FTMʼֵ
  ftmx->CNT = 0;
    3ad8:	1d0a01a0 	stfnes	f0, [sl, #-640]	; 0xfffffd80
    3adc:	03000003 	movweq	r0, #3
  ftmx->CNTIN = 0;
    3ae0:	054e35ab 	strbeq	r3, [lr, #-1451]	; 0x5ab
    3ae4:	23030000 	movwcs	r0, #12288	; 0x3000
  // FTMMODֵ
  ftmx->MOD = mod2;
    3ae8:	6d0a01a4 	stfvss	f0, [sl, #-656]	; 0xfffffd70
  
  ftmx->DEADTIME = FTM_DEADTIME_DTPS(dt_div) | FTM_DEADTIME_DTVAL(dt_val);
    3aec:	03000012 	movweq	r0, #18
    3af0:	005335ac 	subseq	r3, r3, ip, lsr #11
    3af4:	23030000 	movwcs	r0, #12288	; 0x3000
    3af8:	4a0a01c0 	bmi	284200 <__etext+0x27b558>
    3afc:	03000011 	movweq	r0, #17
  ftmx->COMBINE = dt_en;        //ʹ
    3b00:	005335ad 	subseq	r3, r3, sp, lsr #11
    3b04:	23030000 	movwcs	r0, #12288	; 0x3000
  
  // FTMƼĴ
  // ж, Ӽģʽ, ʱԴ:System clockBus Clk, Ƶϵ:8
  // SysClk = 50MHz, SC_PS=3, FTM Clk = 50MHz/2^3 = 6.25MHz
  ftmx->SC = FTM_SC_CLKS(1)|FTM_SC_PS(ps);
    3b08:	950a01c4 	strls	r0, [sl, #-452]	; 0x1c4
    3b0c:	03000012 	movweq	r0, #18
    3b10:	005335ae 	subseq	r3, r3, lr, lsr #11
  
  return 1;
    3b14:	23030000 	movwcs	r0, #12288	; 0x3000
}
    3b18:	0e0001c8 	adfeqdm	f0, f0, #0.0
    3b1c:	000011b1 			; <UNDEFINED> instruction: 0x000011b1
    3b20:	4735af03 	ldrmi	sl, [r5, -r3, lsl #30]!
    3b24:	0f000006 	svceq	0x00000006
/*
 * LPLD_FTM_IC_Init
 * FTMģ벶ģʽʼڲ
 */
static uint8 LPLD_FTM_IC_Init(FTM_InitTypeDef ftm_init_structure)
{
    3b28:	00064d04 	andeq	r4, r6, r4, lsl #26
    3b2c:	059e1000 	ldreq	r1, [lr]
    3b30:	44120000 	ldrmi	r0, [r2], #-0
    3b34:	70000010 	andvc	r0, r0, r0, lsl r0
  uint8 i;
  uint8 ps = ftm_init_structure.FTM_ClkDiv;
    3b38:	3d950310 	ldccc	3, cr0, [r5, #64]	; 0x40
    3b3c:	0000082e 	andeq	r0, r0, lr, lsr #16
  FTM_ISR_CALLBACK isr_func = ftm_init_structure.FTM_Isr;
    3b40:	0010380a 	andseq	r3, r0, sl, lsl #16
  FTM_MemMapPtr  ftmx = ftm_init_structure.FTM_Ftmx;
    3b44:	3d960300 	ldccc	3, cr0, [r6]
  
  //
  //ASSERT( ps <= 7);             //ʱӷƵϵ
  
  if (ps > 7)
    3b48:	00000053 	andeq	r0, r0, r3, asr r0
    return 0;
    3b4c:	0a002302 	beq	c75c <__etext+0x3ab4>
    3b50:	00000d02 	andeq	r0, r0, r2, lsl #26
  ftmx->CONF=FTM_CONF_BDMMODE(0x3);
    3b54:	533d9703 	teqpl	sp, #786432	; 0xc0000
    3b58:	02000000 	andeq	r0, r0, #0
  
  ftmx->SC = 0;
    3b5c:	120a0423 	andne	r0, sl, #587202560	; 0x23000000
    3b60:	03000003 	movweq	r0, #3
  
  ftmx->CNT = 0;
    3b64:	082e3d98 	stmdaeq	lr!, {r3, r4, r7, r8, sl, fp, ip, sp}
    3b68:	23020000 	movwcs	r0, #8192	; 0x2000
  ftmx->CNTIN = 0;
    3b6c:	103e0a08 	eorsne	r0, lr, r8, lsl #20
    3b70:	99030000 	stmdbls	r3, {}	; <UNPREDICTABLE>
  ftmx->MOD = 0;                           
    3b74:	0000533d 	andeq	r5, r0, sp, lsr r3
    3b78:	84230300 	strthi	r0, [r3], #-768	; 0x300
  ftmx->QDCTRL = (~FTM_QDCTRL_QUADEN_MASK); //ر
    3b7c:	031d0a20 	tsteq	sp, #131072	; 0x20000
    3b80:	9a030000 	bls	c3b88 <__etext+0xbaee0>
    3b84:	00055e3d 	andeq	r5, r5, sp, lsr lr
  ftmx->FILTER = 0x00;                      //ع
    3b88:	88230300 	stmdahi	r3!, {r8, r9}
    3b8c:	104f0a20 	subne	r0, pc, r0, lsr #20
  
  // FTMƼĴ
  // FTM CounteróFree Counter
  // ж, Ӽģʽ, ʱԴ:System clockBus Clk, Ƶϵ:PS
  // SysClk = 50MHz, SC_PS=3, FTM Clk = 50MHz/2^3 = 6.25MHz
  ftmx->SC |= FTM_SC_CLKS(1)|FTM_SC_PS(ps);
    3b90:	9b030000 	blls	c3b98 <__etext+0xbaef0>
    3b94:	0000533d 	andeq	r5, r0, sp, lsr r3
    3b98:	8c230300 	stchi	3, cr0, [r3], #-0
    3b9c:	10550a20 	subsne	r0, r5, r0, lsr #20
    3ba0:	9c030000 	stcls	0, cr0, [r3], {-0}
  //ftmx->SC |= FTM_SC_TOIE_MASK;             //ʹܼж
  ftmx->SC &= (~FTM_SC_CPWMS_MASK);         //FTMӼ
    3ba4:	0000533d 	andeq	r5, r0, sp, lsr r3
    3ba8:	90230300 	eorls	r0, r3, r0, lsl #6
    3bac:	105b0a20 	subsne	r0, fp, r0, lsr #20

  //жϺڵַж
  if(isr_func!=NULL)
    3bb0:	9d030000 	stcls	0, cr0, [r3, #-0]
  {
    if(ftmx == FTM0)
    3bb4:	0000533d 	andeq	r5, r0, sp, lsr r3
    3bb8:	94230300 	strtls	r0, [r3], #-768	; 0x300
    3bbc:	10610a20 	rsbne	r0, r1, r0, lsr #20
    3bc0:	9e030000 	cdpls	0, 0, cr0, cr3, cr0, {0}
      i=0;
    3bc4:	0000533d 	andeq	r5, r0, sp, lsr r3
    3bc8:	98230300 	stmdals	r3!, {r8, r9}
    else if(ftmx == FTM1)
    3bcc:	0a9a0a20 	beq	fe686454 <__StackLimit+0xde686454>
    3bd0:	9f030000 	svcls	0x00030000
    3bd4:	00056e3d 	andeq	r6, r5, sp, lsr lr
      i=1;
    3bd8:	9c230300 	stcls	3, cr0, [r3], #-0
    3bdc:	0c640a20 	stcleq	10, cr0, [r4], #-128	; 0xffffff80
    else if(ftmx == FTM2)
    3be0:	a0030000 	andge	r0, r3, r0
    3be4:	0000533d 	andeq	r5, r0, sp, lsr r3
    3be8:	a4230300 	strtge	r0, [r3], #-768	; 0x300
    3bec:	0c690a20 	stcleq	10, cr0, [r9], #-128	; 0xffffff80
      i=2;
    3bf0:	a1030000 	mrsge	r0, (UNDEF: 3)
    3bf4:	0000533d 	andeq	r5, r0, sp, lsr r3
    else if (ftmx == FTM3)
    3bf8:	a8230300 	stmdage	r3!, {r8, r9}
    3bfc:	0c6f0a20 	stcleq	10, cr0, [pc], #-128	; 3b84 <LPLD_FTM_IC_Init+0x5c>
    3c00:	a2030000 	andge	r0, r3, #0
        i = 3;
    3c04:	0000533d 	andeq	r5, r0, sp, lsr r3
    3c08:	ac230300 	stcge	3, cr0, [r3], #-0
    else
      return 0;
    3c0c:	0c750a20 	ldcleq	10, cr0, [r5], #-128	; 0xffffff80
    3c10:	a3030000 	movwge	r0, #12288	; 0x3000
    FTM_ISR[i] = isr_func;
    3c14:	0000533d 	andeq	r5, r0, sp, lsr r3
    3c18:	b0230300 	eorlt	r0, r3, r0, lsl #6
    3c1c:	0c7b0a20 	ldcleq	10, cr0, [fp], #-128	; 0xffffff80
    3c20:	a4030000 	strge	r0, [r3], #-0
  }

  return 1;
    3c24:	0000533d 	andeq	r5, r0, sp, lsr r3
}
    3c28:	b4230300 	strtlt	r0, [r3], #-768	; 0x300
    3c2c:	0c810a20 	vstmiaeq	r1, {s0-s31}
    3c30:	a5030000 	strge	r0, [r3, #-0]
/*
 * LPLD_FTM_PinInit
 * ʼͨnָŵFTMùܣڲ
 */
static uint8 LPLD_FTM_PinInit(FTM_MemMapPtr  ftmx, FtmChnEnum_Type chn, PortPinsEnum_Type pin)
{ 
    3c34:	0000533d 	andeq	r5, r0, sp, lsr r3
    3c38:	b8230300 	stmdalt	r3!, {r8, r9}
    3c3c:	0c870a20 	vstmiaeq	r7, {s0-s31}
    3c40:	a6030000 	strge	r0, [r3], -r0
  //ftmxʹӦpinftm
  if(ftmx == FTM0)
    3c44:	0000533d 	andeq	r5, r0, sp, lsr r3
    3c48:	bc230300 	stclt	3, cr0, [r3], #-0
    3c4c:	0c8d0a20 	vstmiaeq	sp, {s0-s31}
    3c50:	a7030000 	strge	r0, [r3, -r0]
  {
    switch(chn)
    3c54:	0000533d 	andeq	r5, r0, sp, lsr r3
    3c58:	c0230300 	eorgt	r0, r3, r0, lsl #6
    3c5c:	0fec0a20 	svceq	0x00ec0a20
    3c60:	a8030000 	stmdage	r3, {}	; <UNPREDICTABLE>
    3c64:	0000533d 	andeq	r5, r0, sp, lsr r3
    3c68:	c4230300 	strtgt	r0, [r3], #-768	; 0x300
    3c6c:	0ff40a20 	svceq	0x00f40a20
    3c70:	a9030000 	stmdbge	r3, {}	; <UNPREDICTABLE>
    3c74:	0000533d 	andeq	r5, r0, sp, lsr r3
    3c78:	c8230300 	stmdagt	r3!, {r8, r9}
    3c7c:	0f290a20 	svceq	0x00290a20
    3c80:	aa030000 	bge	c3c88 <__etext+0xbafe0>
    {
    case FTM_Ch0:
      if(pin == PTA3)
    3c84:	0000533d 	andeq	r5, r0, sp, lsr r3
    3c88:	cc230300 	stcgt	3, cr0, [r3], #-0
        PORTA->PCR[3] = (PORTA->PCR[3] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
    3c8c:	0f2f0a20 	svceq	0x002f0a20
    3c90:	ab030000 	blge	c3c98 <__etext+0xbaff0>
    3c94:	0000533d 	andeq	r5, r0, sp, lsr r3
    3c98:	d0230300 	eorle	r0, r3, r0, lsl #6
    3c9c:	0bcb0a20 	bleq	ff2c6524 <__StackLimit+0xdf2c6524>
    3ca0:	ac030000 	stcge	0, cr0, [r3], {-0}
    3ca4:	0000533d 	andeq	r5, r0, sp, lsr r3
      else if(pin == PTC1)
        PORTC->PCR[1] = (PORTC->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
      break;
    3ca8:	d4230300 	strtle	r0, [r3], #-768	; 0x300
    switch(chn)
    {
    case FTM_Ch0:
      if(pin == PTA3)
        PORTA->PCR[3] = (PORTA->PCR[3] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTC1)
    3cac:	0e090a20 	vmlaeq.f32	s0, s18, s1
        PORTC->PCR[1] = (PORTC->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    3cb0:	ad030000 	stcge	0, cr0, [r3, #-0]
    3cb4:	0000533d 	andeq	r5, r0, sp, lsr r3
    3cb8:	d8230300 	stmdale	r3!, {r8, r9}
    3cbc:	0e0f0a20 	vmlaeq.f32	s0, s30, s1
    3cc0:	ae030000 	cdpge	0, 0, cr0, cr3, cr0, {0}
    3cc4:	0000533d 	andeq	r5, r0, sp, lsr r3
    3cc8:	dc230300 	stcle	3, cr0, [r3], #-0
      else
        return 0;
      break;
    3ccc:	0bd00a20 	bleq	ff406554 <__StackLimit+0xdf406554>
      if(pin == PTA3)
        PORTA->PCR[3] = (PORTA->PCR[3] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTC1)
        PORTC->PCR[1] = (PORTC->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
    3cd0:	af030000 	svcge	0x00030000
    3cd4:	0000533d 	andeq	r5, r0, sp, lsr r3
      break;
    case FTM_Ch1:
      if(pin == PTA4)
    3cd8:	e0230300 	eor	r0, r3, r0, lsl #6
    3cdc:	03310a20 	teqeq	r1, #131072	; 0x20000
        PORTA->PCR[4] = (PORTA->PCR[4] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
    3ce0:	b0030000 	andlt	r0, r3, r0
    3ce4:	00055e3d 	andeq	r5, r5, sp, lsr lr
    3ce8:	e4230300 	strt	r0, [r3], #-768	; 0x300
    3cec:	0e9f0a20 	vfnmseq.f32	s0, s30, s1
    3cf0:	b1030000 	mrslt	r0, (UNDEF: 3)
    3cf4:	0000533d 	andeq	r5, r0, sp, lsr r3
    3cf8:	e8230300 	stmda	r3!, {r8, r9}
      else if(pin == PTC2)
        PORTC->PCR[2] = (PORTC->PCR[2] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
      break;
    3cfc:	434d0b20 	movtmi	r0, #56096	; 0xdb20
        return 0;
      break;
    case FTM_Ch1:
      if(pin == PTA4)
        PORTA->PCR[4] = (PORTA->PCR[4] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTC2)
    3d00:	b2030052 	andlt	r0, r3, #82	; 0x52
        PORTC->PCR[2] = (PORTC->PCR[2] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    3d04:	0000533d 	andeq	r5, r0, sp, lsr r3
    3d08:	ec230300 	stc	3, cr0, [r3], #-0
    3d0c:	2c0c0020 	stccs	0, cr0, [ip], {32}
    3d10:	3f000000 	svccc	0x00000000
    3d14:	13000008 	movwne	r0, #8
    3d18:	00000530 	andeq	r0, r0, r0, lsr r5
    3d1c:	0e000ffb 	mcreq	15, 0, r0, cr0, cr11, {7}
      else
        return 0;
      break;
    3d20:	00000f47 	andeq	r0, r0, r7, asr #30
      if(pin == PTA4)
        PORTA->PCR[4] = (PORTA->PCR[4] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTC2)
        PORTC->PCR[2] = (PORTC->PCR[2] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
    3d24:	4b3db303 	blmi	f70938 <__etext+0xf67c90>
    3d28:	0f000008 	svceq	0x00000008
      break;
    case FTM_Ch2:
      if(pin == PTA5)
    3d2c:	00085104 	andeq	r5, r8, r4, lsl #2
    3d30:	06521000 	ldrbeq	r1, [r2], -r0
        PORTA->PCR[5] = (PORTA->PCR[5] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
    3d34:	83030000 	movwhi	r0, #12288	; 0x3000
    3d38:	04000004 	streq	r0, [r0], #-4
    3d3c:	0000371b 	andeq	r3, r0, fp, lsl r7
    3d40:	12e00300 	rscne	r0, r0, #0
    3d44:	1c040000 	stcne	0, cr0, [r4], {-0}
    3d48:	00000045 	andeq	r0, r0, r5, asr #32
    3d4c:	69040402 	stmdbvs	r4, {r1, sl}
      else if(pin == PTC3)
        PORTC->PCR[3] = (PORTC->PCR[3] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
      break;
    3d50:	02000006 	andeq	r0, r0, #6
        return 0;
      break;
    case FTM_Ch2:
      if(pin == PTA5)
        PORTA->PCR[5] = (PORTA->PCR[5] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTC3)
    3d54:	0a870408 	beq	fe1c4d7c <__StackLimit+0xde1c4d7c>
        PORTC->PCR[3] = (PORTC->PCR[3] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    3d58:	c8030000 	stmdagt	r3, {}	; <UNPREDICTABLE>
    3d5c:	0400000d 	streq	r0, [r0], #-13
    3d60:	0000372e 	andeq	r3, r0, lr, lsr #14
    3d64:	8b040f00 	blhi	10796c <__etext+0xfecc4>
    3d68:	14000008 	strne	r0, [r0], #-8
    3d6c:	08010201 	stmdaeq	r1, {r0, r9}
    3d70:	00000712 	andeq	r0, r0, r2, lsl r7
      else
        return 0;
      break;
    3d74:	0018e015 	andseq	lr, r8, r5, lsl r0
      if(pin == PTA5)
        PORTA->PCR[5] = (PORTA->PCR[5] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTC3)
        PORTC->PCR[3] = (PORTC->PCR[3] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
    3d78:	10050100 	andne	r0, r5, r0, lsl #2
      break;
    case FTM_Ch3:
      if(pin == PTA6)
    3d7c:	00000961 	andeq	r0, r0, r1, ror #18
    3d80:	00172d06 	andseq	r2, r7, r6, lsl #26
        PORTA->PCR[6] = (PORTA->PCR[6] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
    3d84:	32060000 	andcc	r0, r6, #0
    3d88:	01000017 	tsteq	r0, r7, lsl r0
    3d8c:	00173706 	andseq	r3, r7, r6, lsl #14
    3d90:	3c060200 	sfmcc	f0, 4, [r6], {-0}
    3d94:	03000017 	movweq	r0, #23
    3d98:	34444116 	strbcc	r4, [r4], #-278	; 0x116
    3d9c:	41160400 	tstmi	r6, r0, lsl #8
      else if(pin == PTC4)
    3da0:	05003544 	streq	r3, [r0, #-1348]	; 0x544
    3da4:	36444116 			; <UNDEFINED> instruction: 0x36444116
        PORTC->PCR[4] = (PORTC->PCR[4] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    3da8:	41160600 	tstmi	r6, r0, lsl #12
    3dac:	07003744 	streq	r3, [r0, -r4, asr #14]
    3db0:	38444116 	stmdacc	r4, {r1, r2, r4, r8, lr}^
    3db4:	41160800 	tstmi	r6, r0, lsl #16
    3db8:	09003944 	stmdbeq	r0, {r2, r6, r8, fp, ip, sp}
    3dbc:	0017ba06 	andseq	fp, r7, r6, lsl #20
    3dc0:	bf060a00 	svclt	0x00060a00
      else
        return 0;
    3dc4:	0b000017 	bleq	3e28 <LPLD_FTM_PinInit+0x1f4>
    3dc8:	0017c406 	andseq	ip, r7, r6, lsl #8
      break;
    case FTM_Ch4:
      if(pin == PTA7)
    3dcc:	c9060c00 	stmdbgt	r6, {sl, fp}
        PORTA->PCR[7] = (PORTA->PCR[7] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
    3dd0:	0d000017 	stceq	0, cr0, [r0, #-92]	; 0xffffffa4
    3dd4:	0017ce06 	andseq	ip, r7, r6, lsl #28
    3dd8:	d3060e00 	movwle	r0, #28160	; 0x6e00
    3ddc:	0f000017 	svceq	0x00000017
    3de0:	0017d806 	andseq	sp, r7, r6, lsl #16
    3de4:	dd061000 	stcle	0, cr1, [r6, #-0]
    3de8:	11000017 	tstne	r0, r7, lsl r0
      else if(pin == PTD4)
        PORTD->PCR[4] = (PORTD->PCR[4] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
      break;
    3dec:	0017e206 	andseq	lr, r7, r6, lsl #4
        return 0;
      break;
    case FTM_Ch4:
      if(pin == PTA7)
        PORTA->PCR[7] = (PORTA->PCR[7] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTD4)
    3df0:	e7061200 	str	r1, [r6, -r0, lsl #4]
        PORTD->PCR[4] = (PORTD->PCR[4] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    3df4:	13000017 	movwne	r0, #23
    3df8:	0017ff06 	andseq	pc, r7, r6, lsl #30
    3dfc:	04061400 	streq	r1, [r6], #-1024	; 0x400
    3e00:	15000018 	strne	r0, [r0, #-24]
    3e04:	00180906 	andseq	r0, r8, r6, lsl #18
    3e08:	0e061600 	cfmadd32eq	mvax0, mvfx1, mvfx6, mvfx0
    3e0c:	17000018 	smladne	r0, r8, r0, r0
      else
        return 0;
      break;
    3e10:	0019dd06 	andseq	sp, r9, r6, lsl #26
      if(pin == PTA7)
        PORTA->PCR[7] = (PORTA->PCR[7] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTD4)
        PORTD->PCR[4] = (PORTD->PCR[4] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
    3e14:	13061800 	movwne	r1, #26624	; 0x6800
      break;
    case FTM_Ch5:
      if(pin == PTA0)
    3e18:	19000018 	stmdbne	r0, {r3, r4}
    3e1c:	00181806 	andseq	r1, r8, r6, lsl #16
        PORTA->PCR[0] = (PORTA->PCR[0] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
    3e20:	1d061a00 	vstrne	s2, [r6, #-0]
    3e24:	1b000018 	blne	3e8c <LPLD_FTM_PinInit+0x258>
    3e28:	00182206 	andseq	r2, r8, r6, lsl #4
    3e2c:	27061c00 	strcs	r1, [r6, -r0, lsl #24]
    3e30:	1d000018 	stcne	0, cr0, [r0, #-96]	; 0xffffffa0
    3e34:	00184d06 	andseq	r4, r8, r6, lsl #26
    3e38:	52061e00 	andpl	r1, r6, #0
      else if(pin == PTD5)
    3e3c:	1f000018 	svcne	0x00000018
    3e40:	18b70300 	ldmne	r7!, {r8, r9}
        PORTD->PCR[5] = (PORTD->PCR[5] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    3e44:	32050000 	andcc	r0, r5, #0
    3e48:	00000894 	muleq	r0, r4, r8
    3e4c:	00182c03 	andseq	r2, r8, r3, lsl #24
    3e50:	85780500 	ldrbhi	r0, [r8, #-1280]!	; 0x500
    3e54:	17000008 	strne	r0, [r0, -r8]
    3e58:	2a7b0514 	bcs	1ec52b0 <__etext+0x1ebc608>
    3e5c:	0900000a 	stmdbeq	r0, {r1, r3}
      else
        return 0;
    3e60:	000017b1 			; <UNDEFINED> instruction: 0x000017b1
    3e64:	05378505 	ldreq	r8, [r7, #-1285]!	; 0x505
      break;
    case FTM_Ch6:
      if(pin == PTA1)
    3e68:	23020000 	movwcs	r0, #8192	; 0x2000
        PORTA->PCR[1] = (PORTA->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
    3e6c:	196d0900 	stmdbne	sp!, {r8, fp}^
    3e70:	90050000 	andls	r0, r5, r0
    3e74:	00000856 	andeq	r0, r0, r6, asr r8
    3e78:	09042302 	stmdbeq	r4, {r1, r8, r9, sp}
    3e7c:	000018ab 	andeq	r1, r0, fp, lsr #17
    3e80:	0856a105 	ldmdaeq	r6, {r0, r2, r8, sp, pc}^
    3e84:	23020000 	movwcs	r0, #8192	; 0x2000
      else if(pin == PTD6)
        PORTD->PCR[6] = (PORTD->PCR[6] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
      break;
    3e88:	19270905 	stmdbne	r7!, {r0, r2, r8, fp}
        return 0;
      break;
    case FTM_Ch6:
      if(pin == PTA1)
        PORTA->PCR[1] = (PORTA->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTD6)
    3e8c:	ac050000 	stcge	0, cr0, [r5], {-0}
        PORTD->PCR[6] = (PORTD->PCR[6] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    3e90:	00000856 	andeq	r0, r0, r6, asr r8
    3e94:	09062302 	stmdbeq	r6, {r1, r8, r9, sp}
    3e98:	00001939 	andeq	r1, r0, r9, lsr r9
    3e9c:	0856b905 	ldmdaeq	r6, {r0, r2, r8, fp, ip, sp, pc}^
    3ea0:	23020000 	movwcs	r0, #8192	; 0x2000
    3ea4:	178c0907 	strne	r0, [ip, r7, lsl #18]
    3ea8:	c7050000 	strgt	r0, [r5, -r0]
      else
        return 0;
      break;
    3eac:	00000856 	andeq	r0, r0, r6, asr r8
      if(pin == PTA1)
        PORTA->PCR[1] = (PORTA->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTD6)
        PORTD->PCR[6] = (PORTD->PCR[6] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
    3eb0:	09082302 	stmdbeq	r8, {r1, r8, r9, sp}
      break;
    case FTM_Ch7:
      if(pin == PTA2)
    3eb4:	00001721 	andeq	r1, r0, r1, lsr #14
    3eb8:	0856d705 	ldmdaeq	r6, {r0, r2, r8, r9, sl, ip, lr, pc}^
        PORTA->PCR[2] = (PORTA->PCR[2] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
    3ebc:	23020000 	movwcs	r0, #8192	; 0x2000
    3ec0:	17990909 	ldrne	r0, [r9, r9, lsl #18]
    3ec4:	e2050000 	and	r0, r5, #0
    3ec8:	00000856 	andeq	r0, r0, r6, asr r8
    3ecc:	090a2302 	stmdbeq	sl, {r1, r8, r9, sp}
    3ed0:	00001893 	muleq	r0, r3, r8
    3ed4:	087aed05 	ldmdaeq	sl!, {r0, r2, r8, sl, fp, sp, lr, pc}^
      else if(pin == PTD7)
    3ed8:	23020000 	movwcs	r0, #8192	; 0x2000
    3edc:	197a090b 	ldmdbne	sl!, {r0, r1, r3, r8, fp}^
        PORTD->PCR[7] = (PORTD->PCR[7] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    3ee0:	f9050000 			; <UNDEFINED> instruction: 0xf9050000
    3ee4:	00000856 	andeq	r0, r0, r6, asr r8
    3ee8:	0a0c2302 	beq	30caf8 <__etext+0x303e50>
    3eec:	000019c9 	andeq	r1, r0, r9, asr #19
    3ef0:	7a010405 	bvc	44f0c <__etext+0x3c264>
    3ef4:	02000008 	andeq	r0, r0, #8
    3ef8:	190a0d23 	stmdbne	sl, {r0, r1, r5, r8, sl, fp}
      else
        return 0;
      break;
    3efc:	05000017 	streq	r0, [r0, #-23]
      if(pin == PTA2)
        PORTA->PCR[2] = (PORTA->PCR[2] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTD7)
        PORTD->PCR[7] = (PORTD->PCR[7] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
      else
        return 0;
    3f00:	096c010e 	stmdbeq	ip!, {r1, r2, r3, r8}^
      break;
    default:
      return 0;     
    3f04:	23020000 	movwcs	r0, #8192	; 0x2000
    3f08:	090e0010 	stmdbeq	lr, {r4}
    }
  }
  else if(ftmx == FTM1)
    3f0c:	05000017 	streq	r0, [r0, #-23]
    3f10:	09770110 	ldmdbeq	r7!, {r4, r8}^
    3f14:	01180000 	tsteq	r8, r0
    3f18:	00001755 	andeq	r1, r0, r5, asr r7
  {
    switch(chn)
    3f1c:	56011c01 	strpl	r1, [r1], -r1, lsl #24
    3f20:	b4000008 	strlt	r0, [r0], #-8
    3f24:	8000001f 	andhi	r0, r0, pc, lsl r0
    3f28:	76000021 	strvc	r0, [r0], -r1, lsr #32
    3f2c:	01000006 	tsteq	r0, r6
    3f30:	00000afb 	strdeq	r0, [r0], -fp
    3f34:	00188019 	andseq	r8, r8, r9, lsl r0
    3f38:	2a1c0100 	bcs	704340 <__etext+0x6fb698>
    3f3c:	0200000a 	andeq	r0, r0, #10
    3f40:	691a7091 	ldmdbvs	sl, {r0, r4, r7, ip, sp, lr}
    3f44:	561e0100 	ldrpl	r0, [lr], -r0, lsl #2
    3f48:	02000008 	andeq	r0, r0, #8
    3f4c:	921b6791 	andsls	r6, fp, #38010880	; 0x2440000
    {
    case FTM_Ch0:
      if(pin == PTA8)
    3f50:	01000019 	tsteq	r0, r9, lsl r0
    3f54:	0005371f 	andeq	r3, r5, pc, lsl r7
        PORTA->PCR[8] = (PORTA->PCR[8] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
    3f58:	60910200 	addsvs	r0, r1, r0, lsl #4
    3f5c:	0019221b 	andseq	r2, r9, fp, lsl r2
    3f60:	56200100 	strtpl	r0, [r0], -r0, lsl #2
    3f64:	02000008 	andeq	r0, r0, #8
    3f68:	211b5f91 			; <UNDEFINED> instruction: 0x211b5f91
    3f6c:	0100002b 	tsteq	r0, fp, lsr #32
    3f70:	00085621 	andeq	r5, r8, r1, lsr #12
      else if(pin == PTA12)
    3f74:	5e910200 	cdppl	2, 9, cr0, cr1, cr0, {0}
    3f78:	00177e1b 	andseq	r7, r7, fp, lsl lr
        PORTA->PCR[12] = (PORTA->PCR[12] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
    3f7c:	56220100 	strtpl	r0, [r2], -r0, lsl #2
    3f80:	02000008 	andeq	r0, r0, #8
    3f84:	7d1b5d91 	ldcvc	13, cr5, [fp, #-580]	; 0xfffffdbc
    3f88:	01000017 	tsteq	r0, r7, lsl r0
    3f8c:	00085623 	andeq	r5, r8, r3, lsr #12
    3f90:	5c910200 	lfmpl	f0, 4, [r1], {0}
    3f94:	6776611a 			; <UNDEFINED> instruction: 0x6776611a
      else if(pin == PTB0)
    3f98:	56240100 	strtpl	r0, [r4], -r0, lsl #2
    3f9c:	02000008 	andeq	r0, r0, #8
        PORTB->PCR[0] = (PORTB->PCR[0] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
    3fa0:	c71b5b91 			; <UNDEFINED> instruction: 0xc71b5b91
    3fa4:	01000018 	tsteq	r0, r8, lsl r0
    3fa8:	00085625 	andeq	r5, r8, r5, lsr #12
    3fac:	5a910200 	bpl	fe4447b4 <__StackLimit+0xde4447b4>
    3fb0:	6167701a 	cmnvs	r7, sl, lsl r0
    3fb4:	56260100 	strtpl	r0, [r6], -r0, lsl #2
    3fb8:	02000008 	andeq	r0, r0, #8
      else
        return 0;
    3fbc:	d71b5991 			; <UNDEFINED> instruction: 0xd71b5991
    3fc0:	01000019 	tsteq	r0, r9, lsl r0
      break;
    case FTM_Ch1:
      if(pin == PTA9)
    3fc4:	00085627 	andeq	r5, r8, r7, lsr #12
        PORTA->PCR[9] = (PORTA->PCR[9] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
    3fc8:	58910200 	ldmpl	r1, {r9}
    3fcc:	0017831b 	andseq	r8, r7, fp, lsl r3
    3fd0:	6c280100 	stfvss	f0, [r8], #-0
    3fd4:	02000009 	andeq	r0, r0, #9
    3fd8:	1c005491 	cfstrsne	mvf5, [r0], {145}	; 0x91
    3fdc:	00183d01 	andseq	r3, r8, r1, lsl #26
    3fe0:	01760100 	cmneq	r6, r0, lsl #2
        PORTA->PCR[13] = (PORTA->PCR[13] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
      else if(pin == PTB1)
        PORTB->PCR[1] = (PORTB->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
      else
        return 0;
      break;
    3fe4:	00000856 	andeq	r0, r0, r6, asr r8
        return 0;
      break;
    case FTM_Ch1:
      if(pin == PTA9)
        PORTA->PCR[9] = (PORTA->PCR[9] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTA13)
    3fe8:	00002180 	andeq	r2, r0, r0, lsl #3
        PORTA->PCR[13] = (PORTA->PCR[13] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
    3fec:	00002230 	andeq	r2, r0, r0, lsr r2
    3ff0:	000006ba 			; <UNDEFINED> instruction: 0x000006ba
    3ff4:	000b4401 	andeq	r4, fp, r1, lsl #8
    3ff8:	18801900 	stmne	r0, {r8, fp, ip}
    3ffc:	76010000 	strvc	r0, [r1], -r0
    4000:	00000a2a 	andeq	r0, r0, sl, lsr #20
    4004:	1b709102 	blne	1c28414 <__etext+0x1c1f76c>
      else if(pin == PTB1)
        PORTB->PCR[1] = (PORTB->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
      else
        return 0;
      break;
    4008:	00001992 	muleq	r0, r2, r9
    case FTM_Ch1:
      if(pin == PTA9)
        PORTA->PCR[9] = (PORTA->PCR[9] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTA13)
        PORTA->PCR[13] = (PORTA->PCR[13] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
      else if(pin == PTB1)
    400c:	05377801 	ldreq	r7, [r7, #-2049]!	; 0x801
        PORTB->PCR[1] = (PORTB->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
    4010:	91020000 	mrsls	r0, (UNDEF: 2)
    4014:	19d71b64 	ldmibne	r7, {r2, r5, r6, r8, r9, fp, ip}^
    4018:	79010000 	stmdbvc	r1, {}	; <UNPREDICTABLE>
    401c:	00000856 	andeq	r0, r0, r6, asr r8
    4020:	00639102 	rsbeq	r9, r3, r2, lsl #2
    4024:	1997011c 	ldmibne	r7, {r2, r3, r4, r8}
    4028:	d2010000 	andle	r0, r1, #0
      else
        return 0;
      break;
    402c:	00086101 	andeq	r6, r8, r1, lsl #2
      else if(pin == PTA13)
        PORTA->PCR[13] = (PORTA->PCR[13] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
      else if(pin == PTB1)
        PORTB->PCR[1] = (PORTB->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
      else
        return 0;
    4030:	00223000 	eoreq	r3, r2, r0
      break;
    case FTM_PhA:
      if(pin == PTA8)
    4034:	00228400 	eoreq	r8, r2, r0, lsl #8
    4038:	0006fe00 	andeq	pc, r6, r0, lsl #28
        PORTA->PCR[8] = (PORTA->PCR[8] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6); 
    403c:	0b7f0100 	bleq	1fc4444 <__etext+0x1fbb79c>
    4040:	92190000 	andsls	r0, r9, #0
    4044:	01000019 	tsteq	r0, r9, lsl r0
    4048:	000537d2 	ldrdeq	r3, [r5], -r2
    404c:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    4050:	6e68631d 	mcrvs	3, 3, r6, cr8, cr13, {0}
    4054:	61d20100 	bicsvs	r0, r2, r0, lsl #2
      else if(pin == PTA12)
    4058:	02000009 	andeq	r0, r0, #9
    405c:	1e007391 	mcrne	3, 0, r7, cr0, cr1, {4}
        PORTA->PCR[12] = (PORTA->PCR[12] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(7);
    4060:	00176301 	andseq	r6, r7, r1, lsl #6
    4064:	01f10100 	mvnseq	r0, r0, lsl #2
    4068:	00002284 	andeq	r2, r0, r4, lsl #5
    406c:	000022e2 	andeq	r2, r0, r2, ror #5
    4070:	00000736 	andeq	r0, r0, r6, lsr r7
    4074:	000bd101 	andeq	sp, fp, r1, lsl #2
      else if(pin == PTB0)
    4078:	19921900 	ldmibne	r2, {r8, fp, ip}
    407c:	f1010000 	setend	le
        PORTB->PCR[0] = (PORTB->PCR[0] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
    4080:	00000537 	andeq	r0, r0, r7, lsr r5
    4084:	1d749102 	ldfnep	f1, [r4, #-8]!
    4088:	006e6863 	rsbeq	r6, lr, r3, ror #16
    408c:	0961f101 	stmdbeq	r1!, {r0, r8, ip, sp, lr, pc}^
    4090:	91020000 	mrsls	r0, (UNDEF: 2)
    4094:	62611d73 	rsbvs	r1, r1, #7360	; 0x1cc0
    4098:	56f10100 	ldrbtpl	r0, [r1], r0, lsl #2
      else
        return 0;
      break;
    409c:	02000008 	andeq	r0, r0, #8
      else if(pin == PTA12)
        PORTA->PCR[12] = (PORTA->PCR[12] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(7);
      else if(pin == PTB0)
        PORTB->PCR[0] = (PORTB->PCR[0] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
      else
        return 0;
    40a0:	691d7291 	ldmdbvs	sp, {r0, r4, r7, r9, ip, sp, lr}
      break;
    case FTM_PhB:
      if(pin == PTA9)
    40a4:	01007172 	tsteq	r0, r2, ror r1
    40a8:	00087af1 	strdeq	r7, [r8], -r1
        PORTA->PCR[9] = (PORTA->PCR[9] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6); 
    40ac:	71910200 	orrsvc	r0, r1, r0, lsl #4
    40b0:	ec011f00 	stc	15, cr1, [r1], {-0}
    40b4:	01000017 	tsteq	r0, r7, lsl r0
    40b8:	6101010c 	tstvs	r1, ip, lsl #2
    40bc:	e4000008 	str	r0, [r0], #-8
    40c0:	0a000022 	beq	4150 <LPLD_FTM_PinInit+0x51c>
    40c4:	6e000023 	cdpvs	0, 0, cr0, cr0, cr3, {1}
      else if(pin == PTA13)
    40c8:	01000007 	tsteq	r0, r7
    40cc:	00000c0e 	andeq	r0, r0, lr, lsl #24
        PORTA->PCR[13] = (PORTA->PCR[13] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(7);
    40d0:	00199220 	andseq	r9, r9, r0, lsr #4
    40d4:	010c0100 	mrseq	r0, (UNDEF: 28)
    40d8:	00000537 	andeq	r0, r0, r7, lsr r5
    40dc:	21749102 	cmncs	r4, r2, lsl #2
    40e0:	01006261 	tsteq	r0, r1, ror #4
    40e4:	0856010c 	ldmdaeq	r6, {r2, r3, r8}^
      else if(pin == PTB1)
    40e8:	91020000 	mrsls	r0, (UNDEF: 2)
    40ec:	011f0073 	tsteq	pc, r3, ror r0	; <UNPREDICTABLE>
        PORTB->PCR[1] = (PORTB->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
    40f0:	000019ac 	andeq	r1, r0, ip, lsr #19
    40f4:	01012101 	tsteq	r1, r1, lsl #2
    40f8:	00000856 	andeq	r0, r0, r6, asr r8
    40fc:	0000230c 	andeq	r2, r0, ip, lsl #6
    4100:	00002348 	andeq	r2, r0, r8, asr #6
    4104:	000007a6 	andeq	r0, r0, r6, lsr #15
    4108:	000c3d01 	andeq	r3, ip, r1, lsl #26
      else
        return 0;
    410c:	19922000 	ldmibne	r2, {sp}
    4110:	21010000 	mrscs	r0, (UNDEF: 1)
    default:
      return 0;   
    4114:	00053701 	andeq	r3, r5, r1, lsl #14
    }
  }
  else if(ftmx == FTM2)
    4118:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    411c:	cd012200 	sfmgt	f2, 4, [r1, #-0]
    4120:	01000018 	tsteq	r0, r8, lsl r0
    4124:	56010138 			; <UNDEFINED> instruction: 0x56010138
  {
    switch(chn)
    4128:	48000008 	stmdami	r0, {r3}
    412c:	a6000023 	strge	r0, [r0], -r3, lsr #32
    4130:	de000023 	cdple	0, 0, cr0, cr0, cr3, {1}
    4134:	01000007 	tsteq	r0, r7
    4138:	00000c7b 	andeq	r0, r0, fp, ror ip
    413c:	00188020 	andseq	r8, r8, r0, lsr #32
    4140:	01380100 	teqeq	r8, r0, lsl #2
    4144:	00000a2a 	andeq	r0, r0, sl, lsr #20
    4148:	23709102 	cmncs	r0, #-2147483648	; 0x80000000
    414c:	00001992 	muleq	r0, r2, r9
    4150:	37013a01 	strcc	r3, [r1, -r1, lsl #20]
    4154:	02000005 	andeq	r0, r0, #5
    4158:	22006491 	andcs	r6, r0, #-1862270976	; 0x91000000
    415c:	00174101 	andseq	r4, r7, r1, lsl #2
    {
    case FTM_Ch0:
      if(pin == PTA10)
    4160:	01520100 	cmpeq	r2, r0, lsl #2
    4164:	00085601 	andeq	r5, r8, r1, lsl #12
        PORTA->PCR[10] = (PORTA->PCR[10] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
    4168:	0023a800 	eoreq	sl, r3, r0, lsl #16
    416c:	00240600 	eoreq	r0, r4, r0, lsl #12
    4170:	00082200 	andeq	r2, r8, r0, lsl #4
    4174:	0cb90100 	ldfeqs	f0, [r9]
    4178:	80200000 	eorhi	r0, r0, r0
    417c:	01000018 	tsteq	r0, r8, lsl r0
    4180:	0a2a0152 	beq	a846d0 <__etext+0xa7ba28>
      else if(pin == PTB18)
    4184:	91020000 	mrsls	r0, (UNDEF: 2)
    4188:	19922370 	ldmibne	r2, {r4, r5, r6, r8, r9, sp}
        PORTB->PCR[18] = (PORTB->PCR[18] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
    418c:	54010000 	strpl	r0, [r1], #-0
    4190:	00053701 	andeq	r3, r5, r1, lsl #14
    4194:	64910200 	ldrvs	r0, [r1], #512	; 0x200
    4198:	eb011f00 	bl	4bda0 <__etext+0x430f8>
    419c:	01000018 	tsteq	r0, r8, lsl r0
    41a0:	560101a6 	strpl	r0, [r1], -r6, lsr #3
    41a4:	08000008 	stmdaeq	r0, {r3}
      else
        return 0;
    41a8:	f6000024 			; <UNDEFINED> instruction: 0xf6000024
    41ac:	66000026 	strvs	r0, [r0], -r6, lsr #32
      break;
    case FTM_Ch1:
      if(pin == PTA11)
    41b0:	01000008 	tsteq	r0, r8
        PORTA->PCR[11] = (PORTA->PCR[11] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
    41b4:	00000d06 	andeq	r0, r0, r6, lsl #26
    41b8:	00199220 	andseq	r9, r9, r0, lsr #4
    41bc:	01a60100 			; <UNDEFINED> instruction: 0x01a60100
    41c0:	00000537 	andeq	r0, r0, r7, lsr r5
    41c4:	216c9102 	cmncs	ip, r2, lsl #2
    41c8:	006e6863 	rsbeq	r6, lr, r3, ror #16
    41cc:	6101a601 	tstvs	r1, r1, lsl #12
      else if(pin == PTB19)
        PORTB->PCR[19] = (PORTB->PCR[19] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
      else
        return 0;
      break;
    41d0:	02000009 	andeq	r0, r0, #9
        return 0;
      break;
    case FTM_Ch1:
      if(pin == PTA11)
        PORTA->PCR[11] = (PORTA->PCR[11] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTB19)
    41d4:	6d246b91 	fstmdbxvs	r4!, {d6-d77}	;@ Deprecated
        PORTB->PCR[19] = (PORTB->PCR[19] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
    41d8:	01007875 	tsteq	r0, r5, ror r8
    41dc:	085601a9 	ldmdaeq	r6, {r0, r3, r5, r7, r8}^
    41e0:	91020000 	mrsls	r0, (UNDEF: 2)
    41e4:	a4250077 	strtge	r0, [r5], #-119	; 0x77
    41e8:	01000017 	tsteq	r0, r7, lsl r0
    41ec:	5601022d 	strpl	r0, [r1], -sp, lsr #4
    41f0:	f8000008 			; <UNDEFINED> instruction: 0xf8000008
      else
        return 0;
      break;
    41f4:	78000026 	stmdavc	r0, {r1, r2, r5}
      if(pin == PTA11)
        PORTA->PCR[11] = (PORTA->PCR[11] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3); 
      else if(pin == PTB19)
        PORTB->PCR[19] = (PORTB->PCR[19] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(3);
      else
        return 0;
    41f8:	9e000028 	cdpls	0, 0, cr0, cr0, cr8, {1}
      break;
    case FTM_PhA:
      if(pin == PTA10)
    41fc:	01000008 	tsteq	r0, r8
    4200:	00000d43 	andeq	r0, r0, r3, asr #26
        PORTA->PCR[10] = (PORTA->PCR[10] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6); 
    4204:	00199220 	andseq	r9, r9, r0, lsr #4
    4208:	022d0100 	eoreq	r0, sp, #0
    420c:	00000537 	andeq	r0, r0, r7, lsr r5
    4210:	236c9102 	cmncs	ip, #-2147483648	; 0x80000000
    4214:	000019a4 	andeq	r1, r0, r4, lsr #19
    4218:	61022f01 	tstvs	r2, r1, lsl #30
    421c:	02000008 	andeq	r0, r0, #8
      else if(pin == PTB18)
    4220:	26007691 			; <UNDEFINED> instruction: 0x26007691
    4224:	00185701 	andseq	r5, r8, r1, lsl #14
        PORTB->PCR[18] = (PORTB->PCR[18] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
    4228:	02770100 	rsbseq	r0, r7, #0
    422c:	00287801 	eoreq	r7, r8, r1, lsl #16
    4230:	00288a00 	eoreq	r8, r8, r0, lsl #20
    4234:	0008d600 	andeq	sp, r8, r0, lsl #12
    4238:	01260100 	teqeq	r6, r0, lsl #2
    423c:	0000195d 	andeq	r1, r0, sp, asr r9
    4240:	01027c01 	tsteq	r2, r1, lsl #24
      else
        return 0;
    4244:	0000288c 	andeq	r2, r0, ip, lsl #17
    4248:	0000289e 	muleq	r0, lr, r8
      break;
    case FTM_PhB:
      if(pin == PTA11)
    424c:	00000902 	andeq	r0, r0, r2, lsl #18
        PORTA->PCR[11] = (PORTA->PCR[11] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6); 
    4250:	096c0c01 	stmdbeq	ip!, {r0, sl, fp}^
    4254:	0d810000 	stceq	0, cr0, [r1]
    4258:	300d0000 	andcc	r0, sp, r0
    425c:	01000005 	tsteq	r0, r5
    4260:	19c12700 	stmibne	r1, {r8, r9, sl, sp}^
    4264:	0c010000 	stceq	0, cr0, [r1], {-0}
    4268:	00000d71 	andeq	r0, r0, r1, ror sp
      else if(pin == PTB19)
        PORTB->PCR[19] = (PORTB->PCR[19] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
      else
        return 0;
      break;
    426c:	fc030501 	stc2	5, cr0, [r3], {1}
        return 0;
      break;
    case FTM_PhB:
      if(pin == PTA11)
        PORTA->PCR[11] = (PORTA->PCR[11] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6); 
      else if(pin == PTB19)
    4270:	001fff15 	andseq	pc, pc, r5, lsl pc	; <UNPREDICTABLE>
        PORTB->PCR[19] = (PORTB->PCR[19] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
    4274:	00000f3f 	andeq	r0, r0, pc, lsr pc
    4278:	0a200002 	beq	804288 <__etext+0x7fb5e0>
    427c:	01040000 	mrseq	r0, (UNDEF: 4)
    4280:	00000234 	andeq	r0, r0, r4, lsr r2
    4284:	001a9001 	andseq	r9, sl, r1
    4288:	00082700 	andeq	r2, r8, r0, lsl #14
    428c:	0028a000 	eoreq	sl, r8, r0
      else
        return 0;
      break;
    4290:	0030be00 	eorseq	fp, r0, r0, lsl #28
      if(pin == PTA11)
        PORTA->PCR[11] = (PORTA->PCR[11] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6); 
      else if(pin == PTB19)
        PORTB->PCR[19] = (PORTB->PCR[19] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
      else
        return 0;
    4294:	000a3200 	andeq	r3, sl, r0, lsl #4
    4298:	06010200 	streq	r0, [r1], -r0, lsl #4
      break;
    default:
      return 0;   
    429c:	0000070b 	andeq	r0, r0, fp, lsl #14
    }
  }
  else if (ftmx == FTM3)
    42a0:	0009dd03 	andeq	sp, r9, r3, lsl #26
    42a4:	372a0200 	strcc	r0, [sl, -r0, lsl #4]!
    42a8:	02000000 	andeq	r0, r0, #0
    42ac:	07090801 	streq	r0, [r9, -r1, lsl #16]
  {
      switch(chn)
    42b0:	02020000 	andeq	r0, r2, #0
    42b4:	00073b05 	andeq	r3, r7, r5, lsl #22
    42b8:	03280300 	teqeq	r8, #0
    42bc:	36020000 	strcc	r0, [r2], -r0
    42c0:	00000050 	andeq	r0, r0, r0, asr r0
    42c4:	92070202 	andls	r0, r7, #536870912	; 0x20000000
    42c8:	02000004 	andeq	r0, r0, #4
    42cc:	01960504 	orrseq	r0, r6, r4, lsl #10
    42d0:	9b030000 	blls	c42d8 <__etext+0xbb630>
    42d4:	02000007 	andeq	r0, r0, #7
    42d8:	00006950 	andeq	r6, r0, r0, asr r9
    42dc:	07040200 	streq	r0, [r4, -r0, lsl #4]
      {
          case FTM_Ch0:
              if (pin == PTE5)
    42e0:	000001e4 	andeq	r0, r0, r4, ror #3
    42e4:	91050802 	tstls	r5, r2, lsl #16
                  PORTE->PCR[5] = (PORTE->PCR[5] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
    42e8:	02000001 	andeq	r0, r0, #1
    42ec:	01df0708 	bicseq	r0, pc, r8, lsl #14
    42f0:	04040000 	streq	r0, [r4], #-0
    42f4:	746e6905 	strbtvc	r6, [lr], #-2309	; 0x905
    42f8:	07040200 	streq	r0, [r4, -r0, lsl #4]
    42fc:	000001e9 	andeq	r0, r0, r9, ror #3
    4300:	4b030105 	blmi	c471c <__etext+0xbba74>
              else if (pin == PTD0)
    4304:	000003ab 	andeq	r0, r0, fp, lsr #7
    4308:	000aa506 	andeq	sl, sl, r6, lsl #10
                  PORTD->PCR[0] = (PORTD->PCR[0] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    430c:	9a060000 	bls	184314 <__etext+0x17b66c>
    4310:	01000006 	tsteq	r0, r6
    4314:	00020a06 	andeq	r0, r2, r6, lsl #20
    4318:	00060200 	andeq	r0, r6, r0, lsl #4
    431c:	03000000 	movweq	r0, #0
    4320:	0000c406 	andeq	ip, r0, r6, lsl #8
    4324:	bd060400 	cfstrslt	mvf0, [r6, #-0]
              else
                  return 0;
    4328:	05000001 	streq	r0, [r0, #-1]
    432c:	0008bf06 	andeq	fp, r8, r6, lsl #30
              break;
          case FTM_Ch1:
              if (pin == PTE6)
    4330:	7d060600 	stcvc	6, cr0, [r6, #-0]
                  PORTE->PCR[6] = (PORTE->PCR[6] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
    4334:	07000002 	streq	r0, [r0, -r2]
    4338:	00028b06 	andeq	r8, r2, r6, lsl #22
    433c:	99060800 	stmdbls	r6, {fp}
    4340:	09000002 	stmdbeq	r0, {r1}
    4344:	0009a406 	andeq	sl, r9, r6, lsl #8
    4348:	11060a00 	tstne	r6, r0, lsl #20
    434c:	0b00000a 	bleq	437c <LPLD_FTM_PinInit+0x748>
              else if (pin == PTD1)
                  PORTD->PCR[1] = (PORTD->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
              else 
                  return 0;
              break;
    4350:	00059a06 	andeq	r9, r5, r6, lsl #20
                  return 0;
              break;
          case FTM_Ch1:
              if (pin == PTE6)
                  PORTE->PCR[6] = (PORTE->PCR[6] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
              else if (pin == PTD1)
    4354:	c5060c00 	strgt	r0, [r6, #-3072]	; 0xc00
                  PORTD->PCR[1] = (PORTD->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    4358:	0d000009 	stceq	0, cr0, [r0, #-36]	; 0xffffffdc
    435c:	00054b06 	andeq	r4, r5, r6, lsl #22
    4360:	de060e00 	cdple	14, 0, cr0, cr6, cr0, {0}
    4364:	0f000003 	svceq	0x00000003
    4368:	00010806 	andeq	r0, r1, r6, lsl #16
    436c:	8b061000 	blhi	188374 <__etext+0x17f6cc>
    4370:	11000006 	tstne	r0, r6
              else 
                  return 0;
              break;
    4374:	00014806 	andeq	r4, r1, r6, lsl #16
              if (pin == PTE6)
                  PORTE->PCR[6] = (PORTE->PCR[6] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
              else if (pin == PTD1)
                  PORTD->PCR[1] = (PORTD->PCR[1] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
              else 
                  return 0;
    4378:	f1061200 			; <UNDEFINED> instruction: 0xf1061200
              break;
          case FTM_Ch2:
              if (pin == PTE7)
    437c:	13000006 	movwne	r0, #6
    4380:	00037a06 	andeq	r7, r3, r6, lsl #20
                  PORTE->PCR[7] = (PORTE->PCR[7] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
    4384:	18061400 	stmdane	r6, {sl, ip}
    4388:	15000008 	strne	r0, [r0, #-8]
    438c:	0003cf06 	andeq	ip, r3, r6, lsl #30
    4390:	b0061600 	andlt	r1, r6, r0, lsl #12
    4394:	17000008 	strne	r0, [r0, -r8]
    4398:	00042f06 	andeq	r2, r4, r6, lsl #30
    439c:	39061800 	stmdbcc	r6, {fp, ip}
              else if (pin == PTD2)
    43a0:	19000001 	stmdbne	r0, {r0}
    43a4:	0003bf06 	andeq	fp, r3, r6, lsl #30
                  PORTD->PCR[2] = (PORTD->PCR[2] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    43a8:	98061a00 	stmdals	r6, {r9, fp, ip}
    43ac:	1b000008 	blne	43d4 <LPLD_FTM_PinInit+0x7a0>
    43b0:	00040d06 	andeq	r0, r4, r6, lsl #26
    43b4:	e8061c00 	stmda	r6, {sl, fp, ip}
    43b8:	1d000008 	stcne	0, cr0, [r0, #-32]	; 0xffffffe0
    43bc:	00051f06 	andeq	r1, r5, r6, lsl #30
    43c0:	af061e00 	svcge	0x00061e00
              else 
                  return 0;
    43c4:	1f000003 	svcne	0x00000003
    43c8:	0008cf06 	andeq	ip, r8, r6, lsl #30
              break;
          case FTM_Ch3:
              if (pin == PTE8)
    43cc:	12062000 	andne	r2, r6, #0
                  PORTE->PCR[8] = (PORTE->PCR[8] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
    43d0:	21000002 	tstcs	r0, r2
    43d4:	0003f306 	andeq	pc, r3, r6, lsl #6
    43d8:	17062200 	strne	r2, [r6, -r0, lsl #4]
    43dc:	23000001 	movwcs	r0, #1
    43e0:	0005e006 	andeq	lr, r5, r6
    43e4:	d3062400 	movwle	r2, #25600	; 0x6400
    43e8:	25000004 	strcs	r0, [r0, #-4]
              else if (pin == PTD3)
                  PORTD->PCR[3] = (PORTD->PCR[3] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
              else 
                  return 0;
              break;
    43ec:	000a3706 	andeq	r3, sl, r6, lsl #14
                  return 0;
              break;
          case FTM_Ch3:
              if (pin == PTE8)
                  PORTE->PCR[8] = (PORTE->PCR[8] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
              else if (pin == PTD3)
    43f0:	53062600 	movwpl	r2, #26112	; 0x6600
                  PORTD->PCR[3] = (PORTD->PCR[3] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    43f4:	27000006 	strcs	r0, [r0, -r6]
    43f8:	00075e06 	andeq	r5, r7, r6, lsl #28
    43fc:	53062800 	movwpl	r2, #26624	; 0x6800
    4400:	2900000a 	stmdbcs	r0, {r1, r3}
    4404:	000a6706 	andeq	r6, sl, r6, lsl #14
    4408:	7f062a00 	svcvc	0x00062a00
    440c:	2b000007 	blcs	4430 <LPLD_FTM_PinInit+0x7fc>
              else 
                  return 0;
              break;
    4410:	000a7006 	andeq	r7, sl, r6
              if (pin == PTE8)
                  PORTE->PCR[8] = (PORTE->PCR[8] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
              else if (pin == PTD3)
                  PORTD->PCR[3] = (PORTD->PCR[3] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
              else 
                  return 0;
    4414:	89062c00 	stmdbhi	r6, {sl, fp, sp}
              break;
          case FTM_Ch4:
              if (pin == PTE9)
    4418:	2d000000 	stccs	0, cr0, [r0, #-0]
    441c:	00016606 	andeq	r6, r1, r6, lsl #12
                  PORTE->PCR[9] = (PORTE->PCR[9] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
    4420:	8b062e00 	blhi	18fc28 <__etext+0x186f80>
    4424:	2f000005 	svccs	0x00000005
    4428:	00087706 	andeq	r7, r8, r6, lsl #14
    442c:	63063000 	movwvs	r3, #24576	; 0x6000
    4430:	31000008 	tstcc	r0, r8
    4434:	0002b706 	andeq	fp, r2, r6, lsl #14
    4438:	68063200 	stmdavs	r6, {r9, ip, sp}
              else if (pin == PTD4)
    443c:	33000003 	movwcc	r0, #3
    4440:	000a8e06 	andeq	r8, sl, r6, lsl #28
                  PORTD->PCR[4] = (PORTD->PCR[4] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    4444:	6c063400 	cfstrsvs	mvf3, [r6], {-0}
    4448:	35000000 	strcc	r0, [r0, #-0]
    444c:	00039906 	andeq	r9, r3, r6, lsl #18
    4450:	ae063600 	cfmadd32ge	mvax0, mvfx3, mvfx6, mvfx0
    4454:	37000001 	strcc	r0, [r0, -r1]
    4458:	0001f606 	andeq	pc, r1, r6, lsl #12
    445c:	cb063800 	blgt	192464 <__etext+0x1897bc>
              else
                  return 0;
    4460:	39000001 	stmdbcc	r0, {r0}
    4464:	00043e06 	andeq	r3, r4, r6, lsl #28
              break;
          case FTM_Ch5:
              if (pin == PTE10)
    4468:	db063a00 	blle	192c70 <__etext+0x189fc8>
                  PORTE->PCR[10] = (PORTE->PCR[10] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
    446c:	3b000004 	blcc	4484 <LPLD_FTM_PinInit+0x850>
    4470:	00074506 	andeq	r4, r7, r6, lsl #10
    4474:	18063c00 	stmdane	r6, {sl, fp, ip, sp}
    4478:	3d000009 	stccc	0, cr0, [r0, #-36]	; 0xffffffdc
    447c:	00045406 	andeq	r5, r4, r6, lsl #8
    4480:	6a063e00 	bvs	193c88 <__etext+0x18afe0>
    4484:	3f000004 	svccc	0x00000004
              else if (pin == PTD5)
                  PORTD->PCR[5] = (PORTD->PCR[5] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
              else
                  return 0;
              break;
    4488:	000a7906 	andeq	r7, sl, r6, lsl #18
                  return 0;
              break;
          case FTM_Ch5:
              if (pin == PTE10)
                  PORTE->PCR[10] = (PORTE->PCR[10] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
              else if (pin == PTD5)
    448c:	0600c000 	streq	ip, [r0], -r0
                  PORTD->PCR[5] = (PORTD->PCR[5] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    4490:	00000994 	muleq	r0, r4, r9
    4494:	7d0600c1 	stcvc	0, cr0, [r6, #-772]	; 0xfffffcfc
    4498:	c2000005 	andgt	r0, r0, #5
    449c:	04a50600 	strteq	r0, [r5], #1536	; 0x600
    44a0:	00c30000 	sbceq	r0, r3, r0
    44a4:	000a2106 	andeq	r2, sl, r6, lsl #2
    44a8:	0600c400 	streq	ip, [r0], -r0, lsl #8
              else
                  return 0;
              break;
    44ac:	000009f8 	strdeq	r0, [r0], -r8
              if (pin == PTE10)
                  PORTE->PCR[10] = (PORTE->PCR[10] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
              else if (pin == PTD5)
                  PORTD->PCR[5] = (PORTD->PCR[5] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
              else
                  return 0;
    44b0:	7a0600c5 	bvc	1847cc <__etext+0x17bb24>
              break;
          case FTM_Ch6:
              if (pin == PTE11)
    44b4:	c6000009 	strgt	r0, [r0], -r9
    44b8:	04c30600 	strbeq	r0, [r3], #1536	; 0x600
                  PORTE->PCR[11] = (PORTE->PCR[11] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
    44bc:	00c70000 	sbceq	r0, r7, r0
    44c0:	00053d06 	andeq	r3, r5, r6, lsl #26
    44c4:	0600c800 	streq	ip, [r0], -r0, lsl #16
    44c8:	00000404 	andeq	r0, r0, r4, lsl #8
    44cc:	2b0600c9 	blcs	1847f8 <__etext+0x17bb50>
    44d0:	ca000002 	bgt	44e0 <LPLD_FTM_PinInit+0x8ac>
    44d4:	09b30600 	ldmibeq	r3!, {r9, sl}
              else if (pin == PTD6)
    44d8:	00cb0000 	sbceq	r0, fp, r0
    44dc:	00066f06 	andeq	r6, r6, r6, lsl #30
                  PORTD->PCR[6] = (PORTD->PCR[6] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    44e0:	0600cc00 	streq	ip, [r0], -r0, lsl #24
    44e4:	00000678 	andeq	r0, r0, r8, ror r6
    44e8:	cd0600cd 	stcgt	0, cr0, [r6, #-820]	; 0xfffffccc
    44ec:	ce000002 	cdpgt	0, 0, cr0, cr0, cr2, {0}
    44f0:	02d60600 	sbcseq	r0, r6, #0
    44f4:	00cf0000 	sbceq	r0, pc, r0
    44f8:	0002df06 	andeq	sp, r2, r6, lsl #30
              else
                  return 0;
    44fc:	0600d000 	streq	sp, [r0], -r0
    4500:	0000021a 	andeq	r0, r0, sl, lsl r2
              break;
          case FTM_Ch7:
              if (pin == PTE12)
    4504:	620600d1 	andvs	r0, r6, #209	; 0xd1
                  PORTE->PCR[12] = (PORTE->PCR[12] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
    4508:	d2000004 	andle	r0, r0, #4
    450c:	03890600 	orreq	r0, r9, #0
    4510:	00d30000 	sbcseq	r0, r3, r0
    4514:	00047a06 	andeq	r7, r4, r6, lsl #20
    4518:	0600d400 	streq	sp, [r0], -r0, lsl #8
    451c:	0000002e 	andeq	r0, r0, lr, lsr #32
    4520:	cb0600d5 	blgt	18487c <__etext+0x17bbd4>
              else if (pin == PTD7)
                  PORTD->PCR[7] = (PORTD->PCR[7] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
              else
                 return 0;
              break;
    4524:	d6000007 	strle	r0, [r0], -r7
                  return 0;
              break;
          case FTM_Ch7:
              if (pin == PTE12)
                  PORTE->PCR[12] = (PORTE->PCR[12] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
              else if (pin == PTD7)
    4528:	00450600 	subeq	r0, r5, r0, lsl #12
                  PORTD->PCR[7] = (PORTD->PCR[7] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
    452c:	00d70000 	sbcseq	r0, r7, r0
    4530:	0005ec06 	andeq	lr, r5, r6, lsl #24
    4534:	0600d800 	streq	sp, [r0], -r0, lsl #16
    4538:	00000222 	andeq	r0, r0, r2, lsr #4
    453c:	530600d9 	movwpl	r0, #24793	; 0x60d9
    4540:	da000007 	ble	4564 <LPLD_FTM_PinInit+0x930>
    4544:	09040600 	stmdbeq	r4, {r9, sl}
              else
                 return 0;
              break;
    4548:	00db0000 	sbcseq	r0, fp, r0
              if (pin == PTE12)
                  PORTE->PCR[12] = (PORTE->PCR[12] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(6);
              else if (pin == PTD7)
                  PORTD->PCR[7] = (PORTD->PCR[7] &~ PORT_PCR_MUX_MASK) | PORT_PCR_MUX(4);
              else
                 return 0;
    454c:	0000de06 	andeq	sp, r0, r6, lsl #28
    4550:	0600dc00 	streq	sp, [r0], -r0, lsl #24
              break;
          default:
              return 0;
    4554:	00000056 	andeq	r0, r0, r6, asr r0
      }
  }
  else
  {
    return 0;
    4558:	9f0600dd 	svcls	0x000600dd
    455c:	de000001 	cdple	0, 0, cr0, cr0, cr1, {0}
  }
  return 1;
    4560:	0a440600 	beq	1105d68 <__etext+0x10fd0c0>
}
    4564:	00df0000 	sbcseq	r0, pc, r0
    4568:	0000a606 	andeq	sl, r0, r6, lsl #12
    456c:	0600e000 	streq	lr, [r0], -r0
/*
 * LPLD_FTM_PinInit
 * ʼͨnָŵFTMùܣڲ
 */
static uint8 LPLD_FTM_PinDeinit(FTM_MemMapPtr ftmx, FtmChnEnum_Type chn)
{
    4570:	000005d7 	ldrdeq	r0, [r0], -r7
    4574:	ea0600e1 	b	184900 <__etext+0x17bc58>
    4578:	e2000004 	and	r0, r0, #4
  //ftmxӦpinftmܣظĬϹ
  if(ftmx == FTM0)
    457c:	03ea0600 	mvneq	r0, #0
    4580:	00e30000 	rsceq	r0, r3, r0
    4584:	00004e06 	andeq	r4, r0, r6, lsl #28
    4588:	0600e400 	streq	lr, [r0], -r0, lsl #8
  {
    switch(chn)
    458c:	00000306 	andeq	r0, r0, r6, lsl #6
    4590:	b40600e5 	strlt	r0, [r6], #-229	; 0xe5
    4594:	e6000000 	str	r0, [r0], -r0
    4598:	05f50600 	ldrbeq	r0, [r5, #1536]!	; 0x600
    459c:	00e70000 	rsceq	r0, r7, r0
    45a0:	00012a06 	andeq	r2, r1, r6, lsl #20
    45a4:	0600e800 	streq	lr, [r0], -r0, lsl #16
    45a8:	00000610 	andeq	r0, r0, r0, lsl r6
    45ac:	310600e9 	smlattcc	r6, r9, r0, r0
    45b0:	ea000007 	b	45d4 <LPLD_FTM_PinDeinit+0x64>
    45b4:	062c0600 	strteq	r0, [ip], -r0, lsl #12
    45b8:	00eb0000 	rsceq	r0, fp, r0
    {
    case FTM_Ch0:
      if((PORTA->PCR[3]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    45bc:	00063606 	andeq	r3, r6, r6, lsl #12
    45c0:	0600ec00 	streq	lr, [r0], -r0, lsl #24
    45c4:	00000890 	muleq	r0, r0, r8
    45c8:	610600ed 	smlattvs	r6, sp, r0, r0
    45cc:	ee000006 	cdp	0, 0, cr0, cr0, cr6, {0}
        PORTA->PCR[3] = PORT_PCR_MUX(0); 
    45d0:	05c30600 	strbeq	r0, [r3, #1536]	; 0x600
    45d4:	00ef0000 	rsceq	r0, pc, r0
    45d8:	00068106 	andeq	r8, r6, r6, lsl #2
    45dc:	0600f000 	streq	pc, [r0], -r0
      if((PORTC->PCR[1]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
    45e0:	000000f8 	strdeq	r0, [r0], -r8
    45e4:	e50600f1 	str	r0, [r6, #-241]	; 0xf1
    45e8:	f2000009 	vhadd.s8	d0, d0, d9
    45ec:	035d0600 	cmpeq	sp, #0
    45f0:	00f30000 	rscseq	r0, r3, r0
        PORTC->PCR[1] = PORT_PCR_MUX(0);
    45f4:	0002a706 	andeq	sl, r2, r6, lsl #14
    45f8:	0600f400 	streq	pc, [r0], -r0, lsl #8
    45fc:	000002e8 	andeq	r0, r0, r8, ror #5
    4600:	1d0600f5 	stcne	0, cr0, [r6, #-980]	; 0xfffffc2c
      break;
    case FTM_Ch1:
      if((PORTA->PCR[4]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    4604:	f6000004 			; <UNDEFINED> instruction: 0xf6000004
    4608:	04260600 	strteq	r0, [r6], #-1536	; 0x600
    460c:	00f70000 	rscseq	r0, r7, r0
    4610:	00018506 	andeq	r8, r1, r6, lsl #10
    4614:	0600f800 	streq	pc, [r0], -r0, lsl #16
        PORTA->PCR[4] = PORT_PCR_MUX(0); 
    4618:	00000988 	andeq	r0, r0, r8, lsl #19
    461c:	020000f9 	andeq	r0, r0, #249	; 0xf9
    4620:	05740704 	ldrbeq	r0, [r4, #-1796]!	; 0x704
    4624:	2c070000 	stccs	0, cr0, [r7], {-0}
      if((PORTC->PCR[2]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
    4628:	c2000000 	andgt	r0, r0, #0
    462c:	08000003 	stmdaeq	r0, {r0, r1}
    4630:	000003ab 	andeq	r0, r0, fp, lsr #7
    4634:	2c07000f 	stccs	0, cr0, [r7], {15}
    4638:	d2000000 	andle	r0, r0, #0
        PORTC->PCR[2] = PORT_PCR_MUX(0);
    463c:	08000003 	stmdaeq	r0, {r0, r1}
    4640:	000003ab 	andeq	r0, r0, fp, lsr #7
    4644:	2c070003 	stccs	0, cr0, [r7], {3}
    4648:	e2000000 	and	r0, r0, #0
      break;
    case FTM_Ch2:
      if((PORTA->PCR[5]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    464c:	08000003 	stmdaeq	r0, {r0, r1}
    4650:	000003ab 	andeq	r0, r0, fp, lsr #7
    4654:	04090007 	streq	r0, [r9], #-7
    4658:	10118003 	andsne	r8, r1, r3
    465c:	0a000004 	beq	4674 <LPLD_FTM_PinDeinit+0x104>
        PORTA->PCR[5] = PORT_PCR_MUX(0); 
    4660:	0000078f 	andeq	r0, r0, pc, lsl #15
    4664:	5e118103 	mnfpls	f0, f3
    4668:	0a000000 	beq	4670 <LPLD_FTM_PinDeinit+0x100>
    466c:	0000001f 	andeq	r0, r0, pc, lsl r0
      if((PORTC->PCR[3]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
    4670:	5e118203 	cdppl	2, 1, cr8, cr1, cr3, {0}
    4674:	0a000000 	beq	467c <LPLD_FTM_PinDeinit+0x10c>
    4678:	000007b2 			; <UNDEFINED> instruction: 0x000007b2
    467c:	5e118303 	cdppl	3, 1, cr8, cr1, cr3, {0}
    4680:	00000000 	andeq	r0, r0, r0
        PORTC->PCR[3] = PORT_PCR_MUX(0);
    4684:	88030209 	stmdahi	r3, {r0, r3, r9}
    4688:	00043211 	andeq	r3, r4, r1, lsl r2
    468c:	00370a00 	eorseq	r0, r7, r0, lsl #20
    4690:	89030000 	stmdbhi	r3, {}	; <UNPREDICTABLE>
      break;
    case FTM_Ch3:
      if((PORTA->PCR[6]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    4694:	00004511 	andeq	r4, r0, r1, lsl r5
    4698:	07700a00 	ldrbeq	r0, [r0, -r0, lsl #20]!
    469c:	8a030000 	bhi	c46a4 <__etext+0xbb9fc>
    46a0:	00004511 	andeq	r4, r0, r1, lsl r5
    46a4:	02090000 	andeq	r0, r9, #0
        PORTA->PCR[6] = PORT_PCR_MUX(0); 
    46a8:	54118e03 	ldrpl	r8, [r1], #-3587	; 0xe03
    46ac:	0a000004 	beq	46c4 <LPLD_FTM_PinDeinit+0x154>
    46b0:	000007d4 	ldrdeq	r0, [r0], -r4
    46b4:	45118f03 	ldrmi	r8, [r1, #-3843]	; 0xf03
      if((PORTC->PCR[4]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
    46b8:	0a000000 	beq	46c0 <LPLD_FTM_PinDeinit+0x150>
    46bc:	0000095b 	andeq	r0, r0, fp, asr r9
    46c0:	45119003 	ldrmi	r9, [r1, #-3]
    46c4:	00000000 	andeq	r0, r0, r0
    46c8:	7c03200b 	stcvc	0, cr2, [r3], {11}
        PORTC->PCR[4] = PORT_PCR_MUX(0);
    46cc:	0004ee11 	andeq	lr, r4, r1, lsl lr
    46d0:	03740c00 	cmneq	r4, #0
    46d4:	7d030000 	stcvc	0, cr0, [r3, #-0]
    46d8:	00005e11 	andeq	r5, r0, r1, lsl lr
      break;
    case FTM_Ch4:
      if((PORTA->PCR[7]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    46dc:	00230200 	eoreq	r0, r3, r0, lsl #4
    46e0:	0004be0c 	andeq	fp, r4, ip, lsl #28
    46e4:	117e0300 	cmnne	lr, r0, lsl #6
    46e8:	00000045 	andeq	r0, r0, r5, asr #32
    46ec:	0c042302 	stceq	3, cr2, [r4], {2}
        PORTA->PCR[7] = PORT_PCR_MUX(0); 
    46f0:	0000044f 	andeq	r0, r0, pc, asr #8
    46f4:	45117f03 	ldrmi	r7, [r1, #-3843]	; 0xf03
    46f8:	02000000 	andeq	r0, r0, #0
    46fc:	e20d0623 	and	r0, sp, #36700160	; 0x2300000
      if((PORTD->PCR[4]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
    4700:	02000003 	andeq	r0, r0, #3
    4704:	5b0c0823 	blpl	306798 <__etext+0x2fdaf0>
    4708:	03000006 	movweq	r0, #6
    470c:	005e1185 	subseq	r1, lr, r5, lsl #3
    4710:	23020000 	movwcs	r0, #8192	; 0x2000
        PORTD->PCR[4] = PORT_PCR_MUX(0);
    4714:	08dd0c0c 	ldmeq	sp, {r2, r3, sl, fp}^
    4718:	86030000 	strhi	r0, [r3], -r0
    471c:	00005e11 	andeq	r5, r0, r1, lsl lr
    4720:	10230200 	eorne	r0, r3, r0, lsl #4
      break;
    case FTM_Ch5:
      if((PORTA->PCR[0]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    4724:	0000af0c 	andeq	sl, r0, ip, lsl #30
    4728:	11870300 	orrne	r0, r7, r0, lsl #6
    472c:	00000045 	andeq	r0, r0, r5, asr #32
    4730:	0d142302 	ldceq	3, cr2, [r4, #-8]
    4734:	00000410 	andeq	r0, r0, r0, lsl r4
        PORTA->PCR[0] = PORT_PCR_MUX(0); 
    4738:	0c162302 	ldceq	3, cr2, [r6], {2}
    473c:	000005b4 			; <UNDEFINED> instruction: 0x000005b4
    4740:	5e118c03 	cdppl	12, 1, cr8, cr1, cr3, {0}
    4744:	02000000 	andeq	r0, r0, #0
      if((PORTD->PCR[5]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
    4748:	430e1823 	movwmi	r1, #59427	; 0xe823
    474c:	03005253 	movweq	r5, #595	; 0x253
    4750:	0045118d 	subeq	r1, r5, sp, lsl #3
    4754:	23020000 	movwcs	r0, #8192	; 0x2000
    4758:	04320d1c 	ldrteq	r0, [r2], #-3356	; 0xd1c
        PORTD->PCR[5] = PORT_PCR_MUX(0);
    475c:	23020000 	movwcs	r0, #8192	; 0x2000
    4760:	480f001e 	stmdami	pc, {r1, r2, r3, r4}	; <UNPREDICTABLE>
    4764:	00000009 	andeq	r0, r0, r9
    4768:	11450314 	cmpne	r5, r4, lsl r3
      break;
    case FTM_Ch6:
      if((PORTA->PCR[1]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    476c:	00000856 	andeq	r0, r0, r6, asr r8
    4770:	0052430e 	subseq	r4, r2, lr, lsl #6
    4774:	5e114603 	cfmsub32pl	mvax0, mvfx4, mvfx1, mvfx3
    4778:	02000000 	andeq	r0, r0, #0
    477c:	450e0023 	strmi	r0, [lr, #-35]	; 0x23
        PORTA->PCR[1] = PORT_PCR_MUX(0); 
    4780:	47030053 	smlsdmi	r3, r3, r0, r0
    4784:	00005e11 	andeq	r5, r0, r1, lsl lr
    4788:	04230200 	strteq	r0, [r3], #-512	; 0x200
    478c:	0003120c 	andeq	r1, r3, ip, lsl #4
      if((PORTD->PCR[6]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
    4790:	11480300 	mrsne	r0, (UNDEF: 120)
    4794:	000003c2 	andeq	r0, r0, r2, asr #7
    4798:	0e082302 	cdpeq	3, 0, cr2, cr8, cr2, {0}
    479c:	00515245 	subseq	r5, r1, r5, asr #4
    47a0:	5e114903 	cdppl	9, 1, cr4, cr1, cr3, {0}
        PORTD->PCR[6] = PORT_PCR_MUX(0);
    47a4:	02000000 	andeq	r0, r0, #0
    47a8:	1d0c0c23 	stcne	12, cr0, [ip, #-140]	; 0xffffff74
    47ac:	03000003 	movweq	r0, #3
    47b0:	03c2114a 	biceq	r1, r2, #-2147483630	; 0x80000012
      break;
    case FTM_Ch7:
      if((PORTA->PCR[2]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    47b4:	23020000 	movwcs	r0, #8192	; 0x2000
    47b8:	45450e10 	strbmi	r0, [r5, #-3600]	; 0xe10
    47bc:	4b030049 	blmi	c48e8 <__etext+0xbbc40>
    47c0:	00005e11 	andeq	r5, r0, r1, lsl lr
    47c4:	14230200 	strtne	r0, [r3], #-512	; 0x200
        PORTA->PCR[2] = PORT_PCR_MUX(0); 
    47c8:	0008e30c 	andeq	lr, r8, ip, lsl #6
    47cc:	114c0300 	mrsne	r0, SPSR_mon
    47d0:	0000002c 	andeq	r0, r0, ip, lsr #32
    47d4:	0c182302 	ldceq	3, cr2, [r8], {2}
      if((PORTD->PCR[7]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
    47d8:	000000d9 	ldrdeq	r0, [r0], -r9
    47dc:	2c114d03 	ldccs	13, cr4, [r1], {3}
    47e0:	02000000 	andeq	r0, r0, #0
    47e4:	490c1923 	stmdbmi	ip, {r0, r1, r5, r8, fp, ip}
    47e8:	03000006 	movweq	r0, #6
        PORTD->PCR[7] = PORT_PCR_MUX(0);      
    47ec:	002c114e 	eoreq	r1, ip, lr, asr #2
    47f0:	23020000 	movwcs	r0, #8192	; 0x2000
    47f4:	088b0c1a 	stmeq	fp, {r1, r3, r4, sl, fp}
    47f8:	4f030000 	svcmi	0x00030000
      break;
    47fc:	00002c11 	andeq	r2, r0, r1, lsl ip
    default:
      return 0;     
    4800:	1b230200 	blne	8c5008 <__etext+0x8bc360>
    }
  }
  else if(ftmx == FTM1)
    4804:	0002c80c 	andeq	ip, r2, ip, lsl #16
    4808:	11500300 	cmpne	r0, r0, lsl #6
    480c:	0000002c 	andeq	r0, r0, ip, lsr #32
    4810:	0c1c2302 	ldceq	3, cr2, [ip], {2}
  {
    switch(chn)
    4814:	000003aa 	andeq	r0, r0, sl, lsr #7
    4818:	2c115103 	ldfcss	f5, [r1], {3}
    481c:	02000000 	andeq	r0, r0, #0
    4820:	4e0c1d23 	cdpmi	13, 0, cr1, cr12, cr3, {1}
    4824:	03000006 	movweq	r0, #6
    4828:	002c1152 	eoreq	r1, ip, r2, asr r1
    482c:	23020000 	movwcs	r0, #8192	; 0x2000
    4830:	06b60c1e 	ssateq	r0, #23, lr, lsl #24
    4834:	53030000 	movwpl	r0, #12288	; 0x3000
    4838:	00002c11 	andeq	r2, r0, r1, lsl ip
    483c:	1f230200 	svcne	0x00230200
    4840:	000a9a0c 	andeq	r9, sl, ip, lsl #20
    4844:	11540300 	cmpne	r4, r0, lsl #6
    4848:	000003c2 	andeq	r0, r0, r2, asr #7
    {
    case FTM_Ch0:
      if((PORTA->PCR[8]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    484c:	0e202302 	cdpeq	3, 2, cr2, cr0, cr2, {0}
    4850:	00544e49 	subseq	r4, r4, r9, asr #28
    4854:	5e115503 	cfmul32pl	mvfx5, mvfx1, mvfx3
    4858:	02000000 	andeq	r0, r0, #0
    485c:	310c2423 	tstcc	ip, r3, lsr #8
        PORTA->PCR[8] = PORT_PCR_MUX(0); 
    4860:	03000003 	movweq	r0, #3
    4864:	03c21156 	biceq	r1, r2, #-2147483627	; 0x80000015
    4868:	23020000 	movwcs	r0, #8192	; 0x2000
    486c:	52450e28 	subpl	r0, r5, #640	; 0x280
      if((PORTA->PCR[12]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    4870:	57030052 	smlsdpl	r3, r2, r0, r0
    4874:	00005e11 	andeq	r5, r0, r1, lsl lr
    4878:	2c230200 	sfmcs	f0, 4, [r3], #-0
    487c:	00033c0c 	andeq	r3, r3, ip, lsl #24
    4880:	11580300 	cmpne	r8, r0, lsl #6
        PORTA->PCR[12] = PORT_PCR_MUX(0);
    4884:	000003c2 	andeq	r0, r0, r2, asr #7
    4888:	0e302302 	cdpeq	3, 3, cr2, cr0, cr2, {0}
    488c:	00535248 	subseq	r5, r3, r8, asr #4
      if((PORTB->PCR[0]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    4890:	5e115903 	cdppl	9, 1, cr5, cr1, cr3, {0}
    4894:	02000000 	andeq	r0, r0, #0
    4898:	470c3423 	strmi	r3, [ip, -r3, lsr #8]
    489c:	03000003 	movweq	r0, #3
    48a0:	0856115a 	ldmdaeq	r6, {r1, r3, r4, r6, r8, ip}^
    48a4:	23020000 	movwcs	r0, #8192	; 0x2000
        PORTB->PCR[0] = PORT_PCR_MUX(0);
    48a8:	09400c38 	stmdbeq	r0, {r3, r4, r5, sl, fp}^
    48ac:	5b030000 	blpl	c48b4 <__etext+0xbbc0c>
    48b0:	00002c11 	andeq	r2, r0, r1, lsl ip
      break;
    48b4:	80230300 	eorhi	r0, r3, r0, lsl #6
    case FTM_Ch1:
      if((PORTA->PCR[9]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    48b8:	09380c02 	ldmdbeq	r8!, {r1, sl, fp}
    48bc:	5c030000 	stcpl	0, cr0, [r3], {-0}
    48c0:	00002c11 	andeq	r2, r0, r1, lsl ip
    48c4:	81230300 	teqhi	r3, r0, lsl #6
    48c8:	09300c02 	ldmdbeq	r0!, {r1, sl, fp}
        PORTA->PCR[9] = PORT_PCR_MUX(0); 
    48cc:	5d030000 	stcpl	0, cr0, [r3, #-0]
    48d0:	00002c11 	andeq	r2, r0, r1, lsl ip
    48d4:	82230300 	eorhi	r0, r3, #0
      if((PORTA->PCR[13]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    48d8:	09280c02 	stmdbeq	r8!, {r1, sl, fp}
    48dc:	5e030000 	cdppl	0, 0, cr0, cr3, cr0, {0}
    48e0:	00002c11 	andeq	r2, r0, r1, lsl ip
    48e4:	83230300 	teqhi	r3, #0
    48e8:	096a0c02 	stmdbeq	sl!, {r1, sl, fp}^
        PORTA->PCR[13] = PORT_PCR_MUX(0);
    48ec:	5f030000 	svcpl	0x00030000
    48f0:	00002c11 	andeq	r2, r0, r1, lsl ip
    48f4:	84230300 	strthi	r0, [r3], #-768	; 0x300
    48f8:	03fc0c02 	mvnseq	r0, #512	; 0x200
      if((PORTB->PCR[1]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    48fc:	60030000 	andvs	r0, r3, r0
    4900:	00002c11 	andeq	r2, r0, r1, lsl ip
    4904:	85230300 	strhi	r0, [r3, #-768]!	; 0x300
    4908:	09530c02 	ldmdbeq	r3, {r1, sl, fp}^
    490c:	61030000 	mrsvs	r0, (UNDEF: 3)
        PORTB->PCR[1] = PORT_PCR_MUX(0);
    4910:	00002c11 	andeq	r2, r0, r1, lsl ip
    4914:	86230300 	strthi	r0, [r3], -r0, lsl #6
    4918:	00f00c02 	rscseq	r0, r0, r2, lsl #24
    491c:	62030000 	andvs	r0, r3, #0
      break;
    case FTM_PhA:
      if((PORTA->PCR[8]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
    4920:	00002c11 	andeq	r2, r0, r1, lsl ip
    4924:	87230300 	strhi	r0, [r3, -r0, lsl #6]!
    4928:	06c40c02 	strbeq	r0, [r4], r2, lsl #24
    492c:	63030000 	movwvs	r0, #12288	; 0x3000
    4930:	00002c11 	andeq	r2, r0, r1, lsl ip
        PORTA->PCR[8] = PORT_PCR_MUX(0); 
    4934:	88230300 	stmdahi	r3!, {r8, r9}
    4938:	06bb0c02 	ldrteq	r0, [fp], r2, lsl #24
    493c:	64030000 	strvs	r0, [r3], #-0
    4940:	00002c11 	andeq	r2, r0, r1, lsl ip
      if((PORTA->PCR[12]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(7))
    4944:	89230300 	stmdbhi	r3!, {r8, r9}
    4948:	08a80c02 	stmiaeq	r8!, {r1, sl, fp}
    494c:	65030000 	strvs	r0, [r3, #-0]
    4950:	00002c11 	andeq	r2, r0, r1, lsl ip
    4954:	8a230300 	bhi	8c555c <__etext+0x8bc8b4>
        PORTA->PCR[12] = PORT_PCR_MUX(0);
    4958:	09720c02 	ldmdbeq	r2!, {r1, sl, fp}^
    495c:	66030000 	strvs	r0, [r3], -r0
    4960:	00002c11 	andeq	r2, r0, r1, lsl ip
      if((PORTB->PCR[0]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
    4964:	8b230300 	blhi	8c556c <__etext+0x8bc8c4>
    4968:	06e80c02 	strbteq	r0, [r8], r2, lsl #24
    496c:	67030000 	strvs	r0, [r3, -r0]
    4970:	00002c11 	andeq	r2, r0, r1, lsl ip
    4974:	8c230300 	stchi	3, cr0, [r3], #-0
    4978:	06df0c02 	ldrbeq	r0, [pc], r2, lsl #24
        PORTB->PCR[0] = PORT_PCR_MUX(0);
    497c:	68030000 	stmdavs	r3, {}	; <UNPREDICTABLE>
    4980:	00002c11 	andeq	r2, r0, r1, lsl ip
    4984:	8d230300 	stchi	3, cr0, [r3, #-0]
      break;
    4988:	06d60c02 	ldrbeq	r0, [r6], r2, lsl #24
    case FTM_PhB:
      if((PORTA->PCR[9]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
    498c:	69030000 	stmdbvs	r3, {}	; <UNPREDICTABLE>
    4990:	00002c11 	andeq	r2, r0, r1, lsl ip
    4994:	8e230300 	cdphi	3, 2, cr0, cr3, cr0, {0}
    4998:	06cd0c02 	strbeq	r0, [sp], r2, lsl #24
    499c:	6a030000 	bvs	c49a4 <__etext+0xbbcfc>
        PORTA->PCR[9] = PORT_PCR_MUX(0); 
    49a0:	00002c11 	andeq	r2, r0, r1, lsl ip
    49a4:	8f230300 	svchi	0x00230300
    49a8:	07170c02 	ldreq	r0, [r7, -r2, lsl #24]
      if((PORTA->PCR[13]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(7))
    49ac:	6b030000 	blvs	c49b4 <__etext+0xbbd0c>
    49b0:	00002c11 	andeq	r2, r0, r1, lsl ip
    49b4:	90230300 	eorls	r0, r3, r0, lsl #6
    49b8:	04b50c02 	ldrteq	r0, [r5], #3074	; 0xc02
    49bc:	6c030000 	stcvs	0, cr0, [r3], {-0}
        PORTA->PCR[13] = PORT_PCR_MUX(0);
    49c0:	00002c11 	andeq	r2, r0, r1, lsl ip
    49c4:	91230300 	teqls	r3, r0, lsl #6
    49c8:	07000c02 	streq	r0, [r0, -r2, lsl #24]
    49cc:	6d030000 	stcvs	0, cr0, [r3, #-0]
      if((PORTB->PCR[1]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
    49d0:	00002c11 	andeq	r2, r0, r1, lsl ip
    49d4:	92230300 	eorls	r0, r3, #0
    49d8:	017c0c02 	cmneq	ip, r2, lsl #24
    49dc:	6e030000 	cdpvs	0, 0, cr0, cr3, cr0, {0}
    49e0:	00002c11 	andeq	r2, r0, r1, lsl ip
        PORTB->PCR[1] = PORT_PCR_MUX(0);
    49e4:	93230300 	teqls	r3, #0
    49e8:	05ab0c02 	streq	r0, [fp, #3074]!	; 0xc02
    49ec:	6f030000 	svcvs	0x00030000
    49f0:	00002c11 	andeq	r2, r0, r1, lsl ip
      break;
    49f4:	94230300 	strtls	r0, [r3], #-768	; 0x300
    default:
      return 0;   
    49f8:	04890c02 	streq	r0, [r9], #3074	; 0xc02
    }
  }
  else if(ftmx == FTM2)
    49fc:	70030000 	andvc	r0, r3, r0
    4a00:	00002c11 	andeq	r2, r0, r1, lsl ip
    4a04:	95230300 	strls	r0, [r3, #-768]!	; 0x300
    4a08:	07c20c02 	strbeq	r0, [r2, r2, lsl #24]
  {
    switch(chn)
    4a0c:	71030000 	mrsvc	r0, (UNDEF: 3)
    4a10:	00002c11 	andeq	r2, r0, r1, lsl ip
    4a14:	96230300 	strtls	r0, [r3], -r0, lsl #6
    4a18:	056b0c02 	strbeq	r0, [fp, #-3074]!	; 0xc02
    4a1c:	72030000 	andvc	r0, r3, #0
    4a20:	00002c11 	andeq	r2, r0, r1, lsl ip
    4a24:	97230300 	strls	r0, [r3, -r0, lsl #6]!
    4a28:	07fd0c02 	ldrbeq	r0, [sp, r2, lsl #24]!
    4a2c:	73030000 	movwvc	r0, #12288	; 0x3000
    4a30:	00002c11 	andeq	r2, r0, r1, lsl ip
    4a34:	98230300 	stmdals	r3!, {r8, r9}
    4a38:	07f40c02 	ldrbeq	r0, [r4, r2, lsl #24]!
    4a3c:	74030000 	strvc	r0, [r3], #-0
    4a40:	00002c11 	andeq	r2, r0, r1, lsl ip
    {
    case FTM_Ch0:
      if((PORTA->PCR[10]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    4a44:	99230300 	stmdbls	r3!, {r8, r9}
    4a48:	07eb0c02 	strbeq	r0, [fp, r2, lsl #24]!
    4a4c:	75030000 	strvc	r0, [r3, #-0]
    4a50:	00002c11 	andeq	r2, r0, r1, lsl ip
    4a54:	9a230300 	bls	8c565c <__etext+0x8bc9b4>
        PORTA->PCR[10] = PORT_PCR_MUX(0); 
    4a58:	07e20c02 	strbeq	r0, [r2, r2, lsl #24]!
    4a5c:	76030000 	strvc	r0, [r3], -r0
    4a60:	00002c11 	andeq	r2, r0, r1, lsl ip
    4a64:	9b230300 	blls	8c566c <__etext+0x8bc9c4>
      if((PORTB->PCR[18]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    4a68:	0a080c02 	beq	207a78 <__etext+0x1fedd0>
    4a6c:	77030000 	strvc	r0, [r3, -r0]
    4a70:	00002c11 	andeq	r2, r0, r1, lsl ip
    4a74:	9c230300 	stcls	3, cr0, [r3], #-0
    4a78:	09bc0c02 	ldmibeq	ip!, {r1, sl, fp}
        PORTB->PCR[18] = PORT_PCR_MUX(0);
    4a7c:	78030000 	stmdavc	r3, {}	; <UNPREDICTABLE>
    4a80:	00002c11 	andeq	r2, r0, r1, lsl ip
    4a84:	9d230300 	stcls	3, cr0, [r3, #-0]
    4a88:	080f0c02 	stmdaeq	pc, {r1, sl, fp}	; <UNPREDICTABLE>
      break;
    case FTM_Ch1:
      if((PORTA->PCR[11]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    4a8c:	79030000 	stmdbvc	r3, {}	; <UNPREDICTABLE>
    4a90:	00002c11 	andeq	r2, r0, r1, lsl ip
    4a94:	9e230300 	cdpls	3, 2, cr0, cr3, cr0, {0}
    4a98:	08060c02 	stmdaeq	r6, {r1, sl, fp}
    4a9c:	7a030000 	bvc	c4aa4 <__etext+0xbbdfc>
        PORTA->PCR[11] = PORT_PCR_MUX(0); 
    4aa0:	00002c11 	andeq	r2, r0, r1, lsl ip
    4aa4:	9f230300 	svcls	0x00230300
    4aa8:	03520c02 	cmpeq	r2, #512	; 0x200
    4aac:	7b030000 	blvc	c4ab4 <__etext+0xbbe0c>
      if((PORTB->PCR[19]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
    4ab0:	00086611 	andeq	r6, r8, r1, lsl r6
    4ab4:	a0230300 	eorge	r0, r3, r0, lsl #6
    4ab8:	43540e02 	cmpmi	r4, #32
    4abc:	92030044 	andls	r0, r3, #68	; 0x44
    4ac0:	00087711 	andeq	r7, r8, r1, lsl r7
        PORTB->PCR[19] = PORT_PCR_MUX(0);
    4ac4:	80230300 	eorhi	r0, r3, r0, lsl #6
    4ac8:	2c070020 	stccs	0, cr0, [r7], {32}
    4acc:	66000000 	strvs	r0, [r0], -r0
      break;
    4ad0:	08000008 	stmdaeq	r0, {r3}
    case FTM_PhA:
      if((PORTA->PCR[10]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
    4ad4:	000003ab 	andeq	r0, r0, fp, lsr #7
    4ad8:	2c0700c7 	stccs	0, cr0, [r7], {199}	; 0xc7
    4adc:	77000000 	strvc	r0, [r0, -r0]
    4ae0:	10000008 	andne	r0, r0, r8
    4ae4:	000003ab 	andeq	r0, r0, fp, lsr #7
        PORTA->PCR[10] = PORT_PCR_MUX(0); 
    4ae8:	07000edf 			; <UNDEFINED> instruction: 0x07000edf
    4aec:	00000454 	andeq	r0, r0, r4, asr r4
    4af0:	00000887 	andeq	r0, r0, r7, lsl #17
      if((PORTB->PCR[18]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
    4af4:	0003ab08 	andeq	sl, r3, r8, lsl #22
    4af8:	11001f00 	tstne	r0, r0, lsl #30
    4afc:	00000511 	andeq	r0, r0, r1, lsl r5
    4b00:	93119303 	tstls	r1, #201326592	; 0xc000000
    4b04:	12000008 	andne	r0, r0, #8
        PORTB->PCR[18] = PORT_PCR_MUX(0);
    4b08:	00089904 	andeq	r9, r8, r4, lsl #18
    4b0c:	04ee1300 	strbteq	r1, [lr], #768	; 0x300
    4b10:	31140000 	tstcc	r4, r0
    4b14:	10000014 	andne	r0, r0, r4, lsl r0
      break;
    case FTM_PhB:
      if((PORTA->PCR[11]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
    4b18:	bb17c303 	bllt	5f572c <__etext+0x5eca84>
    4b1c:	0c000008 	stceq	0, cr0, [r0], {8}
    4b20:	000012a9 	andeq	r1, r0, r9, lsr #5
    4b24:	b217c403 	andslt	ip, r7, #50331648	; 0x3000000
    4b28:	02000003 	andeq	r0, r0, #3
        PORTA->PCR[11] = PORT_PCR_MUX(0); 
    4b2c:	11000023 	tstne	r0, r3, lsr #32
    4b30:	0000153f 	andeq	r1, r0, pc, lsr r5
    4b34:	c717c503 	ldrgt	ip, [r7, -r3, lsl #10]
    4b38:	12000008 	andne	r0, r0, #8
      if((PORTB->PCR[19]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
    4b3c:	0008cd04 	andeq	ip, r8, r4, lsl #26
    4b40:	089e1300 	ldmeq	lr, {r8, r9, ip}
    4b44:	440f0000 	strmi	r0, [pc], #-0	; 4b4c <LPLD_FTM_PinDeinit+0x5dc>
    4b48:	70000010 	andvc	r0, r0, r0, lsl r0
    4b4c:	3d950310 	ldccc	3, cr0, [r5, #64]	; 0x40
        PORTB->PCR[19] = PORT_PCR_MUX(0);
    4b50:	00000aae 	andeq	r0, r0, lr, lsr #21
    4b54:	0010380c 	andseq	r3, r0, ip, lsl #16
    4b58:	3d960300 	ldccc	3, cr0, [r6]
      break;
    4b5c:	0000005e 	andeq	r0, r0, lr, asr r0
    default:
      return 0;   
    4b60:	0c002302 	stceq	3, cr2, [r0], {2}
    4b64:	00000d02 	andeq	r0, r0, r2, lsl #26
    }
  }
  else if (ftmx == FTM3)
    4b68:	5e3d9703 	cdppl	7, 3, cr9, cr13, cr3, {0}
    4b6c:	02000000 	andeq	r0, r0, #0
    4b70:	120c0423 	andne	r0, ip, #587202560	; 0x23000000
      switch (chn)
      {
        case FTM_Ch0:
            if 
      }*/
    return 0;
    4b74:	03000003 	movweq	r0, #3
    4b78:	0aae3d98 	beq	feb941e0 <__StackLimit+0xdeb941e0>
    case FTM_Ch0:
      if((PORTA->PCR[3]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTA->PCR[3] = PORT_PCR_MUX(0); 
      if((PORTC->PCR[1]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
        PORTC->PCR[1] = PORT_PCR_MUX(0);
      break;
    4b7c:	23020000 	movwcs	r0, #8192	; 0x2000
    case FTM_Ch1:
      if((PORTA->PCR[4]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTA->PCR[4] = PORT_PCR_MUX(0); 
      if((PORTC->PCR[2]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
        PORTC->PCR[2] = PORT_PCR_MUX(0);
      break;
    4b80:	103e0c08 	eorsne	r0, lr, r8, lsl #24
    case FTM_Ch2:
      if((PORTA->PCR[5]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTA->PCR[5] = PORT_PCR_MUX(0); 
      if((PORTC->PCR[3]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
        PORTC->PCR[3] = PORT_PCR_MUX(0);
      break;
    4b84:	99030000 	stmdbls	r3, {}	; <UNPREDICTABLE>
    case FTM_Ch3:
      if((PORTA->PCR[6]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTA->PCR[6] = PORT_PCR_MUX(0); 
      if((PORTC->PCR[4]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
        PORTC->PCR[4] = PORT_PCR_MUX(0);
      break;
    4b88:	00005e3d 	andeq	r5, r0, sp, lsr lr
    case FTM_Ch4:
      if((PORTA->PCR[7]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTA->PCR[7] = PORT_PCR_MUX(0); 
      if((PORTD->PCR[4]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
        PORTD->PCR[4] = PORT_PCR_MUX(0);
      break;
    4b8c:	84230300 	strthi	r0, [r3], #-768	; 0x300
    case FTM_Ch5:
      if((PORTA->PCR[0]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTA->PCR[0] = PORT_PCR_MUX(0); 
      if((PORTD->PCR[5]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
        PORTD->PCR[5] = PORT_PCR_MUX(0);
      break;
    4b90:	031d0c20 	tsteq	sp, #8192	; 0x2000
    case FTM_Ch6:
      if((PORTA->PCR[1]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTA->PCR[1] = PORT_PCR_MUX(0); 
      if((PORTD->PCR[6]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
        PORTD->PCR[6] = PORT_PCR_MUX(0);
      break;
    4b94:	9a030000 	bls	c4b9c <__etext+0xbbef4>
    case FTM_Ch7:
      if((PORTA->PCR[2]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTA->PCR[2] = PORT_PCR_MUX(0); 
      if((PORTD->PCR[7]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(4))
        PORTD->PCR[7] = PORT_PCR_MUX(0);      
      break;
    4b98:	0003c23d 	andeq	ip, r3, sp, lsr r2
        PORTA->PCR[8] = PORT_PCR_MUX(0); 
      if((PORTA->PCR[12]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTA->PCR[12] = PORT_PCR_MUX(0);
      if((PORTB->PCR[0]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTB->PCR[0] = PORT_PCR_MUX(0);
      break;
    4b9c:	88230300 	stmdahi	r3!, {r8, r9}
        PORTA->PCR[9] = PORT_PCR_MUX(0); 
      if((PORTA->PCR[13]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTA->PCR[13] = PORT_PCR_MUX(0);
      if((PORTB->PCR[1]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTB->PCR[1] = PORT_PCR_MUX(0);
      break;
    4ba0:	104f0c20 	subne	r0, pc, r0, lsr #24
        PORTA->PCR[8] = PORT_PCR_MUX(0); 
      if((PORTA->PCR[12]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(7))
        PORTA->PCR[12] = PORT_PCR_MUX(0);
      if((PORTB->PCR[0]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
        PORTB->PCR[0] = PORT_PCR_MUX(0);
      break;
    4ba4:	9b030000 	blls	c4bac <__etext+0xbbf04>
        PORTA->PCR[9] = PORT_PCR_MUX(0); 
      if((PORTA->PCR[13]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(7))
        PORTA->PCR[13] = PORT_PCR_MUX(0);
      if((PORTB->PCR[1]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
        PORTB->PCR[1] = PORT_PCR_MUX(0);
      break;
    4ba8:	00005e3d 	andeq	r5, r0, sp, lsr lr
    case FTM_Ch0:
      if((PORTA->PCR[10]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTA->PCR[10] = PORT_PCR_MUX(0); 
      if((PORTB->PCR[18]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTB->PCR[18] = PORT_PCR_MUX(0);
      break;
    4bac:	8c230300 	stchi	3, cr0, [r3], #-0
    case FTM_Ch1:
      if((PORTA->PCR[11]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTA->PCR[11] = PORT_PCR_MUX(0); 
      if((PORTB->PCR[19]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(3))
        PORTB->PCR[19] = PORT_PCR_MUX(0);
      break;
    4bb0:	10550c20 	subsne	r0, r5, r0, lsr #24
    case FTM_PhA:
      if((PORTA->PCR[10]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
        PORTA->PCR[10] = PORT_PCR_MUX(0); 
      if((PORTB->PCR[18]& PORT_PCR_MUX_MASK) == PORT_PCR_MUX(6))
        PORTB->PCR[18] = PORT_PCR_MUX(0);
      break;
    4bb4:	9c030000 	stcls	0, cr0, [r3], {-0}
        case FTM_Ch0:
            if 
      }*/
    return 0;
  }
  return 1;
    4bb8:	00005e3d 	andeq	r5, r0, sp, lsr lr
}
    4bbc:	90230300 	eorls	r0, r3, r0, lsl #6
    4bc0:	105b0c20 	subsne	r0, fp, r0, lsr #24
    4bc4:	9d030000 	stcls	0, cr0, [r3, #-0]
/*
 * LPLD_FTM_QD_Init
 * FTMģģʽʼڲ
 */
static uint8 LPLD_FTM_QD_Init(FTM_InitTypeDef ftm_init_structure)
{
    4bc8:	00005e3d 	andeq	r5, r0, sp, lsr lr
    4bcc:	94230300 	strtls	r0, [r3], #-768	; 0x300
    4bd0:	10610c20 	rsbne	r0, r1, r0, lsr #24
    4bd4:	9e030000 	cdpls	0, 0, cr0, cr3, cr0, {0}
  uint8 mode = ftm_init_structure.FTM_QdMode;
    4bd8:	00005e3d 	andeq	r5, r0, sp, lsr lr
    4bdc:	98230300 	stmdals	r3!, {r8, r9}
  FTM_MemMapPtr ftmx = ftm_init_structure.FTM_Ftmx;
    4be0:	0a9a0c20 	beq	fe687c68 <__StackLimit+0xde687c68>
 
  ftmx->MODE |= FTM_MODE_FTMEN_MASK;    //FTM2EN=1   
    4be4:	9f030000 	svcls	0x00030000
    4be8:	0003d23d 	andeq	sp, r3, sp, lsr r2
    4bec:	9c230300 	stcls	3, cr0, [r3], #-0
  
  ftmx->CNTIN = 0;//FTM0ʼֵΪ0  
    4bf0:	0c640c20 	stcleq	12, cr0, [r4], #-128	; 0xffffff80
    4bf4:	a0030000 	andge	r0, r3, r0
  ftmx->CNT=0;  
    4bf8:	00005e3d 	andeq	r5, r0, sp, lsr lr
    4bfc:	a4230300 	strtge	r0, [r3], #-768	; 0x300
  ftmx->MOD = 0xFFFF;//ֵ  
    4c00:	0c690c20 	stcleq	12, cr0, [r9], #-128	; 0xffffff80
    4c04:	a1030000 	mrsge	r0, (UNDEF: 3)
  
  ftmx->QDCTRL |= mode;     //ģʽѡ
    4c08:	00005e3d 	andeq	r5, r0, sp, lsr lr
    4c0c:	a8230300 	stmdage	r3!, {r8, r9}
    4c10:	0c6f0c20 	stcleq	12, cr0, [pc], #-128	; 4b98 <LPLD_FTM_PinDeinit+0x628>
    4c14:	a2030000 	andge	r0, r3, #0
  ftmx->QDCTRL |= FTM_QDCTRL_QUADEN_MASK;       //ʹģʽ 
    4c18:	00005e3d 	andeq	r5, r0, sp, lsr lr
    4c1c:	ac230300 	stcge	3, cr0, [r3], #-0
    4c20:	0c750c20 	ldcleq	12, cr0, [r5], #-128	; 0xffffff80
    4c24:	a3030000 	movwge	r0, #12288	; 0x3000

  return 1;
    4c28:	00005e3d 	andeq	r5, r0, sp, lsr lr
}
    4c2c:	b0230300 	eorlt	r0, r3, r0, lsl #6
    4c30:	0c7b0c20 	ldcleq	12, cr0, [fp], #-128	; 0xffffff80
    4c34:	a4030000 	strge	r0, [r3], #-0

static uint8 LPLD_FTM_DEC_Init(FTM_InitTypeDef ftm_init_structure)
{
    4c38:	00005e3d 	andeq	r5, r0, sp, lsr lr
    4c3c:	b4230300 	strtlt	r0, [r3], #-768	; 0x300
    4c40:	0c810c20 	stceq	12, cr0, [r1], {32}
    4c44:	a5030000 	strge	r0, [r3, #-0]
  
  return 0;
    4c48:	00005e3d 	andeq	r5, r0, sp, lsr lr
}
    4c4c:	b8230300 	stmdalt	r3!, {r8, r9}
    4c50:	0c870c20 	stceq	12, cr0, [r7], {32}
 * FTM0--FTM1жϴ
 * ļstartup_K60.sеж
 * û޸ģԶӦͨжϺ
 */
void FTM0_IRQHandler(void)
{
    4c54:	a6030000 	strge	r0, [r3], -r0
  OS_ENTER_CRITICAL(); //֪ϵͳʱѾжϷӺ
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif
  
  FTM_ISR[0]();
    4c58:	00005e3d 	andeq	r5, r0, sp, lsr lr
    4c5c:	bc230300 	stclt	3, cr0, [r3], #-0
    4c60:	0c8d0c20 	stceq	12, cr0, [sp], {32}
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    4c64:	a7030000 	strge	r0, [r3, -r0]

void FTM1_IRQHandler(void)
{
    4c68:	00005e3d 	andeq	r5, r0, sp, lsr lr
  OS_ENTER_CRITICAL(); //֪ϵͳʱѾжϷӺ
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif
  
  FTM_ISR[1]();
    4c6c:	c0230300 	eorgt	r0, r3, r0, lsl #6
    4c70:	0fec0c20 	svceq	0x00ec0c20
    4c74:	a8030000 	stmdage	r3, {}	; <UNPREDICTABLE>
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    4c78:	00005e3d 	andeq	r5, r0, sp, lsr lr

void FTM2_IRQHandler(void)
{
    4c7c:	c4230300 	strtgt	r0, [r3], #-768	; 0x300
  OS_ENTER_CRITICAL(); //֪ϵͳʱѾжϷӺ
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif
  
  FTM_ISR[2]();
    4c80:	0ff40c20 	svceq	0x00f40c20
    4c84:	a9030000 	stmdbge	r3, {}	; <UNPREDICTABLE>
    4c88:	00005e3d 	andeq	r5, r0, sp, lsr lr
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    4c8c:	c8230300 	stmdagt	r3!, {r8, r9}
 * \param gpio_init_structure
* \return 0--配置失败
 *         1--配置成功
 */
int8 LPLD_GPIO_Init(GPIO_InitTypeDef gpio_init_structure)
{
    4c90:	0f290c20 	svceq	0x00290c20
    4c94:	aa030000 	bge	c4c9c <__etext+0xbbff4>
    4c98:	00005e3d 	andeq	r5, r0, sp, lsr lr
    4c9c:	cc230300 	stcgt	3, cr0, [r3], #-0
    uint8 i;

    PORT_MemMapPtr portx;
    uint32 pcr = PORT_PCR_MUX(1)
                |gpio_init_structure.GPIO_PinControl;
    4ca0:	0f2f0c20 	svceq	0x002f0c20
int8 LPLD_GPIO_Init(GPIO_InitTypeDef gpio_init_structure)
{
    uint8 i;

    PORT_MemMapPtr portx;
    uint32 pcr = PORT_PCR_MUX(1)
    4ca4:	ab030000 	blge	c4cac <__etext+0xbc004>
                |gpio_init_structure.GPIO_PinControl;
    GPIO_MemMapPtr ptx = gpio_init_structure.GPIO_PTx;
    4ca8:	00005e3d 	andeq	r5, r0, sp, lsr lr
    uint32 pins = gpio_init_structure.GPIO_Pins;
    4cac:	d0230300 	eorle	r0, r3, r0, lsl #6
    uint8 dir = gpio_init_structure.GPIO_Dir;
    4cb0:	0bcb0c20 	bleq	ff2c7d38 <__StackLimit+0xdf2c7d38>
    4cb4:	ac030000 	stcge	0, cr0, [r3], {-0}
    uint8 output = gpio_init_structure.GPIO_Output;
    4cb8:	00005e3d 	andeq	r5, r0, sp, lsr lr
    //GPIO_ISR_CALLBACK isr_func = gpio_init_structure.GPIO_Isr;
    

    if  (ptx == PTA)
    4cbc:	d4230300 	strtle	r0, [r3], #-768	; 0x300
    4cc0:	0e090c20 	cdpeq	12, 0, cr0, cr9, cr0, {1}
    4cc4:	ad030000 	stcge	0, cr0, [r3, #-0]
    4cc8:	00005e3d 	andeq	r5, r0, sp, lsr lr
        portx = PORTA_BASE_PTR;
    4ccc:	d8230300 	stmdale	r3!, {r8, r9}
    4cd0:	0e0f0c20 	cdpeq	12, 0, cr0, cr15, cr0, {1}
    4cd4:	ae030000 	cdpge	0, 0, cr0, cr3, cr0, {0}
    else if (ptx == PTB)
    4cd8:	00005e3d 	andeq	r5, r0, sp, lsr lr
    4cdc:	dc230300 	stcle	3, cr0, [r3], #-0
    4ce0:	0bd00c20 	bleq	ff407d68 <__StackLimit+0xdf407d68>
        portx = PORTB_BASE_PTR;
    4ce4:	af030000 	svcge	0x00030000
    4ce8:	00005e3d 	andeq	r5, r0, sp, lsr lr
    4cec:	e0230300 	eor	r0, r3, r0, lsl #6
    else if (ptx == PTC)
    4cf0:	03310c20 	teqeq	r1, #8192	; 0x2000
    4cf4:	b0030000 	andlt	r0, r3, r0
    4cf8:	0003c23d 	andeq	ip, r3, sp, lsr r2
    4cfc:	e4230300 	strt	r0, [r3], #-768	; 0x300
        portx = PORTC_BASE_PTR;
    4d00:	0e9f0c20 	cdpeq	12, 9, cr0, cr15, cr0, {1}
    4d04:	b1030000 	mrslt	r0, (UNDEF: 3)
    4d08:	00005e3d 	andeq	r5, r0, sp, lsr lr
    else if (ptx == PTD)
    4d0c:	e8230300 	stmda	r3!, {r8, r9}
    4d10:	434d0e20 	movtmi	r0, #56864	; 0xde20
    4d14:	b2030052 	andlt	r0, r3, #82	; 0x52
        portx = PORTD_BASE_PTR;
    4d18:	00005e3d 	andeq	r5, r0, sp, lsr lr
    4d1c:	ec230300 	stc	3, cr0, [r3], #-0
    4d20:	2c070020 	stccs	0, cr0, [r7], {32}
    else if (ptx == PTE)
    4d24:	bf000000 	svclt	0x00000000
    4d28:	1000000a 	andne	r0, r0, sl
    4d2c:	000003ab 	andeq	r0, r0, fp, lsr #7
    4d30:	11000ffb 	strdne	r0, [r0, -fp]
        portx = PORTE_BASE_PTR;
    4d34:	00000f47 	andeq	r0, r0, r7, asr #30
    4d38:	cb3db303 	blgt	f7194c <__etext+0xf68ca4>
    4d3c:	1200000a 	andne	r0, r0, #10
    else if (ptx == PTF)
    4d40:	000ad104 	andeq	sp, sl, r4, lsl #2
    4d44:	08d21300 	ldmeq	r2, {r8, r9, ip}^
    4d48:	83030000 	movwhi	r0, #12288	; 0x3000
        portx = PORTF_BASE_PTR;
    4d4c:	04000004 	streq	r0, [r0], #-4
    4d50:	0000371b 	andeq	r3, r0, fp, lsl r7
    4d54:	12e00300 	rscne	r0, r0, #0
    else
        return 0;
    4d58:	1c040000 	stcne	0, cr0, [r4], {-0}
    4d5c:	00000050 	andeq	r0, r0, r0, asr r0
    
    if (dir == DIR_OUTPUT)
    4d60:	001d7b03 	andseq	r7, sp, r3, lsl #22
    {
        ptx->PDDR |= pins;
    4d64:	691d0400 	ldmdbvs	sp, {sl}
    4d68:	03000000 	movweq	r0, #0
    4d6c:	000012e1 	andeq	r1, r0, r1, ror #5
        if (output == OUTPUT_H)
    4d70:	003e2004 	eorseq	r2, lr, r4
    4d74:	04020000 	streq	r0, [r2], #-0
            ptx->PSOR |= pins;
    4d78:	00066904 	andeq	r6, r6, r4, lsl #18
    4d7c:	04080200 	streq	r0, [r8], #-512	; 0x200
    4d80:	00000a87 	andeq	r0, r0, r7, lsl #21
        else
            ptx->PCOR |= pins;
    4d84:	000dc803 	andeq	ip, sp, r3, lsl #16
    4d88:	372e0400 	strcc	r0, [lr, -r0, lsl #8]!
    4d8c:	12000000 	andne	r0, r0, #0
    4d90:	000b2104 	andeq	r2, fp, r4, lsl #2
    }
    else
    {
        ptx->PDDR &= ~(pins);
    4d94:	02011500 	andeq	r1, r1, #0
    4d98:	07120801 	ldreq	r0, [r2, -r1, lsl #16]
    4d9c:	20030000 	andcs	r0, r3, r0
    4da0:	05000007 	streq	r0, [r0, #-7]
    }
    //配置所选引脚的控制寄存器
    for (i =0; i < 32; i++)
    4da4:	000b1b22 	andeq	r1, fp, r2, lsr #22
    4da8:	052c1600 	streq	r1, [ip, #-1536]!	; 0x600
    {
        if (pins&(1ul<<i))
    4dac:	000c3289 	andeq	r3, ip, r9, lsl #5
    4db0:	13bb1700 			; <UNDEFINED> instruction: 0x13bb1700
    4db4:	93050000 	movwls	r0, #20480	; 0x5000
    4db8:	00000ad6 	ldrdeq	r0, [r0], -r6
            portx->PCR[i] = pcr;
    4dbc:	17002302 	strne	r2, [r0, -r2, lsl #6]
    4dc0:	0000131b 	andeq	r1, r0, fp, lsl r3
    else
    {
        ptx->PDDR &= ~(pins);
    }
    //配置所选引脚的控制寄存器
    for (i =0; i < 32; i++)
    4dc4:	0ad69d05 	beq	ff5ac1e0 <__StackLimit+0xdf5ac1e0>
    4dc8:	23020000 	movwcs	r0, #8192	; 0x2000
    4dcc:	11301701 	teqne	r0, r1, lsl #14
    4dd0:	a8050000 	stmdage	r5, {}	; <UNPREDICTABLE>
    {
        if (pins&(1ul<<i))
            portx->PCR[i] = pcr;
    }

    return 1;
    4dd4:	00000b10 	andeq	r0, r0, r0, lsl fp

}
    4dd8:	17022302 	strne	r2, [r2, -r2, lsl #6]
    4ddc:	000011a0 	andeq	r1, r0, r0, lsr #3
    4de0:	0ae1b205 	beq	ff8715fc <__StackLimit+0xdf8715fc>
    4de4:	23020000 	movwcs	r0, #8192	; 0x2000
 *    0--配置错误
 *    1--配置成功
 *
 */
uint8 LPLD_GPIO_EnableIrq(GPIO_InitTypeDef gpio_init_structure)
{
    4de8:	11d31704 	bicsne	r1, r3, r4, lsl #14
    4dec:	bc050000 	stclt	0, cr0, [r5], {-0}
    4df0:	00000aec 	andeq	r0, r0, ip, ror #21
    4df4:	17082302 	strne	r2, [r8, -r2, lsl #6]
    GPIO_MemMapPtr ptx = gpio_init_structure.GPIO_PTx;
    4df8:	000013f9 	strdeq	r1, [r0], -r9
    GPIO_ISR_CALLBACK isr_func = gpio_init_structure.GPIO_Isr;
    4dfc:	0aecc605 	beq	ffb36618 <__StackLimit+0xdfb36618>
    
    if (isr_func == NULL)
    4e00:	23020000 	movwcs	r0, #8192	; 0x2000
    4e04:	1225170c 	eorne	r1, r5, #3145728	; 0x300000
        return 0;
    4e08:	d3050000 	movwle	r0, #20480	; 0x5000
    if (ptx == PTA)
    4e0c:	00000ad6 	ldrdeq	r0, [r0], -r6
    4e10:	17102302 	ldrne	r2, [r0, -r2, lsl #6]
    4e14:	000012b7 			; <UNDEFINED> instruction: 0x000012b7
    4e18:	0af7dd05 	beq	ffdfc234 <__StackLimit+0xdfdfc234>
    {
        GPIO_ISR[0] = isr_func;
    4e1c:	23020000 	movwcs	r0, #8192	; 0x2000
    4e20:	15fe1712 	ldrbne	r1, [lr, #1810]!	; 0x712
    4e24:	e7050000 	str	r0, [r5, -r0]
        enable_irq(87);
    4e28:	0000007e 	andeq	r0, r0, lr, ror r0
    4e2c:	17142302 	ldrne	r2, [r4, -r2, lsl #6]
    }
    else if (ptx == PTB)
    4e30:	00001350 	andeq	r1, r0, r0, asr r3
    4e34:	0aecf105 	beq	ffb41250 <__StackLimit+0xdfb41250>
    4e38:	23020000 	movwcs	r0, #8192	; 0x2000
    4e3c:	16141718 			; <UNDEFINED> instruction: 0x16141718
    {
        enable_irq(88);
    4e40:	fe050000 	cdp2	0, 0, cr0, cr5, cr0, {0}
    4e44:	00000ad6 	ldrdeq	r0, [r0], -r6
        GPIO_ISR[1] = isr_func;
    4e48:	0c1c2302 	ldceq	3, cr2, [ip], {2}
    4e4c:	00001588 	andeq	r1, r0, r8, lsl #11
    4e50:	f7010805 			; <UNDEFINED> instruction: 0xf7010805
    }
    else if (ptx == PTC)
    4e54:	0200000a 	andeq	r0, r0, #10
    4e58:	460c1e23 	strmi	r1, [ip], -r3, lsr #28
    4e5c:	05000014 	streq	r0, [r0, #-20]
    4e60:	007e0112 	rsbseq	r0, lr, r2, lsl r1
    {
        enable_irq(89);
    4e64:	23020000 	movwcs	r0, #8192	; 0x2000
    4e68:	156c0c20 	strbne	r0, [ip, #-3104]!	; 0xc20
        GPIO_ISR[2] = isr_func;
    4e6c:	1d050000 	stcne	0, cr0, [r5, #-0]
    4e70:	000b1001 	andeq	r1, fp, r1
    4e74:	24230200 	strtcs	r0, [r3], #-512	; 0x200
    }
    else if (ptx == PTD)
    4e78:	0013a00c 	andseq	sl, r3, ip
    4e7c:	01280500 	teqeq	r8, r0, lsl #10
    4e80:	00000b10 	andeq	r0, r0, r0, lsl fp
    4e84:	0c252302 	stceq	3, cr2, [r5], #-8
    {
        enable_irq(90);
    4e88:	000013cd 	andeq	r1, r0, sp, asr #7
    4e8c:	10013305 	andne	r3, r1, r5, lsl #6
        GPIO_ISR[3] = isr_func;
    4e90:	0200000b 	andeq	r0, r0, #11
    4e94:	2d0c2623 	stccs	6, cr2, [ip, #-140]	; 0xffffff74
    4e98:	05000015 	streq	r0, [r0, #-21]
    }
    else if (ptx == PTE)
    4e9c:	0b2a013d 	bleq	a85398 <__etext+0xa7c6f0>
    4ea0:	23020000 	movwcs	r0, #8192	; 0x2000
    4ea4:	08110028 	ldmdaeq	r1, {r3, r5}
    4ea8:	05000014 	streq	r0, [r0, #-20]
    {
        enable_irq(91);
    4eac:	0b35013f 	bleq	d453b0 <__etext+0xd3c708>
    4eb0:	01180000 	tsteq	r8, r0
        GPIO_ISR[4] = isr_func;
    4eb4:	00001be2 	andeq	r1, r0, r2, ror #23
    4eb8:	d6012901 	strle	r2, [r1], -r1, lsl #18
    4ebc:	a000000a 	andge	r0, r0, sl
    }
    else
        return 0;
    4ec0:	5c000028 	stcpl	0, cr0, [r0], {40}	; 0x28
    4ec4:	2e00002d 	cdpcs	0, 0, cr0, cr0, cr13, {1}
    return 1;
    4ec8:	01000009 	tsteq	r0, r9
}
    4ecc:	00000d2f 	andeq	r0, r0, pc, lsr #26
    4ed0:	001af619 	andseq	pc, sl, r9, lsl r6	; <UNPREDICTABLE>
    4ed4:	32290100 	eorcc	r0, r9, #0
    4ed8:	0200000c 	andeq	r0, r0, #12
 *    0--配置错误
 *    1--配置成功
 *
 */
uint8 LPLD_GPIO_DisableIrq(GPIO_InitTypeDef gpio_init_structure)
{
    4edc:	631a7091 	tstvs	sl, #145	; 0x91
    4ee0:	01007868 	tsteq	r0, r8, ror #16
    4ee4:	000ad62b 	andeq	sp, sl, fp, lsr #12
    4ee8:	67910200 	ldrvs	r0, [r1, r0, lsl #4]
    uint8 i;
    GPIO_MemMapPtr ptx = gpio_init_structure.GPIO_PTx;
    4eec:	7165721a 	cmnvc	r5, sl, lsl r2
    PORT_MemMapPtr portx;
    uint32 pins = gpio_init_structure.GPIO_Pins;
    4ef0:	d62c0100 	strtle	r0, [ip], -r0, lsl #2
 
    if  (ptx == PTA)
    4ef4:	0200000a 	andeq	r0, r0, #10
    4ef8:	c31b6691 	tstgt	fp, #152043520	; 0x9100000
    4efc:	0100001b 	tsteq	r0, fp, lsl r0
    4f00:	000b102d 	andeq	r1, fp, sp, lsr #32
        portx = PORTA_BASE_PTR;
    4f04:	65910200 	ldrvs	r0, [r1, #512]	; 0x200
    4f08:	001adc1b 	andseq	sp, sl, fp, lsl ip
    4f0c:	e12e0100 	teq	lr, r0, lsl #2
    else if (ptx == PTB)
    4f10:	0200000a 	andeq	r0, r0, #10
    4f14:	261b6291 			; <UNDEFINED> instruction: 0x261b6291
    4f18:	0100001b 	tsteq	r0, fp, lsl r0
        portx = PORTB_BASE_PTR;
    4f1c:	000aec2f 	andeq	lr, sl, pc, lsr #24
    4f20:	5c910200 	lfmpl	f0, 4, [r1], {0}
    4f24:	001bf01b 	andseq	pc, fp, fp, lsl r0	; <UNPREDICTABLE>
    else if (ptx == PTC)
    4f28:	ec300100 	ldfs	f0, [r0], #-0
    4f2c:	0200000a 	andeq	r0, r0, #10
    4f30:	c61b5891 			; <UNDEFINED> instruction: 0xc61b5891
    4f34:	0100001a 	tsteq	r0, sl, lsl r0
        portx = PORTC_BASE_PTR;
    4f38:	000ad631 	andeq	sp, sl, r1, lsr r6
    4f3c:	57910200 	ldrpl	r0, [r1, r0, lsl #4]
    4f40:	001ab71b 	andseq	fp, sl, fp, lsl r7
    else if (ptx == PTD)
    4f44:	f7320100 			; <UNDEFINED> instruction: 0xf7320100
    4f48:	0200000a 	andeq	r0, r0, #10
    4f4c:	4e1b5491 	cfcmpsmi	r5, mvf11, mvf1
        portx = PORTD_BASE_PTR;
    4f50:	0100001b 	tsteq	r0, fp, lsl r0
    4f54:	00007e33 	andeq	r7, r0, r3, lsr lr
    4f58:	50910200 	addspl	r0, r1, r0, lsl #4
    else if (ptx == PTE)
    4f5c:	001a871b 	andseq	r8, sl, fp, lsl r7
    4f60:	ec340100 	ldfs	f0, [r4], #-0
    4f64:	0200000a 	andeq	r0, r0, #10
    4f68:	f91b4c91 			; <UNDEFINED> instruction: 0xf91b4c91
        portx = PORTE_BASE_PTR;
    4f6c:	0100001b 	tsteq	r0, fp, lsl r0
    4f70:	000ad635 	andeq	sp, sl, r5, lsr r6
    4f74:	4b910200 	blmi	fe44577c <__StackLimit+0xde44577c>
    else if (ptx == PTF)
    4f78:	001a091b 	andseq	r0, sl, fp, lsl r9
    4f7c:	f7360100 			; <UNDEFINED> instruction: 0xf7360100
    4f80:	0200000a 	andeq	r0, r0, #10
        portx = PORTF_BASE_PTR;
    4f84:	d01b4891 	mulsle	fp, r1, r8
    4f88:	0100001a 	tsteq	r0, sl, lsl r0
    4f8c:	00007e37 	andeq	r7, r0, r7, lsr lr
    else
        return 0;
    4f90:	44910200 	ldrmi	r0, [r1], #512	; 0x200
    4f94:	001a181b 	andseq	r1, sl, fp, lsl r8
    //配置所选引脚的控制寄存器
    for (i =0; i < 32; i++)
    4f98:	10380100 	eorsne	r0, r8, r0, lsl #2
    4f9c:	0200000b 	andeq	r0, r0, #11
    {
        if (pins&(1ul<<i))
    4fa0:	1c004391 	stcne	3, cr4, [r0], {145}	; 0x91
    4fa4:	001b6a01 	andseq	r6, fp, r1, lsl #20
    4fa8:	01b60100 			; <UNDEFINED> instruction: 0x01b60100
    4fac:	00000ad6 	ldrdeq	r0, [r0], -r6
            portx->PCR[i] &= ~(PORT_PCR_IRQC_MASK);
    4fb0:	00002d5c 	andeq	r2, r0, ip, asr sp
    4fb4:	00002d82 	andeq	r2, r0, r2, lsl #27
    4fb8:	00000974 	andeq	r0, r0, r4, ror r9
    4fbc:	000d5c01 	andeq	r5, sp, r1, lsl #24
    4fc0:	1af61900 	bne	ffd8b3c8 <__StackLimit+0xdfd8b3c8>
    else if (ptx == PTF)
        portx = PORTF_BASE_PTR;
    else
        return 0;
    //配置所选引脚的控制寄存器
    for (i =0; i < 32; i++)
    4fc4:	b6010000 	strlt	r0, [r1], -r0
    4fc8:	00000c32 	andeq	r0, r0, r2, lsr ip
    4fcc:	00709102 	rsbseq	r9, r0, r2, lsl #2
    {
        if (pins&(1ul<<i))
            portx->PCR[i] &= ~(PORT_PCR_IRQC_MASK);
    }
    return 1;
    4fd0:	1b9f011c 	blne	fe7c5448 <__StackLimit+0xde7c5448>
}
    4fd4:	c8010000 	stmdagt	r1, {}	; <UNPREDICTABLE>
    4fd8:	000ad601 	andeq	sp, sl, r1, lsl #12
    4fdc:	002d8400 	eoreq	r8, sp, r0, lsl #8
    4fe0:	002daa00 	eoreq	sl, sp, r0, lsl #20
 * /param ptx   --
 *        data32 --
 * /return 无
 */
void LPLD_GPIO_Output(GPIO_MemMapPtr ptx, uint32 data32)
{
    4fe4:	0009ac00 	andeq	sl, r9, r0, lsl #24
    4fe8:	0d890100 	stfeqs	f0, [r9]
    4fec:	f6190000 			; <UNDEFINED> instruction: 0xf6190000
    ptx->PDOR |= data32;
    4ff0:	0100001a 	tsteq	r0, sl, lsl r0
    4ff4:	000c32c8 	andeq	r3, ip, r8, asr #5
    4ff8:	70910200 	addsvc	r0, r1, r0, lsl #4
}
    4ffc:	30011d00 	andcc	r1, r1, r0, lsl #26
    5000:	0100001b 	tsteq	r0, fp, lsl r0

void LPLD_GPIO_Output_b (GPIO_MemMapPtr ptx, uint8 lsb_num, uint8 data1)
{
    5004:	2dac01d9 	stfcss	f0, [ip, #868]!	; 0x364
    5008:	2e000000 	cdpcs	0, 0, cr0, cr0, cr0, {0}
    500c:	09e40000 	stmibeq	r4!, {}^	; <UNPREDICTABLE>
    5010:	b2010000 	andlt	r0, r1, #0
    ptx->PDOR = (ptx -> PDOR & ~(0x01L << lsb_num)) | ((uint32) data1 << lsb_num);
    5014:	1900000d 	stmdbne	r0, {r0, r2, r3}
    5018:	00001af6 	strdeq	r1, [r0], -r6
    501c:	0c32d901 	ldceq	9, cr13, [r2], #-4
    5020:	91020000 	mrsls	r0, (UNDEF: 2)
    5024:	011e0070 	tsteq	lr, r0, ror r0
    5028:	00001a36 	andeq	r1, r0, r6, lsr sl
    502c:	0001e301 	andeq	lr, r1, r1, lsl #6
    5030:	2a00002e 	bcs	50f0 <PORTA_IRQHandler+0x1c>
    5034:	1c00002e 	stcne	0, cr0, [r0], {46}	; 0x2e
}
    5038:	0100000a 	tsteq	r0, sl
    503c:	1ae6011e 	bne	ff9854bc <__StackLimit+0xdf9854bc>
 * /param ptx --
 *        data32 --
 * /return 无
 */
void LPLD_GPIO_Toggle(GPIO_MemMapPtr ptx, uint32 data32)
{
    5040:	f6010000 			; <UNDEFINED> instruction: 0xf6010000
    5044:	002e2c01 	eoreq	r2, lr, r1, lsl #24
    5048:	002e5600 	eoreq	r5, lr, r0, lsl #12
    ptx->PTOR |= data32;
    504c:	000a4800 	andeq	r4, sl, r0, lsl #16
    5050:	011f0100 	tsteq	pc, r0, lsl #2
    5054:	00001bb3 			; <UNDEFINED> instruction: 0x00001bb3
}
    5058:	01010901 	tsteq	r1, r1, lsl #18
    505c:	00002e58 	andeq	r2, r0, r8, asr lr

void LPLD_GPIO_Toggle_b(GPIO_MemMapPtr ptx, uint8 lsb_num)
{
    5060:	00002e82 	andeq	r2, r0, r2, lsl #29
    5064:	00000a74 	andeq	r0, r0, r4, ror sl
    5068:	67011f01 	strvs	r1, [r1, -r1, lsl #30]
    ptx -> PTOR |= 0x01L << lsb_num;
    506c:	0100001a 	tsteq	r0, sl, lsl r0
    5070:	8401011c 	strhi	r0, [r1], #-284	; 0x11c
    5074:	ae00002e 	cdpge	0, 0, cr0, cr0, cr14, {1}
    5078:	a000002e 	andge	r0, r0, lr, lsr #32
    507c:	0100000a 	tsteq	r0, sl
}
    5080:	1b16011f 	blne	585504 <__etext+0x57c85c>
    5084:	2f010000 	svccs	0x00010000
    5088:	2eb00101 	frdcss	f0, f0, f1
 * /brief 读取GPIO端口0~31的数据
 * /param ptx --
 * /return 取得的32为数据
 */
uint32 LPLD_GPIO_Input(GPIO_MemMapPtr ptx)
{
    508c:	2eda0000 	cdpcs	0, 13, cr0, cr10, cr0, {0}
    5090:	0acc0000 	beq	ff305098 <__StackLimit+0xdf305098>
    uint32 tmp;
    tmp = ptx->PDIR;
    5094:	1f010000 	svcne	0x00010000
    5098:	001bd201 	andseq	sp, fp, r1, lsl #4
    return (tmp);
}
    509c:	01420100 	mrseq	r0, (UNDEF: 82)
    50a0:	002edc01 	eoreq	sp, lr, r1, lsl #24
    50a4:	002f0600 	eoreq	r0, pc, r0, lsl #12

uint8 LPLD_GPIO_Input_b (GPIO_MemMapPtr ptx, uint8 lsb_num)
{
    50a8:	000af800 	andeq	pc, sl, r0, lsl #16
    50ac:	011f0100 	tsteq	pc, r0, lsl #2
    50b0:	00001a57 	andeq	r1, r0, r7, asr sl
    return (uint8) ((ptx -> PDIR >> lsb_num) & 0x01L);
    50b4:	01015501 	tsteq	r1, r1, lsl #10
    50b8:	00002f08 	andeq	r2, r0, r8, lsl #30
    50bc:	00002f32 	andeq	r2, r0, r2, lsr pc
    50c0:	00000b24 	andeq	r0, r0, r4, lsr #22
    50c4:	06011f01 	streq	r1, [r1], -r1, lsl #30
}
    50c8:	0100001b 	tsteq	r0, fp, lsl r0
    50cc:	34010168 	strcc	r0, [r1], #-360	; 0x168
    50d0:	5e00002f 	cdppl	0, 0, cr0, cr0, cr15, {1}

/*
 * PORTA-PORTE中断处理函数
 */
void PORTA_IRQHandler (void)
{
    50d4:	5000002f 	andpl	r0, r0, pc, lsr #32
    GPIO_ISR[0]();
    50d8:	0100000b 	tsteq	r0, fp
    50dc:	1b5a011f 	blne	1685560 <__etext+0x167c8b8>
    50e0:	7b010000 	blvc	450e8 <__etext+0x3c440>
    PORTA_ISFR = 0xFFFFFFFF;
    50e4:	2f600101 	svccs	0x00600101
    50e8:	2f8a0000 	svccs	0x008a0000
    50ec:	0b7c0000 	bleq	1f050f4 <__etext+0x1efc44c>
    50f0:	1f010000 	svcne	0x00010000
}
    50f4:	001a7701 	andseq	r7, sl, r1, lsl #14
void PORTB_IRQHandler (void)
{
    50f8:	018e0100 	orreq	r0, lr, r0, lsl #2
    GPIO_ISR[1]();
    50fc:	002f8c01 	eoreq	r8, pc, r1, lsl #24
    5100:	002fb600 	eoreq	fp, pc, r0, lsl #12
    5104:	000ba800 	andeq	sl, fp, r0, lsl #16
    PORTB_ISFR = 0xFFFFFFFF;
    5108:	011f0100 	tsteq	pc, r0, lsl #2
    510c:	000019f8 	strdeq	r1, [r0], -r8
    5110:	0101a101 	tsteq	r1, r1, lsl #2
    5114:	00002fb8 			; <UNDEFINED> instruction: 0x00002fb8
}
    5118:	00002fe2 	andeq	r2, r0, r2, ror #31
void PORTC_IRQHandler (void)
{
    511c:	00000bd4 	ldrdeq	r0, [r0], -r4
    GPIO_ISR[2]();
    5120:	a6011f01 	strge	r1, [r1], -r1, lsl #30
    5124:	0100001a 	tsteq	r0, sl, lsl r0
    5128:	e40101b4 	str	r0, [r1], #-436	; 0x1b4
    PORTC_ISFR = 0xFFFFFFFF;
    512c:	0e00002f 	cdpeq	0, 0, cr0, cr0, cr15, {1}
    5130:	00000030 	andeq	r0, r0, r0, lsr r0
    5134:	0100000c 	tsteq	r0, ip
    5138:	1b7d011f 	blne	1f455bc <__etext+0x1f3c914>
}
    513c:	c7010000 	strgt	r0, [r1, -r0]

void PORTD_IRQHandler (void)
{
    5140:	30100101 	andscc	r0, r0, r1, lsl #2
    GPIO_ISR[3]();
    5144:	303a0000 	eorscc	r0, sl, r0
    5148:	0c2c0000 	stceq	0, cr0, [ip], #-0
    514c:	1f010000 	svcne	0x00010000
    PORTD_ISFR = 0xFFFFFFFF;
    5150:	001a2501 	andseq	r2, sl, r1, lsl #10
    5154:	01da0100 	bicseq	r0, sl, r0, lsl #2
    5158:	00303c01 	eorseq	r3, r0, r1, lsl #24
    515c:	00306600 	eorseq	r6, r0, r0, lsl #12
}
    5160:	000c5800 	andeq	r5, ip, r0, lsl #16

void PORTE_IRQHandler (void)
{
    5164:	011f0100 	tsteq	pc, r0, lsl #2
    GPIO_ISR[4]();
    5168:	00001a46 	andeq	r1, r0, r6, asr #20
    516c:	0101ed01 	tsteq	r1, r1, lsl #26
    5170:	00003068 	andeq	r3, r0, r8, rrx
    PORTE_ISFR = 0xFFFFFFFF;
    5174:	00003092 	muleq	r0, r2, r0
    5178:	00000c84 	andeq	r0, r0, r4, lsl #25
    517c:	8e011f01 	cdphi	15, 0, cr1, cr1, cr1, {0}
    5180:	0100001b 	tsteq	r0, fp, lsl r0
}
    5184:	94010200 	strls	r0, [r1], #-512	; 0x200
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_LPTMR_Init(LPTMR_InitTypeDef lptmr_init_structure)
{
    5188:	be000030 	mcrlt	0, 0, r0, cr0, cr0, {1}
    518c:	b0000030 	andlt	r0, r0, r0, lsr r0
    5190:	0100000c 	tsteq	r0, ip
    5194:	000b2a07 	andeq	r2, fp, r7, lsl #20
  uint8  mode = lptmr_init_structure.LPTMR_Mode; 
    5198:	000f3000 	andeq	r3, pc, r0
  uint16 period_ms = lptmr_init_structure.LPTMR_PeriodMs;
    519c:	03ab0800 			; <UNDEFINED> instruction: 0x03ab0800
  uint8  pluseacc_input = lptmr_init_structure.LPTMR_PluseAccInput;
    51a0:	000f0000 	andeq	r0, pc, r0
  LPTMR_ISR_CALLBACK isr_func = lptmr_init_structure.LPTMR_Isr;
    51a4:	000a2f20 	andeq	r2, sl, r0, lsr #30

//  ASSERT(mode <= LPTMR_MODE_PLACC );
 // ASSERT(pluseacc_input <= LPTMR_ALT2 );
    if (mode > LPTMR_MODE_PLACC)
    51a8:	201a0100 	andscs	r0, sl, r0, lsl #2
        return 0;
    51ac:	0100000f 	tsteq	r0, pc
    51b0:	16040305 	strne	r0, [r4], -r5, lsl #6
    if (pluseacc_input > LPTMR_ALT2)
    51b4:	81001fff 	strdhi	r1, [r0, -pc]
        return 0;
    51b8:	02000010 	andeq	r0, r0, #16
    51bc:	000bf400 	andeq	pc, fp, r0, lsl #8
  //ʹOSCERCLK
  OSC0_CR |= OSC_CR_ERCLKEN_MASK;
    51c0:	34010400 	strcc	r0, [r1], #-1024	; 0x400
    51c4:	01000002 	tsteq	r0, r2
    51c8:	00001d87 	andeq	r1, r0, r7, lsl #27
    51cc:	00000827 	andeq	r0, r0, r7, lsr #16
    51d0:	000030c0 	andeq	r3, r0, r0, asr #1
    51d4:	00004c8e 	andeq	r4, r0, lr, lsl #25
    51d8:	00000c29 	andeq	r0, r0, r9, lsr #24
  //ʼLPTMRʱ
  SIM_SCGC5|=SIM_SCGC5_LPTIMER_MASK;  
    51dc:	0b060102 	bleq	1855ec <__etext+0x17c944>
    51e0:	03000007 	movweq	r0, #7
    51e4:	000009dd 	ldrdeq	r0, [r0], -sp
    51e8:	00372a02 	eorseq	r2, r7, r2, lsl #20
    51ec:	01020000 	mrseq	r0, (UNDEF: 2)
    51f0:	00070908 	andeq	r0, r7, r8, lsl #18
    51f4:	05020200 	streq	r0, [r2, #-512]	; 0x200
    51f8:	0000073b 	andeq	r0, r0, fp, lsr r7
    51fc:	92070202 	andls	r0, r7, #536870912	; 0x20000000
    5200:	02000004 	andeq	r0, r0, #4
   
  //ռĴ
  LPTMR0_CSR = 0x00;                   
    5204:	01960504 	orrseq	r0, r6, r4, lsl #10
    5208:	9b030000 	blls	c5210 <__etext+0xbc568>
    520c:	02000007 	andeq	r0, r0, #7
  LPTMR0_PSR = 0x00;
    5210:	00005e50 	andeq	r5, r0, r0, asr lr
    5214:	07040200 	streq	r0, [r4, -r0, lsl #4]
    5218:	000001e4 	andeq	r0, r0, r4, ror #3
    521c:	91050802 	tstls	r5, r2, lsl #16
  LPTMR0_CMR = 0x00;
    5220:	02000001 	andeq	r0, r0, #1
    5224:	01df0708 	bicseq	r0, pc, r8, lsl #14
    5228:	04040000 	streq	r0, [r4], #-0
   
  if(mode == LPTMR_MODE_TIMER)          // óɵ͹Ķʱ
    522c:	746e6905 	strbtvc	r6, [lr], #-2309	; 0x905
    5230:	07040200 	streq	r0, [r4, -r0, lsl #4]
    // LPO 1Khz
    //ñȽϵֵ
    //ʹڲʱ ƵϵPrescaleΪ 2^(X+1)
    //ʱһ=ʱԴ(Clk_Src)/ ԤƵֵ(Prescale)
    //ʱĶʱֵ=õıȽֵ(compare_value)/ʱһ
    LPTMR0_CMR = LPTMR_CMR_COMPARE(period_ms);                 //ñȽֵ
    5234:	000001e9 	andeq	r0, r0, r9, ror #3
    5238:	74070402 	strvc	r0, [r7], #-1026	; 0x402
    523c:	05000005 	streq	r0, [r0, #-5]
    //LPTMR0_PSR = LPTMR_PSR_PCS(0x1)|LPTMR_PSR_PBYP_MASK;       //LPOʱ·ʹ
    LPTMR0_PSR = (0 | LPTMR_PSR_PCS(3)
    5240:	0000002c 	andeq	r0, r0, ip, lsr #32
    5244:	00000098 	muleq	r0, r8, r0
    5248:	00008106 	andeq	r8, r0, r6, lsl #2
    524c:	05001b00 	streq	r1, [r0, #-2816]	; 0xb00
                    | LPTMR_PSR_PRESCALE(4)
                 );
        
  }
  else if(mode == LPTMR_MODE_PLACC)             //ó岶ģʽ
    5250:	0000002c 	andeq	r0, r0, ip, lsr #32
  {
    
    if(pluseacc_input == LPTMR_ALT1)            //PTA19
    5254:	000000a8 	andeq	r0, r0, r8, lsr #1
    5258:	00008106 	andeq	r8, r0, r6, lsl #2
    {
      PORTA->PCR[19] = PORT_PCR_MUX(0x6);       //PTA19Ϊۼ
    525c:	05000300 	streq	r0, [r0, #-768]	; 0x300
    5260:	0000002c 	andeq	r0, r0, ip, lsr #32
    5264:	000000b8 	strheq	r0, [r0], -r8
    5268:	00008106 	andeq	r8, r0, r6, lsl #2
    }
    else if(pluseacc_input == LPTMR_ALT2)       //PTC5
    526c:	05000700 	streq	r0, [r0, #-1792]	; 0x700
    {
      PORTC->PCR[5] = PORT_PCR_MUX(0x4);        //PTC5Ϊۼ  
    5270:	0000002c 	andeq	r0, r0, ip, lsr #32
    5274:	000000c8 	andeq	r0, r0, r8, asr #1
    5278:	00008106 	andeq	r8, r0, r6, lsl #2
    527c:	07001700 	streq	r1, [r0, -r0, lsl #14]
    }

    //õڲʱ޹
    //ⲿźΪʱ
     LPTMR0_PSR = (0 | LPTMR_PSR_PCS(3)
    5280:	231d0308 	tstcs	sp, #536870912	; 0x20000000
    5284:	000000f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    5288:	001d5908 	andseq	r5, sp, r8, lsl #18
                    | LPTMR_PSR_PRESCALE(4)
                 );
  //LPTMR0_PSR = LPTMR_PSR_PCS(0x1)|LPTMR_PSR_PBYP_MASK; 
    LPTMR0_CSR = LPTMR_CSR_TPS(pluseacc_input);
    528c:	231e0300 	tstcs	lr, #0
    5290:	00000053 	andeq	r0, r0, r3, asr r0
    5294:	09002302 	stmdbeq	r0, {r1, r8, r9, sp}
    5298:	00566e43 	subseq	r6, r6, r3, asr #28
    529c:	53231f03 	teqpl	r3, #12
    LPTMR0_CSR |= LPTMR_CSR_TMS_MASK; //ģʽ
    52a0:	02000000 	andeq	r0, r0, #0
    52a4:	0a000423 	beq	6338 <LPLD_PIT_TimeGetUs+0x8c>
    52a8:	00001d0f 	andeq	r1, r0, pc, lsl #26
    52ac:	2319039c 	tstcs	r9, #1879048194	; 0x70000002
    52b0:	0000026c 	andeq	r0, r0, ip, ror #4
    52b4:	00435309 	subeq	r5, r3, r9, lsl #6
    LPTMR0_CSR |= LPTMR_CSR_TFC_MASK; //ɼģʽ
    52b8:	53231a03 	teqpl	r3, #12288	; 0x3000
    52bc:	02000000 	andeq	r0, r0, #0
    52c0:	43090023 	movwmi	r0, #36899	; 0x9023
    52c4:	0300544e 	movweq	r5, #1102	; 0x44e
    52c8:	0053231b 	subseq	r2, r3, fp, lsl r3
    52cc:	23020000 	movwcs	r0, #8192	; 0x2000
  }
  
  if(lptmr_init_structure.LPTMR_IntEnable == TRUE && isr_func != NULL)
    52d0:	4f4d0904 	svcmi	0x004d0904
    52d4:	1c030044 	stcne	0, cr0, [r3], {68}	; 0x44
    52d8:	00005323 	andeq	r5, r0, r3, lsr #6
  {
    LPTMR_ISR[0] = isr_func;
    52dc:	08230200 	stmdaeq	r3!, {r9}
    52e0:	001dc108 	andseq	ip, sp, r8, lsl #2
    52e4:	23200300 	teqcs	r0, #0
    LPTMR0_CSR |= LPTMR_CSR_TIE_MASK;
    52e8:	0000026c 	andeq	r0, r0, ip, ror #4
    52ec:	080c2302 	stmdaeq	ip, {r1, r8, r9, sp}
    52f0:	00001ed2 	ldrdeq	r1, [r0], -r2
    52f4:	53232103 	teqpl	r3, #-1073741824	; 0xc0000000
    52f8:	02000000 	andeq	r0, r0, #0
    52fc:	f1084c23 			; <UNDEFINED> instruction: 0xf1084c23
  }

  LPTMR0_CSR |= LPTMR_CSR_TEN_MASK; //LPTMR
    5300:	0300001f 	movweq	r0, #31
    5304:	00532322 	subseq	r2, r3, r2, lsr #6
    5308:	23020000 	movwcs	r0, #8192	; 0x2000
    530c:	1f450850 	svcne	0x00450850
    5310:	23030000 	movwcs	r0, #12288	; 0x3000
    5314:	00005323 	andeq	r5, r0, r3, lsr #6
  return 1;
    5318:	54230200 	strtpl	r0, [r3], #-512	; 0x200
}
    531c:	001fbe08 	andseq	fp, pc, r8, lsl #28
    5320:	23240300 	teqcs	r4, #0
    5324:	00000053 	andeq	r0, r0, r3, asr r0
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_LPTMR_Deinit(void)
{
    5328:	08582302 	ldmdaeq	r8, {r1, r8, r9, sp}^
  //CSRĴ
  LPTMR0_CSR=0x00;  
    532c:	00001e44 	andeq	r1, r0, r4, asr #28
    5330:	53232503 	teqpl	r3, #12582912	; 0xc00000
    5334:	02000000 	andeq	r0, r0, #0
    5338:	b9085c23 	stmdblt	r8, {r0, r1, r5, sl, fp, ip, lr}
  //PSRĴ
  LPTMR0_PSR=0x00;
    533c:	0300001d 	movweq	r0, #29
    5340:	00532326 	subseq	r2, r3, r6, lsr #6
    5344:	23020000 	movwcs	r0, #8192	; 0x2000
  //CMRĴ
  LPTMR0_CMR=0x00;
    5348:	1c190860 	ldcne	8, cr0, [r9], {96}	; 0x60
    534c:	27030000 	strcs	r0, [r3, -r0]
    5350:	00005323 	andeq	r5, r0, r3, lsr #6
    5354:	64230200 	strtvs	r0, [r3], #-512	; 0x200
  //ֹLPTimerж
  disable_irq(INT_LPTimer - 16);
    5358:	001f7308 	andseq	r7, pc, r8, lsl #6
    535c:	23280300 	teqcs	r8, #0
  
   //رLPTMRʱ
  SIM_SCGC5 &= ~(SIM_SCGC5_LPTIMER_MASK);  
    5360:	00000053 	andeq	r0, r0, r3, asr r0
    5364:	08682302 	stmdaeq	r8!, {r1, r8, r9, sp}^
    5368:	00001ee0 	andeq	r1, r0, r0, ror #29
    536c:	53232903 	teqpl	r3, #49152	; 0xc000
    5370:	02000000 	andeq	r0, r0, #0
    5374:	50096c23 	andpl	r6, r9, r3, lsr #24
    5378:	03004c4f 	movweq	r4, #3151	; 0xc4f
    537c:	0053232a 	subseq	r2, r3, sl, lsr #6
    5380:	23020000 	movwcs	r0, #8192	; 0x2000
    5384:	4d460970 	stclmi	9, cr0, [r6, #-448]	; 0xfffffe40
  
  return 1;
    5388:	2b030053 	blcs	c54dc <__etext+0xbc834>
}
    538c:	00005323 	andeq	r5, r0, r3, lsr #6
 *      
 *  :
 *      
 */
void LPLD_LPTMR_ResetCounter(void)
{
    5390:	74230200 	strtvc	r0, [r3], #-512	; 0x200
  LPTMR0_CSR&=(~LPTMR_CSR_TEN_MASK);       //Reset LPTMR0 Counter
    5394:	001cb808 	andseq	fp, ip, r8, lsl #16
    5398:	232c0300 	teqcs	ip, #0
    539c:	00000053 	andeq	r0, r0, r3, asr r0
    53a0:	08782302 	ldmdaeq	r8!, {r1, r8, r9, sp}^
    53a4:	00001e3c 	andeq	r1, r0, ip, lsr lr
    53a8:	53232d03 	teqpl	r3, #192	; 0xc0
}
    53ac:	02000000 	andeq	r0, r0, #0
    53b0:	1a087c23 	bne	224444 <__etext+0x21b79c>
 *    0--ô
 *    1--óɹ
 *
 */
uint8 LPLD_LPTMR_EnableIrq(void)
{
    53b4:	0300001d 	movweq	r0, #29
  enable_irq(INT_LPTimer - 16);
    53b8:	0053232e 	subseq	r2, r3, lr, lsr #6
    53bc:	23030000 	movwcs	r0, #12288	; 0x3000
  return 1;
    53c0:	0c080180 	stfeqs	f0, [r8], {128}	; 0x80
}
    53c4:	03000020 	movweq	r0, #32
 *    0--ô
 *    1--óɹ
 *
 */
uint8 LPLD_LPTMR_DisableIrq(void)
{
    53c8:	0053232f 	subseq	r2, r3, pc, lsr #6
  disable_irq(INT_LPTimer - 16); 
    53cc:	23030000 	movwcs	r0, #12288	; 0x3000
    53d0:	1e080184 	adfne<illegal precision>	f0, f0, f4
  return 1;
    53d4:	0300001f 	movweq	r0, #31
}
    53d8:	00532330 	subseq	r2, r3, r0, lsr r3
 *      
 *  :
 *      ۼֵ
 */
uint16 LPLD_LPTMR_GetPulseAcc(void)
{
    53dc:	23030000 	movwcs	r0, #12288	; 0x3000
    LPTMR0_CNR = 0;
    53e0:	09080188 	stmdbeq	r8, {r3, r7, r8}
    53e4:	03000020 	movweq	r0, #32
    53e8:	00532331 	subseq	r2, r3, r1, lsr r3
    53ec:	23030000 	movwcs	r0, #12288	; 0x3000
   return (uint16)LPTMR0_CNR;
    53f0:	5808018c 	stmdapl	r8, {r2, r3, r7, r8}
    53f4:	0300001f 	movweq	r0, #31
    53f8:	00532332 	subseq	r2, r3, r2, lsr r3
}
    53fc:	23030000 	movwcs	r0, #12288	; 0x3000
    5400:	5e080190 	fltpl<illegal precision>	f0, r0
 *
 *  :
 *      
 */
void LPLD_LPTMR_DelayMs(uint16 period_ms)
{
    5404:	0300001d 	movweq	r0, #29
    5408:	00532333 	subseq	r2, r3, r3, lsr r3
    540c:	23030000 	movwcs	r0, #12288	; 0x3000
  if(!period_ms)
    5410:	a2080194 	andge	r0, r8, #37	; 0x25
    return;
  
  OSC0_CR |= OSC_CR_ERCLKEN_MASK;
    5414:	0300001d 	movweq	r0, #29
    5418:	00532334 	subseq	r2, r3, r4, lsr r3
    541c:	23030000 	movwcs	r0, #12288	; 0x3000
    5420:	05000198 	streq	r0, [r0, #-408]	; 0x198
    5424:	000000c8 	andeq	r0, r0, r8, asr #1
    5428:	0000027c 	andeq	r0, r0, ip, ror r2
    542c:	00008106 	andeq	r8, r0, r6, lsl #2
  /* LPTMRʱ */
  SIM_SCGC5|=SIM_SCGC5_LPTIMER_MASK; 
    5430:	0b000700 	bleq	7038 <SPI0_IRQHandler+0xec>
    5434:	00001f7c 	andeq	r1, r0, ip, ror pc
    5438:	88233503 	stmdahi	r3!, {r0, r1, r8, sl, ip, sp}
    543c:	0c000002 	stceq	0, cr0, [r0], {2}
    5440:	00028e04 	andeq	r8, r2, r4, lsl #28
    5444:	00f00d00 	rscseq	r0, r0, r0, lsl #26
    5448:	53050000 	movwpl	r0, #20480	; 0x5000
    544c:	a3000000 	movwge	r0, #0
    5450:	06000002 	streq	r0, [r0], -r2
    5454:	00000081 	andeq	r0, r0, r1, lsl #1
  
  /* úʱ */
  LPTMR0_CMR = period_ms; 
    5458:	610a001f 	tstvs	sl, pc, lsl r0
    545c:	cc000012 	stcgt	0, cr0, [r0], {18}
    5460:	4035a503 	eorsmi	sl, r5, r3, lsl #10
  
  /* LPTMRƵ1kHz LPOΪʱԴ */
  LPTMR0_PSR = 0|LPTMR_PSR_PCS(1)|LPTMR_PSR_PBYP_MASK; 
    5464:	09000003 	stmdbeq	r0, {r0, r1}
    5468:	00524350 	subseq	r4, r2, r0, asr r3
    546c:	9335a603 	teqls	r5, #3145728	; 0x300000
    5470:	02000002 	andeq	r0, r0, #2
  
  /* ʱ */
  LPTMR0_CSR |= LPTMR_CSR_TEN_MASK; 
    5474:	11080023 	tstne	r8, r3, lsr #32
    5478:	03000011 	movweq	r0, #17
    547c:	005335a7 	subseq	r3, r3, r7, lsr #11
    5480:	23030000 	movwcs	r0, #12288	; 0x3000
    5484:	5a080180 	bpl	205a8c <__etext+0x1fcde4>
    5488:	03000014 	movweq	r0, #20

  /* ȴﵽ趨ֵ */
  while (!(LPTMR0_CSR & LPTMR_CSR_TCF_MASK));
    548c:	005335a8 	subseq	r3, r3, r8, lsr #11
    5490:	23030000 	movwcs	r0, #12288	; 0x3000
    5494:	12080184 	andne	r0, r8, #33	; 0x21
    5498:	03000003 	movweq	r0, #3
    549c:	00b835a9 	adcseq	r3, r8, r9, lsr #11
  
  /*ʱȽϱ־ */
  LPTMR0_CSR &= ~LPTMR_CSR_TEN_MASK;
    54a0:	23030000 	movwcs	r0, #12288	; 0x3000
    54a4:	38080188 	stmdacc	r8, {r3, r7, r8}
    54a8:	03000012 	movweq	r0, #18
    54ac:	005335aa 	subseq	r3, r3, sl, lsr #11
    54b0:	23030000 	movwcs	r0, #12288	; 0x3000
    54b4:	1d0801a0 	stfnes	f0, [r8, #-640]	; 0xfffffd80
 *      
 */
void LPLD_LPTMR_DelayMs(uint16 period_ms)
{
  if(!period_ms)
    return;
    54b8:	03000003 	movweq	r0, #3
  while (!(LPTMR0_CSR & LPTMR_CSR_TCF_MASK));
  
  /*ʱȽϱ־ */
  LPTMR0_CSR &= ~LPTMR_CSR_TEN_MASK;
  
}
    54bc:	008835ab 	addeq	r3, r8, fp, lsr #11
    54c0:	23030000 	movwcs	r0, #12288	; 0x3000
 * LPTMRжϴ
 * ļstartup_K60.sеж
 * û޸ģԶӦͨжϺ
 */
void LPT_IRQHandler(void)
{
    54c4:	6d0801a4 	stfvss	f0, [r8, #-656]	; 0xfffffd70
  LPTMR0_CSR|=LPTMR_CSR_TCF_MASK;  //LPTȽϱ־
    54c8:	03000012 	movweq	r0, #18
    54cc:	005335ac 	subseq	r3, r3, ip, lsr #11
    54d0:	23030000 	movwcs	r0, #12288	; 0x3000
    54d4:	4a0801c0 	bmi	205bdc <__etext+0x1fcf34>
    54d8:	03000011 	movweq	r0, #17
    54dc:	005335ad 	subseq	r3, r3, sp, lsr #11
  LPTMR_ISR[0]();
    54e0:	23030000 	movwcs	r0, #12288	; 0x3000
    54e4:	950801c4 	strls	r0, [r8, #-452]	; 0x1c4
    54e8:	03000012 	movweq	r0, #18
}
    54ec:	005335ae 	subseq	r3, r3, lr, lsr #11
 *
 * 输出:
 *    内核频率，单位MHz
 */
uint8 LPLD_PLL_Setup(PllOptionEnum_Type core_clk_mhz)
{
    54f0:	23030000 	movwcs	r0, #12288	; 0x3000
    54f4:	0b0001c8 	bleq	5c1c <LPLD_PDB_Deinit+0x70>
    54f8:	000011b1 			; <UNDEFINED> instruction: 0x000011b1
  uint8 pll_freq;
  uint8 prdiv, vdiv;
  uint8 core_div, bus_div, flexbus_div, flash_div;
  
  core_div = 0;
    54fc:	4c35af03 	ldcmi	15, cr10, [r5], #-12
  bus_div = 0;
    5500:	0c000003 	stceq	0, cr0, [r0], {3}
    5504:	00035204 	andeq	r5, r3, r4, lsl #4
  flexbus_div = 0;
    5508:	02a30d00 	adceq	r0, r3, #0
  flash_div = 0;
    550c:	440e0000 	strmi	r0, [lr], #-0
    5510:	70000010 	andvc	r0, r0, r0, lsl r0
  PLL参考时钟范围: 2MHz~4MHz
  PLL参考时钟 = 外部参考时钟(CPU_XTAL_CLK_HZ)/prdiv
  CoreClk = PLL参考时钟 x PLL倍频系数 /OUTDIV1
 *************************************************
 */
  core_clk_mhz = (PllOptionEnum_Type)(core_clk_mhz>200u?200u:core_clk_mhz);
    5514:	3d950310 	ldccc	3, cr0, [r5, #64]	; 0x40
    5518:	00000533 	andeq	r0, r0, r3, lsr r5
   switch(core_clk_mhz)
    551c:	00103808 	andseq	r3, r0, r8, lsl #16
    5520:	3d960300 	ldccc	3, cr0, [r6]
    5524:	00000053 	andeq	r0, r0, r3, asr r0
    5528:	08002302 	stmdaeq	r0, {r1, r8, r9, sp}
    552c:	00000d02 	andeq	r0, r0, r2, lsl #26
    5530:	533d9703 	teqpl	sp, #786432	; 0xc0000
    5534:	02000000 	andeq	r0, r0, #0
    5538:	12080423 	andne	r0, r8, #587202560	; 0x23000000
    553c:	03000003 	movweq	r0, #3
  {
  case PLL_50:
    prdiv = 7u;
    5540:	05333d98 	ldreq	r3, [r3, #-3480]!	; 0xd98
    vdiv = 1u;
    5544:	23020000 	movwcs	r0, #8192	; 0x2000
    5548:	103e0808 	eorsne	r0, lr, r8, lsl #16
    break;
  case PLL_100:
    prdiv = 7u;
    554c:	99030000 	stmdbls	r3, {}	; <UNPREDICTABLE>
    5550:	0000533d 	andeq	r5, r0, sp, lsr r3
    vdiv = 16u;
    5554:	84230300 	strthi	r0, [r3], #-768	; 0x300
    break;
    5558:	031d0820 	tsteq	sp, #2097152	; 0x200000
  case PLL_120:
    prdiv = 4u;
    555c:	9a030000 	bls	c5564 <__etext+0xbc8bc>
    vdiv = 8u;
    5560:	0000983d 	andeq	r9, r0, sp, lsr r8
    5564:	88230300 	stmdahi	r3!, {r8, r9}
    break;
  case PLL_150:
    prdiv = 4u;
    5568:	104f0820 	subne	r0, pc, r0, lsr #16
    556c:	9b030000 	blls	c5574 <__etext+0xbc8cc>
    vdiv = 14u;
    5570:	0000533d 	andeq	r5, r0, sp, lsr r3
    break;
    5574:	8c230300 	stchi	3, cr0, [r3], #-0
  case PLL_180:
    prdiv = 4u;
    5578:	10550820 	subsne	r0, r5, r0, lsr #16
    vdiv = 20u;
    557c:	9c030000 	stcls	0, cr0, [r3], {-0}
    5580:	0000533d 	andeq	r5, r0, sp, lsr r3
    break;
  case PLL_200:
    prdiv = 4u;
    5584:	90230300 	eorls	r0, r3, r0, lsl #6
    5588:	105b0820 	subsne	r0, fp, r0, lsr #16
    vdiv = 24u;
    558c:	9d030000 	stcls	0, cr0, [r3, #-0]
    break;
    5590:	0000533d 	andeq	r5, r0, sp, lsr r3
  default:
    return LPLD_PLL_Setup(PLL_120);
    5594:	94230300 	strtls	r0, [r3], #-768	; 0x300
    5598:	10610820 	rsbne	r0, r1, r0, lsr #16
    559c:	9e030000 	cdpls	0, 0, cr0, cr3, cr0, {0}
  }
  pll_freq = core_clk_mhz * 1;
    55a0:	0000533d 	andeq	r5, r0, sp, lsr r3
  //core_div = 0;
  if((bus_div = (uint8)(core_clk_mhz/BUS_CLK_MHZ - 1u)) == (uint8)-1)
    55a4:	98230300 	stmdals	r3!, {r8, r9}
    55a8:	0a9a0820 	beq	fe687630 <__StackLimit+0xde687630>
    55ac:	9f030000 	svcls	0x00030000
    55b0:	0000a83d 	andeq	sl, r0, sp, lsr r8
    55b4:	9c230300 	stcls	3, cr0, [r3], #-0
    55b8:	0c640820 	stcleq	8, cr0, [r4], #-128	; 0xffffff80
    55bc:	a0030000 	andge	r0, r3, r0
    55c0:	0000533d 	andeq	r5, r0, sp, lsr r3
  {
    bus_div = 0;
    55c4:	a4230300 	strtge	r0, [r3], #-768	; 0x300
    55c8:	0c690820 	stcleq	8, cr0, [r9], #-128	; 0xffffff80
  }
  else if(core_clk_mhz/(bus_div+1) > BUS_CLK_MHZ)
    55cc:	a1030000 	mrsge	r0, (UNDEF: 3)
    55d0:	0000533d 	andeq	r5, r0, sp, lsr r3
    55d4:	a8230300 	stmdage	r3!, {r8, r9}
    55d8:	0c6f0820 	stcleq	8, cr0, [pc], #-128	; 5560 <LPLD_PLL_Setup+0x70>
  {
    bus_div += 1;
    55dc:	a2030000 	andge	r0, r3, #0
    55e0:	0000533d 	andeq	r5, r0, sp, lsr r3
  }
  if((flexbus_div = (core_clk_mhz/FLEXBUS_CLK_MHZ - 1u)) == (uint8)-1)
    55e4:	ac230300 	stcge	3, cr0, [r3], #-0
    55e8:	0c750820 	ldcleq	8, cr0, [r5], #-128	; 0xffffff80
    55ec:	a3030000 	movwge	r0, #12288	; 0x3000
    55f0:	0000533d 	andeq	r5, r0, sp, lsr r3
    55f4:	b0230300 	eorlt	r0, r3, r0, lsl #6
    55f8:	0c7b0820 	ldcleq	8, cr0, [fp], #-128	; 0xffffff80
    55fc:	a4030000 	strge	r0, [r3], #-0
    5600:	0000533d 	andeq	r5, r0, sp, lsr r3
  {
    flexbus_div = 0;
    5604:	b4230300 	strtlt	r0, [r3], #-768	; 0x300
    5608:	0c810820 	stceq	8, cr0, [r1], {32}
  }
  else if(core_clk_mhz/(flexbus_div+1) > FLEXBUS_CLK_MHZ)
    560c:	a5030000 	strge	r0, [r3, #-0]
    5610:	0000533d 	andeq	r5, r0, sp, lsr r3
    5614:	b8230300 	stmdalt	r3!, {r8, r9}
    5618:	0c870820 	stceq	8, cr0, [r7], {32}
  {
    flexbus_div += 1;
    561c:	a6030000 	strge	r0, [r3], -r0
    5620:	0000533d 	andeq	r5, r0, sp, lsr r3
  }
  if((flash_div = (core_clk_mhz/FLASH_CLK_MHZ - 1u)) == (uint8)-1)
    5624:	bc230300 	stclt	3, cr0, [r3], #-0
    5628:	0c8d0820 	stceq	8, cr0, [sp], {32}
    562c:	a7030000 	strge	r0, [r3, -r0]
    5630:	0000533d 	andeq	r5, r0, sp, lsr r3
    5634:	c0230300 	eorgt	r0, r3, r0, lsl #6
    5638:	0fec0820 	svceq	0x00ec0820
    563c:	a8030000 	stmdage	r3, {}	; <UNPREDICTABLE>
    5640:	0000533d 	andeq	r5, r0, sp, lsr r3
  {
    flash_div = 0;
    5644:	c4230300 	strtgt	r0, [r3], #-768	; 0x300
    5648:	0ff40820 	svceq	0x00f40820
  }
  else if(core_clk_mhz/(flash_div+1) > FLASH_CLK_MHZ)
    564c:	a9030000 	stmdbge	r3, {}	; <UNPREDICTABLE>
    5650:	0000533d 	andeq	r5, r0, sp, lsr r3
    5654:	c8230300 	stmdagt	r3!, {r8, r9}
    5658:	0f290820 	svceq	0x00290820
  {
    flash_div += 1;
    565c:	aa030000 	bge	c5664 <__etext+0xbc9bc>
    5660:	0000533d 	andeq	r5, r0, sp, lsr r3
  }
 
  // 这里假设复位后 MCG 模块默认为 FEI 模式 
  
  // 首先移动到 FBE 模式
  MCG_C2 &= ~0x02;
    5664:	cc230300 	stcgt	3, cr0, [r3], #-0
    5668:	0f2f0820 	svceq	0x002f0820
    566c:	ab030000 	blge	c5674 <__etext+0xbc9cc>
    5670:	0000533d 	andeq	r5, r0, sp, lsr r3
    5674:	d0230300 	eorle	r0, r3, r0, lsl #6
    5678:	0bcb0820 	bleq	ff2c7700 <__StackLimit+0xdf2c7700>
    567c:	ac030000 	stcge	0, cr0, [r3], {-0}
  //编码1 RANGE = 1
  MCG_C2 |= MCG_C2_RANGE(1);
    5680:	0000533d 	andeq	r5, r0, sp, lsr r3
    5684:	d4230300 	strtle	r0, [r3], #-768	; 0x300
    5688:	0e090820 	cdpeq	8, 0, cr0, cr9, cr0, {1}
    568c:	ad030000 	stcge	0, cr0, [r3, #-0]
    5690:	0000533d 	andeq	r5, r0, sp, lsr r3
    5694:	d8230300 	stmdale	r3!, {r8, r9}
    5698:	0e0f0820 	cdpeq	8, 0, cr0, cr15, cr0, {1}

  // 振荡器初始化完成后,释放锁存状态下的 oscillator 和 GPIO 
  SIM_SCGC4 |= SIM_SCGC4_LLWU_MASK;
    569c:	ae030000 	cdpge	0, 0, cr0, cr3, cr0, {0}
    56a0:	0000533d 	andeq	r5, r0, sp, lsr r3
    56a4:	dc230300 	stcle	3, cr0, [r3], #-0
    56a8:	0bd00820 	bleq	ff407730 <__StackLimit+0xdf407730>
    56ac:	af030000 	svcge	0x00030000
    56b0:	0000533d 	andeq	r5, r0, sp, lsr r3
    56b4:	e0230300 	eor	r0, r3, r0, lsl #6
    56b8:	03310820 	teqeq	r1, #2097152	; 0x200000
    56bc:	b0030000 	andlt	r0, r3, r0
    56c0:	0000983d 	andeq	r9, r0, sp, lsr r8
//  LLWU->CS |= LLWU_CS_ACKISO_MASK;
  
  // 选择外部 oscilator 、参考分频器 and 清零 IREFS 启动外部osc
  // CLKS=2, FRDIV=7, IRCLKEN=0, IREFSTEN=0
  // 分频值预留我也不值到分频到多少了...
  MCG_C1 = MCG_C1_CLKS(2) | MCG_C1_FRDIV(7);  
    56c4:	e4230300 	strt	r0, [r3], #-768	; 0x300
    56c8:	0e9f0820 	cdpeq	8, 9, cr0, cr15, cr0, {1}
    56cc:	b1030000 	mrslt	r0, (UNDEF: 3)
  
  while (MCG_S & MCG_S_IREFST_MASK){}; // 等待参考时钟清零
    56d0:	0000533d 	andeq	r5, r0, sp, lsr r3
    56d4:	e8230300 	stmda	r3!, {r8, r9}
    56d8:	434d0920 	movtmi	r0, #55584	; 0xd920
    56dc:	b2030052 	andlt	r0, r3, #82	; 0x52
    56e0:	0000533d 	andeq	r5, r0, sp, lsr r3
    56e4:	ec230300 	stc	3, cr0, [r3], #-0
  
  while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2){}; // 等待时钟状态显示为外部参考时钟(ext ref clk)
    56e8:	2c050020 	stccs	0, cr0, [r5], {32}
    56ec:	44000000 	strmi	r0, [r0], #-0
    56f0:	0f000005 	svceq	0x00000005
    56f4:	00000081 	andeq	r0, r0, r1, lsl #1
    56f8:	0b000ffb 	bleq	96ec <__etext+0xa44>
    56fc:	00000f47 	andeq	r0, r0, r7, asr #30
  
  // 进入FBE模式
  // 配置 PLL 参考分频器, PLLCLKEN=0, PLLSTEN=0, PRDIV=5
  // 用晶振频率来选择 PRDIV 值. 仅在有频率晶振的时候支持
  // 产生 2MHz 的参考时钟给 PLL.
  MCG_C5 = MCG_C5_PRDIV(prdiv); // 设置 PLL 匹配晶振的参考分频数 
    5700:	503db303 	eorspl	fp, sp, r3, lsl #6
    5704:	0c000005 	stceq	0, cr0, [r0], {5}
    5708:	00055604 	andeq	r5, r5, r4, lsl #12
    570c:	03570d00 	cmpeq	r7, #0
    5710:	83030000 	movwhi	r0, #12288	; 0x3000
  
  // 确保MCG_C6处于复位状态,禁止LOLIE、PLL、和时钟控制器,清PLL VCO分频器
  MCG_C6 = 0x0;
    5714:	04000004 	streq	r0, [r0], #-4
    5718:	0000371b 	andeq	r3, r0, fp, lsl r7
    571c:	12e00300 	rscne	r0, r0, #0
  
  //设置系统时钟分频系数
  LPLD_Set_SYS_DIV(core_div, bus_div, flexbus_div, flash_div);  
    5720:	1c040000 	stcne	0, cr0, [r4], {-0}
    5724:	00000045 	andeq	r0, r0, r5, asr #32
    5728:	001d7b03 	andseq	r7, sp, r3, lsl #22
 // LPLD_Set_SYS_DIV(0, 1, 4, 4);  
  
  //设置倍频系数
  MCG_C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV(vdiv); 
    572c:	5e1d0400 	cfmulspl	mvf0, mvf13, mvf0
    5730:	03000000 	movweq	r0, #0
    5734:	00001d7a 	andeq	r1, r0, sl, ror sp
    5738:	05872904 	streq	r2, [r7, #2308]	; 0x904
    573c:	710d0000 	mrsvc	r0, (UNDEF: 13)
    5740:	02000005 	andeq	r0, r0, #5
  
  while (!(MCG_S & MCG_S_PLLST_MASK)){}; // wait for PLL status bit to set
    5744:	06690404 	strbteq	r0, [r9], -r4, lsl #8
    5748:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
    574c:	000a8704 	andeq	r8, sl, r4, lsl #14
    5750:	0dc80300 	stcleq	3, cr0, [r8]
    5754:	2e040000 	cdpcs	0, 0, cr0, cr4, cr0, {0}
    5758:	00000037 	andeq	r0, r0, r7, lsr r0
  
  while (!(MCG_S & MCG_S_LOCK_MASK)){}; // Wait for LOCK bit to set
    575c:	000f3510 	andeq	r3, pc, r0, lsl r5	; <UNPREDICTABLE>
    5760:	0f050100 	svceq	0x00050100
    5764:	0000083c 	andeq	r0, r0, ip, lsr r8
    5768:	000cc211 	andeq	ip, ip, r1, lsl r2
    576c:	c7110000 	ldrgt	r0, [r1, -r0]
  
  // 已经进入PBE模式
  
  // Transition into PEE by setting CLKS to 0
  // CLKS=0, FRDIV=3, IREFS=0, IRCLKEN=0, IREFSTEN=0
  MCG_C1 &= ~MCG_C1_CLKS_MASK;
    5770:	0100000c 	tsteq	r0, ip
    5774:	000ccc11 	andeq	ip, ip, r1, lsl ip
    5778:	d1110200 	tstle	r1, r0, lsl #4
    577c:	0300000c 	movweq	r0, #12
    5780:	000cd611 	andeq	sp, ip, r1, lsl r6
    5784:	db110400 	blle	44678c <__etext+0x43dae4>
    5788:	0500000c 	streq	r0, [r0, #-12]
  
  // Wait for clock status bits to update
  while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3){};
    578c:	000ce011 	andeq	lr, ip, r1, lsl r0
    5790:	e5110600 	ldr	r0, [r1, #-1536]	; 0x600
    5794:	0700000c 	streq	r0, [r0, -ip]
    5798:	000cea11 	andeq	lr, ip, r1, lsl sl
    579c:	ef110800 	svc	0x00110800
    57a0:	0900000c 	stmdbeq	r0, {r2, r3}
    57a4:	000e5f11 	andeq	r5, lr, r1, lsl pc
  
  // 已经进入PEE模式
  
  return pll_freq;
} 
    57a8:	65110a00 	ldrvs	r0, [r1, #-2560]	; 0xa00
    57ac:	0b00000e 	bleq	57ec <LPLD_Set_SYS_DIV+0x38>
    57b0:	000e6b11 	andeq	r6, lr, r1, lsl fp
 *
 * 参数:
 *    outdiv1~outdiv4--分别为core, bus, FlexBus, Flash时钟分频系数
 */
void LPLD_Set_SYS_DIV(uint32 outdiv1, uint32 outdiv2, uint32 outdiv3, uint32 outdiv4)
{
    57b4:	71110c00 	tstvc	r1, r0, lsl #24
    57b8:	0d00000e 	stceq	0, cr0, [r0, #-56]	; 0xffffffc8
    57bc:	000e7711 	andeq	r7, lr, r1, lsl r7
    57c0:	7d110e00 	ldcvc	14, cr0, [r1, #-0]
  uint32 temp_reg;
  uint8 i;
  
  temp_reg = FMC_PFAPR; // 备份 FMC_PFAPR 寄存器
    57c4:	0f00000e 	svceq	0x0000000e
    57c8:	000e8311 	andeq	r8, lr, r1, lsl r3
    57cc:	89111000 	ldmdbhi	r1, {ip}
  
  // 设置 M0PFD 到 M7PFD 为 1 禁用预先读取
  FMC_PFAPR |= FMC_PFAPR_M7PFD_MASK | FMC_PFAPR_M6PFD_MASK | FMC_PFAPR_M5PFD_MASK
    57d0:	1100000e 	tstne	r0, lr
    57d4:	000e8f11 	andeq	r8, lr, r1, lsl pc
    57d8:	7d111200 	lfmvc	f1, 4, [r1, #-0]
    57dc:	1300000b 	movwne	r0, #11
    57e0:	000efa11 	andeq	pc, lr, r1, lsl sl	; <UNPREDICTABLE>
    57e4:	00111800 	andseq	r1, r1, r0, lsl #16
             | FMC_PFAPR_M4PFD_MASK | FMC_PFAPR_M3PFD_MASK | FMC_PFAPR_M2PFD_MASK
             | FMC_PFAPR_M1PFD_MASK | FMC_PFAPR_M0PFD_MASK;
  
  // 设置时钟分频为期望值  
  SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(outdiv1) | SIM_CLKDIV1_OUTDIV2(outdiv2) 
    57e8:	1900000f 	stmdbne	r0, {r0, r1, r2, r3}
    57ec:	000f0611 	andeq	r0, pc, r1, lsl r6	; <UNPREDICTABLE>
    57f0:	0c111a00 	ldceq	10, cr1, [r1], {-0}
    57f4:	1b00000f 	blne	5838 <LPLD_Set_SYS_DIV+0x84>
    57f8:	000f1211 	andeq	r1, pc, r1, lsl r2	; <UNPREDICTABLE>
    57fc:	18111c00 	ldmdane	r1, {sl, fp, ip}
              | SIM_CLKDIV1_OUTDIV3(outdiv3) | SIM_CLKDIV1_OUTDIV4(outdiv4);
    5800:	1d00000f 	stcne	0, cr0, [r0, #-60]	; 0xffffffc4
    5804:	000d5911 	andeq	r5, sp, r1, lsl r9
    5808:	5e112000 	cdppl	0, 1, cr2, cr1, cr0, {0}
    580c:	2100000d 	tstcs	r0, sp
    5810:	000d6311 	andeq	r6, sp, r1, lsl r3
    5814:	68112200 	ldmdavs	r1, {r9, sp}
  FMC_PFAPR |= FMC_PFAPR_M7PFD_MASK | FMC_PFAPR_M6PFD_MASK | FMC_PFAPR_M5PFD_MASK
             | FMC_PFAPR_M4PFD_MASK | FMC_PFAPR_M3PFD_MASK | FMC_PFAPR_M2PFD_MASK
             | FMC_PFAPR_M1PFD_MASK | FMC_PFAPR_M0PFD_MASK;
  
  // 设置时钟分频为期望值  
  SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(outdiv1) | SIM_CLKDIV1_OUTDIV2(outdiv2) 
    5818:	2300000d 	movwcs	r0, #13
    581c:	000d6d11 	andeq	r6, sp, r1, lsl sp
    5820:	72112400 	andsvc	r2, r1, #0
              | SIM_CLKDIV1_OUTDIV3(outdiv3) | SIM_CLKDIV1_OUTDIV4(outdiv4);

  // 延时一小段时间等待改变
  for (i = 0 ; i < outdiv4 ; i++)
    5824:	2500000d 	strcs	r0, [r0, #-13]
    5828:	000d7711 	andeq	r7, sp, r1, lsl r7
    582c:	7c112600 	ldcvc	6, cr2, [r1], {-0}
    5830:	2700000d 	strcs	r0, [r0, -sp]
    5834:	000d8111 	andeq	r8, sp, r1, lsl r1
    5838:	86112800 	ldrhi	r2, [r1], -r0, lsl #16
  {}
  
  FMC_PFAPR = temp_reg; // 回复原先的 FMC_PFAPR 寄存器值
    583c:	2900000d 	stmdbcs	r0, {r0, r2, r3}
    5840:	0010bb11 	andseq	fp, r0, r1, lsl fp
    5844:	c1112a00 	tstgt	r1, r0, lsl #20
  
  return;
} // set_sys_dividers
    5848:	2b000010 	blcs	5890 <LPLD_PDB_Init+0x3c>
    584c:	0010c711 	andseq	ip, r0, r1, lsl r7
    5850:	cd113000 	ldcgt	0, cr3, [r1, #-0]
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_PDB_Init(PDB_InitTypeDef pdb_init_struct)
{
    5854:	31000010 	tstcc	r0, r0, lsl r0
    5858:	0010d311 	andseq	sp, r0, r1, lsl r3
    585c:	d9113200 	ldmdble	r1, {r9, ip, sp}
    5860:	33000010 	movwcc	r0, #16
  uint32 us = pdb_init_struct.PDB_CounterPeriodUs
    5864:	000b8311 	andeq	r8, fp, r1, lsl r3
            + pdb_init_struct.PDB_CounterPeriodMs*1000
            + pdb_init_struct.PDB_CounterPeriodS*1000000;
    5868:	89113400 	ldmdbhi	r1, {sl, ip, sp}
    586c:	3500000b 	strcc	r0, [r0, #-11]
    5870:	000b8f11 	andeq	r8, fp, r1, lsl pc
 *    1--óɹ
 */
uint8 LPLD_PDB_Init(PDB_InitTypeDef pdb_init_struct)
{
  uint32 us = pdb_init_struct.PDB_CounterPeriodUs
            + pdb_init_struct.PDB_CounterPeriodMs*1000
    5874:	95113600 	ldrls	r3, [r1, #-1536]	; 0x600
    5878:	3700000b 	strcc	r0, [r0, -fp]
    587c:	000dd011 	andeq	sp, sp, r1, lsl r0
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_PDB_Init(PDB_InitTypeDef pdb_init_struct)
{
  uint32 us = pdb_init_struct.PDB_CounterPeriodUs
    5880:	d5113c00 	ldrle	r3, [r1, #-3072]	; 0xc00
            + pdb_init_struct.PDB_CounterPeriodMs*1000
            + pdb_init_struct.PDB_CounterPeriodS*1000000;
  uint32 delayus = pdb_init_struct.PDB_DelayUs
    5884:	3d00000d 	stccc	0, cr0, [r0, #-52]	; 0xffffffcc
            + pdb_init_struct.PDB_DelayMs*1000
            + pdb_init_struct.PDB_DelayS*1000000;
    5888:	000dda11 	andeq	sp, sp, r1, lsl sl
    588c:	df113e00 	svcle	0x00113e00
    5890:	3f00000d 	svccc	0x0000000d
{
  uint32 us = pdb_init_struct.PDB_CounterPeriodUs
            + pdb_init_struct.PDB_CounterPeriodMs*1000
            + pdb_init_struct.PDB_CounterPeriodS*1000000;
  uint32 delayus = pdb_init_struct.PDB_DelayUs
            + pdb_init_struct.PDB_DelayMs*1000
    5894:	000de411 	andeq	lr, sp, r1, lsl r4
    5898:	1100c000 	mrsne	ip, (UNDEF: 0)
    589c:	00000de9 	andeq	r0, r0, r9, ror #27
uint8 LPLD_PDB_Init(PDB_InitTypeDef pdb_init_struct)
{
  uint32 us = pdb_init_struct.PDB_CounterPeriodUs
            + pdb_init_struct.PDB_CounterPeriodMs*1000
            + pdb_init_struct.PDB_CounterPeriodS*1000000;
  uint32 delayus = pdb_init_struct.PDB_DelayUs
    58a0:	ee1100c1 	cdp	0, 1, cr0, cr1, cr1, {6}
            + pdb_init_struct.PDB_DelayMs*1000
            + pdb_init_struct.PDB_DelayS*1000000;
  uint8 loadmode = pdb_init_struct.PDB_LoadModeSel;
    58a4:	c200000d 	andgt	r0, r0, #13
    58a8:	0df31100 	ldfeqe	f1, [r3]
  uint8 trriger = pdb_init_struct.PDB_TriggerInputSourceSel;
    58ac:	00c30000 	sbceq	r0, r3, r0
  uint32 bus_clk = g_bus_clock/1000000;
    58b0:	000e5a11 	andeq	r5, lr, r1, lsl sl
    58b4:	1100c400 	tstne	r0, r0, lsl #8
    58b8:	00000df8 	strdeq	r0, [r0], -r8
    58bc:	0b1100c5 	bleq	445bd8 <__etext+0x43cf30>
    58c0:	c600000d 	strgt	r0, [r0], -sp
    58c4:	0d111100 	ldfeqs	f1, [r1, #-0]
    58c8:	00c70000 	sbceq	r0, r7, r0
  uint8 i,j;
  
  //
  //ASSERT( loadmode <= LOADMODE_3 );       //ģʽѡ
  //ASSERT( trriger <= TRIGGER_SOFTWARE );  //Դѡ
  if ((loadmode > LOADMODE_3) || (trriger > TRIGGER_SOFTWARE))
    58cc:	000d1711 	andeq	r1, sp, r1, lsl r7
    58d0:	1100c800 	tstne	r0, r0, lsl #16
    58d4:	00000d1d 	andeq	r0, r0, sp, lsl sp
        return 0;
    58d8:	e91100c9 	ldmdb	r1, {r0, r3, r6, r7}
    58dc:	ca00000e 	bgt	591c <LPLD_PDB_Init+0xc8>
   = (prescaler*mult*mod)/bus_clk
 *************************************************
 */
  
  //ļԶ趨prescalermultmodֵ
  for(i=0; i<4; i++)
    58e0:	0eef1100 	cdpeq	1, 14, cr1, cr15, cr0, {0}
    58e4:	00cb0000 	sbceq	r0, fp, r0
  {
    mult = i;
    58e8:	000d4111 	andeq	r4, sp, r1, lsl r1
    for(j=0; j<8; j++)
    58ec:	1100cc00 	tstne	r0, r0, lsl #24
    58f0:	00000d47 	andeq	r0, r0, r7, asr #26
    {
      prescaler = j;
    58f4:	4d1100cd 	ldcmi	0, cr0, [r1, #-820]	; 0xfffffccc
      mod = (bus_clk*us)/((1<<j)*pdb_sc_mults[i]);
    58f8:	ce00000d 	cdpgt	0, 0, cr0, cr0, cr13, {0}
    58fc:	0d531100 	ldfeqe	f1, [r3, #-0]
    5900:	00cf0000 	sbceq	r0, pc, r0
    5904:	000e1511 	andeq	r1, lr, r1, lsl r5
    5908:	1100dc00 	tstne	r0, r0, lsl #24
    590c:	00000e1a 	andeq	r0, r0, sl, lsl lr
    5910:	1f1100dd 	svcne	0x001100dd
    5914:	de00000e 	cdple	0, 0, cr0, cr0, cr14, {0}
      if(mod <= 0xFFFFu)
    5918:	0e241100 	sufeqs	f1, f4, f0
    591c:	00df0000 	sbcseq	r0, pc, r0
    5920:	000e2911 	andeq	r2, lr, r1, lsl r9
  
  //ļԶ趨prescalermultmodֵ
  for(i=0; i<4; i++)
  {
    mult = i;
    for(j=0; j<8; j++)
    5924:	1100e000 	mrsne	lr, (UNDEF: 0)
    5928:	00000e2e 	andeq	r0, r0, lr, lsr #28
    592c:	331100e1 	tstcc	r1, #225	; 0xe1
    5930:	e200000e 	and	r0, r0, #14
      prescaler = j;
      mod = (bus_clk*us)/((1<<j)*pdb_sc_mults[i]);
      if(mod <= 0xFFFFu)
        break;
    }
    if(mod <= 0xFFFFu)
    5934:	0e381100 	rsfeqe	f1, f0, f0
    5938:	00e30000 	rsceq	r0, r3, r0
    593c:	000e3d11 	andeq	r3, lr, r1, lsl sp
      break;
    else if(i == 3)
    5940:	1100e400 	tstne	r0, r0, lsl #8
      return 0;         //PDBõĹС
    5944:	00000e42 	andeq	r0, r0, r2, asr #28
    5948:	7f1100e5 	svcvc	0x001100e5
   = (prescaler*mult*mod)/bus_clk
 *************************************************
 */
  
  //ļԶ趨prescalermultmodֵ
  for(i=0; i<4; i++)
    594c:	e600000f 	str	r0, [r0], -pc
    5950:	0f851100 	svceq	0x00851100
    5954:	00e70000 	rsceq	r0, r7, r0
    5958:	000f8b11 	andeq	r8, pc, r1, lsl fp	; <UNPREDICTABLE>
    else if(i == 3)
      return 0;         //PDBõĹС
  }
  
  //ʹPDBʱ
  SIM_SCGC6 |= SIM_SCGC6_PDB_MASK;
    595c:	1100e800 	tstne	r0, r0, lsl #16
    5960:	00000f91 	muleq	r0, r1, pc	; <UNPREDICTABLE>
    5964:	931100e9 	tstls	r1, #233	; 0xe9
    5968:	ea00000d 	b	59a4 <LPLD_PDB_Init+0x150>
    596c:	0d991100 	ldfeqs	f1, [r9]
    5970:	00eb0000 	rsceq	r0, fp, r0
    5974:	000ea711 	andeq	sl, lr, r1, lsl r7
    5978:	1100fc00 	tstne	r0, r0, lsl #24
    597c:	00000eac 	andeq	r0, r0, ip, lsr #29
    5980:	b11100fd 	ldrshlt	r0, [r1, -sp]
  
  //ʼSCĴ
  PDB0_SC = 0x00;
    5984:	fe00000e 	cdp2	0, 0, cr0, cr0, cr14, {0}
    5988:	0eb61100 	frdeqs	f1, f6, f0
    598c:	00ff0000 	rscseq	r0, pc, r0
    5990:	000ebb11 	andeq	fp, lr, r1, lsl fp
  //ʹPDB
  PDB0_SC |= PDB_SC_PDBEN_MASK;
    5994:	11018000 	mrsne	r8, (UNDEF: 1)
    5998:	00000ec0 	andeq	r0, r0, r0, asr #29
    599c:	c5110181 	ldrgt	r0, [r1, #-385]	; 0x181
    59a0:	8200000e 	andhi	r0, r0, #14
    59a4:	0eca1101 	poleqe	f1, f2, f1
    59a8:	01830000 	orreq	r0, r3, r0
  PDB0_SC |= PDB_SC_MULT(mult);
    59ac:	000ecf11 	andeq	ip, lr, r1, lsl pc
    59b0:	11018400 	tstne	r1, r0, lsl #8
    59b4:	00000ed4 	ldrdeq	r0, [r0], -r4
    59b8:	dc110185 	ldfles	f0, [r1], {133}	; 0x85
    59bc:	8600000b 	strhi	r0, [r0], -fp
    59c0:	0be21101 	bleq	ff889dcc <__StackLimit+0xdf889dcc>
    59c4:	01870000 	orreq	r0, r7, r0
    59c8:	000c3911 	andeq	r3, ip, r1, lsl r9
  PDB0_SC |= PDB_SC_PRESCALER(prescaler);
    59cc:	11018800 	tstne	r1, r0, lsl #16
    59d0:	00000cfc 	strdeq	r0, [r0], -ip
    59d4:	3f110194 	svccc	0x00110194
    59d8:	9500000c 	strls	r0, [r0, #-12]
    59dc:	0c451101 	stfeqe	f1, [r5], {1}
    59e0:	01960000 	orrseq	r0, r6, r0
    59e4:	000c4b11 	andeq	r4, ip, r1, lsl fp
    59e8:	11019700 	tstne	r1, r0, lsl #14
  //MODIDLYCHnDLYmINTxPOyDLYĴļģʽ
  PDB0_SC |= PDB_SC_LDMOD(loadmode); 
    59ec:	00000c51 	andeq	r0, r0, r1, asr ip
    59f0:	03000198 	movweq	r0, #408	; 0x198
    59f4:	00001067 	andeq	r1, r0, r7, rrx
    59f8:	05a54505 	streq	r4, [r5, #1285]!	; 0x505
    59fc:	040c0000 	streq	r0, [ip], #-0
    5a00:	0000084d 	andeq	r0, r0, sp, asr #16
    5a04:	01020112 	tsteq	r2, r2, lsl r1
    5a08:	00071208 	andeq	r1, r7, r8, lsl #4
  //ôԴ
  PDB0_SC |= PDB_SC_TRGSEL(trriger);
    5a0c:	1fd61000 	svcne	0x00d61000
    5a10:	06010000 	streq	r0, [r1], -r0
    5a14:	00089f13 	andeq	r9, r8, r3, lsl pc
    5a18:	1e721100 	rpwnes	f1, f2, f0
    5a1c:	11000000 	mrsne	r0, (UNDEF: 0)
    5a20:	00001e7a 	andeq	r1, r0, sl, ror lr
    5a24:	1e821101 	rmfnes	f1, f2, f1
    5a28:	11020000 	mrsne	r0, (UNDEF: 2)
  
  //Ƿʹģʽ
  if(pdb_init_struct.PDB_ContinuousModeEnable == TRUE)
    5a2c:	00001e8a 	andeq	r1, r0, sl, lsl #29
    5a30:	1e921103 	fmlnes	f1, f2, f3
    PDB0_SC |= PDB_SC_CONT_MASK;
    5a34:	11040000 	mrsne	r0, (UNDEF: 4)
    5a38:	00001e9a 	muleq	r0, sl, lr
    5a3c:	1ea21105 	fdvnes	f1, f2, f5
    5a40:	11060000 	mrsne	r0, (UNDEF: 6)
    5a44:	00001eaa 	andeq	r1, r0, sl, lsr #29
    5a48:	1fa51107 	svcne	0x00a51107
  else
    PDB0_SC &= ~(PDB_SC_CONT_MASK);
    5a4c:	11080000 	mrsne	r0, (UNDEF: 8)
    5a50:	00001fad 	andeq	r1, r0, sp, lsr #31
    5a54:	e1030009 	tst	r3, r9
    5a58:	0600001f 			; <UNDEFINED> instruction: 0x0600001f
    5a5c:	0008561f 	andeq	r5, r8, pc, lsl r6
    5a60:	1de20300 	stclne	3, cr0, [r2]
  
  //ǷʹDMA
  if(pdb_init_struct.PDB_DmaEnable == TRUE)
    5a64:	43060000 	movwmi	r0, #24576	; 0x6000
    5a68:	00000847 	andeq	r0, r0, r7, asr #16
    PDB0_SC |= PDB_SC_DMAEN_MASK;
    5a6c:	46061c13 			; <UNDEFINED> instruction: 0x46061c13
    5a70:	0000094a 	andeq	r0, r0, sl, asr #18
    5a74:	001fb514 	andseq	fp, pc, r4, lsl r5	; <UNPREDICTABLE>
    5a78:	7c500600 	mrrcvc	6, 0, r0, r0, cr0	; <UNPREDICTABLE>
    5a7c:	02000002 	andeq	r0, r0, #2
    5a80:	21140023 	tstcs	r4, r3, lsr #32
    5a84:	0600001c 			; <UNDEFINED> instruction: 0x0600001c
  else
    PDB0_SC &= ~(PDB_SC_DMAEN_MASK);
    5a88:	00055b5c 	andeq	r5, r5, ip, asr fp
    5a8c:	04230200 	strteq	r0, [r3], #-512	; 0x200
    5a90:	001e4c14 	andseq	r4, lr, r4, lsl ip
    5a94:	71660600 	cmnvc	r6, r0, lsl #12
    5a98:	02000005 	andeq	r0, r0, #5
    5a9c:	03140823 	tsteq	r4, #2293760	; 0x230000
  
  if(pdb_init_struct.PDB_Isr != NULL)
    5aa0:	0600001e 			; <UNDEFINED> instruction: 0x0600001e
  {
    PDB_ISR[0] = pdb_init_struct.PDB_Isr;
    5aa4:	00057173 	andeq	r7, r5, r3, ror r1
    5aa8:	0c230200 	sfmeq	f0, 4, [r3], #-0
    5aac:	001c9214 	andseq	r9, ip, r4, lsl r2
    //ǷʹPDBж
    if(pdb_init_struct.PDB_IntEnable == TRUE)
    5ab0:	5b7f0600 	blpl	1fc72b8 <__etext+0x1fbe610>
    5ab4:	02000005 	andeq	r0, r0, #5
      PDB0_SC |= PDB_SC_PDBIE_MASK;
    5ab8:	f9141023 			; <UNDEFINED> instruction: 0xf9141023
    5abc:	0600001e 			; <UNDEFINED> instruction: 0x0600001e
    5ac0:	00055b89 	andeq	r5, r5, r9, lsl #23
    5ac4:	11230200 	teqne	r3, r0, lsl #4
    5ac8:	001c8714 	andseq	r8, ip, r4, lsl r7
    5acc:	5b940600 	blpl	fe5072d4 <__StackLimit+0xde5072d4>
    5ad0:	02000005 	andeq	r0, r0, #5
    else
      PDB0_SC &= ~(PDB_SC_PDBIE_MASK);
    5ad4:	f8141223 			; <UNDEFINED> instruction: 0xf8141223
    5ad8:	0600001f 			; <UNDEFINED> instruction: 0x0600001f
    5adc:	00055ba5 	andeq	r5, r5, r5, lsr #23
    5ae0:	13230200 	teqne	r3, #0
    5ae4:	001c6814 	andseq	r6, ip, r4, lsl r8
    5ae8:	9aaf0600 	bls	febc72f0 <__StackLimit+0xdebc72f0>
  }
  
  if(pdb_init_struct.PDB_SeqErrIsr != NULL)
    5aec:	02000005 	andeq	r0, r0, #5
  {
    PDB_SE_ISR[0] = pdb_init_struct.PDB_SeqErrIsr;
    5af0:	9d141423 	cfldrsls	mvf1, [r4, #-140]	; 0xffffff74
    5af4:	0600001f 			; <UNDEFINED> instruction: 0x0600001f
    5af8:	0008aab9 			; <UNDEFINED> instruction: 0x0008aab9
    //ǷʹPDBдж
    if(pdb_init_struct.PDB_SeqErrIntEnable == TRUE)
    5afc:	18230200 	stmdane	r3!, {r9}
    5b00:	1d350300 	ldcne	3, cr0, [r5, #-0]
      PDB0_SC |= PDB_SC_PDBEIE_MASK;
    5b04:	bb060000 	bllt	185b0c <__etext+0x17ce64>
    5b08:	000008b5 			; <UNDEFINED> instruction: 0x000008b5
    5b0c:	1f4a0115 	svcne	0x004a0115
    5b10:	30010000 	andcc	r0, r1, r0
    5b14:	00055b01 	andeq	r5, r5, r1, lsl #22
    5b18:	0030c000 	eorseq	ip, r0, r0
    5b1c:	0032ae00 	eorseq	sl, r2, r0, lsl #28
    else
      PDB0_SC &= ~(PDB_SC_PDBEIE_MASK);
    5b20:	000cdc00 	andeq	sp, ip, r0, lsl #24
    5b24:	099c0100 	ldmibeq	ip, {r8}
    5b28:	c3160000 	tstgt	r6, #0
    5b2c:	0100001f 	tsteq	r0, pc, lsl r0
    5b30:	00094a30 	andeq	r4, r9, r0, lsr sl
    5b34:	70910200 	addsvc	r0, r1, r0, lsl #4
  }
  
  //PDBжʱʱ
  if( delayus <= us )
    5b38:	001cf217 	andseq	pc, ip, r7, lsl r2	; <UNPREDICTABLE>
    5b3c:	5b320100 	blpl	c85f44 <__etext+0xc7d29c>
  {
    temp = (float32)mod/(float32)us;
    5b40:	02000005 	andeq	r0, r0, #5
    5b44:	69186791 	ldmdbvs	r8, {r0, r4, r7, r8, r9, sl, sp, lr}
    5b48:	5b320100 	blpl	c85f50 <__etext+0xc7d2a8>
    5b4c:	02000005 	andeq	r0, r0, #5
    5b50:	15006691 	strne	r6, [r0, #-1681]	; 0x691
    5b54:	001ec201 	andseq	ip, lr, r1, lsl #4
    5b58:	017b0100 	cmneq	fp, r0, lsl #2
    PDB0_IDLY = (uint32)(delayus*temp);
    5b5c:	0000055b 	andeq	r0, r0, fp, asr r5
    5b60:	000032b0 			; <UNDEFINED> instruction: 0x000032b0
    5b64:	000033cc 	andeq	r3, r0, ip, asr #7
    5b68:	00000d20 	andeq	r0, r0, r0, lsr #26
    5b6c:	0009c901 	andeq	ip, r9, r1, lsl #18
    5b70:	1fc31600 	svcne	0x00c31600
    5b74:	7b010000 	blvc	45b7c <__etext+0x3ced4>
    5b78:	0000094a 	andeq	r0, r0, sl, asr #18
    5b7c:	00709102 	rsbseq	r9, r0, r2, lsl #2
  }
  
  //ֵ
  PDB0_SC |= PDB_SC_LDOK_MASK;
    5b80:	1c4d0115 	stfnee	f0, [sp], {21}
    5b84:	c1010000 	mrsgt	r0, (UNDEF: 1)
    5b88:	00055b01 	andeq	r5, r5, r1, lsl #22
    5b8c:	0033cc00 	eorseq	ip, r3, r0, lsl #24
    5b90:	00347200 	eorseq	r7, r4, r0, lsl #4
    5b94:	000d6400 	andeq	r6, sp, r0, lsl #8
  
  return 1;
    5b98:	0a490100 	beq	1245fa0 <__etext+0x123d2f8>
}
    5b9c:	9d160000 	ldcls	0, cr0, [r6, #-0]
    5ba0:	0100001d 	tsteq	r0, sp, lsl r0
    5ba4:	00027cc1 	andeq	r7, r2, r1, asr #25
    5ba8:	6c910200 	lfmvs	f0, 4, [r1], {0}
 *
 * :
 *    
 */
void LPLD_PDB_Deinit(void)
{
    5bac:	6e686319 	mcrvs	3, 3, r6, cr8, cr9, {0}
 
  PDB0_CH0C1 = 0;
    5bb0:	9fc10100 	svcls	0x00c10100
    5bb4:	02000008 	andeq	r0, r0, #8
    5bb8:	82166b91 	andshi	r6, r6, #148480	; 0x24400
    5bbc:	0100001d 	tsteq	r0, sp, lsl r0
  PDB0_CH1C1 = 0;
    5bc0:	000571c1 	andeq	r7, r5, r1, asr #3
    5bc4:	64910200 	ldrvs	r0, [r1], #512	; 0x200
    5bc8:	6e697019 	mcrvs	0, 3, r7, cr9, cr9, {0}
  
  PDB0_DACINTC0 = 0;
    5bcc:	3cc10100 	stfcce	f0, [r1], {0}
    5bd0:	02000008 	andeq	r0, r0, #8
    5bd4:	03166a91 	tsteq	r6, #593920	; 0x91000
    5bd8:	01000020 	tsteq	r0, r0, lsr #32
  PDB0_DACINTC1 = 0;
    5bdc:	00055bc1 	andeq	r5, r5, r1, asr #23
    5be0:	00910200 	addseq	r0, r1, r0, lsl #4
    5be4:	00766318 	rsbseq	r6, r6, r8, lsl r3
    5be8:	0571c301 	ldrbeq	ip, [r1, #-769]!	; 0x301
  
  PDB0_SC = 0;
    5bec:	91020000 	mrsls	r0, (UNDEF: 2)
    5bf0:	6f6d1874 	svcvs	0x006d1874
    5bf4:	c4010064 	strgt	r0, [r1], #-100	; 0x64
    5bf8:	0000057c 	andeq	r0, r0, ip, ror r5
  
  //PDBʱ
  SIM_SCGC6 &= ~(SIM_SCGC6_PDB_MASK);
    5bfc:	00709102 	rsbseq	r9, r0, r2, lsl #2
    5c00:	1dca011a 	stfnee	f0, [sl, #104]	; 0x68
    5c04:	fb010000 	blx	45c0e <__etext+0x3cf66>
    5c08:	00055b01 	andeq	r5, r5, r1, lsl #22
    5c0c:	00347400 	eorseq	r7, r4, r0, lsl #8
    5c10:	0034fc00 	eorseq	pc, r4, r0, lsl #24
    5c14:	000d9c00 	andeq	r9, sp, r0, lsl #24
    5c18:	0aad0100 	beq	feb46020 <__StackLimit+0xdeb46020>
    5c1c:	9d160000 	ldcls	0, cr0, [r6, #-0]
    5c20:	0100001d 	tsteq	r0, sp, lsl r0
  
  disable_irq(INT_PDB0 - 16);
    5c24:	00027cfb 	strdeq	r7, [r2], -fp
    5c28:	6c910200 	lfmvs	f0, 4, [r1], {0}
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_PDB_AdcTriggerCfg(ADC_MemMapPtr adcx, uint32 cfg, uint16 delay)
{
    5c2c:	6e686319 	mcrvs	3, 3, r6, cr8, cr9, {0}
    5c30:	9ffb0100 	svcls	0x00fb0100
    5c34:	02000008 	andeq	r0, r0, #8
    5c38:	82166b91 	andshi	r6, r6, #148480	; 0x24400
  uint8 n,m;
  uint8 prescaler, mult;
  uint32 bus_clk = g_bus_clock/1000000;
    5c3c:	0100001d 	tsteq	r0, sp, lsl r0
    5c40:	000571fb 	strdeq	r7, [r5], -fp
    5c44:	64910200 	ldrvs	r0, [r1], #512	; 0x200
    5c48:	00766318 	rsbseq	r6, r6, r8, lsl r3
    5c4c:	0571fd01 	ldrbeq	pc, [r1, #-3329]!	; 0xd01	; <UNPREDICTABLE>
    5c50:	91020000 	mrsls	r0, (UNDEF: 2)
    5c54:	6f6d1874 	svcvs	0x006d1874

  if(adcx == ADC0)
    5c58:	fe010064 	cdp2	0, 0, cr0, cr1, cr4, {3}
    5c5c:	0000057c 	andeq	r0, r0, ip, ror r5
    5c60:	00709102 	rsbseq	r9, r0, r2, lsl #2
    n = 0;
    5c64:	1d21011b 	stfnes	f0, [r1, #-108]!	; 0xffffff94
    5c68:	2c010000 	stccs	0, cr0, [r1], {-0}
  else if(adcx == ADC1)
    5c6c:	055b0101 	ldrbeq	r0, [fp, #-257]	; 0x101
    5c70:	34fc0000 	ldrbtcc	r0, [ip], #0
    5c74:	35480000 	strbcc	r0, [r8, #-0]
    5c78:	0dd40000 	ldcleq	0, cr0, [r4]
    n = 1;
    5c7c:	eb010000 	bl	45c84 <__etext+0x3cfdc>
    5c80:	1c00000a 	stcne	0, cr0, [r0], {10}
  else
    return 0;
    5c84:	00001d9d 	muleq	r0, sp, sp
    
  if(cfg & 0x01)
    5c88:	7c012c01 	stcvc	12, cr2, [r1], {1}
    5c8c:	02000002 	andeq	r0, r0, #2
    5c90:	631d7491 	tstvs	sp, #-1862270976	; 0x91000000
    m = 0;
    5c94:	01006e68 	tsteq	r0, r8, ror #28
    5c98:	089f012c 	ldmeq	pc, {r2, r3, r5, r8}	; <UNPREDICTABLE>
  else if(cfg & 0x02)
    5c9c:	91020000 	mrsls	r0, (UNDEF: 2)
    5ca0:	011b0073 	tsteq	fp, r3, ror r0
    m = 1;
    5ca4:	00001ca5 	andeq	r1, r0, r5, lsr #25
    5ca8:	01016201 	tsteq	r1, r1, lsl #4
  else
    return 0;
    5cac:	0000055b 	andeq	r0, r0, fp, asr r5
    5cb0:	00003548 	andeq	r3, r0, r8, asr #10
  
  prescaler = 1<<((PDB0_SC & PDB_SC_PRESCALER_MASK) >> PDB_SC_PRESCALER_SHIFT);
    5cb4:	0000366a 	andeq	r3, r0, sl, ror #12
    5cb8:	00000e0c 	andeq	r0, r0, ip, lsl #28
    5cbc:	000b4701 	andeq	r4, fp, r1, lsl #14
    5cc0:	1d9d1c00 	ldcne	12, cr1, [sp]
    5cc4:	62010000 	andvs	r0, r1, #0
    5cc8:	00027c01 	andeq	r7, r2, r1, lsl #24
    5ccc:	74910200 	ldrvc	r0, [r1], #512	; 0x200
  mult = pdb_sc_mults[(PDB0_SC & PDB_SC_MULT_MASK) >> PDB_SC_MULT_SHIFT];
    5cd0:	6e68631d 	mcrvs	3, 3, r6, cr8, cr13, {0}
    5cd4:	01620100 	cmneq	r2, r0, lsl #2
    5cd8:	0000089f 	muleq	r0, pc, r8	; <UNPREDICTABLE>
    5cdc:	1d739102 	ldfnep	f1, [r3, #-8]!
    5ce0:	006e6970 	rsbeq	r6, lr, r0, ror r9
    5ce4:	3c016201 	sfmcc	f6, 4, [r1], {1}
    5ce8:	02000008 	andeq	r0, r0, #8
  
  PDB0_C1(n) |= cfg;        //ݲBBģʽѡԤʹԤ
    5cec:	381c7291 	ldmdacc	ip, {r0, r4, r7, r9, ip, sp, lr}
    5cf0:	0100001f 	tsteq	r0, pc, lsl r0
    5cf4:	055b0162 	ldrbeq	r0, [fp, #-354]	; 0x162
    5cf8:	91020000 	mrsls	r0, (UNDEF: 2)
    5cfc:	011e0071 	tsteq	lr, r1, ror r0
    5d00:	00001daa 	andeq	r1, r0, sl, lsr #27
    5d04:	01018401 	tsteq	r1, r1, lsl #8
    5d08:	0000059a 	muleq	r0, sl, r5
    5d0c:	0000366c 	andeq	r3, r0, ip, ror #12
    5d10:	0000368e 	andeq	r3, r0, lr, lsl #13
    5d14:	00000e44 	andeq	r0, r0, r4, asr #28
    5d18:	000b7601 	andeq	r7, fp, r1, lsl #12
    5d1c:	1d9d1c00 	ldcne	12, cr1, [sp]
    5d20:	84010000 	strhi	r0, [r1], #-0
    5d24:	00027c01 	andeq	r7, r2, r1, lsl #24
    5d28:	74910200 	ldrvc	r0, [r1], #512	; 0x200
  PDB0_DLY(n, m) = (bus_clk * delay)/(prescaler * mult);    //ADCnmԤʱֵ
    5d2c:	16011f00 	strne	r1, [r1], -r0, lsl #30
    5d30:	0100001e 	tsteq	r0, lr, lsl r0
    5d34:	90010197 	mulls	r1, r7, r1
    5d38:	ae000036 	mcrge	0, 0, r0, cr0, cr6, {1}
    5d3c:	7c000036 	stcvc	0, cr0, [r0], {54}	; 0x36
    5d40:	0100000e 	tsteq	r0, lr
    5d44:	00000ba1 	andeq	r0, r0, r1, lsr #23
    5d48:	001d9d1c 	andseq	r9, sp, ip, lsl sp
    5d4c:	01970100 	orrseq	r0, r7, r0, lsl #2
    5d50:	0000027c 	andeq	r0, r0, ip, ror r2
    5d54:	00749102 	rsbseq	r9, r4, r2, lsl #2
    5d58:	1cff011e 	ldfnee	f0, [pc], #120	; 5dd8 <LPLD_PDB_DacTriggerCfg+0x4c>
    5d5c:	b3010000 	movwlt	r0, #4096	; 0x1000
    5d60:	059a0101 	ldreq	r0, [sl, #257]	; 0x101
  
  PDB0_SC |= PDB_SC_LDOK_MASK; //ֵ
    5d64:	36b00000 	ldrtcc	r0, [r0], r0
    5d68:	36e20000 	strbtcc	r0, [r2], r0
    5d6c:	0eb40000 	cdpeq	0, 11, cr0, cr4, cr0, {0}
    5d70:	df010000 	svcle	0x00010000
    5d74:	1c00000b 	stcne	0, cr0, [r0], {11}
    5d78:	00001d9d 	muleq	r0, sp, sp
  
  return 1;
    5d7c:	7c01b301 	stcvc	3, cr11, [r1], {1}
}
    5d80:	02000002 	andeq	r0, r0, #2
    5d84:	631d7491 	tstvs	sp, #-1862270976	; 0x91000000
    5d88:	01006e68 	tsteq	r0, r8, ror #28
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_PDB_DacTriggerCfg(DAC_MemMapPtr dacx, uint32 cfg, uint16 int_delay)
{
    5d8c:	089f01b3 	ldmeq	pc, {r0, r1, r4, r5, r7, r8}	; <UNPREDICTABLE>
    5d90:	91020000 	mrsls	r0, (UNDEF: 2)
    5d94:	011f0073 	tsteq	pc, r3, ror r0	; <UNPREDICTABLE>
    5d98:	00001e5f 	andeq	r1, r0, pc, asr lr
  uint8 n;
  uint8 prescaler, mult;
  uint32 bus_clk = g_bus_clock/1000000;
    5d9c:	0101cf01 	tsteq	r1, r1, lsl #30
    5da0:	000036e4 	andeq	r3, r0, r4, ror #13
    5da4:	0000371e 	andeq	r3, r0, lr, lsl r7
    5da8:	00000eec 	andeq	r0, r0, ip, ror #29
    5dac:	000c1901 	andeq	r1, ip, r1, lsl #18
    5db0:	1d9d1c00 	ldcne	12, cr1, [sp]
    5db4:	cf010000 	svcgt	0x00010000
  
  if(dacx == DAC0)
    5db8:	00027c01 	andeq	r7, r2, r1, lsl #24
    5dbc:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    5dc0:	6e68631d 	mcrvs	3, 3, r6, cr8, cr13, {0}
    n = 0;
    5dc4:	01cf0100 	biceq	r0, pc, r0, lsl #2
    5dc8:	0000089f 	muleq	r0, pc, r8	; <UNPREDICTABLE>
  else if(dacx == DAC1)
    5dcc:	00739102 	rsbseq	r9, r3, r2, lsl #2
    5dd0:	2011011e 	andscs	r0, r1, lr, lsl r1
    5dd4:	eb010000 	bl	45ddc <__etext+0x3d134>
    5dd8:	05660101 	strbeq	r0, [r6, #-257]!	; 0x101
    n = 1;
    5ddc:	37200000 	strcc	r0, [r0, -r0]!
    5de0:	374a0000 	strbcc	r0, [sl, -r0]
  else
    return 0;
    5de4:	0f240000 	svceq	0x00240000
  
  prescaler = 1<<((PDB0_SC & PDB_SC_PRESCALER_MASK) >> PDB_SC_PRESCALER_SHIFT);
    5de8:	57010000 	strpl	r0, [r1, -r0]
    5dec:	1c00000c 	stcne	0, cr0, [r0], {12}
    5df0:	00001d9d 	muleq	r0, sp, sp
    5df4:	7c01eb01 	stcvc	11, cr14, [r1], {1}
    5df8:	02000002 	andeq	r0, r0, #2
    5dfc:	631d7491 	tstvs	sp, #-1862270976	; 0x91000000
    5e00:	01006e68 	tsteq	r0, r8, ror #28
  mult = pdb_sc_mults[(PDB0_SC & PDB_SC_MULT_MASK) >> PDB_SC_MULT_SHIFT];
    5e04:	089f01eb 	ldmeq	pc, {r0, r1, r3, r5, r6, r7, r8}	; <UNPREDICTABLE>
    5e08:	91020000 	mrsls	r0, (UNDEF: 2)
    5e0c:	011e0073 	tsteq	lr, r3, ror r0
    5e10:	00001f8a 	andeq	r1, r0, sl, lsl #31
    5e14:	0101fe01 	tsteq	r1, r1, lsl #28
    5e18:	0000055b 	andeq	r0, r0, fp, asr r5
    5e1c:	0000374c 	andeq	r3, r0, ip, asr #14
    5e20:	00003772 	andeq	r3, r0, r2, ror r7
  
  PDB0_INTC(n) |= cfg;     //ʹⲿڲ
    5e24:	00000f5c 	andeq	r0, r0, ip, asr pc
    5e28:	000c8601 	andeq	r8, ip, r1, lsl #12
    5e2c:	1d9d1c00 	ldcne	12, cr1, [sp]
    5e30:	fe010000 	cdp2	0, 0, cr0, cr1, cr0, {0}
    5e34:	00027c01 	andeq	r7, r2, r1, lsl #24
    5e38:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    5e3c:	28011e00 	stmdacs	r1, {r9, sl, fp, ip}
    5e40:	0100001e 	tsteq	r0, lr, lsl r0
    5e44:	66010211 			; <UNDEFINED> instruction: 0x66010211
    5e48:	74000005 	strvc	r0, [r0], #-5
  PDB0_INT(n) = (bus_clk * int_delay)/(prescaler * mult);    //DACnļʱ
    5e4c:	8e000037 	mcrhi	0, 0, r0, cr0, cr7, {1}
    5e50:	94000037 	strls	r0, [r0], #-55	; 0x37
    5e54:	0100000f 	tsteq	r0, pc
    5e58:	00000cb5 			; <UNDEFINED> instruction: 0x00000cb5
    5e5c:	001d9d1c 	andseq	r9, sp, ip, lsl sp
    5e60:	02110100 	andseq	r0, r1, #0
    5e64:	0000027c 	andeq	r0, r0, ip, ror r2
    5e68:	00749102 	rsbseq	r9, r4, r2, lsl #2
    5e6c:	1c03011f 	stfnes	f0, [r3], {31}
    5e70:	24010000 	strcs	r0, [r1], #-0
  
  PDB0_SC |= PDB_SC_LDOK_MASK; //ֵ
    5e74:	37900102 	ldrcc	r0, [r0, r2, lsl #2]
    5e78:	37aa0000 	strcc	r0, [sl, r0]!
    5e7c:	0fcc0000 	svceq	0x00cc0000
    5e80:	e0010000 	and	r0, r1, r0
    5e84:	1c00000c 	stcne	0, cr0, [r0], {12}
    5e88:	00001d9d 	muleq	r0, sp, sp
  
  return 1;
    5e8c:	7c022401 	cfstrsvc	mvf2, [r2], {1}
}
    5e90:	02000002 	andeq	r0, r0, #2
    5e94:	1b007491 	blne	230e0 <__etext+0x1a438>
    5e98:	001f2501 	andseq	r2, pc, r1, lsl #10
 * PDBжϴ
 * ļstartup_K60.sеж
 * û޸ģԶӦͨжϺ
 */
void PDB0_IRQHandler(void)
{
    5e9c:	02360100 	eorseq	r0, r6, #0
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif
  
  //ǷΪPDBж
  if((PDB0_SC & PDB_SC_PDBIF_MASK) && (PDB0_SC & PDB_SC_PDBIE_MASK))
    5ea0:	00055b01 	andeq	r5, r5, r1, lsl #22
    5ea4:	0037ac00 	eorseq	sl, r7, r0, lsl #24
    5ea8:	00383e00 	eorseq	r3, r8, r0, lsl #28
    5eac:	00100400 	andseq	r0, r0, r0, lsl #8
    5eb0:	0d2b0100 	stfeqs	f0, [fp, #-0]
    5eb4:	c31c0000 	tstgt	ip, #0
    5eb8:	0100001f 	tsteq	r0, pc, lsl r0
    5ebc:	094a0236 	stmdbeq	sl, {r1, r2, r4, r5, r9}^
    5ec0:	91020000 	mrsls	r0, (UNDEF: 2)
  {
    //ûԶжϷ
    PDB_ISR[0]();  
    5ec4:	00692070 	rsbeq	r2, r9, r0, ror r0
    5ec8:	5b023801 	blpl	93ed4 <__etext+0x8b22c>
    5ecc:	02000005 	andeq	r0, r0, #5
    //жϱ־λ  
    PDB0_SC &= ~PDB_SC_PDBIF_MASK;
    5ed0:	9d216791 	stcls	7, cr6, [r1, #-580]!	; 0xfffffdbc
    5ed4:	0100001d 	tsteq	r0, sp, lsl r0
    5ed8:	027c0239 	rsbseq	r0, ip, #-1879048189	; 0x90000003
    5edc:	91020000 	mrsls	r0, (UNDEF: 2)
    5ee0:	011b0060 	tsteq	fp, r0, rrx
    5ee4:	00001d45 	andeq	r1, r0, r5, asr #26
  }
  
  //ǷΪPDBдж CH0
  if((PDB0_CH0S & PDB_S_ERR(1)) && (PDB0_SC & PDB_SC_PDBEIE_MASK))
    5ee8:	01025801 	tsteq	r2, r1, lsl #16
    5eec:	0000055b 	andeq	r0, r0, fp, asr r5
    5ef0:	00003840 	andeq	r3, r0, r0, asr #16
    5ef4:	000038d2 	ldrdeq	r3, [r0], -r2
    5ef8:	00001048 	andeq	r1, r0, r8, asr #32
    5efc:	000d7601 	andeq	r7, sp, r1, lsl #12
    5f00:	1fc31c00 	svcne	0x00c31c00
    5f04:	58010000 	stmdapl	r1, {}	; <UNPREDICTABLE>
    5f08:	00094a02 	andeq	r4, r9, r2, lsl #20
  {
    //ûԶжϷ
    PDB_SE_ISR[0]();  
    5f0c:	70910200 	addsvc	r0, r1, r0, lsl #4
    5f10:	01006920 	tsteq	r0, r0, lsr #18
    5f14:	055b025a 	ldrbeq	r0, [fp, #-602]	; 0x25a
    PDB0_CH0S |= PDB_S_ERR(1);
    5f18:	91020000 	mrsls	r0, (UNDEF: 2)
    5f1c:	1d9d2167 	ldfnes	f2, [sp, #412]	; 0x19c
    5f20:	5b010000 	blpl	45f28 <__etext+0x3d280>
    5f24:	00027c02 	andeq	r7, r2, r2, lsl #24
    5f28:	60910200 	addsvs	r0, r1, r0, lsl #4
    5f2c:	60011b00 	andvs	r1, r1, r0, lsl #22
  }
  
  //ǷΪPDBдж CH1
  if((PDB0_CH1S & PDB_S_ERR(2)) && (PDB0_SC & PDB_SC_PDBEIE_MASK))
    5f30:	0100001f 	tsteq	r0, pc, lsl r0
    5f34:	5b010284 	blpl	4694c <__etext+0x3dca4>
    5f38:	d4000005 	strle	r0, [r0], #-5
    5f3c:	26000038 			; <UNDEFINED> instruction: 0x26000038
    5f40:	8c000039 	stchi	0, cr0, [r0], {57}	; 0x39
    5f44:	01000010 	tsteq	r0, r0, lsl r0
    5f48:	00000dc3 	andeq	r0, r0, r3, asr #27
    5f4c:	001d9d1c 	andseq	r9, sp, ip, lsl sp
    5f50:	02840100 	addeq	r0, r4, #0
  {
    //ûԶжϷ
    PDB_SE_ISR[0]();  
    5f54:	0000027c 	andeq	r0, r0, ip, ror r2
    5f58:	1d749102 	ldfnep	f1, [r4, #-8]!
    5f5c:	00616870 	rsbeq	r6, r1, r0, ror r8
    PDB0_CH1S |= PDB_S_ERR(2);
    5f60:	3c028401 	cfstrscc	mvf8, [r2], {1}
    5f64:	02000008 	andeq	r0, r0, #8
    5f68:	701d7391 	mulsvc	sp, r1, r3
    5f6c:	01006268 	tsteq	r0, r8, ror #4
    5f70:	083c0284 	ldmdaeq	ip!, {r2, r7, r9}
    5f74:	91020000 	mrsls	r0, (UNDEF: 2)
  }
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    5f78:	011b0072 	tsteq	fp, r2, ror r0
 * 输出:
 *    0--配置错误
 *    1--配置成功
 */
uint8 LPLD_PIT_Init(PIT_InitTypeDef pit_init_structure)
{ 
    5f7c:	00001d66 	andeq	r1, r0, r6, ror #26
    5f80:	01029b01 	tsteq	r2, r1, lsl #22
    5f84:	0000055b 	andeq	r0, r0, fp, asr r5
    5f88:	00003928 	andeq	r3, r0, r8, lsr #18
  //计算定时加载值
  uint32 ldval = pit_init_structure.PIT_PeriodUs*(g_bus_clock/1000000)
    5f8c:	0000396a 	andeq	r3, r0, sl, ror #18
    5f90:	000010c4 	andeq	r1, r0, r4, asr #1
    5f94:	000df201 	andeq	pc, sp, r1, lsl #4
    5f98:	1d9d1c00 	ldcne	12, cr1, [sp]
    5f9c:	9b010000 	blls	45fa4 <__etext+0x3d2fc>
    5fa0:	00027c02 	andeq	r7, r2, r2, lsl #24
    5fa4:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    5fa8:	1ccf2200 	sfmne	f2, 2, [pc], {0}
               + pit_init_structure.PIT_PeriodMs*1000*(g_bus_clock/1000000)
    5fac:	a9010000 	stmdbge	r1, {}	; <UNPREDICTABLE>
    5fb0:	055b0102 	ldrbeq	r0, [fp, #-258]	; 0x102
    5fb4:	396c0000 	stmdbcc	ip!, {}^	; <UNPREDICTABLE>
    5fb8:	3b260000 	blcc	985fc0 <__etext+0x97d318>
    5fbc:	10fc0000 	rscsne	r0, ip, r0
    5fc0:	a6010000 	strge	r0, [r1], -r0
    5fc4:	1c00000e 	stcne	0, cr0, [r0], {14}
    5fc8:	00001fc3 	andeq	r1, r0, r3, asr #31
    5fcc:	4a02a901 	bmi	b03d8 <__etext+0xa7730>
    5fd0:	02000009 	andeq	r0, r0, #9
    5fd4:	2a217091 	bcs	862220 <__etext+0x859578>
               + pit_init_structure.PIT_PeriodS*1000000*(g_bus_clock/1000000);
    5fd8:	0100001c 	tsteq	r0, ip, lsl r0
    5fdc:	057102ab 	ldrbeq	r0, [r1, #-683]!	; 0x2ab
    5fe0:	91020000 	mrsls	r0, (UNDEF: 2)
    5fe4:	6f6d204c 	svcvs	0x006d204c
    5fe8:	ac010064 	stcge	0, cr0, [r1], {100}	; 0x64
    5fec:	00057102 	andeq	r7, r5, r2, lsl #2
    5ff0:	48910200 	ldmmi	r1, {r9}
    5ff4:	001c4821 	andseq	r4, ip, r1, lsr #16
    5ff8:	02ac0100 	adceq	r0, ip, #0
    5ffc:	00000571 	andeq	r0, r0, r1, ror r5
    6000:	20649102 	rsbcs	r9, r4, r2, lsl #2
 *    1--配置成功
 */
uint8 LPLD_PIT_Init(PIT_InitTypeDef pit_init_structure)
{ 
  //计算定时加载值
  uint32 ldval = pit_init_structure.PIT_PeriodUs*(g_bus_clock/1000000)
    6004:	01007370 	tsteq	r0, r0, ror r3
               + pit_init_structure.PIT_PeriodMs*1000*(g_bus_clock/1000000)
               + pit_init_structure.PIT_PeriodS*1000000*(g_bus_clock/1000000);
  PITx pitx = pit_init_structure.PIT_Pitx;
    6008:	055b02ad 	ldrbeq	r0, [fp, #-685]	; 0x2ad
  PIT_ISR_CALLBACK isr_func = pit_init_structure.PIT_Isr;
    600c:	91020000 	mrsls	r0, (UNDEF: 2)
  
  //参数检查
  //ASSERT( pitx <= PIT3);        //判断模块号
  //ASSERT( ldval > 0);           //判断时加载值  
  if (pitx > PIT3)
    6010:	24082163 	strcs	r2, [r8], #-355	; 0x163
    return 0;
    6014:	ae010000 	cdpge	0, 0, cr0, cr1, cr0, {0}
    6018:	00057102 	andeq	r7, r5, r2, lsl #2
  if (ldval <= 0)
    601c:	5c910200 	lfmpl	f0, 4, [r1], {0}
    return 0;
    6020:	001cf921 	andseq	pc, ip, r1, lsr #18
    6024:	02af0100 	adceq	r0, pc, #0
  
  //开启定时模块时钟
  SIM_SCGC6 |= SIM_SCGC6_PIT_MASK;
    6028:	00000571 	andeq	r0, r0, r1, ror r5
    602c:	21589102 	cmpcs	r8, r2, lsl #2
    6030:	00001c61 	andeq	r1, r0, r1, ror #24
    6034:	5b02b001 	blpl	b2040 <__etext+0xa9398>
    6038:	02000005 	andeq	r0, r0, #5
    603c:	58215791 	stmdapl	r1!, {r0, r4, r7, r8, r9, sl, ip, lr}
    6040:	0100001e 	tsteq	r0, lr, lsl r0
    6044:	055b02b1 	ldrbeq	r0, [fp, #-689]	; 0x2b1
    6048:	91020000 	mrsls	r0, (UNDEF: 2)
    604c:	1d9d2156 	ldfnes	f2, [sp, #344]	; 0x158
  
  // 开启 PIT
  PIT_MCR = 0x00;
    6050:	b2010000 	andlt	r0, r1, #0
    6054:	00027c02 	andeq	r7, r2, r2, lsl #24
    6058:	50910200 	addspl	r0, r1, r0, lsl #4
 
  if(isr_func != NULL){
    605c:	1c762200 	lfmne	f2, 2, [r6], #-0
    6060:	04010000 	streq	r0, [r1], #-0
    PIT_ISR[pitx] = isr_func;
    6064:	055b0103 	ldrbeq	r0, [fp, #-259]	; 0x103
    6068:	3b280000 	blcc	a06070 <__etext+0x9fd3c8>
    606c:	3c340000 	ldccc	0, cr0, [r4], #-0
    6070:	11400000 	mrsne	r0, (UNDEF: 64)
    //使能中断
    PIT->CHANNEL[pitx].TCTRL = PIT_TCTRL_TIE_MASK;
    6074:	0d010000 	stceq	0, cr0, [r1, #-0]
    6078:	1c00000f 	stcne	0, cr0, [r0], {15}
    607c:	00001fc3 	andeq	r1, r0, r3, asr #31
    6080:	4a030401 	bmi	c708c <__etext+0xbe3e4>
    6084:	02000009 	andeq	r0, r0, #9
    6088:	69207091 	stmdbvs	r0!, {r0, r4, r7, ip, sp, lr}
    //在NVIC中使能PIT中断
    //enable_irq(68 + pitx); 
  }
  
  //period = (period_ns/bus_period_ns)-1
  PIT->CHANNEL[pitx].LDVAL = ldval-1;
    608c:	03060100 	movweq	r0, #24832	; 0x6100
    6090:	0000055b 	andeq	r0, r0, fp, asr r5
    6094:	20679102 	rsbcs	r9, r7, r2, lsl #2
    6098:	01007370 	tsteq	r0, r0, ror r3
    609c:	055b0307 	ldrbeq	r0, [fp, #-775]	; 0x307
    60a0:	91020000 	mrsls	r0, (UNDEF: 2)
    60a4:	17832166 	strne	r2, [r3, r6, ror #2]
  //使能中断
  //PIT->CHANNEL[pitx].TCTRL = PIT_TCTRL_TIE_MASK;
  //开始定时
  PIT->CHANNEL[pitx].TCTRL |= PIT_TCTRL_TEN_MASK;
    60a8:	08010000 	stmdaeq	r1, {}	; <UNPREDICTABLE>
    60ac:	0008aa03 	andeq	sl, r8, r3, lsl #20
    60b0:	60910200 	addsvs	r0, r1, r0, lsl #4
    60b4:	001d9d21 	andseq	r9, sp, r1, lsr #26
    60b8:	03090100 	movweq	r0, #37120	; 0x9100
    60bc:	0000027c 	andeq	r0, r0, ip, ror r2
    60c0:	005c9102 	subseq	r9, ip, r2, lsl #2
    60c4:	001ee822 	andseq	lr, lr, r2, lsr #16
    60c8:	03390100 	teqeq	r9, #0
    60cc:	00055b01 	andeq	r5, r5, r1, lsl #22
    60d0:	003c3400 	eorseq	r3, ip, r0, lsl #8
    60d4:	00456e00 	subeq	r6, r5, r0, lsl #28
  
  return 1;
    60d8:	00118400 	andseq	r8, r1, r0, lsl #8
}
    60dc:	0f590100 	svceq	0x00590100
    60e0:	9d1c0000 	ldcls	0, cr0, [ip, #-0]
    60e4:	0100001d 	tsteq	r0, sp, lsl r0
    60e8:	027c0339 	rsbseq	r0, ip, #-469762048	; 0xe4000000
 *
 * 输出:
 *    无
 */
void LPLD_PIT_Deinit(PIT_InitTypeDef pit_init_structure)
{ 
    60ec:	91020000 	mrsls	r0, (UNDEF: 2)
    60f0:	68631d74 	stmdavs	r3!, {r2, r4, r5, r6, r8, sl, fp, ip}^
    60f4:	3901006e 	stmdbcc	r1, {r1, r2, r3, r5, r6}
    60f8:	00089f03 	andeq	r9, r8, r3, lsl #30
  PITx pitx = pit_init_structure.PIT_Pitx;
    60fc:	73910200 	orrsvc	r0, r1, #0
  
  //参数检查
  //ASSERT( pitx <= PIT3);        //判断模块号              

  disable_irq(68 + pitx); 
    6100:	6e69701d 	mcrvs	0, 3, r7, cr9, cr13, {0}
    6104:	03390100 	teqeq	r9, #0
    6108:	0000083c 	andeq	r0, r0, ip, lsr r8

  //禁用中断\停止定时
  PIT->CHANNEL[pitx].TCTRL = 0;
    610c:	00729102 	rsbseq	r9, r2, r2, lsl #2
    6110:	001c3522 	andseq	r3, ip, r2, lsr #10
    6114:	042e0100 	strteq	r0, [lr], #-256	; 0x100
    6118:	00055b01 	andeq	r5, r5, r1, lsl #22
    611c:	00457000 	subeq	r7, r5, r0
    6120:	004bc800 	subeq	ip, fp, r0, lsl #16
    6124:	0011bc00 	andseq	fp, r1, r0, lsl #24
}
    6128:	0f960100 	svceq	0x00960100
    612c:	9d1c0000 	ldcls	0, cr0, [ip, #-0]
    6130:	0100001d 	tsteq	r0, sp, lsl r0
 * 输出:
 *    无
 *
 */
void LPLD_PIT_EnableIrq(PIT_InitTypeDef pit_init_structure)
{
    6134:	027c042e 	rsbseq	r0, ip, #771751936	; 0x2e000000
    6138:	91020000 	mrsls	r0, (UNDEF: 2)
    613c:	68631d74 	stmdavs	r3!, {r2, r4, r5, r6, r8, sl, fp, ip}^
    6140:	2e01006e 	cdpcs	0, 0, cr0, cr1, cr14, {3}
  PITx pitx = pit_init_structure.PIT_Pitx;
    6144:	00089f04 	andeq	r9, r8, r4, lsl #30
  
  //参数检查
  //ASSERT( pitx <= PIT3);                //判断PITx

  enable_irq(68 + pitx); 
    6148:	73910200 	orrsvc	r0, r1, #0
    614c:	1ce12200 	sfmne	f2, 2, [r1]
    6150:	c2010000 	andgt	r0, r1, #0
}
    6154:	055b0104 	ldrbeq	r0, [fp, #-260]	; 0x104
    6158:	4bc80000 	blmi	ff206160 <__StackLimit+0xdf206160>
    615c:	4c380000 	ldcmi	0, cr0, [r8], #-0
    6160:	11f40000 	mvnsne	r0, r0
 * 输出:
 *    无
 *
 */
void LPLD_PIT_DisableIrq(PIT_InitTypeDef pit_init_structure)
{
    6164:	e2010000 	and	r0, r1, #0
    6168:	1c00000f 	stcne	0, cr0, [r0], {15}
    616c:	00001fc3 	andeq	r1, r0, r3, asr #31
    6170:	4a04c201 	bmi	13697c <__etext+0x12dcd4>
  PITx pitx = pit_init_structure.PIT_Pitx;
    6174:	02000009 	andeq	r0, r0, #9
  
  //参数检查
  //ASSERT( pitx <= PIT3);                //判断PITx
  
  disable_irq(68 + pitx);
    6178:	21217091 			; <UNDEFINED> instruction: 0x21217091
    617c:	0100002b 	tsteq	r0, fp, lsr #32
    6180:	055b04c4 	ldrbeq	r0, [fp, #-1220]	; 0x4c4
}
    6184:	91020000 	mrsls	r0, (UNDEF: 2)
    6188:	1d9d2167 	ldfnes	f2, [sp, #412]	; 0x19c
    618c:	c5010000 	strgt	r0, [r1, #-0]
    6190:	00027c04 	andeq	r7, r2, r4, lsl #24

//pit开始记时
void LPLD_PIT_TimeStart(PITx PIT_pitx)
{
    6194:	60910200 	addsvs	r0, r1, r0, lsl #4
    6198:	1f0c2200 	svcne	0x000c2200
    619c:	d3010000 	movwle	r0, #4096	; 0x1000
    //开启PIT模块
    SIM_SCGC6 |= SIM_SCGC6_PIT_MASK;
    61a0:	055b0104 	ldrbeq	r0, [fp, #-260]	; 0x104
    61a4:	4c380000 	ldcmi	0, cr0, [r8], #-0
    61a8:	4c540000 	mrami	r0, r4, acc0
    61ac:	12380000 	eorsne	r0, r8, #0
    61b0:	10010000 	andne	r0, r1, r0
    61b4:	1c000010 	stcne	0, cr0, [r0], {16}
    61b8:	00001fc3 	andeq	r1, r0, r3, asr #31
    61bc:	4a04d301 	bmi	13adc8 <__etext+0x132120>
    61c0:	02000009 	andeq	r0, r0, #9
    61c4:	23007091 	movwcs	r7, #145	; 0x91
    //使能PIT定时器时钟，调试模式下继续使用
    PIT_MCR &= ~(PIT_MCR_MDIS_MASK | PIT_MCR_FRZ_MASK);
    61c8:	001eb201 	andseq	fp, lr, r1, lsl #4
    61cc:	04de0100 	ldrbeq	r0, [lr], #256	; 0x100
    61d0:	004c5401 	subeq	r5, ip, r1, lsl #8
    61d4:	004c6600 	subeq	r6, ip, r0, lsl #12
    61d8:	00127000 	andseq	r7, r2, r0
    61dc:	01230100 	teqeq	r3, r0, lsl #2
    //禁用PIT， 以便设置加载值生效
    PIT_TCTRL (PIT_pitx) &= ~(PIT_TCTRL_TEN_MASK);
    61e0:	00001cbf 			; <UNDEFINED> instruction: 0x00001cbf
    61e4:	0104ee01 	tsteq	r4, r1, lsl #28
    61e8:	00004c68 	andeq	r4, r0, r8, ror #24
    61ec:	00004c7a 	andeq	r4, r0, sl, ror ip
    61f0:	0000129c 	muleq	r0, ip, r2
    61f4:	f3012301 	vcgt.u8	d2, d1, d1
    61f8:	0100001d 	tsteq	r0, sp, lsl r0
    61fc:	7c0104fe 	cfstrsvc	mvf0, [r1], {254}	; 0xfe
    6200:	8e00004c 	cdphi	0, 0, cr0, cr0, cr12, {2}
    6204:	c800004c 	stmdagt	r0, {r2, r3, r6}
    6208:	01000012 	tsteq	r0, r2, lsl r0
    620c:	000bf724 	andeq	pc, fp, r4, lsr #14
    //设置溢出中断时间
    PIT_LDVAL (PIT_pitx) = ~0;
    6210:	71200700 	teqvc	r0, r0, lsl #14
    6214:	01000005 	tsteq	r0, r5
    6218:	08aa0501 	stmiaeq	sl!, {r0, r8, sl}
    621c:	10720000 	rsbsne	r0, r2, r0
    6220:	81060000 	mrshi	r0, (UNDEF: 6)
    6224:	02000000 	andeq	r0, r0, #0
    //清中断标志位
    //PIT_Flag_Clear (PIT_pitx);
    PIT_TFLG (PIT_pitx) |= PIT_TFLG_TIF_MASK;
    6228:	1ed82500 	cdpne	5, 13, cr2, cr8, cr0, {0}
    622c:	1a010000 	bne	46234 <__etext+0x3d58c>
    6230:	00001062 	andeq	r1, r0, r2, rrx
    6234:	44030501 	strmi	r0, [r3], #-1281	; 0x501
    6238:	001fff16 	andseq	pc, pc, r6, lsl pc	; <UNPREDICTABLE>
    623c:	000005c0 	andeq	r0, r0, r0, asr #11
    6240:	0e3d0002 	cdpeq	0, 3, cr0, cr13, cr2, {0}
    6244:	01040000 	mrseq	r0, (UNDEF: 4)
    6248:	00000234 	andeq	r0, r0, r4, lsr r2
    624c:	00214e01 	eoreq	r4, r1, r1, lsl #28
    6250:	00082700 	andeq	r2, r8, r0, lsl #14
    6254:	004c9000 	subeq	r9, ip, r0
    //禁止PITn定时器 (用来清空计数值)
    PIT_TCTRL (PIT_pitx) &= ~PIT_TCTRL_TEN_MASK;
    6258:	00518600 	subseq	r8, r1, r0, lsl #12
    625c:	000fd800 	andeq	sp, pc, r0, lsl #16
    6260:	06010200 	streq	r0, [r1], -r0, lsl #4
    6264:	0000070b 	andeq	r0, r0, fp, lsl #14
    6268:	0009dd03 	andeq	sp, r9, r3, lsl #26
    626c:	372a0200 	strcc	r0, [sl, -r0, lsl #4]!
    6270:	02000000 	andeq	r0, r0, #0
    6274:	07090801 	streq	r0, [r9, -r1, lsl #16]
    6278:	02020000 	andeq	r0, r2, #0
    627c:	00073b05 	andeq	r3, r7, r5, lsl #22
    6280:	07020200 	streq	r0, [r2, -r0, lsl #4]
    6284:	00000492 	muleq	r0, r2, r4
    //使能PIT定时器
    PIT_TCTRL (PIT_pitx) = (0
    6288:	96050402 	strls	r0, [r5], -r2, lsl #8
    628c:	03000001 	movweq	r0, #1
    6290:	0000079b 	muleq	r0, fp, r7
    6294:	005e5002 	subseq	r5, lr, r2
    6298:	04020000 	streq	r0, [r2], #-0
    629c:	0001e407 	andeq	lr, r1, r7, lsl #8
    62a0:	05080200 	streq	r0, [r8, #-512]	; 0x200
                           |PIT_TCTRL_TEN_MASK
                           );

}
    62a4:	00000191 	muleq	r0, r1, r1
    62a8:	df070802 	svcle	0x00070802
//获取PIT计时时间，（超时关闭定时器）
uint32 LPLD_PIT_TimeGetUs (PITx PIT_pitx)
{
    62ac:	04000001 	streq	r0, [r0], #-1
    62b0:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    62b4:	04020074 	streq	r0, [r2], #-116	; 0x74
    uint32 val;
    val = (~0) - PIT_CVAL(PIT_pitx);
    62b8:	0001e907 	andeq	lr, r1, r7, lsl #18
    62bc:	07040200 	streq	r0, [r4, -r0, lsl #4]
    62c0:	00000574 	andeq	r0, r0, r4, ror r5
    62c4:	00002c05 	andeq	r2, r0, r5, lsl #24
    62c8:	00009800 	andeq	r9, r0, r0, lsl #16
    62cc:	00810600 	addeq	r0, r1, r0, lsl #12
    62d0:	001b0000 	andseq	r0, fp, r0

    if (PIT_TFLG(PIT_pitx) & PIT_TFLG_TIF_MASK)
    62d4:	00002c05 	andeq	r2, r0, r5, lsl #24
    62d8:	0000a800 	andeq	sl, r0, r0, lsl #16
    62dc:	00810600 	addeq	r0, r1, r0, lsl #12
    62e0:	00170000 	andseq	r0, r7, r0
    62e4:	0008f807 	andeq	pc, r8, r7, lsl #16
    62e8:	bf031800 	svclt	0x00031800
    62ec:	00011025 	andeq	r1, r1, r5, lsr #32
    {
        //更换下一句的表达方式
        //PIT_Flag_Clear(PIT_pitx);
        PIT_TFLG (PIT_pitx) |= PIT_TFLG_TIF_MASK;
    62f0:	0a1c0800 	beq	7082f8 <__etext+0x6ff650>
    62f4:	c0030000 	andgt	r0, r3, r0
    62f8:	00005325 	andeq	r5, r0, r5, lsr #6
    62fc:	00230200 	eoreq	r0, r3, r0, lsl #4
    6300:	0002f108 	andeq	pc, r2, r8, lsl #2
    6304:	25c10300 	strbcs	r0, [r1, #768]	; 0x300
    6308:	00000053 	andeq	r0, r0, r3, asr r0
    630c:	08042302 	stmdaeq	r4, {r1, r8, r9, sp}
    6310:	00000134 	andeq	r0, r0, r4, lsr r1
    6314:	5325c203 	teqpl	r5, #805306368	; 0x30000000
    6318:	02000000 	andeq	r0, r0, #0
    631c:	67080823 	strvs	r0, [r8, -r3, lsr #16]

        PIT_TCTRL(PIT_pitx) &= ~PIT_TCTRL_TEN_MASK;
    6320:	03000000 	movweq	r0, #0
    6324:	005325c3 	subseq	r2, r3, r3, asr #11
    6328:	23020000 	movwcs	r0, #8192	; 0x2000
    632c:	0177080c 	cmneq	r7, ip, lsl #16
    6330:	c4030000 	strgt	r0, [r3], #-0
    6334:	00005325 	andeq	r5, r0, r5, lsr #6
    6338:	10230200 	eorne	r0, r3, r0, lsl #4
    633c:	00052f08 	andeq	r2, r5, r8, lsl #30
    6340:	25c50300 	strbcs	r0, [r5, #768]	; 0x300
    6344:	00000053 	andeq	r0, r0, r3, asr r0
    6348:	00142302 	andseq	r2, r4, r2, lsl #6
    634c:	00015709 	andeq	r5, r1, r9, lsl #14
        return ~0;
    6350:	25c60300 	strbcs	r0, [r6, #768]	; 0x300
    6354:	0000011c 	andeq	r0, r0, ip, lsl r1
    }
    if (val == (~0))
    6358:	0122040a 	teqeq	r2, sl, lsl #8
    635c:	a80b0000 	stmdage	fp, {}	; <UNPREDICTABLE>
    {
        val --;
    6360:	05000000 	streq	r0, [r0, #-0]
    6364:	00000053 	andeq	r0, r0, r3, asr r0
    }
    return (val/(g_bus_clock/1000000));
    6368:	00000137 	andeq	r0, r0, r7, lsr r1
    636c:	00008106 	andeq	r8, r0, r6, lsl #2
    6370:	07001f00 	streq	r1, [r0, -r0, lsl #30]
    6374:	00001261 	andeq	r1, r0, r1, ror #4
    6378:	35a503cc 	strcc	r0, [r5, #972]!	; 0x3cc
    637c:	000001d4 	ldrdeq	r0, [r0], -r4
    6380:	5243500c 	subpl	r5, r3, #12
    6384:	35a60300 	strcc	r0, [r6, #768]!	; 0x300
}
    6388:	00000127 	andeq	r0, r0, r7, lsr #2
    638c:	08002302 	stmdaeq	r0, {r1, r8, r9, sp}
    6390:	00001111 	andeq	r1, r0, r1, lsl r1

//关闭PIT计时
void LPLD_PIT_TimeClose(PITx PIT_pitx)
{
    6394:	5335a703 	teqpl	r5, #786432	; 0xc0000
    6398:	03000000 	movweq	r0, #0
    639c:	08018023 	stmdaeq	r1, {r0, r1, r5, pc}
    PIT_TFLG (PIT_pitx) |= PIT_TFLG_TIF_MASK;
    63a0:	0000145a 	andeq	r1, r0, sl, asr r4
    63a4:	5335a803 	teqpl	r5, #196608	; 0x30000
    63a8:	03000000 	movweq	r0, #0
    63ac:	08018423 	stmdaeq	r1, {r0, r1, r5, sl, pc}
    63b0:	00000312 	andeq	r0, r0, r2, lsl r3
    63b4:	9835a903 	ldmdals	r5!, {r0, r1, r8, fp, sp, pc}
    63b8:	03000000 	movweq	r0, #0
    63bc:	08018823 	stmdaeq	r1, {r0, r1, r5, fp, pc}
    63c0:	00001238 	andeq	r1, r0, r8, lsr r2
    63c4:	5335aa03 	teqpl	r5, #12288	; 0x3000
    63c8:	03000000 	movweq	r0, #0
    63cc:	0801a023 	stmdaeq	r1, {r0, r1, r5, sp, pc}

    //PIT_Flag_Clear(PIT_pitx);
    PIT_TCTRL(PIT_pitx) &= ~PIT_TCTRL_TEN_MASK;
    63d0:	0000031d 	andeq	r0, r0, sp, lsl r3
    63d4:	8835ab03 	ldmdahi	r5!, {r0, r1, r8, r9, fp, sp, pc}
    63d8:	03000000 	movweq	r0, #0
    63dc:	0801a423 	stmdaeq	r1, {r0, r1, r5, sl, sp, pc}
    63e0:	0000126d 	andeq	r1, r0, sp, ror #4
    63e4:	5335ac03 	teqpl	r5, #768	; 0x300
    63e8:	03000000 	movweq	r0, #0
    63ec:	0801c023 	stmdaeq	r1, {r0, r1, r5, lr, pc}
    63f0:	0000114a 	andeq	r1, r0, sl, asr #2
    63f4:	5335ad03 	teqpl	r5, #192	; 0xc0
    63f8:	03000000 	movweq	r0, #0
    63fc:	0801c423 	stmdaeq	r1, {r0, r1, r5, sl, lr, pc}
}
    6400:	00001295 	muleq	r0, r5, r2
    6404:	5335ae03 	teqpl	r5, #48	; 0x30
 * 与启动文件startup_K60.s中的中断向量表关联
 * 用户无需修改，程序自动进入对应通道中断函数
 */

void PIT0_IRQHandler(void)
{
    6408:	03000000 	movweq	r0, #0
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif
  
  //调用用户自定义中断服务
  PIT_ISR[0]();  
    640c:	0001c823 	andeq	ip, r1, r3, lsr #16
    6410:	0011b109 	andseq	fp, r1, r9, lsl #2
    6414:	35af0300 	strcc	r0, [pc, #768]!	; 671c <LPLD_SPI_Init+0x254>
  //清除中断标志位
  PIT->CHANNEL[0].TFLG |= PIT_TFLG_TIF_MASK;
    6418:	000001e0 	andeq	r0, r0, r0, ror #3
    641c:	01e6040a 	mvneq	r0, sl, lsl #8
    6420:	370b0000 	strcc	r0, [fp, -r0]
    6424:	03000001 	movweq	r0, #1
    6428:	00000483 	andeq	r0, r0, r3, lsl #9
    642c:	00371b04 	eorseq	r1, r7, r4, lsl #22
    6430:	7b030000 	blvc	c6438 <__etext+0xbd790>
  
#if (UCOS_II > 0u)
  OSIntExit();          //告知系统此时即将离开中断服务子函数
#endif
}
    6434:	0400001d 	streq	r0, [r0], #-29
void PIT1_IRQHandler(void)
{
    6438:	00005e1d 	andeq	r5, r0, sp, lsl lr
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif
  
  //调用用户自定义中断服务
  PIT_ISR[1]();  
    643c:	04040200 	streq	r0, [r4], #-512	; 0x200
    6440:	00000669 	andeq	r0, r0, r9, ror #12
    6444:	87040802 	strhi	r0, [r4, -r2, lsl #16]
  //清除中断标志位
  PIT->CHANNEL[1].TFLG |= PIT_TFLG_TIF_MASK;
    6448:	0d00000a 	stceq	0, cr0, [r0, #-40]	; 0xffffffd8
    644c:	0f040a01 	svceq	0x00040a01
    6450:	02000002 	andeq	r0, r0, #2
    6454:	07120801 	ldreq	r0, [r2, -r1, lsl #16]
    6458:	1a090000 	bne	246460 <__etext+0x23d7b8>
    645c:	05000006 	streq	r0, [r0, #-6]
    6460:	021101a7 	andseq	r0, r1, #-1073741783	; 0xc0000029
  
#if (UCOS_II > 0u)
  OSIntExit();          //告知系统此时即将离开中断服务子函数
#endif
}
    6464:	140e0000 	strne	r0, [lr], #-0
void PIT2_IRQHandler(void)
{
    6468:	8e01aa05 	vmlahi.f32	s20, s2, s10
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif
  
  //调用用户自定义中断服务
  PIT_ISR[2]();  
    646c:	08000002 	stmdaeq	r0, {r1}
    6470:	00000640 	andeq	r0, r0, r0, asr #12
    6474:	1001af05 	andne	sl, r1, r5, lsl #30
  //清除中断标志位
  PIT->CHANNEL[2].TFLG |= PIT_TFLG_TIF_MASK;
    6478:	02000001 	andeq	r0, r0, #1
    647c:	ee080023 	cdp	0, 0, cr0, cr8, cr3, {1}
    6480:	05000009 	streq	r0, [r0, #-9]
    6484:	01f601b3 	ldrheq	r0, [r6, #19]!
    6488:	23020000 	movwcs	r0, #8192	; 0x2000
    648c:	02f60804 	rscseq	r0, r6, #262144	; 0x40000
    6490:	b7050000 	strlt	r0, [r5, -r0]
  
#if (UCOS_II > 0u)
  OSIntExit();          //告知系统此时即将离开中断服务子函数
#endif
}
    6494:	0001f601 	andeq	pc, r1, r1, lsl #12
void PIT3_IRQHandler(void)
{
    6498:	08230200 	stmdaeq	r3!, {r9}
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif
  
  //调用用户自定义中断服务
  PIT_ISR[3]();  
    649c:	00053408 	andeq	r3, r5, r8, lsl #8
    64a0:	01bb0500 			; <UNDEFINED> instruction: 0x01bb0500
    64a4:	000001eb 	andeq	r0, r0, fp, ror #3
  //清除中断标志位
  PIT->CHANNEL[3].TFLG |= PIT_TFLG_TIF_MASK;
    64a8:	080c2302 	stmdaeq	ip, {r1, r8, r9, sp}
    64ac:	00002028 	andeq	r2, r0, r8, lsr #32
    64b0:	eb01bf05 	bl	760cc <__etext+0x6d424>
    64b4:	02000001 	andeq	r0, r0, #1
    64b8:	d4080d23 	strle	r0, [r8], #-3363	; 0xd23
    64bc:	05000009 	streq	r0, [r0, #-9]
    64c0:	021e01c9 	andseq	r0, lr, #1073741874	; 0x40000032
}
    64c4:	23020000 	movwcs	r0, #8192	; 0x2000
 *    0--ô
 *    1--óɹ
 */

uint8 LPLD_SPI_Init(SPI_InitTypeDef spi_init_structure)
{
    64c8:	ff090010 			; <UNDEFINED> instruction: 0xff090010
    64cc:	05000005 	streq	r0, [r0, #-5]
    64d0:	022a01ca 	eoreq	r0, sl, #-2147483598	; 0x80000032
    64d4:	010f0000 	mrseq	r0, CPSR
  SPI_MemMapPtr spix = spi_init_structure.SPI_SPIx;
    64d8:	00002048 	andeq	r2, r0, r8, asr #32
  uint8 spi_mode = spi_init_structure.SPI_ModeSelect;
    64dc:	25011301 	strcs	r1, [r1, #-769]	; 0x301
    64e0:	90000000 	andls	r0, r0, r0
  uint8 sck_div = spi_init_structure.SPI_SckDivider; 
    64e4:	e600004c 	str	r0, [r0], -ip, asr #32
    64e8:	f400004d 	vst4.16	{d0-d3}, [r0]!
  boolean txFIFO_enable = spi_init_structure.SPI_EnableTxFIFO;
    64ec:	01000012 	tsteq	r0, r2, lsl r0
    64f0:	00000327 	andeq	r0, r0, r7, lsr #6
  boolean rxFIFO_enable = spi_init_structure.SPI_EnableRxFIFO;
    64f4:	00203410 	eoreq	r3, r0, r0, lsl r4
    64f8:	8e130100 	mufhis	f0, f3, f0
  //SPIжϱ
  boolean tx_complete_int = spi_init_structure.SPI_TxCompleteIntEnable;
    64fc:	02000002 	andeq	r0, r0, #2
    6500:	69117091 	ldmdbvs	r1, {r0, r4, r7, ip, sp, lr}
  boolean QueueEnd_Request_int = spi_init_structure.SPI_QueueEndIntEnable; 
    6504:	eb150100 	bl	54690c <__etext+0x53dc64>
    6508:	02000001 	andeq	r0, r0, #1
  boolean txFIFO_underflow_int = spi_init_structure.SPI_TxFIFO_UnderflowIntEnable;
    650c:	86126791 			; <UNDEFINED> instruction: 0x86126791
    6510:	01000020 	tsteq	r0, r0, lsr #32
  boolean rxFIFO_overflow_int = spi_init_structure.SPI_RxFIFO_OverflowIntEnable;
    6514:	0001d417 	andeq	sp, r1, r7, lsl r4
    6518:	60910200 	addsvs	r0, r1, r0, lsl #4
  boolean txFIFO_Fill_int = spi_init_structure.SPI_TxFIFO_FillIntEnable;
    651c:	72637011 	rsbvc	r7, r3, #17
    6520:	f6180100 			; <UNDEFINED> instruction: 0xf6180100
  boolean rxFIFO_Drain_int = spi_init_structure.SPI_RxFIFO_DrainIntEnable; 
    6524:	02000001 	andeq	r0, r0, #1
    6528:	70115c91 	mulsvc	r1, r1, ip
  boolean txFIFO_req = spi_init_structure.SPI_TxFIFO_RequestSelect;
    652c:	01007874 	tsteq	r0, r4, ror r8
    6530:	0001101a 	andeq	r1, r1, sl, lsl r0
  boolean rxFIFO_req = spi_init_structure.SPI_RxFIFO_RequestSelect;
    6534:	58910200 	ldmpl	r1, {r9}
    6538:	00208c12 	eoreq	r8, r0, r2, lsl ip
  //ѡSPI
  PortPinsEnum_Type miso_pin = spi_init_structure.SPI_MisoPin;//MISO 
    653c:	f61b0100 			; <UNDEFINED> instruction: 0xf61b0100
    6540:	02000001 	andeq	r0, r0, #1
  PortPinsEnum_Type mosi_pin = spi_init_structure.SPI_MosiPin;//MOSI
    6544:	64115491 	ldrvs	r5, [r1], #-1169	; 0x491
    6548:	01007269 	tsteq	r0, r9, ror #4
  PortPinsEnum_Type sck_pin = spi_init_structure.SPI_SckPin;  //SCK
    654c:	0001eb1c 	andeq	lr, r1, ip, lsl fp
    6550:	53910200 	orrspl	r0, r1, #0
  PortPinsEnum_Type pcs0_pin = spi_init_structure.SPI_Pcs0Pin;//PCS0
    6554:	00211f12 	eoreq	r1, r1, r2, lsl pc
    6558:	eb1d0100 	bl	746960 <__etext+0x73dcb8>
  PortPinsEnum_Type pcs1_pin = spi_init_structure.SPI_Pcs1Pin;//PCS1
    655c:	02000001 	andeq	r0, r0, #1
    6560:	13005291 	movwne	r5, #657	; 0x291
  PortPinsEnum_Type pcs2_pin = spi_init_structure.SPI_Pcs2Pin;//PCS2
    6564:	0020e801 	eoreq	lr, r0, r1, lsl #16
    6568:	01540100 	cmpeq	r4, r0, lsl #2
  PortPinsEnum_Type pcs3_pin = spi_init_structure.SPI_Pcs3Pin;//PCS3
    656c:	000001eb 	andeq	r0, r0, fp, ror #3
    6570:	00004de8 	andeq	r4, r0, r8, ror #27
  PortPinsEnum_Type pcs4_pin = spi_init_structure.SPI_Pcs4Pin;//PCS4
    6574:	00004eda 	ldrdeq	r4, [r0], -sl
    6578:	00001338 	andeq	r1, r0, r8, lsr r3
  PortPinsEnum_Type pcs5_pin = spi_init_structure.SPI_Pcs5Pin;//PCS5
    657c:	00037001 	andeq	r7, r3, r1
    6580:	20341000 	eorscs	r1, r4, r0
  //жϻص
  SPI_ISR_CALLBACK TxComplete_isr = spi_init_structure.SPI_TxCompleteIntIsr;
    6584:	54010000 	strpl	r0, [r1], #-0
  SPI_ISR_CALLBACK QueueEndReq_isr = spi_init_structure.SPI_QueueEndIntIsr;
    6588:	0000028e 	andeq	r0, r0, lr, lsl #5
  SPI_ISR_CALLBACK UnderflowInt_isr = spi_init_structure.SPI_TxFIFO_UnderflowIntIsr;
    658c:	11709102 	cmnne	r0, r2, lsl #2
  SPI_ISR_CALLBACK OverflowInt_isr = spi_init_structure.SPI_RxFIFO_OverflowIntIsr;
    6590:	00787470 	rsbseq	r7, r8, r0, ror r4
  SPI_ISR_CALLBACK FillInt_isr = spi_init_structure.SPI_TxFIFO_FillIntIsr;
    6594:	01105601 	tsteq	r0, r1, lsl #12
  SPI_ISR_CALLBACK DrainInt_isr = spi_init_structure.SPI_RxFIFO_DrainIntIsr;
    6598:	91020000 	mrsls	r0, (UNDEF: 2)
 
    if (spi_mode <= SPI_MODE_MASTER || sck_div <= SPI_SCK_DIV_32768)
    659c:	17831264 	strne	r1, [r3, r4, ror #4]
    65a0:	57010000 	strpl	r0, [r1, -r0]
    65a4:	0000021e 	andeq	r0, r0, lr, lsl r2
    65a8:	00609102 	rsbeq	r9, r0, r2, lsl #2
        return 0;
    65ac:	2057010f 	subscs	r0, r7, pc, lsl #2
    //

  if(spix == SPI0)
    65b0:	86010000 	strhi	r0, [r1], -r0
    65b4:	0001eb01 	andeq	lr, r1, r1, lsl #22
    65b8:	004edc00 	subeq	sp, lr, r0, lsl #24
    65bc:	004fe200 	subeq	lr, pc, r0, lsl #4
  {
    SIM_SCGC6 |= SIM_SCGC6_DSPI0_MASK;  
    65c0:	00137c00 	andseq	r7, r3, r0, lsl #24
    65c4:	03d30100 	bicseq	r0, r3, #0
    65c8:	34100000 	ldrcc	r0, [r0], #-0
    65cc:	01000020 	tsteq	r0, r0, lsr #32
    65d0:	00028e86 	andeq	r8, r2, r6, lsl #29
    65d4:	70910200 	addsvc	r0, r1, r0, lsl #4
    65d8:	01006911 	tsteq	r0, r1, lsl r9
    65dc:	0001eb88 	andeq	lr, r1, r8, lsl #23
    65e0:	67910200 	ldrvs	r0, [r1, r0, lsl #4]
    65e4:	78747011 	ldmdavc	r4!, {r0, r4, ip, sp, lr}^

    //ѡPCS0
    switch(pcs0_pin)
    65e8:	10890100 	addne	r0, r9, r0, lsl #2
    65ec:	02000001 	andeq	r0, r0, #1
    65f0:	86125c91 			; <UNDEFINED> instruction: 0x86125c91
    {
        case PTA14:
            PORTA->PCR[14] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    65f4:	01000020 	tsteq	r0, r0, lsr #32
    65f8:	0001d48a 	andeq	sp, r1, sl, lsl #9
    65fc:	60910200 	addsvs	r0, r1, r0, lsl #4
    6600:	00208c12 	eoreq	r8, r0, r2, lsl ip
        case PTC4:
            PORTA->PCR[4] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    6604:	f68b0100 			; <UNDEFINED> instruction: 0xf68b0100
    6608:	02000001 	andeq	r0, r0, #1
    660c:	14005891 	strne	r5, [r0], #-2193	; 0x891
        default:
            return 0;
    6610:	00202301 	eoreq	r2, r0, r1, lsl #6
    6614:	01aa0100 			; <UNDEFINED> instruction: 0x01aa0100
    else if (miso_pin == PTC7)//miso_pin == PTC7
    {
      PORTC->PCR[7] = 0 | PORT_PCR_MUX(2); //SIN
    } 
  }
  else if(spix == SPI1)
    6618:	00004fe4 	andeq	r4, r0, r4, ror #31
    661c:	00005004 	andeq	r5, r0, r4
    6620:	000013c0 	andeq	r1, r0, r0, asr #7
    6624:	00040a01 	andeq	r0, r4, r1, lsl #20
  {
    SIM_SCGC6 |= SIM_SCGC6_DSPI1_MASK;
    6628:	74701500 	ldrbtvc	r1, [r0], #-1280	; 0x500
    662c:	aa010078 	bge	46814 <__etext+0x3db6c>
    6630:	00000110 	andeq	r0, r0, r0, lsl r1
    6634:	10749102 	rsbsne	r9, r4, r2, lsl #2
    6638:	0000207f 	andeq	r2, r0, pc, ror r0
    663c:	01f6aa01 	mvnseq	sl, r1, lsl #20
    6640:	91020000 	mrsls	r0, (UNDEF: 2)
    6644:	01140070 	tsteq	r4, r0, ror r0
    6648:	00002091 	muleq	r0, r1, r0
    664c:	0401af01 	streq	sl, [r1], #-3841	; 0xf01
    //ѡPCS0
    if(pcs0_pin == PTB10)
    6650:	40000050 	andmi	r0, r0, r0, asr r0
    6654:	f8000050 			; <UNDEFINED> instruction: 0xf8000050
    {
      PORTB->PCR[10] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    6658:	01000013 	tsteq	r0, r3, lsl r0
    665c:	0000044f 	andeq	r0, r0, pc, asr #8
    6660:	78747015 	ldmdavc	r4!, {r0, r2, r4, ip, sp, lr}^
    6664:	10af0100 	adcne	r0, pc, r0, lsl #2
    }
    else if (pcs0_pin == PTE4)//pcs0_pin == PTE4
    6668:	02000001 	andeq	r0, r0, #1
    666c:	fc107491 	ldc2	4, cr7, [r0], {145}	; 0x91
    {
      PORTE->PCR[4] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    6670:	01000020 	tsteq	r0, r0, lsr #32
    6674:	0001ebaf 	andeq	lr, r1, pc, lsr #23
    6678:	73910200 	orrsvc	r0, r1, #0
    }
    //ѡPCS1
    if(pcs1_pin == PTB9)
    667c:	00213710 	eoreq	r3, r1, r0, lsl r7
    6680:	ebaf0100 	bl	febc6a88 <__StackLimit+0xdebc6a88>
    {
      PORTB->PCR[9]  = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    6684:	02000001 	andeq	r0, r0, #1
    6688:	14007291 	strne	r7, [r0], #-657	; 0x291
    668c:	0020d701 	eoreq	sp, r0, r1, lsl #14
    6690:	01ba0100 			; <UNDEFINED> instruction: 0x01ba0100
    }
    else if (pcs1_pin == PTE0)//pcs1_pin == PTE0
    6694:	00005040 	andeq	r5, r0, r0, asr #32
    6698:	00005060 	andeq	r5, r0, r0, rrx
    {
      PORTE->PCR[0] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    669c:	00001430 	andeq	r1, r0, r0, lsr r4
    66a0:	00048601 	andeq	r8, r4, r1, lsl #12
    66a4:	74701500 	ldrbtvc	r1, [r0], #-1280	; 0x500
    66a8:	ba010078 	blt	46890 <__etext+0x3dbe8>
    }
    //ѡPCS2
    if(pcs2_pin == PTE5)
    66ac:	00000110 	andeq	r0, r0, r0, lsl r1
    66b0:	10749102 	rsbsne	r9, r4, r2, lsl #2
    {
      PORTE->PCR[5]  = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    66b4:	0000207f 	andeq	r2, r0, pc, ror r0
    66b8:	01f6ba01 	mvnseq	fp, r1, lsl #20
    66bc:	91020000 	mrsls	r0, (UNDEF: 2)
    }

    //ѡPCS3
    if(pcs3_pin == PTE6)
    66c0:	01140070 	tsteq	r4, r0, ror r0
    66c4:	0000206c 	andeq	r2, r0, ip, rrx
    {
      PORTE->PCR[6]  = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    66c8:	6001bf01 	andvs	fp, r1, r1, lsl #30
    66cc:	8a000050 	bhi	6814 <LPLD_SPI_Init+0x34c>
    66d0:	68000050 	stmdavs	r0, {r4, r6}
    66d4:	01000014 	tsteq	r0, r4, lsl r0
    }

    //ѡSCK
    if(sck_pin == PTB11)
    66d8:	000004bd 			; <UNDEFINED> instruction: 0x000004bd
    66dc:	78747015 	ldmdavc	r4!, {r0, r2, r4, ip, sp, lr}^
    {
      PORTB->PCR[11] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    66e0:	10bf0100 	adcsne	r0, pc, r0, lsl #2
    66e4:	02000001 	andeq	r0, r0, #1
    66e8:	fc107491 	ldc2	4, cr7, [r0], {145}	; 0x91
    66ec:	01000020 	tsteq	r0, r0, lsr #32
    }
    else if (sck_pin == PTE2)//sck_pin == PTE2
    66f0:	0001ebbf 			; <UNDEFINED> instruction: 0x0001ebbf
    66f4:	73910200 	orrsvc	r0, r1, #0
    {
      PORTE->PCR[2] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;//SCK
    66f8:	65010f00 	strvs	r0, [r1, #-3840]	; 0xf00
    66fc:	01000021 	tsteq	r0, r1, lsr #32
    6700:	01f601c9 	mvnseq	r0, r9, asr #3
    }
    //ѡMOSI
    if(mosi_pin == PTB16)
    6704:	508c0000 	addpl	r0, ip, r0
    6708:	50a80000 	adcpl	r0, r8, r0
    {
      PORTB->PCR[16] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;//SOUT
    670c:	14a00000 	strtne	r0, [r0], #0
    6710:	f8010000 			; <UNDEFINED> instruction: 0xf8010000
    6714:	15000004 	strne	r0, [r0, #-4]
    6718:	00787470 	rsbseq	r7, r8, r0, ror r4
    }
    else if (mosi_pin == PTE1)//mosi_pin == PTE1
    671c:	0110c901 	tsteq	r0, r1, lsl #18
    6720:	91020000 	mrsls	r0, (UNDEF: 2)
    {
      PORTE->PCR[1] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;//SOUT
    6724:	6d74116c 	ldfvse	f1, [r4, #-432]!	; 0xfffffe50
    6728:	cb010070 	blgt	468f0 <__etext+0x3dc48>
    672c:	000001f6 	strdeq	r0, [r0], -r6
    6730:	00749102 	rsbseq	r9, r4, r2, lsl #2
    }
    //ѡMISO
    if(miso_pin == PTB17)
    6734:	2104010f 	tstcs	r4, pc, lsl #2
    6738:	d0010000 	andle	r0, r1, r0
    {
      PORTB->PCR[17] = 0 | PORT_PCR_MUX(2); //SIN
    673c:	0001eb01 	andeq	lr, r1, r1, lsl #22
    6740:	0050a800 	subseq	sl, r0, r0, lsl #16
    6744:	0050d200 	subseq	sp, r0, r0, lsl #4
    6748:	0014d800 	andseq	sp, r4, r0, lsl #16
    }
    else if (miso_pin == PTE3)//miso_pin == PTE3
    674c:	05330100 	ldreq	r0, [r3, #-256]!	; 0x100
    6750:	70150000 	andsvc	r0, r5, r0
    {
      PORTE->PCR[3] = 0 | PORT_PCR_MUX(2); //SIN
    6754:	01007874 	tsteq	r0, r4, ror r8
    6758:	000110d0 	ldrdeq	r1, [r1], -r0
    675c:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    6760:	0020fc10 	eoreq	pc, r0, r0, lsl ip	; <UNPREDICTABLE>
    } 
  }
  else if(spix == SPI2)
    6764:	ebd00100 	bl	ff406b6c <__StackLimit+0xdf406b6c>
    6768:	02000001 	andeq	r0, r0, #1
    676c:	16007391 			; <UNDEFINED> instruction: 0x16007391
    6770:	00212601 	eoreq	r2, r1, r1, lsl #12
  {
    SIM_SCGC3 |= SIM_SCGC3_DSPI2_MASK;
    6774:	01d80100 	bicseq	r0, r8, r0, lsl #2
    6778:	000050d4 	ldrdeq	r5, [r0], -r4
    677c:	000050f6 	strdeq	r5, [r0], -r6
    6780:	00001510 	andeq	r1, r0, r0, lsl r5
    6784:	3d011601 	stccc	6, cr1, [r1, #-4]
    6788:	01000021 	tsteq	r0, r1, lsr #32
    678c:	50f801dd 	ldrsbtpl	r0, [r8], #29
    6790:	511a0000 	tstpl	sl, r0
    6794:	153c0000 	ldrne	r0, [ip, #-0]!
    6798:	16010000 	strne	r0, [r1], -r0
    //ѡPCS0
    if(pcs0_pin == PTD11)
    679c:	0020a401 	eoreq	sl, r0, r1, lsl #8
    67a0:	01e20100 	mvneq	r0, r0, lsl #2
    {
      PORTD->PCR[11] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    67a4:	0000511c 	andeq	r5, r0, ip, lsl r1
    67a8:	0000513e 	andeq	r5, r0, lr, lsr r1
    67ac:	00001568 	andeq	r1, r0, r8, ror #10
    67b0:	b5011601 	strlt	r1, [r1, #-1537]	; 0x601
    }
    else if (pcs0_pin == PTB20)//pcs0_pin == PTB20
    67b4:	01000020 	tsteq	r0, r0, lsr #32
    67b8:	514001e8 	smlalttpl	r0, r0, r8, r1	; <UNPREDICTABLE>
    {
      PORTB->PCR[20] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    67bc:	51620000 	cmnpl	r2, r0
    67c0:	15940000 	ldrne	r0, [r4]
    67c4:	16010000 	strne	r0, [r1], -r0
    }
    //ѡPCS1
    if(pcs1_pin == PTD15)
    67c8:	0020c601 	eoreq	ip, r0, r1, lsl #12
    67cc:	01ee0100 	mvneq	r0, r0, lsl #2
    {
      PORTD->PCR[15]  = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    67d0:	00005164 	andeq	r5, r0, r4, ror #2
    67d4:	00005186 	andeq	r5, r0, r6, lsl #3
    67d8:	000015c0 	andeq	r1, r0, r0, asr #11
    67dc:	021e0501 	andseq	r0, lr, #4194304	; 0x400000
    }

    //ѡSCK
    if(sck_pin == PTD12)
    67e0:	05b10000 	ldreq	r0, [r1, #0]!
    67e4:	81060000 	mrshi	r0, (UNDEF: 6)
    {
      PORTD->PCR[12] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;
    67e8:	04000000 	streq	r0, [r0], #-0
    67ec:	21161700 	tstcs	r6, r0, lsl #14
    67f0:	0b010000 	bleq	467f8 <__etext+0x3db50>
    67f4:	000005a1 	andeq	r0, r0, r1, lsr #11
    }
    else if (sck_pin == PTB21)//sck_pin == PTB21
    67f8:	50030501 	andpl	r0, r3, r1, lsl #10
    67fc:	001fff16 	andseq	pc, pc, r6, lsl pc	; <UNPREDICTABLE>
    {
      PORTB->PCR[21] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;//SCK
    6800:	00000927 	andeq	r0, r0, r7, lsr #18
    6804:	0f9b0002 	svceq	0x009b0002
    6808:	01040000 	mrseq	r0, (UNDEF: 4)
    }
    //ѡMOSI
    if(mosi_pin == PTD13)
    680c:	00000234 	andeq	r0, r0, r4, lsr r2
    6810:	00220101 	eoreq	r0, r2, r1, lsl #2
    {
      PORTD->PCR[13] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;//SOUT
    6814:	00082700 	andeq	r2, r8, r0, lsl #14
    6818:	00518800 	subseq	r8, r1, r0, lsl #16
    681c:	0054ee00 	subseq	lr, r4, r0, lsl #28
    6820:	00117d00 	andseq	r7, r1, r0, lsl #26
    }
    else if (mosi_pin == PTB22)//mosi_pin == PTB22
    6824:	06010200 	streq	r0, [r1], -r0, lsl #4
    6828:	0000070b 	andeq	r0, r0, fp, lsl #14
    {
      PORTB->PCR[22] = 0 | PORT_PCR_MUX(2) | PORT_PCR_DSE_MASK;//SOUT
    682c:	0009dd03 	andeq	sp, r9, r3, lsl #26
    6830:	372a0200 	strcc	r0, [sl, -r0, lsl #4]!
    6834:	02000000 	andeq	r0, r0, #0
    6838:	07090801 	streq	r0, [r9, -r1, lsl #16]
    }
    //ѡMISO
    if(miso_pin == PTD14)
    683c:	02020000 	andeq	r0, r2, #0
    6840:	00073b05 	andeq	r3, r7, r5, lsl #22
    {
      PORTD->PCR[14] = 0 | PORT_PCR_MUX(2); //SIN
    6844:	07020200 	streq	r0, [r2, -r0, lsl #4]
    6848:	00000492 	muleq	r0, r2, r4
    684c:	96050402 	strls	r0, [r5], -r2, lsl #8
    6850:	03000001 	movweq	r0, #1
    }
    else if (miso_pin == PTB23)//miso_pin == PTB23
    6854:	0000079b 	muleq	r0, fp, r7
    6858:	005e5002 	subseq	r5, lr, r2
    {
      PORTB->PCR[23] = 0 | PORT_PCR_MUX(2); //SIN
    685c:	04020000 	streq	r0, [r2], #-0
    6860:	0001e407 	andeq	lr, r1, r7, lsl #8
    6864:	05080200 	streq	r0, [r8, #-512]	; 0x200
    } 
  }

  spix->MCR &=  ~(SPI_MCR_MDIS_MASK);
    6868:	00000191 	muleq	r0, r1, r1
    686c:	df070802 	svcle	0x00070802
    6870:	04000001 	streq	r0, [r0], #-1
  spix->MCR |=  (SPI_MCR_HALT_MASK        
    6874:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    6878:	04020074 	streq	r0, [r2], #-116	; 0x74
    687c:	0001e907 	andeq	lr, r1, r7, lsl #18
    6880:	03010500 	movweq	r0, #5376	; 0x1500
    6884:	0003a04b 	andeq	sl, r3, fp, asr #32
                |SPI_MCR_PCSIS_MASK       
                |SPI_MCR_CLR_TXF_MASK    
                |SPI_MCR_CLR_RXF_MASK); 
 
  //ѡSPIģʽ
  switch (spi_mode)
    6888:	0aa50600 	beq	fe948090 <__StackLimit+0xde948090>
    688c:	06000000 	streq	r0, [r0], -r0
    6890:	0000069a 	muleq	r0, sl, r6
  {
    case SPI_MODE_SLAVE:
        spix->MCR &= ~SPI_MCR_MSTR_MASK;
    6894:	020a0601 	andeq	r0, sl, #1048576	; 0x100000
    6898:	06020000 	streq	r0, [r2], -r0
    689c:	00000000 	andeq	r0, r0, r0
        break;
    case SPI_MODE_MASTER:
        spix->MCR |= SPI_MCR_MSTR_MASK;
    68a0:	00c40603 	sbceq	r0, r4, r3, lsl #12
    68a4:	06040000 	streq	r0, [r4], -r0
    68a8:	000001bd 			; <UNDEFINED> instruction: 0x000001bd
        break;
    68ac:	08bf0605 	ldmeq	pc!, {r0, r2, r9, sl}	; <UNPREDICTABLE>
    default:
        return 0;
    68b0:	06060000 	streq	r0, [r6], -r0
  }

  //ѡʹtx FIFO
  if(txFIFO_enable == TRUE)
    68b4:	0000027d 	andeq	r0, r0, sp, ror r2
    68b8:	028b0607 	addeq	r0, fp, #7340032	; 0x700000
  {
    spix->MCR &= ~SPI_MCR_DIS_TXF_MASK; 
    68bc:	06080000 	streq	r0, [r8], -r0
    68c0:	00000299 	muleq	r0, r9, r2
    68c4:	09a40609 	stmibeq	r4!, {r0, r3, r9, sl}
    68c8:	060a0000 	streq	r0, [sl], -r0
  }
  else
  {
    spix->MCR |= SPI_MCR_DIS_TXF_MASK;//ѡͳʽ
    68cc:	00000a11 	andeq	r0, r0, r1, lsl sl
    68d0:	059a060b 	ldreq	r0, [sl, #1547]	; 0x60b
    68d4:	060c0000 	streq	r0, [ip], -r0
  }
  //ѡʹRx FIFO
  if(rxFIFO_enable == TRUE)
    68d8:	000009c5 	andeq	r0, r0, r5, asr #19
    68dc:	054b060d 	strbeq	r0, [fp, #-1549]	; 0x60d
  {
    spix->MCR &= ~SPI_MCR_DIS_RXF_MASK;
    68e0:	060e0000 	streq	r0, [lr], -r0
    68e4:	000003de 	ldrdeq	r0, [r0], -lr
    68e8:	0108060f 	tsteq	r8, pc, lsl #12
  }
  else
  {
    spix->MCR |= SPI_MCR_DIS_RXF_MASK; //ѡͳʽ
    68ec:	06100000 	ldreq	r0, [r0], -r0
    68f0:	0000068b 	andeq	r0, r0, fp, lsl #13
    68f4:	01480611 	cmpeq	r8, r1, lsl r6
  }
  //ѡʹܷж
  if(tx_complete_int == TRUE)
    68f8:	06120000 	ldreq	r0, [r2], -r0
    68fc:	000006f1 	strdeq	r0, [r0], -r1
  {
    spix->RSER |= SPI_RSER_TCF_RE_MASK; 
    6900:	037a0613 	cmneq	sl, #19922944	; 0x1300000
    6904:	06140000 	ldreq	r0, [r4], -r0
    6908:	00000818 	andeq	r0, r0, r8, lsl r8
    690c:	03cf0615 	biceq	r0, pc, #22020096	; 0x1500000
  }
  else
  { 
    spix->RSER &= ~SPI_RSER_TCF_RE_MASK;
    6910:	06160000 	ldreq	r0, [r6], -r0
    6914:	000008b0 			; <UNDEFINED> instruction: 0x000008b0
    6918:	042f0617 	strteq	r0, [pc], #-1559	; 6920 <LPLD_SPI_Init+0x458>
  }
  //ѡʹܷͶнж
  if(QueueEnd_Request_int == TRUE)
    691c:	06180000 	ldreq	r0, [r8], -r0
    6920:	00000139 	andeq	r0, r0, r9, lsr r1
  {
    spix->RSER |=SPI_RSER_EOQF_RE_MASK;
    6924:	03bf0619 			; <UNDEFINED> instruction: 0x03bf0619
    6928:	061a0000 	ldreq	r0, [sl], -r0
    692c:	00000898 	muleq	r0, r8, r8
  }
  else
    spix->RSER &= ~SPI_RSER_EOQF_RE_MASK;
    6930:	040d061b 	streq	r0, [sp], #-1563	; 0x61b
    6934:	061c0000 	ldreq	r0, [ip], -r0
    6938:	000008e8 	andeq	r0, r0, r8, ror #17
  //ѡʹtxFIFOΪж
  if(txFIFO_underflow_int== TRUE)
    693c:	051f061d 	ldreq	r0, [pc, #-1565]	; 6327 <LPLD_PIT_TimeGetUs+0x7b>
    6940:	061e0000 	ldreq	r0, [lr], -r0
  {
    spix->RSER |=SPI_RSER_TFUF_RE_MASK;
    6944:	000003af 	andeq	r0, r0, pc, lsr #7
    6948:	08cf061f 	stmiaeq	pc, {r0, r1, r2, r3, r4, r9, sl}^	; <UNPREDICTABLE>
    694c:	06200000 	strteq	r0, [r0], -r0
    6950:	00000212 	andeq	r0, r0, r2, lsl r2
  }
  else
    spix->RSER &= ~SPI_RSER_TFUF_RE_MASK;
    6954:	03f30621 	mvnseq	r0, #34603008	; 0x2100000
    6958:	06220000 	strteq	r0, [r2], -r0
    695c:	00000117 	andeq	r0, r0, r7, lsl r1
  //ѡʹrxFIFOж
  if(rxFIFO_overflow_int== TRUE)
    6960:	05e00623 	strbeq	r0, [r0, #1571]!	; 0x623
    6964:	06240000 	strteq	r0, [r4], -r0
  {
    spix->RSER |=SPI_RSER_RFOF_RE_MASK;
    6968:	000004d3 	ldrdeq	r0, [r0], -r3
    696c:	0a370625 	beq	dc8208 <__etext+0xdbf560>
    6970:	06260000 	strteq	r0, [r6], -r0
  }
  else
  {
    spix->RSER &= ~SPI_RSER_RFOF_RE_MASK;
    6974:	00000653 	andeq	r0, r0, r3, asr r6
    6978:	075e0627 	ldrbeq	r0, [lr, -r7, lsr #12]
    697c:	06280000 	strteq	r0, [r8], -r0
  }
  //ѡʹtxFIFOݽжϻDMA
  if(txFIFO_Fill_int== TRUE)
    6980:	00000a53 	andeq	r0, r0, r3, asr sl
    6984:	0a670629 	beq	19c8230 <__etext+0x19bf588>
  {
    spix->RSER |=SPI_RSER_TFFF_RE_MASK;
    6988:	062a0000 	strteq	r0, [sl], -r0
    698c:	0000077f 	andeq	r0, r0, pc, ror r7
    6990:	0a70062b 	beq	1c08244 <__etext+0x1bff59c>
    6994:	062c0000 	strteq	r0, [ip], -r0
  }
  else
  {
    spix->RSER &= ~SPI_RSER_TFFF_RE_MASK;
    6998:	00000089 	andeq	r0, r0, r9, lsl #1
    699c:	0166062d 	cmneq	r6, sp, lsr #12
    69a0:	062e0000 	strteq	r0, [lr], -r0
  }
  //ѡʹrxFIFOǿжϻDMA
  if(rxFIFO_Drain_int== TRUE)
    69a4:	0000058b 	andeq	r0, r0, fp, lsl #11
    69a8:	0877062f 	ldmdaeq	r7!, {r0, r1, r2, r3, r5, r9, sl}^
  {
    spix->RSER |=SPI_RSER_RFDF_RE_MASK;
    69ac:	06300000 	ldrteq	r0, [r0], -r0
    69b0:	00000863 	andeq	r0, r0, r3, ror #16
    69b4:	02b70631 	adcseq	r0, r7, #51380224	; 0x3100000
  }
  else
  {
    spix->RSER &= ~SPI_RSER_RFDF_RE_MASK;
    69b8:	06320000 	ldrteq	r0, [r2], -r0
    69bc:	00000368 	andeq	r0, r0, r8, ror #6
    69c0:	0a8e0633 	beq	fe388294 <__StackLimit+0xde388294>
  }
  //ѡʹtxFIFOжϻDMA
  if(txFIFO_req == SPI_FIFO_DMAREQUEST)
    69c4:	06340000 	ldrteq	r0, [r4], -r0
    69c8:	0000006c 	andeq	r0, r0, ip, rrx
  {
    spix->RSER |=SPI_RSER_TFFF_DIRS_MASK;
    69cc:	03990635 	orrseq	r0, r9, #55574528	; 0x3500000
    69d0:	06360000 	ldrteq	r0, [r6], -r0
    69d4:	000001ae 	andeq	r0, r0, lr, lsr #3
    69d8:	01f60637 	mvnseq	r0, r7, lsr r6
  }
  else
  {
    spix->RSER &= ~SPI_RSER_TFFF_DIRS_MASK;
    69dc:	06380000 	ldrteq	r0, [r8], -r0
    69e0:	000001cb 	andeq	r0, r0, fp, asr #3
    69e4:	043e0639 	ldrteq	r0, [lr], #-1593	; 0x639
  }
  //ѡʹrxFIFOжϻDMA
  if(rxFIFO_req == SPI_FIFO_DMAREQUEST)
    69e8:	063a0000 	ldrteq	r0, [sl], -r0
    69ec:	000004db 	ldrdeq	r0, [r0], -fp
  {
    spix->RSER |= SPI_RSER_RFDF_DIRS_MASK;
    69f0:	0745063b 	smlaldxeq	r0, r5, fp, r6
    69f4:	063c0000 	ldrteq	r0, [ip], -r0
    69f8:	00000918 	andeq	r0, r0, r8, lsl r9
  }
  else 
  {
    spix->RSER &= ~SPI_RSER_RFDF_DIRS_MASK;
    69fc:	0454063d 	ldrbeq	r0, [r4], #-1597	; 0x63d
    6a00:	063e0000 	ldrteq	r0, [lr], -r0
    6a04:	0000046a 	andeq	r0, r0, sl, ror #8
  }
  //жϻص

  if(spix == SPI0)
    6a08:	0a79063f 	beq	1e4830c <__etext+0x1e3f664>
    6a0c:	00c00000 	sbceq	r0, r0, r0
    6a10:	00099406 	andeq	r9, r9, r6, lsl #8
    6a14:	0600c100 	streq	ip, [r0], -r0, lsl #2
  {
    if(tx_complete_int == TRUE)
    6a18:	0000057d 	andeq	r0, r0, sp, ror r5
    6a1c:	a50600c2 	strge	r0, [r6, #-194]	; 0xc2
    { SPI0_ISR[SPI_TxComplete_Int] = TxComplete_isr; }
    6a20:	c3000004 	movwgt	r0, #4
    6a24:	0a210600 	beq	84822c <__etext+0x83f584>
    6a28:	00c40000 	sbceq	r0, r4, r0
    if(QueueEnd_Request_int == TRUE)
    6a2c:	0009f806 	andeq	pc, r9, r6, lsl #16
    6a30:	0600c500 	streq	ip, [r0], -r0, lsl #10
    { SPI0_ISR[SPI_QueueEndReq_Int] = QueueEndReq_isr; }
    6a34:	0000097a 	andeq	r0, r0, sl, ror r9
    6a38:	c30600c6 	movwgt	r0, #24774	; 0x60c6
    6a3c:	c7000004 	strgt	r0, [r0, -r4]
    if(txFIFO_underflow_int == TRUE)
    6a40:	053d0600 	ldreq	r0, [sp, #-1536]!	; 0x600
    6a44:	00c80000 	sbceq	r0, r8, r0
    { SPI0_ISR[SPI_TxFIFO_UnderflowInt] = UnderflowInt_isr; }
    6a48:	00040406 	andeq	r0, r4, r6, lsl #8
    6a4c:	0600c900 	streq	ip, [r0], -r0, lsl #18
    6a50:	0000022b 	andeq	r0, r0, fp, lsr #4
    if(rxFIFO_overflow_int == TRUE)
    6a54:	b30600ca 	movwlt	r0, #24778	; 0x60ca
    6a58:	cb000009 	blgt	6a84 <LPLD_SPI_Init+0x5bc>
    { SPI0_ISR[SPI_RxFIFO_OverflowInt] = OverflowInt_isr; }
    6a5c:	066f0600 	strbteq	r0, [pc], -r0, lsl #12
    6a60:	00cc0000 	sbceq	r0, ip, r0
    6a64:	00067806 	andeq	r7, r6, r6, lsl #16
    if(txFIFO_Fill_int == TRUE && txFIFO_req == SPI_FIFO_INTREQUEST)
    6a68:	0600cd00 	streq	ip, [r0], -r0, lsl #26
    6a6c:	000002cd 	andeq	r0, r0, sp, asr #5
    6a70:	d60600ce 	strle	r0, [r6], -lr, asr #1
    6a74:	cf000002 	svcgt	0x00000002
    { SPI0_ISR[SPI_TxFIFO_FillInt] = FillInt_isr; }
    6a78:	02df0600 	sbcseq	r0, pc, #0
    6a7c:	00d00000 	sbcseq	r0, r0, r0
    6a80:	00021a06 	andeq	r1, r2, r6, lsl #20
    if(rxFIFO_Drain_int == TRUE && rxFIFO_req == SPI_FIFO_INTREQUEST)
    6a84:	0600d100 	streq	sp, [r0], -r0, lsl #2
    6a88:	00000462 	andeq	r0, r0, r2, ror #8
    6a8c:	890600d2 	stmdbhi	r6, {r1, r4, r6, r7}
    6a90:	d3000003 	movwle	r0, #3
    6a94:	047a0600 	ldrbteq	r0, [sl], #-1536	; 0x600
    { SPI0_ISR[SPI_RxFIFO_DrainInt] = DrainInt_isr; }
    6a98:	00d40000 	sbcseq	r0, r4, r0
    6a9c:	00002e06 	andeq	r2, r0, r6, lsl #28
    6aa0:	0600d500 	streq	sp, [r0], -r0, lsl #10
  }
  else if (spix == SPI1)
    6aa4:	000007cb 	andeq	r0, r0, fp, asr #15
    6aa8:	450600d6 	strmi	r0, [r6, #-214]	; 0xd6
    6aac:	d7000000 	strle	r0, [r0, -r0]
    6ab0:	05ec0600 	strbeq	r0, [ip, #1536]!	; 0x600
  {
    if(tx_complete_int == TRUE)
    6ab4:	00d80000 	sbcseq	r0, r8, r0
    6ab8:	00022206 	andeq	r2, r2, r6, lsl #4
    { SPI1_ISR[SPI_TxComplete_Int] = TxComplete_isr; }
    6abc:	0600d900 	streq	sp, [r0], -r0, lsl #18
    6ac0:	00000753 	andeq	r0, r0, r3, asr r7
    6ac4:	040600da 	streq	r0, [r6], #-218	; 0xda
    if(QueueEnd_Request_int == TRUE)
    6ac8:	db000009 	blle	6af4 <LPLD_SPI_Init+0x62c>
    6acc:	00de0600 	sbcseq	r0, lr, r0, lsl #12
    { SPI1_ISR[SPI_QueueEndReq_Int] = QueueEndReq_isr; }
    6ad0:	00dc0000 	sbcseq	r0, ip, r0
    6ad4:	00005606 	andeq	r5, r0, r6, lsl #12
    6ad8:	0600dd00 	streq	sp, [r0], -r0, lsl #26
    if(txFIFO_underflow_int == TRUE)
    6adc:	0000019f 	muleq	r0, pc, r1	; <UNPREDICTABLE>
    6ae0:	440600de 	strmi	r0, [r6], #-222	; 0xde
    { SPI1_ISR[SPI_TxFIFO_UnderflowInt] = UnderflowInt_isr; }
    6ae4:	df00000a 	svcle	0x0000000a
    6ae8:	00a60600 	adceq	r0, r6, r0, lsl #12
    6aec:	00e00000 	rsceq	r0, r0, r0
    if(rxFIFO_overflow_int == TRUE)
    6af0:	0005d706 	andeq	sp, r5, r6, lsl #14
    6af4:	0600e100 	streq	lr, [r0], -r0, lsl #2
    { SPI1_ISR[SPI_RxFIFO_OverflowInt] = OverflowInt_isr; }
    6af8:	000004ea 	andeq	r0, r0, sl, ror #9
    6afc:	ea0600e2 	b	186e8c <__etext+0x17e1e4>
    6b00:	e3000003 	movw	r0, #3
    if(txFIFO_Fill_int == TRUE && txFIFO_req == SPI_FIFO_INTREQUEST)
    6b04:	004e0600 	subeq	r0, lr, r0, lsl #12
    6b08:	00e40000 	rsceq	r0, r4, r0
    6b0c:	00030606 	andeq	r0, r3, r6, lsl #12
    6b10:	0600e500 	streq	lr, [r0], -r0, lsl #10
    { SPI1_ISR[SPI_TxFIFO_FillInt] = FillInt_isr; }
    6b14:	000000b4 	strheq	r0, [r0], -r4
    6b18:	f50600e6 			; <UNDEFINED> instruction: 0xf50600e6
    6b1c:	e7000005 	str	r0, [r0, -r5]
    if(rxFIFO_Drain_int == TRUE && rxFIFO_req == SPI_FIFO_INTREQUEST)
    6b20:	012a0600 	teqeq	sl, r0, lsl #12
    6b24:	00e80000 	rsceq	r0, r8, r0
    6b28:	00061006 	andeq	r1, r6, r6
    6b2c:	0600e900 	streq	lr, [r0], -r0, lsl #18
    { SPI1_ISR[SPI_RxFIFO_DrainInt] = DrainInt_isr; }
    6b30:	00000731 	andeq	r0, r0, r1, lsr r7
    6b34:	2c0600ea 	stccs	0, cr0, [r6], {234}	; 0xea
    6b38:	eb000006 	bl	6b58 <LPLD_SPI_Init+0x690>
  }
  else if (spix == SPI2)
    6b3c:	06360600 	ldrteq	r0, [r6], -r0, lsl #12
    6b40:	00ec0000 	rsceq	r0, ip, r0
    6b44:	00089006 	andeq	r9, r8, r6
    6b48:	0600ed00 	streq	lr, [r0], -r0, lsl #26
  {
    if(tx_complete_int == TRUE)
    6b4c:	00000661 	andeq	r0, r0, r1, ror #12
    6b50:	c30600ee 	movwgt	r0, #24814	; 0x60ee
    { SPI2_ISR[SPI_TxComplete_Int] = TxComplete_isr; }
    6b54:	ef000005 	svc	0x00000005
    6b58:	06810600 	streq	r0, [r1], r0, lsl #12
    6b5c:	00f00000 	rscseq	r0, r0, r0
    if(QueueEnd_Request_int == TRUE)
    6b60:	0000f806 	andeq	pc, r0, r6, lsl #16
    6b64:	0600f100 	streq	pc, [r0], -r0, lsl #2
    { SPI2_ISR[SPI_QueueEndReq_Int] = QueueEndReq_isr; }
    6b68:	000009e5 	andeq	r0, r0, r5, ror #19
    6b6c:	5d0600f2 	stcpl	0, cr0, [r6, #-968]	; 0xfffffc38
    6b70:	f3000003 	vhadd.u8	d0, d0, d3
    if(txFIFO_underflow_int == TRUE)
    6b74:	02a70600 	adceq	r0, r7, #0
    6b78:	00f40000 	rscseq	r0, r4, r0
    { SPI2_ISR[SPI_TxFIFO_UnderflowInt] = UnderflowInt_isr; }
    6b7c:	0002e806 	andeq	lr, r2, r6, lsl #16
    6b80:	0600f500 	streq	pc, [r0], -r0, lsl #10
    6b84:	0000041d 	andeq	r0, r0, sp, lsl r4
    if(rxFIFO_overflow_int == TRUE)
    6b88:	260600f6 			; <UNDEFINED> instruction: 0x260600f6
    6b8c:	f7000004 			; <UNDEFINED> instruction: 0xf7000004
    { SPI2_ISR[SPI_RxFIFO_OverflowInt] = OverflowInt_isr; }
    6b90:	01850600 	orreq	r0, r5, r0, lsl #12
    6b94:	00f80000 	rscseq	r0, r8, r0
    6b98:	00098806 	andeq	r8, r9, r6, lsl #16
    if(txFIFO_Fill_int == TRUE && txFIFO_req == SPI_FIFO_INTREQUEST)
    6b9c:	0000f900 	andeq	pc, r0, r0, lsl #18
    6ba0:	74070402 	strvc	r0, [r7], #-1026	; 0x402
    6ba4:	07000005 	streq	r0, [r0, -r5]
    6ba8:	0000002c 	andeq	r0, r0, ip, lsr #32
    { SPI2_ISR[SPI_TxFIFO_FillInt] = FillInt_isr; }
    6bac:	000003b7 			; <UNDEFINED> instruction: 0x000003b7
    6bb0:	0003a008 	andeq	sl, r3, r8
    6bb4:	07001b00 	streq	r1, [r0, -r0, lsl #22]
    if(rxFIFO_Drain_int == TRUE && rxFIFO_req == SPI_FIFO_INTREQUEST)
    6bb8:	0000002c 	andeq	r0, r0, ip, lsr #32
    6bbc:	000003c7 	andeq	r0, r0, r7, asr #7
    6bc0:	0003a008 	andeq	sl, r3, r8
    6bc4:	07000300 	streq	r0, [r0, -r0, lsl #6]
    { SPI2_ISR[SPI_RxFIFO_DrainInt] = DrainInt_isr; }
    6bc8:	0000002c 	andeq	r0, r0, ip, lsr #32
    6bcc:	000003d7 	ldrdeq	r0, [r0], -r7
    6bd0:	0003a008 	andeq	sl, r3, r8
  }
  //SPI CTARĴSPIʱ
  spix->CTAR[0] &= (~SPI_CTAR_LSBFE_MASK);
    6bd4:	07000700 	streq	r0, [r0, -r0, lsl #14]
    6bd8:	0000002c 	andeq	r0, r0, ip, lsr #32
    6bdc:	000003e7 	andeq	r0, r0, r7, ror #7

  spix->CTAR[0] |=  (SPI_CTAR_DBR_MASK  
    6be0:	0003a008 	andeq	sl, r3, r8
    6be4:	07001700 	streq	r1, [r0, -r0, lsl #14]
    6be8:	00000053 	andeq	r0, r0, r3, asr r0
                      |SPI_CTAR_PBR(0)           
                      |SPI_CTAR_FMSZ(7));        
                       
  //SPIƵ
  //SCKƵ = g_bus_clock/ SCK_DIV_x                                             
  spix->CTAR[0] |=SPI_CTAR_BR(sck_div);
    6bec:	000003f7 	strdeq	r0, [r0], -r7
    6bf0:	0003a008 	andeq	sl, r3, r8
    6bf4:	09001f00 	stmdbeq	r0, {r8, r9, sl, fp, ip}
    6bf8:	0000229b 	muleq	r0, fp, r2

  //tCSC = (1/g_bus_clock) x PCSSCK x CSSCK
  //tCSC = 1/50,000,000 x PCSSCK x CSSCK
  spix->CTAR[0] |=SPI_CTAR_PCSSCK(1); 
    6bfc:	2bc20310 	blcs	ff087844 <__StackLimit+0xdf087844>
    6c00:	00000441 	andeq	r0, r0, r1, asr #8
    6c04:	5253430a 	subspl	r4, r3, #671088640	; 0x28000000
  spix->CTAR[0] |=SPI_CTAR_CSSCK(1);  
    6c08:	2bc30300 	blcs	ff0c7810 <__StackLimit+0xdf0c7810>
    6c0c:	00000053 	andeq	r0, r0, r3, asr r0
    6c10:	0a002302 	beq	f820 <__etext+0x6b78>
  
  //tDT = (1/g_bus_clock) x PDT x DT
  spix->CTAR[0] |=SPI_CTAR_DT(1);
    6c14:	00525350 	subseq	r5, r2, r0, asr r3
    6c18:	532bc403 	teqpl	fp, #50331648	; 0x3000000
    6c1c:	02000000 	andeq	r0, r0, #0
  spix->CTAR[0] |=SPI_CTAR_PDT(1);
    6c20:	430a0423 	movwmi	r0, #42019	; 0xa423
    6c24:	0300524d 	movweq	r5, #589	; 0x24d
    6c28:	00532bc5 	subseq	r2, r3, r5, asr #23
  
  //Config the Delay of the last edge of SCK and the negation of PCS
  //tASC = (1/g_bus_clock) x PASC x ASC
  spix->CTAR[0] |=SPI_CTAR_PASC(1);
    6c2c:	23020000 	movwcs	r0, #8192	; 0x2000
    6c30:	4e430a08 	vmlami.f32	s1, s6, s16
    6c34:	c6030052 			; <UNDEFINED> instruction: 0xc6030052
  spix->CTAR[0] |=SPI_CTAR_ASC(1);
    6c38:	0000532b 	andeq	r5, r0, fp, lsr #6
    6c3c:	0c230200 	sfmeq	f0, 4, [r3], #-0
    6c40:	22810b00 	addcs	r0, r1, #0
  //־λ
  spix->SR |=  (SPI_SR_RFDF_MASK   
    6c44:	c7030000 	strgt	r0, [r3, -r0]
    6c48:	00044d2b 	andeq	r4, r4, fp, lsr #26
    6c4c:	53040c00 	movwpl	r0, #19456	; 0x4c00
    6c50:	0d000004 	stceq	0, cr0, [r0, #-16]
              |SPI_SR_TFFF_MASK
              |SPI_SR_TFUF_MASK
              |SPI_SR_TCF_MASK
              |SPI_SR_EOQF_MASK);
  //ʹSPIx
  spix->MCR &=~SPI_MCR_HALT_MASK; 
    6c54:	000003f7 	strdeq	r0, [r0], -r7
    6c58:	0021aa09 	eoreq	sl, r1, r9, lsl #20
    6c5c:	7c030100 	stfvcs	f0, [r3], {-0}
  
  return 1;
    6c60:	00047433 	andeq	r7, r4, r3, lsr r4
}
    6c64:	52430a00 	subpl	r0, r3, #0
    6c68:	337d0300 	cmncc	sp, #0
    6c6c:	0000002c 	andeq	r0, r0, ip, lsr #32
    6c70:	00002302 	andeq	r2, r0, r2, lsl #6
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_SPI_Deinit(SPI_InitTypeDef spi_init_structure)
{
    6c74:	0022330b 	eoreq	r3, r2, fp, lsl #6
    6c78:	337e0300 	cmncc	lr, #0
    6c7c:	00000480 	andeq	r0, r0, r0, lsl #9
    6c80:	0486040c 	streq	r0, [r6], #1036	; 0x40c
  SPI_MemMapPtr spix = spi_init_structure.SPI_SPIx;
    6c84:	580d0000 	stmdapl	sp, {}	; <UNPREDICTABLE>
  spix->MCR |= SPI_MCR_HALT_MASK; //
    6c88:	09000004 	stmdbeq	r0, {r2}
    6c8c:	00001261 	andeq	r1, r0, r1, ror #4
    6c90:	35a503cc 	strcc	r0, [r5, #972]!	; 0x3cc
  if(spix == SPI0)
    6c94:	00000528 	andeq	r0, r0, r8, lsr #10
    6c98:	5243500a 	subpl	r5, r3, #10
    6c9c:	35a60300 	strcc	r0, [r6, #768]!	; 0x300
    6ca0:	000003e7 	andeq	r0, r0, r7, ror #7
  {
    disable_irq(INT_SPI0 - 16);
    6ca4:	0e002302 	cdpeq	3, 0, cr2, cr0, cr2, {0}
    6ca8:	00001111 	andeq	r1, r0, r1, lsl r1
    SIM_SCGC6 &= ~SIM_SCGC6_DSPI0_MASK;
    6cac:	5335a703 	teqpl	r5, #786432	; 0xc0000
    6cb0:	03000000 	movweq	r0, #0
    6cb4:	0e018023 	cdpeq	0, 0, cr8, cr1, cr3, {1}
    6cb8:	0000145a 	andeq	r1, r0, sl, asr r4
    6cbc:	5335a803 	teqpl	r5, #196608	; 0x30000
    6cc0:	03000000 	movweq	r0, #0
    6cc4:	0e018423 	cdpeq	4, 0, cr8, cr1, cr3, {1}
    6cc8:	00000312 	andeq	r0, r0, r2, lsl r3
    6ccc:	d735a903 	ldrle	sl, [r5, -r3, lsl #18]!
    6cd0:	03000003 	movweq	r0, #3
  }
  else if(spix == SPI1)
    6cd4:	0e018823 	cdpeq	8, 0, cr8, cr1, cr3, {1}
    6cd8:	00001238 	andeq	r1, r0, r8, lsr r2
    6cdc:	5335aa03 	teqpl	r5, #12288	; 0x3000
    6ce0:	03000000 	movweq	r0, #0
  {
    disable_irq(INT_SPI1 - 16);
    6ce4:	0e01a023 	cdpeq	0, 0, cr10, cr1, cr3, {1}
    6ce8:	0000031d 	andeq	r0, r0, sp, lsl r3
    SIM_SCGC6 &= ~SIM_SCGC6_DSPI1_MASK;
    6cec:	a735ab03 	ldrge	sl, [r5, -r3, lsl #22]!
    6cf0:	03000003 	movweq	r0, #3
    6cf4:	0e01a423 	cdpeq	4, 0, cr10, cr1, cr3, {1}
    6cf8:	0000126d 	andeq	r1, r0, sp, ror #4
    6cfc:	5335ac03 	teqpl	r5, #768	; 0x300
    6d00:	03000000 	movweq	r0, #0
    6d04:	0e01c023 	cdpeq	0, 0, cr12, cr1, cr3, {1}
    6d08:	0000114a 	andeq	r1, r0, sl, asr #2
    6d0c:	5335ad03 	teqpl	r5, #192	; 0xc0
    6d10:	03000000 	movweq	r0, #0
  }
  else if(spix == SPI2)
    6d14:	0e01c423 	cdpeq	4, 0, cr12, cr1, cr3, {1}
    6d18:	00001295 	muleq	r0, r5, r2
    6d1c:	5335ae03 	teqpl	r5, #48	; 0x30
    6d20:	03000000 	movweq	r0, #0
  {
    disable_irq(INT_SPI2 - 16);
    6d24:	0001c823 	andeq	ip, r1, r3, lsr #16
    6d28:	0011b10b 	andseq	fp, r1, fp, lsl #2
    SIM_SCGC3 &= ~SIM_SCGC3_DSPI2_MASK;
    6d2c:	35af0300 	strcc	r0, [pc, #768]!	; 7034 <SPI0_IRQHandler+0xe8>
    6d30:	00000534 	andeq	r0, r0, r4, lsr r5
    6d34:	053a040c 	ldreq	r0, [sl, #-1036]!	; 0x40c
    6d38:	8b0d0000 	blhi	346d40 <__etext+0x33e098>
    6d3c:	0f000004 	svceq	0x00000004
    6d40:	00001044 	andeq	r1, r0, r4, asr #32
    6d44:	95031070 	strls	r1, [r3, #-112]	; 0x70
    6d48:	00071b3d 	andeq	r1, r7, sp, lsr fp
    6d4c:	10380e00 	eorsne	r0, r8, r0, lsl #28
    6d50:	96030000 	strls	r0, [r3], -r0
  }
  else
    return 0;
    6d54:	0000533d 	andeq	r5, r0, sp, lsr r3
    6d58:	00230200 	eoreq	r0, r3, r0, lsl #4
  return 1;
    6d5c:	000d020e 	andeq	r0, sp, lr, lsl #4
}
    6d60:	3d970300 	ldccc	3, cr0, [r7]
    6d64:	00000053 	andeq	r0, r0, r3, asr r0
    6d68:	0e042302 	cdpeq	3, 0, cr2, cr4, cr2, {0}
    6d6c:	00000312 	andeq	r0, r0, r2, lsl r3
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_SPI_EnableIrq(SPI_InitTypeDef spi_init_structure)
{
    6d70:	1b3d9803 	blne	f6cd84 <__etext+0xf640dc>
    6d74:	02000007 	andeq	r0, r0, #7
    6d78:	3e0e0823 	cdpcc	8, 0, cr0, cr14, cr3, {1}
    6d7c:	03000010 	movweq	r0, #16
  SPI_MemMapPtr spix = spi_init_structure.SPI_SPIx;
    6d80:	00533d99 			; <UNDEFINED> instruction: 0x00533d99
  if(spix == SPI0)
    6d84:	23030000 	movwcs	r0, #12288	; 0x3000
    6d88:	1d0e2084 	stcne	0, cr2, [lr, #-528]	; 0xfffffdf0
    6d8c:	03000003 	movweq	r0, #3
    6d90:	03b73d9a 			; <UNDEFINED> instruction: 0x03b73d9a
  {
    enable_irq(INT_SPI0 - 16);
    6d94:	23030000 	movwcs	r0, #12288	; 0x3000
    6d98:	4f0e2088 	svcmi	0x000e2088
  }
  else if(spix == SPI1)
    6d9c:	03000010 	movweq	r0, #16
    6da0:	00533d9b 			; <UNDEFINED> instruction: 0x00533d9b
    6da4:	23030000 	movwcs	r0, #12288	; 0x3000
    6da8:	550e208c 	strpl	r2, [lr, #-140]	; 0x8c
  {
    enable_irq(INT_SPI1 - 16);
    6dac:	03000010 	movweq	r0, #16
    6db0:	00533d9c 			; <UNDEFINED> instruction: 0x00533d9c
  }
  else if(spix == SPI2)
    6db4:	23030000 	movwcs	r0, #12288	; 0x3000
    6db8:	5b0e2090 	blpl	38f000 <__etext+0x386358>
    6dbc:	03000010 	movweq	r0, #16
    6dc0:	00533d9d 			; <UNDEFINED> instruction: 0x00533d9d
  {
    enable_irq(INT_SPI2 - 16);
    6dc4:	23030000 	movwcs	r0, #12288	; 0x3000
    6dc8:	610e2094 	swpvs	r2, r4, [lr]
  }
  else
    return 0;
    6dcc:	03000010 	movweq	r0, #16
    6dd0:	00533d9e 			; <UNDEFINED> instruction: 0x00533d9e

  return 1;
    6dd4:	23030000 	movwcs	r0, #12288	; 0x3000
}
    6dd8:	9a0e2098 	bls	38f040 <__etext+0x386398>
    6ddc:	0300000a 	movweq	r0, #10
    6de0:	03c73d9f 	biceq	r3, r7, #10176	; 0x27c0
    6de4:	23030000 	movwcs	r0, #12288	; 0x3000
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_SPI_DisableIrq(SPI_InitTypeDef spi_init_structure)
{
    6de8:	640e209c 	strvs	r2, [lr], #-156	; 0x9c
    6dec:	0300000c 	movweq	r0, #12
    6df0:	00533da0 	subseq	r3, r3, r0, lsr #27
    6df4:	23030000 	movwcs	r0, #12288	; 0x3000
  SPI_MemMapPtr spix = spi_init_structure.SPI_SPIx;
    6df8:	690e20a4 	stmdbvs	lr, {r2, r5, r7, sp}
  if(spix == SPI0)
    6dfc:	0300000c 	movweq	r0, #12
    6e00:	00533da1 	subseq	r3, r3, r1, lsr #27
    6e04:	23030000 	movwcs	r0, #12288	; 0x3000
    6e08:	6f0e20a8 	svcvs	0x000e20a8
  {
    disable_irq(INT_SPI0 - 16);
    6e0c:	0300000c 	movweq	r0, #12
    6e10:	00533da2 	subseq	r3, r3, r2, lsr #27
  }
  else if(spix == SPI1)
    6e14:	23030000 	movwcs	r0, #12288	; 0x3000
    6e18:	750e20ac 	strvc	r2, [lr, #-172]	; 0xac
    6e1c:	0300000c 	movweq	r0, #12
    6e20:	00533da3 	subseq	r3, r3, r3, lsr #27
  {
    disable_irq(INT_SPI1 - 16);
    6e24:	23030000 	movwcs	r0, #12288	; 0x3000
    6e28:	7b0e20b0 	blvc	38f0f0 <__etext+0x386448>
  }
  else if(spix == SPI2)
    6e2c:	0300000c 	movweq	r0, #12
    6e30:	00533da4 	subseq	r3, r3, r4, lsr #27
    6e34:	23030000 	movwcs	r0, #12288	; 0x3000
    6e38:	810e20b4 	strhhi	r2, [lr, -r4]
  {
    disable_irq(INT_SPI2 - 16);
    6e3c:	0300000c 	movweq	r0, #12
    6e40:	00533da5 	subseq	r3, r3, r5, lsr #27
  }
  else
    return 0;
    6e44:	23030000 	movwcs	r0, #12288	; 0x3000
    6e48:	870e20b8 			; <UNDEFINED> instruction: 0x870e20b8
  return 1;
    6e4c:	0300000c 	movweq	r0, #12
}
    6e50:	00533da6 	subseq	r3, r3, r6, lsr #27
    6e54:	23030000 	movwcs	r0, #12288	; 0x3000
    6e58:	8d0e20bc 	stchi	0, cr2, [lr, #-752]	; 0xfffffd10
    6e5c:	0300000c 	movweq	r0, #12
 *      |__SPI_PCS_INACTIVE -ƬѡЧ,PCSźűΪߵƽ
 * :
 *    ȡӻ8λ
 */
uint8 LPLD_SPI_Master_WriteRead(SPI_MemMapPtr spix,uint8 data,uint8 pcsx,uint8 pcs_state)
{
    6e60:	00533da7 	subseq	r3, r3, r7, lsr #27
    6e64:	23030000 	movwcs	r0, #12288	; 0x3000
    6e68:	ec0e20c0 	stc	0, cr2, [lr], {192}	; 0xc0
    6e6c:	0300000f 	movweq	r0, #15
  uint8 temp;
  
  spix->PUSHR  = (((uint32_t)(((uint32_t)(pcs_state))<<SPI_PUSHR_CONT_SHIFT))&SPI_PUSHR_CONT_MASK)
               |SPI_PUSHR_CTAS(0)
    6e70:	00533da8 	subseq	r3, r3, r8, lsr #27
               |SPI_PUSHR_PCS(pcsx)
    6e74:	23030000 	movwcs	r0, #12288	; 0x3000
    6e78:	f40e20c4 	vst4.<illegal width 64>	{d2-d5}, [lr], r4
    6e7c:	0300000f 	movweq	r0, #15
               |data;                 
    6e80:	00533da9 	subseq	r3, r3, r9, lsr #27
 */
uint8 LPLD_SPI_Master_WriteRead(SPI_MemMapPtr spix,uint8 data,uint8 pcsx,uint8 pcs_state)
{
  uint8 temp;
  
  spix->PUSHR  = (((uint32_t)(((uint32_t)(pcs_state))<<SPI_PUSHR_CONT_SHIFT))&SPI_PUSHR_CONT_MASK)
    6e84:	23030000 	movwcs	r0, #12288	; 0x3000
               |SPI_PUSHR_CTAS(0)
               |SPI_PUSHR_PCS(pcsx)
               |data;                 
  
  while(!(spix->SR & SPI_SR_TCF_MASK));
    6e88:	290e20c8 	stmdbcs	lr, {r3, r6, r7, sp}
    6e8c:	0300000f 	movweq	r0, #15
    6e90:	00533daa 	subseq	r3, r3, sl, lsr #27
  spix->SR |= SPI_SR_TCF_MASK ;               
    6e94:	23030000 	movwcs	r0, #12288	; 0x3000
    6e98:	2f0e20cc 	svccs	0x000e20cc
    6e9c:	0300000f 	movweq	r0, #15
  
  while(!(spix->SR & SPI_SR_RFDF_MASK)); 
    6ea0:	00533dab 	subseq	r3, r3, fp, lsr #27
    6ea4:	23030000 	movwcs	r0, #12288	; 0x3000
    6ea8:	cb0e20d0 	blgt	38f1f0 <__etext+0x386548>
  temp = (uint8)(spix->POPR & 0xff);           
    6eac:	0300000b 	movweq	r0, #11
    6eb0:	00533dac 	subseq	r3, r3, ip, lsr #27
  spix->SR |= SPI_SR_RFDF_MASK;                
    6eb4:	23030000 	movwcs	r0, #12288	; 0x3000
    6eb8:	090e20d4 	stmdbeq	lr, {r2, r4, r6, r7, sp}
    6ebc:	0300000e 	movweq	r0, #14
  return temp;
  
}
    6ec0:	00533dad 	subseq	r3, r3, sp, lsr #27
    6ec4:	23030000 	movwcs	r0, #12288	; 0x3000
    6ec8:	0f0e20d8 	svceq	0x000e20d8
 *      |__SPI2 -ѡSPI2ģ
 * :
 *    ȡӻ8λ
 */
uint8 LPLD_SPI_Master_Read(SPI_MemMapPtr spix)
{
    6ecc:	0300000e 	movweq	r0, #14
    6ed0:	00533dae 	subseq	r3, r3, lr, lsr #27
  uint8 temp;

  while(!(spix->SR & SPI_SR_RFDF_MASK)); //=1 RIFO is not empty
    6ed4:	23030000 	movwcs	r0, #12288	; 0x3000
    6ed8:	d00e20dc 	ldrdle	r2, [lr], -ip
    6edc:	0300000b 	movweq	r0, #11
    6ee0:	00533daf 	subseq	r3, r3, pc, lsr #27
  temp=(uint8)spix->POPR;
    6ee4:	23030000 	movwcs	r0, #12288	; 0x3000
  spix->SR |=SPI_SR_RFDF_MASK;
    6ee8:	310e20e0 	smlattcc	lr, r0, r0, r2
    6eec:	03000003 	movweq	r0, #3
    6ef0:	03b73db0 			; <UNDEFINED> instruction: 0x03b73db0

  return temp;
    6ef4:	23030000 	movwcs	r0, #12288	; 0x3000
}
    6ef8:	9f0e20e4 	svcls	0x000e20e4
    6efc:	0300000e 	movweq	r0, #14
    6f00:	00533db1 	ldrheq	r3, [r3], #-209	; 0xffffff2f
 *    pcs_state--һ֡ݴɺCS״̬
 *      |__SPI_PCS_ASSERTED -ƬѡЧ,PCSźűΪ͵ƽ
 *      |__SPI_PCS_INACTIVE -ƬѡЧ,PCSźűΪߵƽ
 */
void LPLD_SPI_Master_Write(SPI_MemMapPtr spix,uint8 data,uint8 pcsx,uint8 pcs_state)
{  
    6f04:	23030000 	movwcs	r0, #12288	; 0x3000
    6f08:	4d0a20e8 	stcmi	0, cr2, [sl, #-928]	; 0xfffffc60
    6f0c:	03005243 	movweq	r5, #579	; 0x243
    6f10:	00533db2 	ldrheq	r3, [r3], #-210	; 0xffffff2e
  
  spix->PUSHR = (((uint32_t)(((uint32_t)(pcs_state))<<SPI_PUSHR_CONT_SHIFT)) & SPI_PUSHR_CONT_MASK)
               |SPI_PUSHR_CTAS(0)
    6f14:	23030000 	movwcs	r0, #12288	; 0x3000
               |SPI_PUSHR_PCS(pcsx)
    6f18:	070020ec 	streq	r2, [r0, -ip, ror #1]
    6f1c:	0000002c 	andeq	r0, r0, ip, lsr #32
    6f20:	0000072c 	andeq	r0, r0, ip, lsr #14
               |data; 
    6f24:	0003a010 	andeq	sl, r3, r0, lsl r0
 *      |__SPI_PCS_INACTIVE -ƬѡЧ,PCSźűΪߵƽ
 */
void LPLD_SPI_Master_Write(SPI_MemMapPtr spix,uint8 data,uint8 pcsx,uint8 pcs_state)
{  
  
  spix->PUSHR = (((uint32_t)(((uint32_t)(pcs_state))<<SPI_PUSHR_CONT_SHIFT)) & SPI_PUSHR_CONT_MASK)
    6f28:	000ffb00 	andeq	pc, pc, r0, lsl #22
               |SPI_PUSHR_CTAS(0)
               |SPI_PUSHR_PCS(pcsx)
               |data; 

  while(!(spix->SR & SPI_SR_TCF_MASK));
    6f2c:	000f470b 	andeq	r4, pc, fp, lsl #14
    6f30:	3db30300 	ldccc	3, cr0, [r3]
    6f34:	00000738 	andeq	r0, r0, r8, lsr r7
  spix->SR |= SPI_SR_TCF_MASK ;            
    6f38:	073e040c 	ldreq	r0, [lr, -ip, lsl #8]!
    6f3c:	3f0d0000 	svccc	0x000d0000
    6f40:	03000005 	movweq	r0, #5
}
    6f44:	00000483 	andeq	r0, r0, r3, lsl #9
    6f48:	00371b04 	eorseq	r1, r7, r4, lsl #22


void SPI0_IRQHandler(void)
{
    6f4c:	e0030000 	and	r0, r3, r0
  OS_CPU_SR  cpu_sr = 0u;
  OS_ENTER_CRITICAL(); 
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif
  if( SPI0->SR & SPI_SR_TCF_MASK)
    6f50:	04000012 	streq	r0, [r0], #-18
    6f54:	0000451c 	andeq	r4, r0, ip, lsl r5
    6f58:	04040200 	streq	r0, [r4], #-512	; 0x200
    6f5c:	00000669 	andeq	r0, r0, r9, ror #12
  {
    SPI0_ISR[SPI_TxComplete_Int]();
    6f60:	87040802 	strhi	r0, [r4, -r2, lsl #16]
    6f64:	0300000a 	movweq	r0, #10
    6f68:	00000dc8 	andeq	r0, r0, r8, asr #27
    SPI0->SR |= SPI_SR_TCF_MASK;
    6f6c:	00372e04 	eorseq	r2, r7, r4, lsl #28
    6f70:	040c0000 	streq	r0, [ip], #-0
    6f74:	00000778 	andeq	r0, r0, r8, ror r7
    6f78:	01020111 	tsteq	r2, r1, lsl r1
    6f7c:	00071208 	andeq	r1, r7, r8, lsl #4
    6f80:	22bd0300 	adcscs	r0, sp, #0
  }
  else if( SPI0->SR & SPI_SR_EOQF_MASK)
    6f84:	24050000 	strcs	r0, [r5], #-0
    6f88:	00000772 	andeq	r0, r0, r2, ror r7
    6f8c:	26050c12 			; <UNDEFINED> instruction: 0x26050c12
    6f90:	000007db 	ldrdeq	r0, [r0], -fp
    6f94:	0022b213 	eoreq	fp, r2, r3, lsl r2
  {
    SPI0_ISR[SPI_QueueEndReq_Int]();
    6f98:	43310500 	teqmi	r1, #0
    6f9c:	02000007 	andeq	r0, r0, #7
    6fa0:	9b130023 	blls	4c7034 <__etext+0x4be38c>
    SPI0->SR |= SPI_SR_EOQF_MASK;
    6fa4:	05000021 	streq	r0, [r0, #-33]	; 0x21
    6fa8:	00074e3c 	andeq	r4, r7, ip, lsr lr
    6fac:	02230200 	eoreq	r0, r3, #0
    6fb0:	00218713 	eoreq	r8, r1, r3, lsl r7
    6fb4:	43480500 	movtmi	r0, #34048	; 0x8500
    6fb8:	02000007 	andeq	r0, r0, #7
  }
  else if( SPI0->SR & SPI_SR_TFUF_MASK)
    6fbc:	b5130423 	ldrlt	r0, [r3, #-1059]	; 0x423
    6fc0:	05000021 	streq	r0, [r0, #-33]	; 0x21
    6fc4:	00076753 	andeq	r6, r7, r3, asr r7
    6fc8:	05230200 	streq	r0, [r3, #-512]!	; 0x200
    6fcc:	00229113 	eoreq	r9, r2, r3, lsl r1
  {
    SPI0_ISR[SPI_TxFIFO_UnderflowInt]();
    6fd0:	815d0500 	cmphi	sp, r0, lsl #10
    6fd4:	02000007 	andeq	r0, r0, #7
    6fd8:	03000823 	movweq	r0, #2083	; 0x823
    SPI0->SR |= SPI_SR_TFUF_MASK;
    6fdc:	00002175 	andeq	r2, r0, r5, ror r1
    6fe0:	078c5f05 	streq	r5, [ip, r5, lsl #30]
    6fe4:	01140000 	tsteq	r4, r0
    6fe8:	00002219 	andeq	r2, r0, r9, lsl r2
    6fec:	43012701 	movwmi	r2, #5889	; 0x1701
    6ff0:	88000007 	stmdahi	r0, {r0, r1, r2}
  }
  else if( SPI0->SR & SPI_SR_TFFF_MASK)
    6ff4:	28000051 	stmdacs	r0, {r0, r4, r6}
    6ff8:	ec000053 	stc	0, cr0, [r0], {83}	; 0x53
    6ffc:	01000015 	tsteq	r0, r5, lsl r0
    7000:	0000084b 	andeq	r0, r0, fp, asr #16
    7004:	00226c15 	eoreq	r6, r2, r5, lsl ip
  {  
    SPI0_ISR[SPI_TxFIFO_FillInt]();    
    7008:	db270100 	blle	9c7410 <__etext+0x9be768>
    700c:	02000007 	andeq	r0, r0, #7
    7010:	21165c91 			; <UNDEFINED> instruction: 0x21165c91
    SPI0->SR |= SPI_SR_TFFF_MASK;
    7014:	0100002b 	tsteq	r0, fp, lsr #32
    7018:	00074329 	andeq	r4, r7, r9, lsr #6
    701c:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
    7020:	0022a816 	eoreq	sl, r2, r6, lsl r8
    7024:	4e2a0100 	sufmie	f0, f2, f0
    7028:	02000007 	andeq	r0, r0, #7
  }
  else if( SPI0->SR & SPI_SR_RFOF_MASK)
    702c:	f7167491 			; <UNDEFINED> instruction: 0xf7167491
    7030:	01000022 	tsteq	r0, r2, lsr #32
    7034:	0007432b 	andeq	r4, r7, fp, lsr #6
    7038:	73910200 	orrsvc	r0, r1, #0
    703c:	00178316 	andseq	r8, r7, r6, lsl r3
  {   
    SPI0_ISR[SPI_RxFIFO_OverflowInt]();
    7040:	812c0100 	teqhi	ip, r0, lsl #2
    7044:	02000007 	andeq	r0, r0, #7
    7048:	17006c91 			; <UNDEFINED> instruction: 0x17006c91
    SPI0->SR |= SPI_SR_RFOF_MASK;
    704c:	0021ef01 	eoreq	lr, r1, r1, lsl #30
    7050:	01790100 	cmneq	r9, r0, lsl #2
    7054:	00000743 	andeq	r0, r0, r3, asr #14
    7058:	00005328 	andeq	r5, r0, r8, lsr #6
    705c:	0000538e 	andeq	r5, r0, lr, lsl #7
    7060:	00001624 	andeq	r1, r0, r4, lsr #12
  }
  else if( SPI0->SR & SPI_SR_RFDF_MASK)
    7064:	df011801 	svcle	0x00011801
    7068:	01000022 	tsteq	r0, r2, lsr #32
    706c:	53900193 	orrspl	r0, r0, #-1073741788	; 0xc0000024
    7070:	53b20000 			; <UNDEFINED> instruction: 0x53b20000
    7074:	16500000 	ldrbne	r0, [r0], -r0
  {
    SPI0_ISR[SPI_RxFIFO_DrainInt]();
    7078:	17010000 	strne	r0, [r1, -r0]
    707c:	00224101 	eoreq	r4, r2, r1, lsl #2
    7080:	01a30100 			; <UNDEFINED> instruction: 0x01a30100
    SPI0->SR |= SPI_SR_RFDF_MASK;
    7084:	00000743 	andeq	r0, r0, r3, asr #14
    7088:	000053b4 			; <UNDEFINED> instruction: 0x000053b4
    708c:	000053c8 	andeq	r5, r0, r8, asr #7
    7090:	0000167c 	andeq	r1, r0, ip, ror r6
    7094:	56011701 	strpl	r1, [r1], -r1, lsl #14
    7098:	01000022 	tsteq	r0, r2, lsr #32
#endif
}


void SPI1_IRQHandler(void)
{
    709c:	074301b5 			; <UNDEFINED> instruction: 0x074301b5
  OS_CPU_SR  cpu_sr = 0u;
  OS_ENTER_CRITICAL(); 
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif
  if( SPI1->SR & SPI_SR_TCF_MASK)
    70a0:	53c80000 	bicpl	r0, r8, #0
    70a4:	53dc0000 	bicspl	r0, ip, #0
    70a8:	16a80000 	strtne	r0, [r8], r0
    70ac:	19010000 	stmdbne	r1, {}	; <UNPREDICTABLE>
  {
    SPI1_ISR[SPI_TxComplete_Int]();
    70b0:	0021d801 	eoreq	sp, r1, r1, lsl #16
    70b4:	01c40100 	biceq	r0, r4, r0, lsl #2
    70b8:	0000074e 	andeq	r0, r0, lr, asr #14
    SPI1->SR |= SPI_SR_TCF_MASK;
    70bc:	000053dc 	ldrdeq	r5, [r0], -ip
    70c0:	00005402 	andeq	r5, r0, r2, lsl #8
    70c4:	000016d4 	ldrdeq	r1, [r0], -r4
    70c8:	c5011a01 	strgt	r1, [r1, #-2561]	; 0xa01
    70cc:	01000021 	tsteq	r0, r1, lsr #32
    70d0:	540401d5 	strpl	r0, [r4], #-469	; 0x1d5
  }
  else if( SPI1->SR & SPI_SR_EOQF_MASK)
    70d4:	54c40000 	strbpl	r0, [r4], #0
    70d8:	17000000 	strne	r0, [r0, -r0]
    70dc:	f2010000 	vhadd.s8	d0, d1, d0
    70e0:	15000008 	strne	r0, [r0, #-8]
    70e4:	000022a8 	andeq	r2, r0, r8, lsr #5
  {
    SPI1_ISR[SPI_QueueEndReq_Int]();
    70e8:	074ed501 	strbeq	sp, [lr, -r1, lsl #10]
    70ec:	91020000 	mrsls	r0, (UNDEF: 2)
    70f0:	011b0076 	tsteq	fp, r6, ror r0
    SPI1->SR |= SPI_SR_EOQF_MASK;
    70f4:	000022d0 	ldrdeq	r2, [r0], -r0
    70f8:	c401f501 	strgt	pc, [r1], #-1281	; 0x501
    70fc:	ee000054 	mcr	0, 0, r0, cr0, cr4, {2}
    7100:	38000054 	stmdacc	r0, {r2, r4, r6}
    7104:	01000017 	tsteq	r0, r7, lsl r0
    7108:	00078107 	andeq	r8, r7, r7, lsl #2
  }
  else if( SPI1->SR & SPI_SR_TFUF_MASK)
    710c:	00091800 	andeq	r1, r9, r0, lsl #16
    7110:	03a00800 	moveq	r0, #0
    7114:	00000000 	andeq	r0, r0, r0
    7118:	0022291c 	eoreq	r2, r2, ip, lsl r9
    711c:	081a0100 	ldmdaeq	sl, {r8}
  {
    SPI1_ISR[SPI_TxFIFO_UnderflowInt]();
    7120:	01000009 	tsteq	r0, r9
    7124:	16640305 	strbtne	r0, [r4], -r5, lsl #6
    7128:	cf001fff 	svcgt	0x00001fff
    SPI1->SR |= SPI_SR_TFUF_MASK;
    712c:	02000006 	andeq	r0, r0, #6
    7130:	00114800 	andseq	r4, r1, r0, lsl #16
    7134:	34010400 	strcc	r0, [r1], #-1024	; 0x400
    7138:	01000002 	tsteq	r0, r2
    713c:	00002327 	andeq	r2, r0, r7, lsr #6
    7140:	00000827 	andeq	r0, r0, r7, lsr #16
  }
  else if( SPI1->SR & SPI_SR_TFFF_MASK)
    7144:	000054f0 	strdeq	r5, [r0], -r0
    7148:	00005852 	andeq	r5, r0, r2, asr r8
    714c:	00001302 	andeq	r1, r0, r2, lsl #6
    7150:	0b060102 	bleq	187560 <__etext+0x17e8b8>
    7154:	03000007 	movweq	r0, #7
  {  
    SPI1_ISR[SPI_TxFIFO_FillInt]();    
    7158:	000009dd 	ldrdeq	r0, [r0], -sp
    715c:	00372a02 	eorseq	r2, r7, r2, lsl #20
    7160:	01020000 	mrseq	r0, (UNDEF: 2)
    SPI1->SR |= SPI_SR_TFFF_MASK;
    7164:	00070908 	andeq	r0, r7, r8, lsl #18
    7168:	05020200 	streq	r0, [r2, #-512]	; 0x200
    716c:	0000073b 	andeq	r0, r0, fp, lsr r7
    7170:	92070202 	andls	r0, r7, #536870912	; 0x20000000
    7174:	02000004 	andeq	r0, r0, #4
    7178:	01960504 	orrseq	r0, r6, r4, lsl #10
  }
  else if( SPI1->SR & SPI_SR_RFOF_MASK)
    717c:	9b030000 	blls	c7184 <__etext+0xbe4dc>
    7180:	02000007 	andeq	r0, r0, #7
    7184:	00005e50 	andeq	r5, r0, r0, asr lr
    7188:	07040200 	streq	r0, [r4, -r0, lsl #4]
    718c:	000001e4 	andeq	r0, r0, r4, ror #3
  {   
    SPI1_ISR[SPI_RxFIFO_OverflowInt]();
    7190:	91050802 	tstls	r5, r2, lsl #16
    7194:	02000001 	andeq	r0, r0, #1
    7198:	01df0708 	bicseq	r0, pc, r8, lsl #14
    SPI1->SR |= SPI_SR_RFOF_MASK;
    719c:	04040000 	streq	r0, [r4], #-0
    71a0:	746e6905 	strbtvc	r6, [lr], #-2309	; 0x905
    71a4:	07040200 	streq	r0, [r4, -r0, lsl #4]
    71a8:	000001e9 	andeq	r0, r0, r9, ror #3
    71ac:	74070402 	strvc	r0, [r7], #-1026	; 0x402
    71b0:	05000005 	streq	r0, [r0, #-5]
  }
  else if( SPI1->SR & SPI_SR_RFDF_MASK)
    71b4:	0000002c 	andeq	r0, r0, ip, lsr #32
    71b8:	00000098 	muleq	r0, r8, r0
    71bc:	00008106 	andeq	r8, r0, r6, lsl #2
    71c0:	05000300 	streq	r0, [r0, #-768]	; 0x300
    71c4:	0000002c 	andeq	r0, r0, ip, lsr #32
  {
    SPI1_ISR[SPI_RxFIFO_DrainInt]();
    71c8:	000000a8 	andeq	r0, r0, r8, lsr #1
    71cc:	00008106 	andeq	r8, r0, r6, lsl #2
    71d0:	07000700 	streq	r0, [r0, -r0, lsl #14]
    SPI1->SR |= SPI_SR_RFDF_MASK;
    71d4:	207e0310 	rsbscs	r0, lr, r0, lsl r3
    71d8:	000000ee 	andeq	r0, r0, lr, ror #1
    71dc:	00238808 	eoreq	r8, r3, r8, lsl #16
    71e0:	207f0300 	rsbscs	r0, pc, r0, lsl #6
    71e4:	00000053 	andeq	r0, r0, r3, asr r0
    71e8:	08002302 	stmdaeq	r0, {r1, r8, r9, sp}
#endif
}


void SPI2_IRQHandler(void)
{
    71ec:	00002346 	andeq	r2, r0, r6, asr #6
  OS_CPU_SR  cpu_sr = 0u;
  OS_ENTER_CRITICAL(); 
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif
  if( SPI2->SR & SPI_SR_TCF_MASK)
    71f0:	53208003 	teqpl	r0, #3
    71f4:	02000000 	andeq	r0, r0, #0
    71f8:	b9080423 	stmdblt	r8, {r0, r1, r5, sl}
    71fc:	03000023 	movweq	r0, #35	; 0x23
  {
    SPI2_ISR[SPI_TxComplete_Int]();
    7200:	00532081 	subseq	r2, r3, r1, lsl #1
    7204:	23020000 	movwcs	r0, #8192	; 0x2000
    7208:	23ab0808 			; <UNDEFINED> instruction: 0x23ab0808
    SPI2->SR |= SPI_SR_TCF_MASK;
    720c:	82030000 	andhi	r0, r3, #0
    7210:	00005320 	andeq	r5, r0, r0, lsr #6
    7214:	0c230200 	sfmeq	f0, 4, [r3], #-0
    7218:	23540900 	cmpcs	r4, #0
    721c:	03000000 	movweq	r0, #0
    7220:	69207703 	stmdbvs	r0!, {r0, r1, r8, r9, sl, ip, sp, lr}
  }
  else if( SPI2->SR & SPI_SR_EOQF_MASK)
    7224:	08000001 	stmdaeq	r0, {r0}
    7228:	0000234e 	andeq	r2, r0, lr, asr #6
    722c:	53207803 	teqpl	r0, #196608	; 0x30000
    7230:	02000000 	andeq	r0, r0, #0
    7234:	a3080023 	movwge	r0, #32803	; 0x8023
  {
    SPI2_ISR[SPI_QueueEndReq_Int]();
    7238:	03000023 	movweq	r0, #35	; 0x23
    723c:	00532079 	subseq	r2, r3, r9, ror r0
    7240:	23020000 	movwcs	r0, #8192	; 0x2000
    SPI2->SR |= SPI_SR_EOQF_MASK;
    7244:	23ee0804 	mvncs	r0, #262144	; 0x40000
    7248:	7a030000 	bvc	c7250 <__etext+0xbe5a8>
    724c:	00005320 	andeq	r5, r0, r0, lsr #6
    7250:	08230200 	stmdaeq	r3!, {r9}
    7254:	00031208 	andeq	r1, r3, r8, lsl #4
    7258:	207b0300 	rsbscs	r0, fp, r0, lsl #6
  }
  else if( SPI2->SR & SPI_SR_TFUF_MASK)
    725c:	00000169 	andeq	r0, r0, r9, ror #2
    7260:	080c2302 	stmdaeq	ip, {r1, r8, r9, sp}
    7264:	00002382 	andeq	r2, r0, r2, lsl #7
    7268:	79207c03 	stmdbvc	r0!, {r0, r1, sl, fp, ip, sp, lr}
    726c:	03000001 	movweq	r0, #1
  {
    SPI2_ISR[SPI_TxFIFO_UnderflowInt]();
    7270:	08028023 	stmdaeq	r2, {r0, r1, r5, pc}
    7274:	0000031d 	andeq	r0, r0, sp, lsl r3
    7278:	8f207d03 	svchi	0x00207d03
    SPI2->SR |= SPI_SR_TFUF_MASK;
    727c:	03000001 	movweq	r0, #1
    7280:	0a02c023 	beq	b7314 <__etext+0xae66c>
    7284:	00544553 	subseq	r4, r4, r3, asr r5
    7288:	9f208303 	svcls	0x00208303
    728c:	03000001 	movweq	r0, #1
    7290:	00048023 	andeq	r8, r4, r3, lsr #32
  }
  else if( SPI2->SR & SPI_SR_TFFF_MASK)
    7294:	00002c05 	andeq	r2, r0, r5, lsl #24
    7298:	00017900 	andeq	r7, r1, r0, lsl #18
    729c:	00810600 	addeq	r0, r1, r0, lsl #12
    72a0:	00f30000 	rscseq	r0, r3, r0
    72a4:	00005305 	andeq	r5, r0, r5, lsl #6
  {  
    SPI2_ISR[SPI_TxFIFO_FillInt]();    
    72a8:	00018f00 	andeq	r8, r1, r0, lsl #30
    72ac:	00810600 	addeq	r0, r1, r0, lsl #12
    72b0:	06030000 	streq	r0, [r3], -r0
    SPI2->SR |= SPI_SR_TFFF_MASK;
    72b4:	00000081 	andeq	r0, r0, r1, lsl #1
    72b8:	2c050003 	stccs	0, cr0, [r5], {3}
    72bc:	9f000000 	svcls	0x00000000
    72c0:	06000001 	streq	r0, [r0], -r1
    72c4:	00000081 	andeq	r0, r0, r1, lsl #1
    72c8:	a80500bf 	stmdage	r5, {r0, r1, r2, r3, r4, r5, r7}
  }
  else if( SPI2->SR & SPI_SR_RFOF_MASK)
    72cc:	b5000000 	strlt	r0, [r0, #-0]
    72d0:	06000001 	streq	r0, [r0], -r1
    72d4:	00000081 	andeq	r0, r0, r1, lsl #1
    72d8:	00810603 	addeq	r0, r1, r3, lsl #12
    72dc:	00030000 	andeq	r0, r3, r0
  {   
    SPI2_ISR[SPI_RxFIFO_OverflowInt]();
    72e0:	0023f60b 	eoreq	pc, r3, fp, lsl #12
    72e4:	20840300 	addcs	r0, r4, r0, lsl #6
    72e8:	000001c1 	andeq	r0, r0, r1, asr #3
    SPI2->SR |= SPI_SR_RFOF_MASK;
    72ec:	01c7040c 	biceq	r0, r7, ip, lsl #8
    72f0:	ee0d0000 	cdp	0, 0, cr0, cr13, cr0, {0}
    72f4:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    72f8:	00000ffc 	strdeq	r0, [r0], -ip
    72fc:	2c370313 	ldccs	3, cr0, [r7], #-76	; 0xffffffb4
    7300:	000002ea 	andeq	r0, r0, sl, ror #5
  }
  else if( SPI2->SR & SPI_SR_RFDF_MASK)
    7304:	0031430a 	eorseq	r4, r1, sl, lsl #6
    7308:	2c2c3803 	stccs	8, cr3, [ip], #-12
    730c:	02000000 	andeq	r0, r0, #0
    7310:	430a0023 	movwmi	r0, #40995	; 0xa023
    7314:	39030032 	stmdbcc	r3, {r1, r4, r5}
  {
    SPI2_ISR[SPI_RxFIFO_DrainInt]();
    7318:	00002c2c 	andeq	r2, r0, ip, lsr #24
    731c:	01230200 	teqeq	r3, r0, lsl #4
    7320:	0033430a 	eorseq	r4, r3, sl, lsl #6
    SPI2->SR |= SPI_SR_RFDF_MASK;
    7324:	2c2c3a03 	stccs	10, cr3, [ip], #-12
    7328:	02000000 	andeq	r0, r0, #0
    732c:	430a0223 	movwmi	r0, #41507	; 0xa223
    7330:	3b030034 	blcc	c7408 <__etext+0xbe760>
    7334:	00002c2c 	andeq	r2, r0, ip, lsr #24
    7338:	03230200 	teqeq	r3, #0
 * 输出:
 *    无
 *
 */
void LPLD_UART_Init(UART_InitTypeDef uart_init_structure)
{
    733c:	0035430a 	eorseq	r4, r5, sl, lsl #6
    7340:	2c2c3c03 	stccs	12, cr3, [ip], #-12
    7344:	02000000 	andeq	r0, r0, #0
    7348:	430a0423 	movwmi	r0, #42019	; 0xa423
  register uint16 sbr, brfa;
  uint32 sysclk;
  uint8 temp, x;
  UART_MemMapPtr uartx = uart_init_structure.UART_Uartx;
    734c:	3d030036 	stccc	0, cr0, [r3, #-216]	; 0xffffff28
  uint32 baud = uart_init_structure.UART_BaudRate;
    7350:	00002c2c 	andeq	r2, r0, ip, lsr #24
  PortPinsEnum_Type tx_pin = uart_init_structure.UART_TxPin;
    7354:	05230200 	streq	r0, [r3, #-512]!	; 0x200
    7358:	0300530a 	movweq	r5, #778	; 0x30a
  PortPinsEnum_Type rx_pin = uart_init_structure.UART_RxPin;
    735c:	002c2c3e 	eoreq	r2, ip, lr, lsr ip
  UART_ISR_CALLBACK rx_isr = uart_init_structure.UART_RxIsr;
    7360:	23020000 	movwcs	r0, #8192	; 0x2000
  UART_ISR_CALLBACK tx_isr = uart_init_structure.UART_TxIsr;
    7364:	03120806 	tsteq	r2, #393216	; 0x60000
  
  if(baud == 0)
    7368:	3f030000 	svccc	0x00030000
    736c:	0002ea2c 	andeq	lr, r2, ip, lsr #20
  {
    baud = 9600;
    7370:	07230200 	streq	r0, [r3, -r0, lsl #4]!
  }
  
  //使能选中的UART串口通道时钟，相应GPIO的UART复用功能   
  if(uartx == UART0_BASE_PTR)
    7374:	0043530a 	subeq	r5, r3, sl, lsl #6
    7378:	2c2c4003 	stccs	0, cr4, [ip], #-12
    737c:	02000000 	andeq	r0, r0, #0
    7380:	1d080823 	stcne	8, cr0, [r8, #-140]	; 0xffffff74
  {
    x = 0;
    7384:	03000003 	movweq	r0, #3
    sysclk = g_core_clock;
    7388:	02ea2c41 	rsceq	r2, sl, #16640	; 0x4100
    738c:	23020000 	movwcs	r0, #8192	; 0x2000
    7390:	0ba20809 	bleq	fe8893bc <__StackLimit+0xde8893bc>
    SIM_SCGC4 |= SIM_SCGC4_UART0_MASK;
    7394:	42030000 	andmi	r0, r3, #0
    7398:	00002c2c 	andeq	r2, r0, ip, lsr #24
    739c:	0a230200 	beq	8c7ba4 <__etext+0x8beefc>
    73a0:	000baf08 	andeq	sl, fp, r8, lsl #30
    73a4:	2c430300 	mcrrcs	3, 0, r0, r3, cr0
    73a8:	0000002c 	andeq	r0, r0, ip, lsr #32
    73ac:	0a0b2302 	beq	2cffbc <__etext+0x2c7314>
    73b0:	03003743 	movweq	r3, #1859	; 0x743
    73b4:	002c2c44 	eoreq	r2, ip, r4, asr #24
    73b8:	23020000 	movwcs	r0, #8192	; 0x2000
    //设置Tx引脚
    if(tx_pin == PTA2)
    73bc:	38430a0c 	stmdacc	r3, {r2, r3, r9, fp}^
    73c0:	2c450300 	mcrrcs	3, 0, r0, r5, cr0
      PORTA_BASE_PTR->PCR[2] = PORT_PCR_MUX(2); 
    73c4:	0000002c 	andeq	r0, r0, ip, lsr #32
    73c8:	0a0d2302 	beq	34ffd8 <__etext+0x347330>
    73cc:	03003943 	movweq	r3, #2371	; 0x943
    73d0:	002c2c46 	eoreq	r2, ip, r6, asr #24
    else if(tx_pin == PTA14)
    73d4:	23020000 	movwcs	r0, #8192	; 0x2000
      PORTA_BASE_PTR->PCR[14] = PORT_PCR_MUX(3); 
    73d8:	31430a0e 	cmpcc	r3, lr, lsl #20
    73dc:	47030030 	smladxmi	r3, r0, r0, r0
    73e0:	00002c2c 	andeq	r2, r0, ip, lsr #24
    73e4:	0f230200 	svceq	0x00230200
    else
      PORTB_BASE_PTR->PCR[17] = PORT_PCR_MUX(3); 
    73e8:	3131430a 	teqcc	r1, sl, lsl #6
    73ec:	2c480300 	mcrrcs	3, 0, r0, r8, cr0
    73f0:	0000002c 	andeq	r0, r0, ip, lsr #32
    73f4:	0a102302 	beq	410004 <__etext+0x40735c>
    //设置Rx引脚
    if(rx_pin == PTA1)
    73f8:	00323143 	eorseq	r3, r2, r3, asr #2
      PORTA_BASE_PTR->PCR[1] = PORT_PCR_MUX(2); 
    73fc:	2c2c4903 	stccs	9, cr4, [ip], #-12
    7400:	02000000 	andeq	r0, r0, #0
    7404:	530a1123 	movwpl	r1, #41251	; 0xa123
    7408:	4a030032 	bmi	c74d8 <__etext+0xbe830>
    else if(rx_pin == PTA15)
    740c:	00002c2c 	andeq	r2, r0, ip, lsr #24
    7410:	12230200 	eorne	r0, r3, #0
      PORTA_BASE_PTR->PCR[15] = PORT_PCR_MUX(3); 
    7414:	002c0500 	eoreq	r0, ip, r0, lsl #10
    7418:	02fa0000 	rscseq	r0, sl, #0
    741c:	81060000 	mrshi	r0, (UNDEF: 6)
    7420:	00000000 	andeq	r0, r0, r0
    else
      PORTB_BASE_PTR->PCR[16] = PORT_PCR_MUX(3); 
    7424:	0fba0b00 	svceq	0x00ba0b00
    7428:	4b030000 	blmi	c7430 <__etext+0xbe788>
    742c:	0003062c 	andeq	r0, r3, ip, lsr #12
    7430:	0c040c00 	stceq	12, cr0, [r4], {-0}
  }
  else
  {
    if (uartx == UART1_BASE_PTR)
    7434:	0d000003 	stceq	0, cr0, [r0, #-12]
    7438:	000001cc 	andeq	r0, r0, ip, asr #3
    743c:	00104409 	andseq	r4, r0, r9, lsl #8
    {
      x = 1;
    7440:	03107000 	tsteq	r0, #0
    7444:	04ed3d95 	strbteq	r3, [sp], #3477	; 0xd95
      sysclk = g_core_clock;
    7448:	38080000 	stmdacc	r8, {}	; <UNPREDICTABLE>
    744c:	03000010 	movweq	r0, #16
    7450:	00533d96 			; <UNDEFINED> instruction: 0x00533d96
      SIM_SCGC4 |= SIM_SCGC4_UART1_MASK;
    7454:	23020000 	movwcs	r0, #8192	; 0x2000
    7458:	0d020800 	stceq	8, cr0, [r2, #-0]
    745c:	97030000 	strls	r0, [r3, -r0]
    7460:	0000533d 	andeq	r5, r0, sp, lsr r3
    7464:	04230200 	strteq	r0, [r3], #-512	; 0x200
    7468:	00031208 	andeq	r1, r3, r8, lsl #4
    746c:	3d980300 	ldccc	3, cr0, [r8]
    7470:	000004ed 	andeq	r0, r0, sp, ror #9
    7474:	08082302 	stmdaeq	r8, {r1, r8, r9, sp}
    7478:	0000103e 	andeq	r1, r0, lr, lsr r0
      
      if(tx_pin == PTE0)   
    747c:	533d9903 	teqpl	sp, #49152	; 0xc000
        PORTE_BASE_PTR->PCR[0] = PORT_PCR_MUX(3); 
    7480:	03000000 	movweq	r0, #0
    7484:	08208423 	stmdaeq	r0!, {r0, r1, r5, sl, pc}
    7488:	0000031d 	andeq	r0, r0, sp, lsl r3
    748c:	883d9a03 	ldmdahi	sp!, {r0, r1, r9, fp, ip, pc}
      else
        PORTC_BASE_PTR->PCR[4] = PORT_PCR_MUX(3); 
    7490:	03000000 	movweq	r0, #0
    7494:	08208823 	stmdaeq	r0!, {r0, r1, r5, fp, pc}
    7498:	0000104f 	andeq	r1, r0, pc, asr #32
    749c:	533d9b03 	teqpl	sp, #3072	; 0xc00
      
      if(rx_pin == PTE1)
    74a0:	03000000 	movweq	r0, #0
        PORTE_BASE_PTR->PCR[1] = PORT_PCR_MUX(3); 
    74a4:	08208c23 	stmdaeq	r0!, {r0, r1, r5, sl, fp, pc}
    74a8:	00001055 	andeq	r1, r0, r5, asr r0
    74ac:	533d9c03 	teqpl	sp, #768	; 0x300
    74b0:	03000000 	movweq	r0, #0
      else
        PORTC_BASE_PTR->PCR[3] = PORT_PCR_MUX(3); 
    74b4:	08209023 	stmdaeq	r0!, {r0, r1, r5, ip, pc}
    74b8:	0000105b 	andeq	r1, r0, fp, asr r0
    74bc:	533d9d03 	teqpl	sp, #192	; 0xc0
    74c0:	03000000 	movweq	r0, #0
    }
    else
    {
      sysclk = g_bus_clock;
    74c4:	08209423 	stmdaeq	r0!, {r0, r1, r5, sl, ip, pc}
    74c8:	00001061 	andeq	r1, r0, r1, rrx
    74cc:	533d9e03 	teqpl	sp, #48	; 0x30
      if (uartx == UART2_BASE_PTR)
    74d0:	03000000 	movweq	r0, #0
    74d4:	08209823 	stmdaeq	r0!, {r0, r1, r5, fp, ip, pc}
    74d8:	00000a9a 	muleq	r0, sl, sl
    74dc:	983d9f03 	ldmdals	sp!, {r0, r1, r8, r9, sl, fp, ip, pc}
      {
        x = 2;
    74e0:	03000000 	movweq	r0, #0
        SIM_SCGC4 |= SIM_SCGC4_UART2_MASK;
    74e4:	08209c23 	stmdaeq	r0!, {r0, r1, r5, sl, fp, ip, pc}
    74e8:	00000c64 	andeq	r0, r0, r4, ror #24
    74ec:	533da003 	teqpl	sp, #3
    74f0:	03000000 	movweq	r0, #0
    74f4:	0820a423 	stmdaeq	r0!, {r0, r1, r5, sl, sp, pc}
    74f8:	00000c69 	andeq	r0, r0, r9, ror #24
    74fc:	533da103 	teqpl	sp, #-1073741824	; 0xc0000000
    7500:	03000000 	movweq	r0, #0
    7504:	0820a823 	stmdaeq	r0!, {r0, r1, r5, fp, sp, pc}
    7508:	00000c6f 	andeq	r0, r0, pc, ror #24
        
        PORTD_BASE_PTR->PCR[3] = PORT_PCR_MUX(3); 
    750c:	533da203 	teqpl	sp, #805306368	; 0x30000000
    7510:	03000000 	movweq	r0, #0
    7514:	0820ac23 	stmdaeq	r0!, {r0, r1, r5, sl, fp, sp, pc}
    7518:	00000c75 	andeq	r0, r0, r5, ror ip
        PORTD_BASE_PTR->PCR[2] = PORT_PCR_MUX(3);
    751c:	533da303 	teqpl	sp, #201326592	; 0xc000000
    7520:	03000000 	movweq	r0, #0
    7524:	0820b023 	stmdaeq	r0!, {r0, r1, r5, ip, sp, pc}
    7528:	00000c7b 	andeq	r0, r0, fp, ror ip
      }
      else
      {
        if(uartx == UART3_BASE_PTR)
    752c:	533da403 	teqpl	sp, #50331648	; 0x3000000
    7530:	03000000 	movweq	r0, #0
    7534:	0820b423 	stmdaeq	r0!, {r0, r1, r5, sl, ip, sp, pc}
        {
          x = 3;
    7538:	00000c81 	andeq	r0, r0, r1, lsl #25
    753c:	533da503 	teqpl	sp, #12582912	; 0xc00000
          SIM_SCGC4 |= SIM_SCGC4_UART3_MASK;
    7540:	03000000 	movweq	r0, #0
    7544:	0820b823 	stmdaeq	r0!, {r0, r1, r5, fp, ip, sp, pc}
    7548:	00000c87 	andeq	r0, r0, r7, lsl #25
    754c:	533da603 	teqpl	sp, #3145728	; 0x300000
    7550:	03000000 	movweq	r0, #0
    7554:	0820bc23 	stmdaeq	r0!, {r0, r1, r5, sl, fp, ip, sp, pc}
    7558:	00000c8d 	andeq	r0, r0, sp, lsl #25
    755c:	533da703 	teqpl	sp, #786432	; 0xc0000
    7560:	03000000 	movweq	r0, #0
    7564:	0820c023 	stmdaeq	r0!, {r0, r1, r5, lr, pc}
          
          if(tx_pin == PTE4)
    7568:	00000fec 	andeq	r0, r0, ip, ror #31
            PORTE_BASE_PTR->PCR[4] = PORT_PCR_MUX(3); 
    756c:	533da803 	teqpl	sp, #196608	; 0x30000
    7570:	03000000 	movweq	r0, #0
    7574:	0820c423 	stmdaeq	r0!, {r0, r1, r5, sl, lr, pc}
    7578:	00000ff4 	strdeq	r0, [r0], -r4
          else if(tx_pin == PTB11)
    757c:	533da903 	teqpl	sp, #49152	; 0xc000
    7580:	03000000 	movweq	r0, #0
            PORTB_BASE_PTR->PCR[11] = PORT_PCR_MUX(3); 
    7584:	0820c823 	stmdaeq	r0!, {r0, r1, r5, fp, lr, pc}
    7588:	00000f29 	andeq	r0, r0, r9, lsr #30
    758c:	533daa03 	teqpl	sp, #12288	; 0x3000
    7590:	03000000 	movweq	r0, #0
          else 
            PORTC_BASE_PTR->PCR[17] = PORT_PCR_MUX(3); 
    7594:	0820cc23 	stmdaeq	r0!, {r0, r1, r5, sl, fp, lr, pc}
    7598:	00000f2f 	andeq	r0, r0, pc, lsr #30
    759c:	533dab03 	teqpl	sp, #3072	; 0xc00
          
          if(rx_pin == PTE5)
    75a0:	03000000 	movweq	r0, #0
    75a4:	0820d023 	stmdaeq	r0!, {r0, r1, r5, ip, lr, pc}
            PORTE_BASE_PTR->PCR[5] = PORT_PCR_MUX(3); 
    75a8:	00000bcb 	andeq	r0, r0, fp, asr #23
    75ac:	533dac03 	teqpl	sp, #768	; 0x300
    75b0:	03000000 	movweq	r0, #0
    75b4:	0820d423 	stmdaeq	r0!, {r0, r1, r5, sl, ip, lr, pc}
          else if(rx_pin == PTB10)
    75b8:	00000e09 	andeq	r0, r0, r9, lsl #28
            PORTB_BASE_PTR->PCR[10] = PORT_PCR_MUX(3); 
    75bc:	533dad03 	teqpl	sp, #192	; 0xc0
    75c0:	03000000 	movweq	r0, #0
    75c4:	0820d823 	stmdaeq	r0!, {r0, r1, r5, fp, ip, lr, pc}
    75c8:	00000e0f 	andeq	r0, r0, pc, lsl #28
          else
            PORTC_BASE_PTR->PCR[16] = PORT_PCR_MUX(3);
    75cc:	533dae03 	teqpl	sp, #48	; 0x30
    75d0:	03000000 	movweq	r0, #0
    75d4:	0820dc23 	stmdaeq	r0!, {r0, r1, r5, sl, fp, ip, lr, pc}
    75d8:	00000bd0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
        }
        else
        {
          if(uartx == UART4_BASE_PTR)
    75dc:	533daf03 	teqpl	sp, #12
    75e0:	03000000 	movweq	r0, #0
    75e4:	0820e023 	stmdaeq	r0!, {r0, r1, r5, sp, lr, pc}
    75e8:	00000331 	andeq	r0, r0, r1, lsr r3
          {
            x = 4;
    75ec:	883db003 	ldmdahi	sp!, {r0, r1, ip, sp, pc}
            SIM_SCGC1 |= SIM_SCGC1_UART4_MASK;
    75f0:	03000000 	movweq	r0, #0
    75f4:	0820e423 	stmdaeq	r0!, {r0, r1, r5, sl, sp, lr, pc}
    75f8:	00000e9f 	muleq	r0, pc, lr	; <UNPREDICTABLE>
    75fc:	533db103 	teqpl	sp, #-1073741824	; 0xc0000000
    7600:	03000000 	movweq	r0, #0
    7604:	0a20e823 	beq	841698 <__etext+0x8389f0>
    7608:	0052434d 	subseq	r4, r2, sp, asr #6
    760c:	533db203 	teqpl	sp, #805306368	; 0x30000000
    7610:	03000000 	movweq	r0, #0
    7614:	0020ec23 	eoreq	lr, r0, r3, lsr #24
            
            if(tx_pin == PTE24)
    7618:	00002c05 	andeq	r2, r0, r5, lsl #24
    761c:	0004fe00 	andeq	pc, r4, r0, lsl #28
              PORTE_BASE_PTR->PCR[24] = PORT_PCR_MUX(3); 
    7620:	00810f00 	addeq	r0, r1, r0, lsl #30
    7624:	0ffb0000 	svceq	0x00fb0000
    7628:	0f470b00 	svceq	0x00470b00
    762c:	b3030000 	movwlt	r0, #12288	; 0x3000
            else
              PORTC_BASE_PTR->PCR[15] = PORT_PCR_MUX(3); 
    7630:	00050a3d 	andeq	r0, r5, sp, lsr sl
    7634:	10040c00 	andne	r0, r4, r0, lsl #24
    7638:	0d000005 	stceq	0, cr0, [r0, #-20]	; 0xffffffec
            
            if(rx_pin == PTE25)
    763c:	00000311 	andeq	r0, r0, r1, lsl r3
    7640:	00048303 	andeq	r8, r4, r3, lsl #6
              PORTE_BASE_PTR->PCR[25] = PORT_PCR_MUX(3); 
    7644:	371b0400 	ldrcc	r0, [fp, -r0, lsl #8]
    7648:	03000000 	movweq	r0, #0
    764c:	00001d7b 	andeq	r1, r0, fp, ror sp
    7650:	005e1d04 	subseq	r1, lr, r4, lsl #26
            else
              PORTC_BASE_PTR->PCR[14] = PORT_PCR_MUX(3);
    7654:	04020000 	streq	r0, [r2], #-0
    7658:	00066904 	andeq	r6, r6, r4, lsl #18
    765c:	04080200 	streq	r0, [r8], #-512	; 0x200
    7660:	00000a87 	andeq	r0, r0, r7, lsl #21
          }
          else
          {
            x = 5;
    7664:	000fa510 	andeq	sl, pc, r0, lsl r5	; <UNPREDICTABLE>
            uartx = UART5_BASE_PTR;
    7668:	0d050100 	stfeqs	f0, [r5, #-0]
    766c:	0000057c 	andeq	r0, r0, ip, ror r5
    7670:	000daa11 	andeq	sl, sp, r1, lsl sl
            SIM_SCGC1 |= SIM_SCGC1_UART5_MASK;
    7674:	fd113000 	ldc2	0, cr3, [r1, #-0]
    7678:	3200000d 	andcc	r0, r0, #13
    767c:	000f9e11 	andeq	r9, pc, r1, lsl lr	; <UNPREDICTABLE>
    7680:	1100e000 	mrsne	lr, (UNDEF: 0)
    7684:	00000b6f 	andeq	r0, r0, pc, ror #22
    7688:	ef1100e4 	svc	0x001100e4
    768c:	f800000b 			; <UNDEFINED> instruction: 0xf800000b
    7690:	0cf41100 	ldfeqe	f1, [r4]
    7694:	01960000 	orrseq	r0, r6, r0
    7698:	000e5211 	andeq	r5, lr, r1, lsl r2
            
            if(tx_pin == PTD9)
    769c:	1101b400 	tstne	r1, r0, lsl #8
              PORTD_BASE_PTR->PCR[9] = PORT_PCR_MUX(3); 
    76a0:	00000d8b 	andeq	r0, r0, fp, lsl #27
    76a4:	030001c8 	movweq	r0, #456	; 0x1c8
    76a8:	00002390 	muleq	r0, r0, r3
    76ac:	05391805 	ldreq	r1, [r9, #-2053]!	; 0x805
            else
              PORTE_BASE_PTR->PCR[8] = PORT_PCR_MUX(3); 
    76b0:	01020000 	mrseq	r0, (UNDEF: 2)
    76b4:	00071208 	andeq	r1, r7, r8, lsl #4
    76b8:	c6011200 	strgt	r1, [r1], -r0, lsl #4
    76bc:	01000023 	tsteq	r0, r3, lsr #32
            
            if(rx_pin == PTD8)
    76c0:	0515011c 	ldreq	r0, [r5, #-284]	; 0x11c
              PORTD_BASE_PTR->PCR[8] = PORT_PCR_MUX(3); 
    76c4:	54f00000 	ldrbtpl	r0, [r0], #0
    76c8:	57b20000 	ldrpl	r0, [r2, r0]!
    76cc:	17640000 	strbne	r0, [r4, -r0]!
    76d0:	1d010000 	stcne	0, cr0, [r1, #-0]
            else
              PORTE_BASE_PTR->PCR[9] = PORT_PCR_MUX(3); 
    76d4:	13000006 	movwne	r0, #6
    76d8:	00002369 	andeq	r2, r0, r9, ror #6
    76dc:	057c1c01 	ldrbeq	r1, [ip, #-3073]!	; 0xc01
    76e0:	91020000 	mrsls	r0, (UNDEF: 2)
      }
    }
  }
  
  //在配置好其他寄存器前，先关闭发送器和接收器
  uartx->C2 &= ~(UART_C2_TE_MASK | UART_C2_RE_MASK );
    76e4:	2404146f 	strcs	r1, [r4], #-1135	; 0x46f
    76e8:	1e010000 	cdpne	0, 0, cr0, cr1, cr0, {0}
    76ec:	00000515 	andeq	r0, r0, r5, lsl r5
    76f0:	14719102 	ldrbtne	r9, [r1], #-258	; 0x102
  
  //配置UART为 8位, 无奇偶校验 */
  uartx->C1 = 0;	
    76f4:	000023b3 			; <UNDEFINED> instruction: 0x000023b3
    76f8:	05151f01 	ldreq	r1, [r5, #-3841]	; 0xf01
  
  //计算波特率
  sbr = (uint16)((sysclk)/(baud * 16));
    76fc:	91020000 	mrsls	r0, (UNDEF: 2)
    7700:	23c11477 	biccs	r1, r1, #1996488704	; 0x77000000
    7704:	1f010000 	svcne	0x00010000
  
  //保存UARTx_BDH寄存器中除了SBR的值
  temp = uartx->BDH & ~(UART_BDH_SBR(0x1F));
    7708:	00000515 	andeq	r0, r0, r5, lsl r5
    770c:	14769102 	ldrbtne	r9, [r6], #-258	; 0x102
    7710:	0000231e 	andeq	r2, r0, lr, lsl r3
  
  uartx->BDH = temp |  UART_BDH_SBR(((sbr & 0x1F00) >> 8));
    7714:	05152001 	ldreq	r2, [r5, #-1]
    7718:	91020000 	mrsls	r0, (UNDEF: 2)
    771c:	237a1472 	cmncs	sl, #1912602624	; 0x72000000
    7720:	20010000 	andcs	r0, r1, r0
    7724:	00000515 	andeq	r0, r0, r5, lsl r5
    7728:	14759102 	ldrbtne	r9, [r5], #-258	; 0x102
    772c:	00002376 	andeq	r2, r0, r6, ror r3
  uartx->BDL = (uint8)(sbr & UART_BDL_SBR_MASK);
    7730:	05152001 	ldreq	r2, [r5, #-1]
    7734:	91020000 	mrsls	r0, (UNDEF: 2)
  
  //配置波特率的微调分数
  brfa = (((sysclk*32)/(baud * 16)) - (sbr * 32));
    7738:	235f1474 	cmpcs	pc, #1946157056	; 0x74000000
    773c:	20010000 	andcs	r0, r1, r0
    7740:	00000515 	andeq	r0, r0, r5, lsl r5
    7744:	00739102 	rsbseq	r9, r3, r2, lsl #2
    7748:	23dd0115 	bicscs	r0, sp, #1073741829	; 0x40000005
    774c:	ac010000 	stcge	0, cr0, [r1], {-0}
    7750:	0057b401 	subseq	fp, r7, r1, lsl #8
    7754:	00585200 	subseq	r5, r8, r0, lsl #4
    7758:	00179c00 	andseq	r9, r7, r0, lsl #24
  
  //保存UARTx_C4寄存器中除了BRFA的值
  temp = uartx->C4 & ~(UART_C4_BRFA(0x1F));
    775c:	068a0100 	streq	r0, [sl], r0, lsl #2
    7760:	06130000 	ldreq	r0, [r3], -r0
    7764:	01000023 	tsteq	r0, r3, lsr #32
  
  uartx->C4 = temp |  UART_C4_BRFA(brfa);    
    7768:	000520ac 	andeq	r2, r5, ip, lsr #1
    776c:	6c910200 	lfmvs	f0, 4, [r1], {0}
    7770:	00230e13 	eoreq	r0, r3, r3, lsl lr
    7774:	20ac0100 	adccs	r0, ip, r0, lsl #2
    7778:	02000005 	andeq	r0, r0, #5
  
  //配置接收中断
  if(uart_init_structure.UART_RxIntEnable == TRUE && rx_isr != NULL)
    777c:	d5136891 	ldrle	r6, [r3, #-2193]	; 0x891
    7780:	01000023 	tsteq	r0, r3, lsr #32
    7784:	000520ac 	andeq	r2, r5, ip, lsr #1
  {
    uartx->C2 |= UART_C2_RIE_MASK; 
    7788:	64910200 	ldrvs	r0, [r1], #512	; 0x200
    778c:	00231613 	eoreq	r1, r3, r3, lsl r6
    7790:	20ac0100 	adccs	r0, ip, r0, lsl #2
    7794:	02000005 	andeq	r0, r0, #5
    UART_R_ISR[x] = rx_isr;
    7798:	3d146091 	ldccc	0, cr6, [r4, #-580]	; 0xfffffdbc
    779c:	01000023 	tsteq	r0, r3, lsr #32
    77a0:	000520ae 	andeq	r2, r5, lr, lsr #1
    77a4:	70910200 	addsvc	r0, r1, r0, lsl #4
    77a8:	01006916 	tsteq	r0, r6, lsl r9
  } 
  else
  {
    uartx->C2 &= ~(UART_C2_RIE_MASK); 
    77ac:	000515af 	andeq	r1, r5, pc, lsr #11
    77b0:	77910200 	ldrvc	r0, [r1, r0, lsl #4]
    77b4:	0fce1700 	svceq	0x00ce1700
    77b8:	0c010000 	stceq	0, cr0, [r1], {-0}
  }
  //配置发送中断
  if(uart_init_structure.UART_TxIntEnable == TRUE && tx_isr != NULL)
    77bc:	00000520 	andeq	r0, r0, r0, lsr #10
    77c0:	68030501 	stmdavs	r3, {r0, r8, sl}
    77c4:	171fff00 	ldrne	pc, [pc, -r0, lsl #30]
  {
    uartx->C2 |= UART_C2_TIE_MASK; 
    77c8:	00000bf7 	strdeq	r0, [r0], -r7
    77cc:	05200d01 	streq	r0, [r0, #-3329]!	; 0xd01
    77d0:	05010000 	streq	r0, [r1, #-0]
    77d4:	ff006c03 			; <UNDEFINED> instruction: 0xff006c03
    UART_T_ISR[x] = tx_isr;
    77d8:	0b44171f 	bleq	110d45c <__etext+0x11047b4>
    77dc:	0e010000 	cdpeq	0, 0, cr0, cr1, cr0, {0}
    77e0:	00000520 	andeq	r0, r0, r0, lsr #10
    77e4:	70030501 	andvc	r0, r3, r1, lsl #10
    77e8:	171fff00 	ldrne	pc, [pc, -r0, lsl #30]
  } 
  else
  {
    uartx->C2 &= ~(UART_C2_TIE_MASK); 
    77ec:	00000bbb 			; <UNDEFINED> instruction: 0x00000bbb
    77f0:	05200f01 	streq	r0, [r0, #-3841]!	; 0xf01
    77f4:	05010000 	streq	r0, [r1, #-0]
    77f8:	ff007403 			; <UNDEFINED> instruction: 0xff007403
  }
  
  //使能发送器和接收器
  uartx->C2 |= (UART_C2_TE_MASK | UART_C2_RE_MASK );    
    77fc:	0d39001f 	ldceq	0, cr0, [r9, #-124]!	; 0xffffff84
    7800:	00020000 	andeq	r0, r2, r0
    7804:	0000128c 	andeq	r1, r0, ip, lsl #5
    7808:	02340104 	eorseq	r0, r4, #1
}
    780c:	d8010000 	stmdale	r1, {}	; <UNPREDICTABLE>
    7810:	27000024 	strcs	r0, [r0, -r4, lsr #32]
    7814:	54000008 	strpl	r0, [r0], #-8
 * 输出:
 *    串口接收的1个字节
 *
 */
int8 LPLD_UART_GetChar(UART_MemMapPtr uartx)
{
    7818:	7a000058 	bvc	7980 <LPLD_UART_EnableIrq+0xa4>
    781c:	9000005f 	andls	r0, r0, pc, asr r0
  //等待数据接收
  while (!(uartx->S1 & UART_S1_RDRF_MASK));
    7820:	02000014 	andeq	r0, r0, #20
    7824:	070b0601 	streq	r0, [fp, -r1, lsl #12]
    7828:	dd030000 	stcle	0, cr0, [r3, #-0]
    782c:	02000009 	andeq	r0, r0, #9
  
  //返回接收的1个字节数据
  return uartx->D;
    7830:	0000372a 	andeq	r3, r0, sl, lsr #14
    7834:	08010200 	stmdaeq	r1, {r9}
    7838:	00000709 	andeq	r0, r0, r9, lsl #14
}
    783c:	3b050202 	blcc	14804c <__etext+0x13f3a4>
    7840:	02000007 	andeq	r0, r0, #7
    7844:	04920702 	ldreq	r0, [r2], #1794	; 0x702
 * 输出:
 *  0       没有接收到字符
 *  1       已经接收到字符
 */
int32 LPLD_UART_GetChar_Present(UART_MemMapPtr uartx)
{
    7848:	04020000 	streq	r0, [r2], #-0
    784c:	00019605 	andeq	r9, r1, r5, lsl #12
    return (uartx->S1 & UART_S1_RDRF_MASK);
    7850:	079b0300 	ldreq	r0, [fp, r0, lsl #6]
    7854:	50020000 	andpl	r0, r2, r0
    7858:	0000005e 	andeq	r0, r0, lr, asr r0
}
    785c:	e4070402 	str	r0, [r7], #-1026	; 0x402
    7860:	02000001 	andeq	r0, r0, #1
    7864:	01910508 	orrseq	r0, r1, r8, lsl #10
 * 输出:
 *    无
 *
 */
void LPLD_UART_PutChar(UART_MemMapPtr uartx, int8 ch)
{
    7868:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
    786c:	0001df07 	andeq	sp, r1, r7, lsl #30
    7870:	05040400 	streq	r0, [r4, #-1024]	; 0x400
  //等待FIFO准备就绪
  while(!(uartx->S1 & UART_S1_TDRE_MASK));
    7874:	00746e69 	rsbseq	r6, r4, r9, ror #28
    7878:	e9070402 	stmdb	r7, {r1, sl}
    787c:	05000001 	streq	r0, [r0, #-1]
    7880:	a04b0301 	subge	r0, fp, r1, lsl #6
  
  //将要发送的1个字节发给UART数据寄存器
  uartx->D = (uint8)ch;
    7884:	06000003 	streq	r0, [r0], -r3
    7888:	00000aa5 	andeq	r0, r0, r5, lsr #21
}
    788c:	069a0600 	ldreq	r0, [sl], r0, lsl #12
    7890:	06010000 	streq	r0, [r1], -r0
 * 输出:
 *    无
 *
 */
void LPLD_UART_PutCharArr(UART_MemMapPtr uartx, char *ch, int32 len)
{
    7894:	0000020a 	andeq	r0, r0, sl, lsl #4
    7898:	00000602 	andeq	r0, r0, r2, lsl #12
    789c:	06030000 	streq	r0, [r3], -r0
  while(len--)
    78a0:	000000c4 	andeq	r0, r0, r4, asr #1
  {
    LPLD_UART_PutChar(uartx, *(ch++));
    78a4:	01bd0604 			; <UNDEFINED> instruction: 0x01bd0604
    78a8:	06050000 	streq	r0, [r5], -r0
    78ac:	000008bf 			; <UNDEFINED> instruction: 0x000008bf
    78b0:	027d0606 	rsbseq	r0, sp, #6291456	; 0x600000
    78b4:	06070000 	streq	r0, [r7], -r0
    78b8:	0000028b 	andeq	r0, r0, fp, lsl #5
 *    无
 *
 */
void LPLD_UART_PutCharArr(UART_MemMapPtr uartx, char *ch, int32 len)
{
  while(len--)
    78bc:	02990608 	addseq	r0, r9, #8388608	; 0x800000
    78c0:	06090000 	streq	r0, [r9], -r0
    78c4:	000009a4 	andeq	r0, r0, r4, lsr #19
    78c8:	0a11060a 	beq	4490f8 <__etext+0x440450>
    78cc:	060b0000 	streq	r0, [fp], -r0
    78d0:	0000059a 	muleq	r0, sl, r5
  {
    LPLD_UART_PutChar(uartx, *(ch++));
  }
}
    78d4:	09c5060c 	stmibeq	r5, {r2, r3, r9, sl}^
    78d8:	060d0000 	streq	r0, [sp], -r0
 * 输出:
 *    无
 *
 */
void LPLD_UART_EnableIrq(UART_InitTypeDef uart_init_structure)
{
    78dc:	0000054b 	andeq	r0, r0, fp, asr #10
    78e0:	03de060e 	bicseq	r0, lr, #14680064	; 0xe00000
    78e4:	060f0000 	streq	r0, [pc], -r0
    78e8:	00000108 	andeq	r0, r0, r8, lsl #2
  if(uart_init_structure.UART_Uartx == UART0_BASE_PTR)
    78ec:	068b0610 	pkhbteq	r0, fp, r0, lsl #12
    78f0:	06110000 	ldreq	r0, [r1], -r0
    78f4:	00000148 	andeq	r0, r0, r8, asr #2
  {
    enable_irq(INT_UART0_RX_TX - 16);
    78f8:	06f10612 	usateq	r0, #17, r2, lsl #12
    78fc:	06130000 	ldreq	r0, [r3], -r0
    7900:	0000037a 	andeq	r0, r0, sl, ror r3
  }
  else if(uart_init_structure.UART_Uartx == UART1_BASE_PTR)
    7904:	08180614 	ldmdaeq	r8, {r2, r4, r9, sl}
    7908:	06150000 	ldreq	r0, [r5], -r0
    790c:	000003cf 	andeq	r0, r0, pc, asr #7
  {
    enable_irq(INT_UART1_RX_TX - 16);
    7910:	08b00616 	ldmeq	r0!, {r1, r2, r4, r9, sl}
    7914:	06170000 	ldreq	r0, [r7], -r0
    7918:	0000042f 	andeq	r0, r0, pc, lsr #8
  }
  else if(uart_init_structure.UART_Uartx == UART2_BASE_PTR)
    791c:	01390618 	teqeq	r9, r8, lsl r6
    7920:	06190000 	ldreq	r0, [r9], -r0
    7924:	000003bf 			; <UNDEFINED> instruction: 0x000003bf
  {
    enable_irq(INT_UART3_RX_TX - 16);
    7928:	0898061a 	ldmeq	r8, {r1, r3, r4, r9, sl}
    792c:	061b0000 	ldreq	r0, [fp], -r0
    7930:	0000040d 	andeq	r0, r0, sp, lsl #8
  }
  else if(uart_init_structure.UART_Uartx == UART3_BASE_PTR)
    7934:	08e8061c 	stmiaeq	r8!, {r2, r3, r4, r9, sl}^
    7938:	061d0000 	ldreq	r0, [sp], -r0
    793c:	0000051f 	andeq	r0, r0, pc, lsl r5
  {
    enable_irq(INT_UART3_RX_TX - 16);
    7940:	03af061e 			; <UNDEFINED> instruction: 0x03af061e
    7944:	061f0000 	ldreq	r0, [pc], -r0
    7948:	000008cf 	andeq	r0, r0, pc, asr #17
  }
  else if(uart_init_structure.UART_Uartx == UART4_BASE_PTR)
    794c:	02120620 	andseq	r0, r2, #33554432	; 0x2000000
    7950:	06210000 	strteq	r0, [r1], -r0
    7954:	000003f3 	strdeq	r0, [r0], -r3
  {
    enable_irq(INT_UART4_RX_TX - 16);
    7958:	01170622 	tsteq	r7, r2, lsr #12
    795c:	06230000 	strteq	r0, [r3], -r0
    7960:	000005e0 	andeq	r0, r0, r0, ror #11
  }
  else if(uart_init_structure.UART_Uartx == UART5_BASE_PTR)
    7964:	04d30624 	ldrbeq	r0, [r3], #1572	; 0x624
    7968:	06250000 	strteq	r0, [r5], -r0
    796c:	00000a37 	andeq	r0, r0, r7, lsr sl
  {
    enable_irq(INT_UART5_RX_TX - 16);
    7970:	06530626 	ldrbeq	r0, [r3], -r6, lsr #12
    7974:	06270000 	strteq	r0, [r7], -r0
  }
}
    7978:	0000075e 	andeq	r0, r0, lr, asr r7
    797c:	0a530628 	beq	14c9224 <__etext+0x14c057c>
    7980:	06290000 	strteq	r0, [r9], -r0
 * 输出:
 *    无
 *
 */
void LPLD_UART_DisableIrq(UART_InitTypeDef uart_init_structure)
{
    7984:	00000a67 	andeq	r0, r0, r7, ror #20
    7988:	077f062a 	ldrbeq	r0, [pc, -sl, lsr #12]!
    798c:	062b0000 	strteq	r0, [fp], -r0
    7990:	00000a70 	andeq	r0, r0, r0, ror sl
  //根据中断请求号使能相应中断
  if(uart_init_structure.UART_Uartx == UART0_BASE_PTR)
    7994:	0089062c 	addeq	r0, r9, ip, lsr #12
    7998:	062d0000 	strteq	r0, [sp], -r0
    799c:	00000166 	andeq	r0, r0, r6, ror #2
    disable_irq(INT_UART0_RX_TX - 16);
    79a0:	058b062e 	streq	r0, [fp, #1582]	; 0x62e
    79a4:	062f0000 	strteq	r0, [pc], -r0
    79a8:	00000877 	andeq	r0, r0, r7, ror r8
  else if(uart_init_structure.UART_Uartx == UART1_BASE_PTR)
    79ac:	08630630 	stmdaeq	r3!, {r4, r5, r9, sl}^
    79b0:	06310000 	ldrteq	r0, [r1], -r0
    79b4:	000002b7 			; <UNDEFINED> instruction: 0x000002b7
    disable_irq(INT_UART1_RX_TX - 16);
    79b8:	03680632 	cmneq	r8, #52428800	; 0x3200000
    79bc:	06330000 	ldrteq	r0, [r3], -r0
    79c0:	00000a8e 	andeq	r0, r0, lr, lsl #21
  else if(uart_init_structure.UART_Uartx == UART2_BASE_PTR)
    79c4:	006c0634 	rsbeq	r0, ip, r4, lsr r6
    79c8:	06350000 	ldrteq	r0, [r5], -r0
    79cc:	00000399 	muleq	r0, r9, r3
    disable_irq(INT_UART2_RX_TX - 16);
    79d0:	01ae0636 			; <UNDEFINED> instruction: 0x01ae0636
    79d4:	06370000 	ldrteq	r0, [r7], -r0
    79d8:	000001f6 	strdeq	r0, [r0], -r6
  else if(uart_init_structure.UART_Uartx == UART3_BASE_PTR)
    79dc:	01cb0638 	biceq	r0, fp, r8, lsr r6
    79e0:	06390000 	ldrteq	r0, [r9], -r0
    79e4:	0000043e 	andeq	r0, r0, lr, lsr r4
    disable_irq(INT_UART3_RX_TX - 16);
    79e8:	04db063a 	ldrbeq	r0, [fp], #1594	; 0x63a
    79ec:	063b0000 	ldrteq	r0, [fp], -r0
    79f0:	00000745 	andeq	r0, r0, r5, asr #14
  else if(uart_init_structure.UART_Uartx == UART4_BASE_PTR)
    79f4:	0918063c 	ldmdbeq	r8, {r2, r3, r4, r5, r9, sl}
    79f8:	063d0000 	ldrteq	r0, [sp], -r0
    79fc:	00000454 	andeq	r0, r0, r4, asr r4
    disable_irq(INT_UART4_RX_TX - 16);
    7a00:	046a063e 	strbteq	r0, [sl], #-1598	; 0x63e
    7a04:	063f0000 	ldrteq	r0, [pc], -r0
    7a08:	00000a79 	andeq	r0, r0, r9, ror sl
  else if(uart_init_structure.UART_Uartx == UART5_BASE_PTR)
    7a0c:	940600c0 	strls	r0, [r6], #-192	; 0xc0
    7a10:	c1000009 	tstgt	r0, r9
    7a14:	057d0600 	ldrbeq	r0, [sp, #-1536]!	; 0x600
    disable_irq(INT_UART5_RX_TX - 16);
    7a18:	00c20000 	sbceq	r0, r2, r0
    7a1c:	0004a506 	andeq	sl, r4, r6, lsl #10
}
    7a20:	0600c300 	streq	ip, [r0], -r0, lsl #6
    7a24:	00000a21 	andeq	r0, r0, r1, lsr #20
    7a28:	f80600c4 			; <UNDEFINED> instruction: 0xf80600c4

//HW层中断函数，用户无需调用
//UART0
void UART0_RX_TX_IRQHandler(void)
{
    7a2c:	c5000009 	strgt	r0, [r0, #-9]
  
  //进入接收中断函数
  if((UART0_S1 & UART_S1_RDRF_MASK) && (UART0_C2 & UART_C2_RIE_MASK))
    7a30:	097a0600 	ldmdbeq	sl!, {r9, sl}^
    7a34:	00c60000 	sbceq	r0, r6, r0
    7a38:	0004c306 	andeq	ip, r4, r6, lsl #6
    7a3c:	0600c700 	streq	ip, [r0], -r0, lsl #14
    7a40:	0000053d 	andeq	r0, r0, sp, lsr r5
    7a44:	040600c8 	streq	r0, [r6], #-200	; 0xc8
    7a48:	c9000004 	stmdbgt	r0, {r2}
    7a4c:	022b0600 	eoreq	r0, fp, #0
    7a50:	00ca0000 	sbceq	r0, sl, r0
    7a54:	0009b306 	andeq	fp, r9, r6, lsl #6
  {
    UART_R_ISR[0]();
    7a58:	0600cb00 	streq	ip, [r0], -r0, lsl #22
    7a5c:	0000066f 	andeq	r0, r0, pc, ror #12
    7a60:	780600cc 	stmdavc	r6, {r2, r3, r6, r7}
  }
  //进入发送中断函数
  if((UART0_S1 & UART_S1_TDRE_MASK) && (UART0_C2 & UART_C2_TIE_MASK))
    7a64:	cd000006 	stcgt	0, cr0, [r0, #-24]	; 0xffffffe8
    7a68:	02cd0600 	sbceq	r0, sp, #0
    7a6c:	00ce0000 	sbceq	r0, lr, r0
    7a70:	0002d606 	andeq	sp, r2, r6, lsl #12
    7a74:	0600cf00 	streq	ip, [r0], -r0, lsl #30
    7a78:	000002df 	ldrdeq	r0, [r0], -pc	; <UNPREDICTABLE>
    7a7c:	1a0600d0 	bne	187dc4 <__etext+0x17f11c>
    7a80:	d1000002 	tstle	r0, r2
    7a84:	04620600 	strbteq	r0, [r2], #-1536	; 0x600
    7a88:	00d20000 	sbcseq	r0, r2, r0
  {
    UART_T_ISR[0]();
    7a8c:	00038906 	andeq	r8, r3, r6, lsl #18
    7a90:	0600d300 	streq	sp, [r0], -r0, lsl #6
    7a94:	0000047a 	andeq	r0, r0, sl, ror r4
  }
}
    7a98:	2e0600d4 	mcrcs	0, 0, r0, cr6, cr4, {6}

//UART1
void UART1_RX_TX_IRQHandler(void)
{
    7a9c:	d5000000 	strle	r0, [r0, #-0]
  
  //进入接收中断函数
  if((UART1_S1 & UART_S1_RDRF_MASK) && (UART1_C2 & UART_C2_RIE_MASK))
    7aa0:	07cb0600 	strbeq	r0, [fp, r0, lsl #12]
    7aa4:	00d60000 	sbcseq	r0, r6, r0
    7aa8:	00004506 	andeq	r4, r0, r6, lsl #10
    7aac:	0600d700 	streq	sp, [r0], -r0, lsl #14
    7ab0:	000005ec 	andeq	r0, r0, ip, ror #11
    7ab4:	220600d8 	andcs	r0, r6, #216	; 0xd8
    7ab8:	d9000002 	stmdble	r0, {r1}
    7abc:	07530600 	ldrbeq	r0, [r3, -r0, lsl #12]
    7ac0:	00da0000 	sbcseq	r0, sl, r0
    7ac4:	00090406 	andeq	r0, r9, r6, lsl #8
  {
    UART_R_ISR[0]();
    7ac8:	0600db00 	streq	sp, [r0], -r0, lsl #22
    7acc:	000000de 	ldrdeq	r0, [r0], -lr
    7ad0:	560600dc 			; <UNDEFINED> instruction: 0x560600dc
  }
  //进入发送中断函数
  if((UART1_S1 & UART_S1_TDRE_MASK) && (UART1_C2 & UART_C2_TIE_MASK))
    7ad4:	dd000000 	stcle	0, cr0, [r0, #-0]
    7ad8:	019f0600 	orrseq	r0, pc, r0, lsl #12
    7adc:	00de0000 	sbcseq	r0, lr, r0
    7ae0:	000a4406 	andeq	r4, sl, r6, lsl #8
    7ae4:	0600df00 	streq	sp, [r0], -r0, lsl #30
    7ae8:	000000a6 	andeq	r0, r0, r6, lsr #1
    7aec:	d70600e0 	strle	r0, [r6, -r0, ror #1]
    7af0:	e1000005 	tst	r0, r5
    7af4:	04ea0600 	strbteq	r0, [sl], #1536	; 0x600
    7af8:	00e20000 	rsceq	r0, r2, r0
  {
    UART_T_ISR[0]();
    7afc:	0003ea06 	andeq	lr, r3, r6, lsl #20
    7b00:	0600e300 	streq	lr, [r0], -r0, lsl #6
    7b04:	0000004e 	andeq	r0, r0, lr, asr #32
  }
}
    7b08:	060600e4 	streq	r0, [r6], -r4, ror #1

//UART2
void UART2_RX_TX_IRQHandler(void)
{
    7b0c:	e5000003 	str	r0, [r0, #-3]
  //进入接收中断函数
  if((UART2_S1 & UART_S1_RDRF_MASK) && (UART2_C2 & UART_C2_RIE_MASK))
    7b10:	00b40600 	adcseq	r0, r4, r0, lsl #12
    7b14:	00e60000 	rsceq	r0, r6, r0
    7b18:	0005f506 	andeq	pc, r5, r6, lsl #10
    7b1c:	0600e700 	streq	lr, [r0], -r0, lsl #14
    7b20:	0000012a 	andeq	r0, r0, sl, lsr #2
    7b24:	100600e8 	andne	r0, r6, r8, ror #1
    7b28:	e9000006 	stmdb	r0, {r1, r2}
    7b2c:	07310600 	ldreq	r0, [r1, -r0, lsl #12]!
    7b30:	00ea0000 	rsceq	r0, sl, r0
    7b34:	00062c06 	andeq	r2, r6, r6, lsl #24
  {
    UART_R_ISR[0]();
    7b38:	0600eb00 	streq	lr, [r0], -r0, lsl #22
    7b3c:	00000636 	andeq	r0, r0, r6, lsr r6
    7b40:	900600ec 	andls	r0, r6, ip, ror #1
  }
  //进入发送中断函数
  if((UART2_S1 & UART_S1_TDRE_MASK) && (UART2_C2 & UART_C2_TIE_MASK))
    7b44:	ed000008 	stc	0, cr0, [r0, #-32]	; 0xffffffe0
    7b48:	06610600 	strbteq	r0, [r1], -r0, lsl #12
    7b4c:	00ee0000 	rsceq	r0, lr, r0
    7b50:	0005c306 	andeq	ip, r5, r6, lsl #6
    7b54:	0600ef00 	streq	lr, [r0], -r0, lsl #30
    7b58:	00000681 	andeq	r0, r0, r1, lsl #13
    7b5c:	f80600f0 			; <UNDEFINED> instruction: 0xf80600f0
    7b60:	f1000000 	cps	#0
    7b64:	09e50600 	stmibeq	r5!, {r9, sl}^
    7b68:	00f20000 	rscseq	r0, r2, r0
  {
    UART_T_ISR[0]();
    7b6c:	00035d06 	andeq	r5, r3, r6, lsl #26
    7b70:	0600f300 	streq	pc, [r0], -r0, lsl #6
    7b74:	000002a7 	andeq	r0, r0, r7, lsr #5
  }
}
    7b78:	e80600f4 	stmda	r6, {r2, r4, r5, r6, r7}

//uart3
void UART3_RX_TX_IRQHandler(void)
{
    7b7c:	f5000002 			; <UNDEFINED> instruction: 0xf5000002
  //进入接收中断函数
  if((UART3_S1 & UART_S1_RDRF_MASK) && (UART3_C2 & UART_C2_RIE_MASK))
    7b80:	041d0600 	ldreq	r0, [sp], #-1536	; 0x600
    7b84:	00f60000 	rscseq	r0, r6, r0
    7b88:	00042606 	andeq	r2, r4, r6, lsl #12
    7b8c:	0600f700 	streq	pc, [r0], -r0, lsl #14
    7b90:	00000185 	andeq	r0, r0, r5, lsl #3
    7b94:	880600f8 	stmdahi	r6, {r3, r4, r5, r6, r7}
    7b98:	f9000009 			; <UNDEFINED> instruction: 0xf9000009
    7b9c:	87070000 	strhi	r0, [r7, -r0]
    7ba0:	70000019 	andvc	r0, r0, r9, lsl r0
    7ba4:	0520f003 	streq	pc, [r0, #-3]!
  {
    UART_R_ISR[0]();
    7ba8:	53080000 	movwpl	r0, #32768	; 0x8000
    7bac:	03003143 	movweq	r3, #323	; 0x143
    7bb0:	000520f1 	strdeq	r2, [r5], -r1
  }
  //进入发送中断函数
  if((UART3_S1 & UART_S1_TDRE_MASK) && (UART3_C2 & UART_C2_TIE_MASK))
    7bb4:	00230200 	eoreq	r0, r3, r0, lsl #4
    7bb8:	000f2a09 	andeq	r2, pc, r9, lsl #20
    7bbc:	53f20300 	mvnspl	r0, #0
    7bc0:	02000000 	andeq	r0, r0, #0
    7bc4:	30090823 	andcc	r0, r9, r3, lsr #16
    7bc8:	0300000f 	movweq	r0, #15
    7bcc:	000053f3 	strdeq	r5, [r0], -r3
    7bd0:	0c230200 	sfmeq	f0, 4, [r3], #-0
    7bd4:	03005208 	movweq	r5, #520	; 0x208
    7bd8:	000520f4 	strdeq	r2, [r5], -r4
  {
    UART_T_ISR[0]();
    7bdc:	10230200 	eorne	r0, r3, r0, lsl #4
    7be0:	31564308 	cmpcc	r6, r8, lsl #6
    7be4:	53f50300 	mvnspl	r0, #0
  }
}
    7be8:	02000000 	andeq	r0, r0, #0

//uart4
void UART4_RX_TX_IRQHandler(void)
{
    7bec:	43081823 	movwmi	r1, #34851	; 0x8823
  //进入接收中断函数
  if((UART4_S1 & UART_S1_RDRF_MASK) && (UART4_C2 & UART_C2_RIE_MASK))
    7bf0:	03003256 	movweq	r3, #598	; 0x256
    7bf4:	000053f6 	strdeq	r5, [r0], -r6
    7bf8:	1c230200 	sfmne	f0, 4, [r3], #-0
    7bfc:	32435308 	subcc	r5, r3, #536870912	; 0x20000000
    7c00:	53f70300 	mvnspl	r0, #0
    7c04:	02000000 	andeq	r0, r0, #0
    7c08:	53082023 	movwpl	r2, #32803	; 0x8023
    7c0c:	03003343 	movweq	r3, #835	; 0x343
    7c10:	000053f8 	strdeq	r5, [r0], -r8
    7c14:	24230200 	strtcs	r0, [r3], #-512	; 0x200
  {
    UART_R_ISR[0]();
    7c18:	53464f08 	movtpl	r4, #28424	; 0x6f08
    7c1c:	53f90300 	mvnspl	r0, #0
    7c20:	02000000 	andeq	r0, r0, #0
  }
  //进入发送中断函数
  if((UART4_S1 & UART_S1_TDRE_MASK) && (UART4_C2 & UART_C2_TIE_MASK))
    7c24:	50082823 	andpl	r2, r8, r3, lsr #16
    7c28:	fa030047 	blx	c7d4c <__etext+0xbf0a4>
    7c2c:	00000053 	andeq	r0, r0, r3, asr r0
    7c30:	082c2302 	stmdaeq	ip!, {r1, r8, r9, sp}
    7c34:	0300474d 	movweq	r4, #1869	; 0x74d
    7c38:	000053fb 	strdeq	r5, [r0], -fp
    7c3c:	30230200 	eorcc	r0, r3, r0, lsl #4
    7c40:	00191809 	andseq	r1, r9, r9, lsl #16
    7c44:	53fc0300 	mvnspl	r0, #0
    7c48:	02000000 	andeq	r0, r0, #0
  {
    UART_T_ISR[0]();
    7c4c:	1d093423 	cfstrsne	mvf3, [r9, #-140]	; 0xffffff74
    7c50:	03000019 	movweq	r0, #25
    7c54:	000053fd 	strdeq	r5, [r0], -sp
  }
}
    7c58:	38230200 	stmdacc	r3!, {r9}

//uart3
void UART5_RX_TX_IRQHandler(void)
{
    7c5c:	00191309 	andseq	r1, r9, r9, lsl #6
  //进入接收中断函数
  if((UART5_S1 & UART_S1_RDRF_MASK) && (UART5_C2 & UART_C2_RIE_MASK))
    7c60:	53fe0300 	mvnspl	r0, #0
    7c64:	02000000 	andeq	r0, r0, #0
    7c68:	0e093c23 	cdpeq	12, 0, cr3, cr9, cr3, {1}
    7c6c:	03000019 	movweq	r0, #25
    7c70:	000053ff 	strdeq	r5, [r0], -pc	; <UNPREDICTABLE>
    7c74:	40230200 	eormi	r0, r3, r0, lsl #4
    7c78:	0019090a 	andseq	r0, r9, sl, lsl #18
    7c7c:	01000300 	mrseq	r0, LR_irq
    7c80:	00000053 	andeq	r0, r0, r3, asr r0
    7c84:	0a442302 	beq	1110894 <__etext+0x1107bec>
  {
    UART_R_ISR[0]();
    7c88:	00001904 	andeq	r1, r0, r4, lsl #18
    7c8c:	53010103 	movwpl	r0, #4355	; 0x1103
    7c90:	02000000 	andeq	r0, r0, #0
  }
  //进入发送中断函数
  if((UART5_S1 & UART_S1_TDRE_MASK) && (UART5_C2 & UART_C2_TIE_MASK))
    7c94:	ff0a4823 			; <UNDEFINED> instruction: 0xff0a4823
    7c98:	03000018 	movweq	r0, #24
    7c9c:	00530102 	subseq	r0, r3, r2, lsl #2
    7ca0:	23020000 	movwcs	r0, #8192	; 0x2000
    7ca4:	47500b4c 	ldrbmi	r0, [r0, -ip, asr #22]
    7ca8:	03030041 	movweq	r0, #12353	; 0x3041
    7cac:	00005301 	andeq	r5, r0, r1, lsl #6
    7cb0:	50230200 	eorpl	r0, r3, r0, lsl #4
    7cb4:	0018a10a 	andseq	sl, r8, sl, lsl #2
    7cb8:	01040300 	mrseq	r0, LR_abt
  {
    UART_T_ISR[0]();
    7cbc:	00000053 	andeq	r0, r0, r3, asr r0
    7cc0:	0a542302 	beq	15108d0 <__etext+0x1507c28>
    7cc4:	000018a6 	andeq	r1, r0, r6, lsr #17
  }
}
    7cc8:	53010503 	movwpl	r0, #5379	; 0x1503
#include "common.h"
#include "hw_uart.h"

/********************************************************************/
int8 in_char (void)
{
    7ccc:	02000000 	andeq	r0, r0, #0
	return LPLD_UART_GetChar(TERM_PORT);
    7cd0:	7b0a5823 	blvc	29dd64 <__etext+0x2950bc>
    7cd4:	03000018 	movweq	r0, #24
    7cd8:	00530106 	subseq	r0, r3, r6, lsl #2
    7cdc:	23020000 	movwcs	r0, #8192	; 0x2000
}
    7ce0:	18760a5c 	ldmdane	r6!, {r2, r3, r4, r6, r9, fp}^
/********************************************************************/
void out_char (int8 ch)
{
    7ce4:	07030000 	streq	r0, [r3, -r0]
    7ce8:	00005301 	andeq	r5, r0, r1, lsl #6
    7cec:	60230200 	eorvs	r0, r3, r0, lsl #4
	LPLD_UART_PutChar(TERM_PORT, ch);
    7cf0:	0018710a 	andseq	r7, r8, sl, lsl #2
    7cf4:	01080300 	mrseq	r0, (UNDEF: 56)
    7cf8:	00000053 	andeq	r0, r0, r3, asr r0
    7cfc:	0a642302 	beq	191090c <__etext+0x1907c64>
}
    7d00:	0000186c 	andeq	r1, r0, ip, ror #16
    7d04:	53010903 	movwpl	r0, #6403	; 0x1903
/********************************************************************/
int32 char_present (void)
{
    7d08:	02000000 	andeq	r0, r0, #0
	return LPLD_UART_GetChar_Present(TERM_PORT);
    7d0c:	670a6823 	strvs	r6, [sl, -r3, lsr #16]
    7d10:	03000018 	movweq	r0, #24
    7d14:	0053010a 	subseq	r0, r3, sl, lsl #2
    7d18:	23020000 	movwcs	r0, #8192	; 0x2000
}
    7d1c:	530c006c 	movwpl	r0, #49260	; 0xc06c
#define IS_FMT_p(a)     (a & FMT_p)
#define IS_FMT_n(a)     (a & FMT_n)

/********************************************************************/
static void printk_putc (int32 c, int32 *count, PRINTK_INFO *info)
{
    7d20:	30000000 	andcc	r0, r0, r0
    7d24:	0d000005 	stceq	0, cr0, [r0, #-20]	; 0xffffffec
    7d28:	00000530 	andeq	r0, r0, r0, lsr r5
    switch (info->dest)
    7d2c:	04020001 	streq	r0, [r2], #-1
    7d30:	00057407 	andeq	r7, r5, r7, lsl #8
    7d34:	194f0e00 	stmdbne	pc, {r9, sl, fp}^	; <UNPREDICTABLE>
    7d38:	0b030000 	bleq	c7d40 <__etext+0xbf098>
    {
        case DEST_CONSOLE:
            info->func((int8)c);
    7d3c:	00054301 	andeq	r4, r5, r1, lsl #6
    7d40:	49040f00 	stmdbmi	r4, {r8, r9, sl, fp}
    7d44:	10000005 	andne	r0, r0, r5
            break;
    7d48:	000003a0 	andeq	r0, r0, r0, lsr #7
        case DEST_STRING:
            *(info->loc) = (uint8)c;
    7d4c:	00002c0c 	andeq	r2, r0, ip, lsl #24
    7d50:	00055e00 	andeq	r5, r5, r0, lsl #28
            ++(info->loc);
    7d54:	05300d00 	ldreq	r0, [r0, #-3328]!	; 0xd00
    7d58:	00030000 	andeq	r0, r3, r0
    7d5c:	00002c0c 	andeq	r2, r0, ip, lsl #24
            break;
    7d60:	00056e00 	andeq	r6, r5, r0, lsl #28
        default:
            break;
    }
    *count += 1;
    7d64:	05300d00 	ldreq	r0, [r0, #-3328]!	; 0xd00
    7d68:	00070000 	andeq	r0, r7, r0
    7d6c:	00002c0c 	andeq	r2, r0, ip, lsl #24
}
    7d70:	00057e00 	andeq	r7, r5, r0, lsl #28
    7d74:	05300d00 	ldreq	r0, [r0, #-3328]!	; 0xd00

/********************************************************************/
static int32 printk_mknumstr (int8 *numstr, void *nump, int32 neg, int32 radix)
{
    7d78:	002f0000 	eoreq	r0, pc, r0
    7d7c:	2b030211 	blcs	c85c8 <__etext+0xbf920>
    7d80:	0005a60d 	andeq	sl, r5, sp, lsl #12
    7d84:	249d0a00 	ldrcs	r0, [sp], #2560	; 0xa00
    uint32 ua,ub,uc;

    int32 nlen;
    int8 *nstrp;

    nlen = 0;
    7d88:	2c030000 	stccs	0, cr0, [r3], {-0}
    nstrp = numstr;
    7d8c:	00002c0d 	andeq	r2, r0, sp, lsl #24
    *nstrp++ = '\0';
    7d90:	00230200 	eoreq	r0, r3, r0, lsl #4
    7d94:	0024980a 	eoreq	r9, r4, sl, lsl #16
    7d98:	0d2d0300 	stceq	3, cr0, [sp, #-0]
    7d9c:	0000002c 	andeq	r0, r0, ip, lsr #32

    if (neg)
    7da0:	00012302 	andeq	r2, r1, r2, lsl #6
    7da4:	0025d712 	eoreq	sp, r5, r2, lsl r7
    {
        a = *(int32 *)nump;
    7da8:	2a032400 	bcs	d0db0 <__etext+0xc8108>
        if (a == 0)
    7dac:	0005fb0d 	andeq	pc, r5, sp, lsl #22
    7db0:	41440b00 	cmpmi	r4, r0, lsl #22
        {
            *nstrp = '0';
    7db4:	2e030054 	mcrcs	0, 0, r0, cr3, cr4, {2}
    7db8:	0005fb0d 	andeq	pc, r5, sp, lsl #22
            ++nlen;
    7dbc:	00230200 	eoreq	r0, r3, r0, lsl #4
    7dc0:	0052530b 	subseq	r5, r2, fp, lsl #6
            goto done;
        }
        while (a != 0)
        {
            b = (int32)a / (int32)radix;
    7dc4:	2c0d2f03 	stccs	15, cr2, [sp], {3}
    7dc8:	02000000 	andeq	r0, r0, #0
    7dcc:	430b2023 	movwmi	r2, #45091	; 0xb023
            c = (int32)a - ((int32)b * (int32)radix);
    7dd0:	30030030 	andcc	r0, r3, r0, lsr r0
    7dd4:	00002c0d 	andeq	r2, r0, sp, lsl #24
    7dd8:	21230200 	teqcs	r3, r0, lsl #4
            if (c < 0)
    7ddc:	0031430b 	eorseq	r4, r1, fp, lsl #6
    7de0:	2c0d3103 	stfcss	f3, [sp], {3}
            {
                c = ~c + 1 + '0';
    7de4:	02000000 	andeq	r0, r0, #0
    7de8:	430b2223 	movwmi	r2, #45603	; 0xb223
            }
            else
            {
                c = c + '0';
    7dec:	32030032 	andcc	r0, r3, #50	; 0x32
    7df0:	00002c0d 	andeq	r2, r0, sp, lsl #24
            }
            a = b;
    7df4:	23230200 	teqcs	r3, #0
            *nstrp++ = (int8)c;
    7df8:	057e0c00 	ldrbeq	r0, [lr, #-3072]!	; 0xc00
    7dfc:	060b0000 	streq	r0, [fp], -r0
    7e00:	300d0000 	andcc	r0, sp, r0
    7e04:	0f000005 	svceq	0x00000005
            ++nlen;
    7e08:	24a20e00 	strtcs	r0, [r2], #3584	; 0xe00
    7e0c:	33030000 	movwcc	r0, #12288	; 0x3000
        {
            *nstrp = '0';
            ++nlen;
            goto done;
        }
        while (a != 0)
    7e10:	0006170d 	andeq	r1, r6, sp, lsl #14
    7e14:	1d040f00 	stcne	15, cr0, [r4, #-0]
            ++nlen;
        }
    }
    else
    {
        ua = *(uint32 *)nump;
    7e18:	10000006 	andne	r0, r0, r6
    7e1c:	000005a6 	andeq	r0, r0, r6, lsr #11
        if (ua == 0)
    7e20:	00002c0c 	andeq	r2, r0, ip, lsl #24
        {
            *nstrp = '0';
    7e24:	00063200 	andeq	r3, r6, r0, lsl #4
    7e28:	05300d00 	ldreq	r0, [r0, #-3328]!	; 0xd00
            ++nlen;
    7e2c:	00170000 	andseq	r0, r7, r0
    7e30:	0000530c 	andeq	r5, r0, ip, lsl #6
            goto done;
    7e34:	00064200 	andeq	r4, r6, r0, lsl #4
        }
        while (ua != 0)
        {
            ub = (uint32)ua / (uint32)radix;
    7e38:	05300d00 	ldreq	r0, [r0, #-3328]!	; 0xd00
    7e3c:	00030000 	andeq	r0, r3, r0
            uc = (uint32)ua - ((uint32)ub * (uint32)radix);
    7e40:	dd032811 	stcle	8, cr2, [r3, #-68]	; 0xffffffbc
    7e44:	00068533 	andeq	r8, r6, r3, lsr r5
    7e48:	31430b00 	cmpcc	r3, r0, lsl #22
    7e4c:	33de0300 	bicscc	r0, lr, #0
            if (uc < 10)
    7e50:	00000053 	andeq	r0, r0, r3, asr r0
            {
                uc = uc + '0';
    7e54:	0b002302 	bleq	10a64 <__etext+0x7dbc>
    7e58:	df030053 	svcle	0x00030053
    7e5c:	00005333 	andeq	r5, r0, r3, lsr r3
            }
            else
            {
                uc = uc - 10 + 'A';
    7e60:	04230200 	strteq	r0, [r3], #-512	; 0x200
    7e64:	594c440b 	stmdbpl	ip, {r0, r1, r3, sl, lr}^
            }
            ua = ub;
    7e68:	33e00300 	mvncc	r0, #0
            *nstrp++ = (int8)uc;
    7e6c:	00000520 	andeq	r0, r0, r0, lsr #10
    7e70:	0a082302 	beq	210a80 <__etext+0x207dd8>
    7e74:	00000312 	andeq	r0, r0, r2, lsl r3
    7e78:	2233e103 	eorscs	lr, r3, #-1073741824	; 0xc0000000
            ++nlen;
    7e7c:	02000006 	andeq	r0, r0, #6
    7e80:	11001023 	tstne	r0, r3, lsr #32
        {
            *nstrp = '0';
            ++nlen;
            goto done;
        }
        while (ua != 0)
    7e84:	33e40308 	mvncc	r0, #536870912	; 0x20000000
            *nstrp++ = (int8)uc;
            ++nlen;
        }
    }
    done:
    return nlen;
    7e88:	000006ad 	andeq	r0, r0, sp, lsr #13
}
    7e8c:	0024b00a 	eoreq	fp, r4, sl
    7e90:	33e50300 	mvncc	r0, #0
    7e94:	00000053 	andeq	r0, r0, r3, asr r0

/********************************************************************/
static void printk_pad_zero (int32 curlen, int32 field_width, int32 *count, PRINTK_INFO *info)
{
    7e98:	0b002302 	bleq	10aa8 <__etext+0x7e00>
    7e9c:	00544e49 	subseq	r4, r4, r9, asr #28
    7ea0:	5333e603 	teqpl	r3, #3145728	; 0x300000
    7ea4:	02000000 	andeq	r0, r0, #0
    int32 i;

    for (i = curlen; i < field_width; i++)
    7ea8:	13000423 	movwne	r0, #1059	; 0x423
    {
        printk_putc('0',count, info);
    7eac:	00002435 	andeq	r2, r0, r5, lsr r4
    7eb0:	d80301a4 	stmdale	r3, {r2, r5, r7, r8}
    7eb4:	00075533 	andeq	r5, r7, r3, lsr r5
/********************************************************************/
static void printk_pad_zero (int32 curlen, int32 field_width, int32 *count, PRINTK_INFO *info)
{
    int32 i;

    for (i = curlen; i < field_width; i++)
    7eb8:	43530b00 	cmpmi	r3, #0
    7ebc:	33d90300 	bicscc	r0, r9, #0
    7ec0:	00000053 	andeq	r0, r0, r3, asr r0
    7ec4:	0b002302 	bleq	10ad4 <__etext+0x7e2c>
    {
        printk_putc('0',count, info);
    }
}
    7ec8:	00444f4d 	subeq	r4, r4, sp, asr #30
    7ecc:	5333da03 	teqpl	r3, #12288	; 0x3000

/********************************************************************/
static void
printk_pad_space (int32 curlen, int32 field_width, int32 *count, PRINTK_INFO *info)
{
    7ed0:	02000000 	andeq	r0, r0, #0
    7ed4:	430b0423 	movwmi	r0, #46115	; 0xb423
    7ed8:	0300544e 	movweq	r5, #1102	; 0x44e
    7edc:	005333db 	ldrsbeq	r3, [r3], #-59	; 0xffffffc5
    int32 i;

    for (i = curlen; i < field_width; i++)
    7ee0:	23020000 	movwcs	r0, #8192	; 0x2000
    {
        printk_putc(' ',count, info);
    7ee4:	25d20a08 	ldrbcs	r0, [r2, #2568]	; 0xa08
    7ee8:	dc030000 	stcle	0, cr0, [r3], {-0}
    7eec:	00005333 	andeq	r5, r0, r3, lsr r3
static void
printk_pad_space (int32 curlen, int32 field_width, int32 *count, PRINTK_INFO *info)
{
    int32 i;

    for (i = curlen; i < field_width; i++)
    7ef0:	0c230200 	sfmeq	f0, 4, [r3], #-0
    7ef4:	0048430b 	subeq	r4, r8, fp, lsl #6
    7ef8:	5533e203 	ldrpl	lr, [r3, #-515]!	; 0x203
    7efc:	02000007 	andeq	r0, r0, #7
    {
        printk_putc(' ',count, info);
    }
}
    7f00:	120a1023 	andne	r1, sl, #35	; 0x23
    7f04:	03000003 	movweq	r0, #3

/********************************************************************/
int32 printk (PRINTK_INFO *info, const char *fmt, va_list ap)
{
    7f08:	076533e3 	strbeq	r3, [r5, -r3, ror #7]!
    7f0c:	23030000 	movwcs	r0, #12288	; 0x3000
    7f10:	440b01b0 	strmi	r0, [fp], #-432	; 0x1b0
    int8 vstr[33];
    int8 *vstrp;
    int32 vlen;

    int32 done;
    int32 count = 0;
    7f14:	03004341 	movweq	r4, #833	; 0x341
    7f18:	077533e7 	ldrbeq	r3, [r5, -r7, ror #7]!

    /*
     * Start parsing apart the format string and display appropriate
     * formats and data.
     */
    for (p = (int8 *)fmt; (c = *p) != 0; p++)
    7f1c:	23030000 	movwcs	r0, #12288	; 0x3000
         * All formats begin with a '%' marker.  Special chars like
         * '\n' or '\t' are normally converted to the appropriate
         * character by the __compiler__.  Thus, no need for this
         * routine to account for the '\' character.
         */
        if (c != '%')
    7f20:	1d0a02d0 	sfmne	f0, 4, [sl, #-832]	; 0xfffffcc0
    7f24:	03000003 	movweq	r0, #3
            /*
             * This needs to be replaced with something like
             * 'out_char()' or call an OS routine.
             */
#ifndef UNIX_DEBUG
            if (c != '\n')
    7f28:	056e33e8 	strbeq	r3, [lr, #-1000]!	; 0x3e8
            {
                printk_putc(c, &count, info);
    7f2c:	23030000 	movwcs	r0, #12288	; 0x3000
    7f30:	bf0a02e0 	svclt	0x000a02e0
    7f34:	03000025 	movweq	r0, #37	; 0x25
    7f38:	005333e9 	subseq	r3, r3, r9, ror #7
            }
            else
            {
                printk_putc(0x0D /* CR */, &count, info);
    7f3c:	23030000 	movwcs	r0, #12288	; 0x3000
    7f40:	c40a0390 	strgt	r0, [sl], #-912	; 0x390
    7f44:	03000025 	movweq	r0, #37	; 0x25
    7f48:	063233ea 	ldrteq	r3, [r2], -sl, ror #7
                printk_putc(0x0A /* LF */, &count, info);
    7f4c:	23030000 	movwcs	r0, #12288	; 0x3000
    7f50:	0c000394 	stceq	3, cr0, [r0], {148}	; 0x94
    7f54:	00000642 	andeq	r0, r0, r2, asr #12
    7f58:	00000765 	andeq	r0, r0, r5, ror #14

            /*
             * By using 'continue', the next iteration of the loop
             * is used, skipping the code that follows.
             */
            continue;
    7f5c:	0005300d 	andeq	r3, r5, sp
        }

        /*
         * First check for specification modifier flags.
         */
        flags_used = 0;
    7f60:	0c000300 	stceq	3, cr0, [r0], {-0}
        done = FALSE;
    7f64:	0000002c 	andeq	r0, r0, ip, lsr #32
    7f68:	00000775 	andeq	r0, r0, r5, ror r7
        while (!done)
        {
            switch (/* c = */ *++p)
    7f6c:	0005300d 	andeq	r3, r5, sp
    7f70:	0c009f00 	stceq	15, cr9, [r0], {-0}
    7f74:	00000685 	andeq	r0, r0, r5, lsl #13
    7f78:	00000785 	andeq	r0, r0, r5, lsl #15
    7f7c:	0005300d 	andeq	r3, r5, sp
    7f80:	0e000100 	adfeqs	f0, f0, f0
    7f84:	000024c5 	andeq	r2, r0, r5, asr #9
    7f88:	9133eb03 	teqls	r3, r3, lsl #22
    7f8c:	0f000007 	svceq	0x00000007
    7f90:	00079704 	andeq	r9, r7, r4, lsl #14
    7f94:	06ad1000 	strteq	r1, [sp], r0
    7f98:	44130000 	ldrmi	r0, [r3], #-0
    7f9c:	70000010 	andvc	r0, r0, r0, lsl r0
    7fa0:	3d950310 	ldccc	3, cr0, [r5, #64]	; 0x40
    7fa4:	00000978 	andeq	r0, r0, r8, ror r9
    7fa8:	0010380a 	andseq	r3, r0, sl, lsl #16
    7fac:	3d960300 	ldccc	3, cr0, [r6]
    7fb0:	00000053 	andeq	r0, r0, r3, asr r0
    7fb4:	0a002302 	beq	10bc4 <__etext+0x7f1c>
    7fb8:	00000d02 	andeq	r0, r0, r2, lsl #26
    7fbc:	533d9703 	teqpl	sp, #786432	; 0xc0000
    7fc0:	02000000 	andeq	r0, r0, #0
    7fc4:	120a0423 	andne	r0, sl, #587202560	; 0x23000000
    7fc8:	03000003 	movweq	r0, #3
            {
                case '-':
                    flags_used |= FLAGS_MINUS;
    7fcc:	09783d98 	ldmdbeq	r8!, {r3, r4, r7, r8, sl, fp, ip, sp}^
    7fd0:	23020000 	movwcs	r0, #8192	; 0x2000
                    break;
    7fd4:	103e0a08 	eorsne	r0, lr, r8, lsl #20
                case '+':
                    flags_used |= FLAGS_PLUS;
    7fd8:	99030000 	stmdbls	r3, {}	; <UNPREDICTABLE>
    7fdc:	0000533d 	andeq	r5, r0, sp, lsr r3
                    break;
                case ' ':
                    flags_used |= FLAGS_SPACE;
    7fe0:	84230300 	strthi	r0, [r3], #-768	; 0x300
    7fe4:	031d0a20 	tsteq	sp, #131072	; 0x20000
                    break;
    7fe8:	9a030000 	bls	c7ff0 <__etext+0xbf348>
                case '0':
                    flags_used |= FLAGS_ZERO;
    7fec:	00054e3d 	andeq	r4, r5, sp, lsr lr
    7ff0:	88230300 	stmdahi	r3!, {r8, r9}
                    break;
                case '#':
                    flags_used |= FLAGS_POUND;
    7ff4:	104f0a20 	subne	r0, pc, r0, lsr #20
    7ff8:	9b030000 	blls	c8000 <__etext+0xbf358>
                    break;
    7ffc:	0000533d 	andeq	r5, r0, sp, lsr r3
                default:
                    /* we've gone one int8 too far */
                    --p;
    8000:	8c230300 	stchi	3, cr0, [r3], #-0
    8004:	10550a20 	subsne	r0, r5, r0, lsr #20
                    done = TRUE;
    8008:	9c030000 	stcls	0, cr0, [r3], {-0}
                    break;
    800c:	0000533d 	andeq	r5, r0, sp, lsr r3
        /*
         * First check for specification modifier flags.
         */
        flags_used = 0;
        done = FALSE;
        while (!done)
    8010:	90230300 	eorls	r0, r3, r0, lsl #6
        }

        /*
         * Next check for minimum field width.
         */
        field_width = 0;
    8014:	105b0a20 	subsne	r0, fp, r0, lsr #20
    8018:	9d030000 	stcls	0, cr0, [r3, #-0]
        done = FALSE;
    801c:	0000533d 	andeq	r5, r0, sp, lsr r3
        while (!done)
    8020:	94230300 	strtls	r0, [r3], #-768	; 0x300
        {
            switch (c = *++p)
    8024:	10610a20 	rsbne	r0, r1, r0, lsr #20
    8028:	9e030000 	cdpls	0, 0, cr0, cr3, cr0, {0}
    802c:	0000533d 	andeq	r5, r0, sp, lsr r3
    8030:	98230300 	stmdals	r3!, {r8, r9}
    8034:	0a9a0a20 	beq	fe68a8bc <__StackLimit+0xde68a8bc>
    8038:	9f030000 	svcls	0x00030000
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    field_width = (field_width * 10) + (c - '0');
    803c:	00055e3d 	andeq	r5, r5, sp, lsr lr
    8040:	9c230300 	stcls	3, cr0, [r3], #-0
    8044:	0c640a20 	stcleq	10, cr0, [r4], #-128	; 0xffffff80
    8048:	a0030000 	andge	r0, r3, r0
    804c:	0000533d 	andeq	r5, r0, sp, lsr r3
    8050:	a4230300 	strtge	r0, [r3], #-768	; 0x300
    8054:	0c690a20 	stcleq	10, cr0, [r9], #-128	; 0xffffff80
                    break;
                default:
                    /* we've gone one int8 too far */
                    --p;
    8058:	a1030000 	mrsge	r0, (UNDEF: 3)
    805c:	0000533d 	andeq	r5, r0, sp, lsr r3
                    done = TRUE;
    8060:	a8230300 	stmdage	r3!, {r8, r9}
    8064:	0c6f0a20 	stcleq	10, cr0, [pc], #-128	; 7fec <printk+0xe4>
        /*
         * Next check for minimum field width.
         */
        field_width = 0;
        done = FALSE;
        while (!done)
    8068:	a2030000 	andge	r0, r3, #0
    806c:	0000533d 	andeq	r5, r0, sp, lsr r3
        }

        /*
         * Next check for the width and precision field separator.
         */
        if (/* (c = *++p) */ *++p == '.')
    8070:	ac230300 	stcge	3, cr0, [r3], #-0
    8074:	0c750a20 	ldcleq	10, cr0, [r5], #-128	; 0xffffff80
    8078:	a3030000 	movwge	r0, #12288	; 0x3000
    807c:	0000533d 	andeq	r5, r0, sp, lsr r3

            /*
             * Must get precision field width, if present.
             */
            /* precision_width = 0; */
            done = FALSE;
    8080:	b0230300 	eorlt	r0, r3, r0, lsl #6
    8084:	0c7b0a20 	ldcleq	10, cr0, [fp], #-128	; 0xffffff80
            while (!done)
            {
                switch (/* c = uncomment if used below */ *++p)
    8088:	a4030000 	strge	r0, [r3], #-0
    808c:	0000533d 	andeq	r5, r0, sp, lsr r3
    8090:	b4230300 	strtlt	r0, [r3], #-768	; 0x300
    8094:	0c810a20 	vstmiaeq	r1, {s0-s31}
    8098:	a5030000 	strge	r0, [r3, #-0]
    809c:	0000533d 	andeq	r5, r0, sp, lsr r3
                            (c - '0');
#endif
                        break;
                    default:
                        /* we've gone one int8 too far */
                        --p;
    80a0:	b8230300 	stmdalt	r3!, {r8, r9}
    80a4:	0c870a20 	vstmiaeq	r7, {s0-s31}
                        done = TRUE;
    80a8:	a6030000 	strge	r0, [r3], -r0
    80ac:	0000533d 	andeq	r5, r0, sp, lsr r3
            /*
             * Must get precision field width, if present.
             */
            /* precision_width = 0; */
            done = FALSE;
            while (!done)
    80b0:	bc230300 	stclt	3, cr0, [r3], #-0
    80b4:	0c8d0a20 	vstmiaeq	sp, {s0-s31}
            }
        }
        else
        {
            /* we've gone one int8 too far */
            --p;
    80b8:	a7030000 	strge	r0, [r3, -r0]
    80bc:	0000533d 	andeq	r5, r0, sp, lsr r3

        /*
         * Check for the length modifier.
         */
        /* length_modifier = 0; */
        switch (/* c = */ *++p)
    80c0:	c0230300 	eorgt	r0, r3, r0, lsl #6
    80c4:	0fec0a20 	svceq	0x00ec0a20
    80c8:	a8030000 	stmdage	r3, {}	; <UNPREDICTABLE>
    80cc:	0000533d 	andeq	r5, r0, sp, lsr r3
    80d0:	c4230300 	strtgt	r0, [r3], #-768	; 0x300
    80d4:	0ff40a20 	svceq	0x00f40a20
    80d8:	a9030000 	stmdbge	r3, {}	; <UNPREDICTABLE>
            case 'L':
                /* length_modifier |= LENMOD_L; */
                break;
            default:
                /* we've gone one int8 too far */
                --p;
    80dc:	0000533d 	andeq	r5, r0, sp, lsr r3
    80e0:	c8230300 	stmdagt	r3!, {r8, r9}
        /* length_modifier = 0; */
        switch (/* c = */ *++p)
        {
            case 'h':
                /* length_modifier |= LENMOD_h; */
                break;
    80e4:	0f290a20 	svceq	0x00290a20
            case 'l':
                /* length_modifier |= LENMOD_l; */
                break;
    80e8:	aa030000 	bge	c80f0 <__etext+0xbf448>
            case 'L':
                /* length_modifier |= LENMOD_L; */
                break;
    80ec:	0000533d 	andeq	r5, r0, sp, lsr r3
        }

        /*
         * Now we're ready to examine the format.
         */
        switch (c = *++p)
    80f0:	cc230300 	stcgt	3, cr0, [r3], #-0
    80f4:	0f2f0a20 	svceq	0x002f0a20
    80f8:	ab030000 	blge	c8100 <__etext+0xbf458>
    80fc:	0000533d 	andeq	r5, r0, sp, lsr r3
    8100:	d0230300 	eorle	r0, r3, r0, lsl #6
    8104:	0bcb0a20 	bleq	ff2ca98c <__StackLimit+0xdf2ca98c>
    8108:	ac030000 	stcge	0, cr0, [r3], {-0}
    810c:	0000533d 	andeq	r5, r0, sp, lsr r3
    8110:	d4230300 	strtle	r0, [r3], #-768	; 0x300
    8114:	0e090a20 	vmlaeq.f32	s0, s18, s1
    8118:	ad030000 	stcge	0, cr0, [r3, #-0]
    811c:	0000533d 	andeq	r5, r0, sp, lsr r3
    8120:	d8230300 	stmdale	r3!, {r8, r9}
    8124:	0e0f0a20 	vmlaeq.f32	s0, s30, s1
    8128:	ae030000 	cdpge	0, 0, cr0, cr3, cr0, {0}
    812c:	0000533d 	andeq	r5, r0, sp, lsr r3
    8130:	dc230300 	stcle	3, cr0, [r3], #-0
    8134:	0bd00a20 	bleq	ff40a9bc <__StackLimit+0xdf40a9bc>
    8138:	af030000 	svcge	0x00030000
    813c:	0000533d 	andeq	r5, r0, sp, lsr r3
    8140:	e0230300 	eor	r0, r3, r0, lsl #6
    8144:	03310a20 	teqeq	r1, #131072	; 0x20000
    8148:	b0030000 	andlt	r0, r3, r0
    814c:	00054e3d 	andeq	r4, r5, sp, lsr lr
    8150:	e4230300 	strt	r0, [r3], #-768	; 0x300
    8154:	0e9f0a20 	vfnmseq.f32	s0, s30, s1
    8158:	b1030000 	mrslt	r0, (UNDEF: 3)
    815c:	0000533d 	andeq	r5, r0, sp, lsr r3
    8160:	e8230300 	stmda	r3!, {r8, r9}
    8164:	434d0b20 	movtmi	r0, #56096	; 0xdb20
    8168:	b2030052 	andlt	r0, r3, #82	; 0x52
    816c:	0000533d 	andeq	r5, r0, sp, lsr r3
    8170:	ec230300 	stc	3, cr0, [r3], #-0
    8174:	2c0c0020 	stccs	0, cr0, [ip], {32}
    8178:	89000000 	stmdbhi	r0, {}	; <UNPREDICTABLE>
    817c:	14000009 	strne	r0, [r0], #-9
    8180:	00000530 	andeq	r0, r0, r0, lsr r5
    8184:	0e000ffb 	mcreq	15, 0, r0, cr0, cr11, {7}
    8188:	00000f47 	andeq	r0, r0, r7, asr #30
    818c:	953db303 	ldrls	fp, [sp, #-771]!	; 0x303
    8190:	0f000009 	svceq	0x00000009
        {
            case 'd':
            case 'i':
                ival = (int32)va_arg(ap, int32);
    8194:	00099b04 	andeq	r9, r9, r4, lsl #22
    8198:	079c1000 	ldreq	r1, [ip, r0]
    819c:	83030000 	movwhi	r0, #12288	; 0x3000
                vlen = printk_mknumstr(vstr,&ival,TRUE,10);
    81a0:	04000004 	streq	r0, [r0], #-4
    81a4:	0000371b 	andeq	r3, r0, fp, lsl r7
    81a8:	12e00300 	rscne	r0, r0, #0
    81ac:	1c040000 	stcne	0, cr0, [r4], {-0}
    81b0:	00000045 	andeq	r0, r0, r5, asr #32
    81b4:	001d7b03 	andseq	r7, sp, r3, lsl #22
    81b8:	5e1d0400 	cfmulspl	mvf0, mvf13, mvf0
                vstrp = &vstr[vlen];
    81bc:	03000000 	movweq	r0, #0
    81c0:	00002506 	andeq	r2, r0, r6, lsl #10

                if (ival < 0)
    81c4:	09cc2b04 	stmibeq	ip, {r2, r8, r9, fp, sp}^
    81c8:	04020000 	streq	r0, [r2], #-0
                {
                    schar = '-';
    81cc:	00066904 	andeq	r6, r6, r4, lsl #18
                    ++vlen;
    81d0:	04080200 	streq	r0, [r8], #-512	; 0x200
    81d4:	00000a87 	andeq	r0, r0, r7, lsl #21
    81d8:	000dc803 	andeq	ip, sp, r3, lsl #16
                }
                else
                {
                    if (IS_FLAG_PLUS(flags_used))
    81dc:	372e0400 	strcc	r0, [lr, -r0, lsl #8]!
    81e0:	0f000000 	svceq	0x00000000
                    {
                        schar = '+';
    81e4:	0009eb04 	andeq	lr, r9, r4, lsl #22
    81e8:	02011500 	andeq	r1, r1, #0
                        ++vlen;
    81ec:	07120801 	ldreq	r0, [r2, -r1, lsl #16]
    81f0:	40030000 	andmi	r0, r3, r0
                    }
                    else
                    {
                        if (IS_FLAG_SPACE(flags_used))
    81f4:	05000024 	streq	r0, [r0, #-36]	; 0x24
    81f8:	0009e51d 	andeq	lr, r9, sp, lsl r5
    81fc:	05281600 	streq	r1, [r8, #-1536]!	; 0x600
                        {
                            schar = ' ';
    8200:	000acc45 	andeq	ip, sl, r5, asr #24
                            ++vlen;
    8204:	25770900 	ldrbcs	r0, [r7, #-2304]!	; 0x900
    8208:	4f050000 	svcmi	0x00050000
    820c:	000009b6 			; <UNDEFINED> instruction: 0x000009b6
                        }
                        else
                        {
                            schar = 0;
    8210:	09002302 	stmdbeq	r0, {r1, r8, r9, sp}
                        }
                    }
                }
                dschar = FALSE;
    8214:	00002421 	andeq	r2, r0, r1, lsr #8
    8218:	09b65905 	ldmibeq	r6!, {r0, r2, r8, fp, ip, lr}
            
                /*
                 * do the ZERO pad.
                 */
                if (IS_FLAG_ZERO(flags_used))
    821c:	23020000 	movwcs	r0, #8192	; 0x2000
    8220:	25fd0904 	ldrbcs	r0, [sp, #2308]!	; 0x904
                {
                    if (schar)
    8224:	63050000 	movwvs	r0, #20480	; 0x5000
    8228:	000009b6 			; <UNDEFINED> instruction: 0x000009b6
                        printk_putc(schar, &count, info);
    822c:	09082302 	stmdbeq	r8, {r1, r8, r9, sp}
    8230:	0000252f 	andeq	r2, r0, pc, lsr #10
    8234:	09a07005 	stmibeq	r0!, {r0, r2, ip, sp, lr}
                    dschar = TRUE;
    8238:	23020000 	movwcs	r0, #8192	; 0x2000
    823c:	258b090c 	strcs	r0, [fp, #2316]	; 0x90c
            
                    printk_pad_zero (vlen, field_width, &count, info);
    8240:	89050000 	stmdbhi	r5, {}	; <UNPREDICTABLE>
    8244:	000009a0 	andeq	r0, r0, r0, lsr #19
    8248:	090d2302 	stmdbeq	sp, {r1, r8, r9, sp}
    824c:	00002516 	andeq	r2, r0, r6, lsl r5
                    vlen = field_width;
    8250:	09da9405 	ldmibeq	sl, {r0, r2, sl, ip, pc}^
                }
                else
                {
                    if (!IS_FLAG_MINUS(flags_used))
    8254:	23020000 	movwcs	r0, #8192	; 0x2000
    8258:	2556090e 	ldrbcs	r0, [r6, #-2318]	; 0x90e
    825c:	9f050000 	svcls	0x00050000
                    {
                        printk_pad_space (vlen, field_width, &count, info);
    8260:	000009da 	ldrdeq	r0, [r0], -sl
    8264:	090f2302 	stmdbeq	pc, {r1, r8, r9, sp}	; <UNPREDICTABLE>
    8268:	0000262e 	andeq	r2, r0, lr, lsr #12
    826c:	09daaa05 	ldmibeq	sl, {r0, r2, r9, fp, sp, pc}^
            
                        if (schar)
    8270:	23020000 	movwcs	r0, #8192	; 0x2000
                            printk_putc(schar, &count, info);
    8274:	240d0910 	strcs	r0, [sp], #-2320	; 0x910
    8278:	b5050000 	strlt	r0, [r5, #-0]
    827c:	000009da 	ldrdeq	r0, [r0], -sl
    8280:	09112302 	ldmdbeq	r1, {r1, r8, r9, sp}
                        dschar = TRUE;
    8284:	00002478 	andeq	r2, r0, r8, ror r4
                    }
                }
            
                /* the string was built in reverse order, now display in */
                /* correct order */
                if (!dschar && schar)
    8288:	09b6bf05 	ldmibeq	r6!, {r0, r2, r8, r9, sl, fp, ip, sp, pc}
    828c:	23020000 	movwcs	r0, #8192	; 0x2000
    8290:	248c0914 	strcs	r0, [ip], #2324	; 0x914
    8294:	c9050000 	stmdbgt	r5, {}	; <UNPREDICTABLE>
                {
                    printk_putc(schar, &count, info);
    8298:	000009b6 			; <UNDEFINED> instruction: 0x000009b6
    829c:	09182302 	ldmdbeq	r8, {r1, r8, r9, sp}
    82a0:	00002564 	andeq	r2, r0, r4, ror #10
    82a4:	09b6d305 	ldmibeq	r6!, {r0, r2, r8, r9, ip, lr, pc}
                }
                goto cont_xd;

            case 'x':
            case 'X':
                uval = (uint32)va_arg(ap, uint32);
    82a8:	23020000 	movwcs	r0, #8192	; 0x2000
    82ac:	25ca091c 	strbcs	r0, [sl, #2332]	; 0x91c
    82b0:	dd050000 	stcle	0, cr0, [r5, #-0]
                vlen = printk_mknumstr(vstr,&uval,FALSE,16);
    82b4:	000009f4 	strdeq	r0, [r0], -r4
    82b8:	09202302 	stmdbeq	r0!, {r1, r8, r9, sp}
    82bc:	000025ef 	andeq	r2, r0, pc, ror #11
    82c0:	09f4e705 	ldmibeq	r4!, {r0, r2, r8, r9, sl, sp, lr, pc}^
    82c4:	23020000 	movwcs	r0, #8192	; 0x2000
    82c8:	af030024 	svcge	0x00030024
    82cc:	05000025 	streq	r0, [r0, #-37]	; 0x25
                vstrp = &vstr[vlen];
    82d0:	0009ffe9 	andeq	pc, r9, r9, ror #31
    82d4:	10011700 	andne	r1, r1, r0, lsl #14

                dschar = FALSE;
    82d8:	01000026 	tsteq	r0, r6, lsr #32
    82dc:	09a0012d 	stmibeq	r0!, {r0, r2, r3, r5, r8}
                if (IS_FLAG_ZERO(flags_used))
    82e0:	58540000 	ldmdapl	r4, {}^	; <UNPREDICTABLE>
    82e4:	5baa0000 	blpl	fea882ec <__StackLimit+0xdea882ec>
                {
                    if (IS_FLAG_POUND(flags_used))
    82e8:	17d40000 	ldrbne	r0, [r4, r0]
    82ec:	99010000 	stmdbls	r1, {}	; <UNPREDICTABLE>
    82f0:	1800000b 	stmdane	r0, {r0, r1, r3}
                    {
                        printk_putc('0', &count, info);
    82f4:	000024f6 	strdeq	r2, [r0], -r6
    82f8:	0acc2d01 	beq	ff313704 <__StackLimit+0xdf313704>
    82fc:	91020000 	mrsls	r0, (UNDEF: 2)
    8300:	73751970 	cmnvc	r5, #1835008	; 0x1c0000
                        printk_putc('x', &count, info);
    8304:	b62f0100 	strtlt	r0, [pc], -r0, lsl #2
    8308:	02000009 	andeq	r0, r0, #9
    830c:	0e1a5091 	mrceq	0, 0, r5, cr10, cr1, {4}
    8310:	01000025 	tsteq	r0, r5, lsr #32
                        /*vlen += 2;*/
                        dschar = TRUE;
    8314:	0009b632 	andeq	fp, r9, r2, lsr r6
                    }
                    printk_pad_zero (vlen, field_width, &count, info);
    8318:	4c910200 	lfmmi	f0, 4, [r1], {0}
    831c:	00263c1a 	eoreq	r3, r6, sl, lsl ip
    8320:	a0350100 	eorsge	r0, r5, r0, lsl #2
    8324:	02000009 	andeq	r0, r0, #9
                    vlen = field_width;
    8328:	ee1a4b91 	vmov.32	r4, d26[0]
    832c:	01000024 	tsteq	r0, r4, lsr #32
                }
                else
                {
                    if (!IS_FLAG_MINUS(flags_used))
    8330:	0009a036 	andeq	sl, r9, r6, lsr r0
    8334:	4a910200 	bmi	fe448b3c <__StackLimit+0xde448b3c>
                    {
                        if (IS_FLAG_POUND(flags_used))
    8338:	0024841a 	eoreq	r8, r4, sl, lsl r4
    833c:	b6370100 	ldrtlt	r0, [r7], -r0, lsl #2
    8340:	02000009 	andeq	r0, r0, #9
                        {
                            vlen += 2;
    8344:	a51a4491 	ldrge	r4, [sl, #-1169]	; 0x491
    8348:	01000025 	tsteq	r0, r5, lsr #32
                        }
                        printk_pad_space (vlen, field_width, &count, info);
    834c:	0009a038 	andeq	sl, r9, r8, lsr r0
    8350:	5f910200 	svcpl	0x00910200
    8354:	0024c01a 	eoreq	ip, r4, sl, lsl r0
    8358:	a0380100 	eorsge	r0, r8, r0, lsl #2
                        if (IS_FLAG_POUND(flags_used))
    835c:	02000009 	andeq	r0, r0, #9
    8360:	6d195e91 	ldcvs	14, cr5, [r9, #-580]	; 0xfffffdbc
                        {
                            printk_putc('0', &count, info);
    8364:	0100646f 	tsteq	r0, pc, ror #8
    8368:	0009b639 	andeq	fp, r9, r9, lsr r6
    836c:	58910200 	ldmpl	r1, {r9}
    8370:	000f421a 	andeq	r4, pc, sl, lsl r2	; <UNPREDICTABLE>
                            printk_putc('x', &count, info);
    8374:	c13a0100 	teqgt	sl, r0, lsl #2
    8378:	02000009 	andeq	r0, r0, #9
    837c:	69194091 	ldmdbvs	r9, {r0, r4, r7, lr}
    8380:	a03b0100 	eorsge	r0, fp, r0, lsl #2
                            dschar = TRUE;
    8384:	02000009 	andeq	r0, r0, #9
    8388:	6a195791 	bvs	65e1d4 <__etext+0x65552c>
                        }
                    }
                }

                if ((IS_FLAG_POUND(flags_used)) && !dschar)
    838c:	a03b0100 	eorsge	r0, fp, r0, lsl #2
    8390:	02000009 	andeq	r0, r0, #9
    8394:	1b005691 	blne	1dde0 <__etext+0x15138>
    8398:	00261e01 	eoreq	r1, r6, r1, lsl #28
    839c:	01a30100 			; <UNDEFINED> instruction: 0x01a30100
                {
                    printk_putc('0', &count, info);
    83a0:	00005bac 	andeq	r5, r0, ip, lsr #23
    83a4:	00005c2c 	andeq	r5, r0, ip, lsr #24
    83a8:	0000181a 	andeq	r1, r0, sl, lsl r8
    83ac:	61011c01 	tstvs	r1, r1, lsl #24
                    printk_putc('x', &count, info);
    83b0:	01000024 	tsteq	r0, r4, lsr #32
    83b4:	09a001cd 	stmibeq	r0!, {r0, r2, r3, r6, r7, r8}
    83b8:	5c2c0000 	stcpl	0, cr0, [ip], #-0
    83bc:	5d8a0000 	stcpl	0, cr0, [sl]
                    vlen += 2;
    83c0:	18460000 	stmdane	r6, {}^	; <UNPREDICTABLE>
    83c4:	3a010000 	bcc	483cc <__etext+0x3f724>
                }
                goto cont_xd;

            case 'o':
                uval = (uint32)va_arg(ap, uint32);
    83c8:	1800000c 	stmdane	r0, {r2, r3}
    83cc:	00001992 	muleq	r0, r2, r9
    83d0:	0537cd01 	ldreq	ip, [r7, #-3329]!	; 0xd01
                vlen = printk_mknumstr(vstr,&uval,FALSE,8);
    83d4:	91020000 	mrsls	r0, (UNDEF: 2)
    83d8:	66631d5c 			; <UNDEFINED> instruction: 0x66631d5c
    83dc:	cd010067 	stcgt	0, cr0, [r1, #-412]	; 0xfffffe64
    83e0:	000009b6 			; <UNDEFINED> instruction: 0x000009b6
    83e4:	18589102 	ldmdane	r8, {r1, r8, ip, pc}^
    83e8:	00002649 	andeq	r2, r0, r9, asr #12
    83ec:	09abcd01 	stmibeq	fp!, {r0, r8, sl, fp, lr, pc}
                goto cont_u;
            case 'b':
                uval = (uint32)va_arg(ap, uint32);
    83f0:	91020000 	mrsls	r0, (UNDEF: 2)
    83f4:	006e1956 	rsbeq	r1, lr, r6, asr r9
    83f8:	09a0cf01 	stmibeq	r0!, {r0, r8, r9, sl, fp, lr, pc}
                vlen = printk_mknumstr(vstr,&uval,FALSE,2);
    83fc:	91020000 	mrsls	r0, (UNDEF: 2)
    8400:	006d196f 	rsbeq	r1, sp, pc, ror #18
    8404:	09a0cf01 	stmibeq	r0!, {r0, r8, r9, sl, fp, lr, pc}
    8408:	91020000 	mrsls	r0, (UNDEF: 2)
    840c:	25a51a6e 	strcs	r1, [r5, #2670]!	; 0xa6e
    8410:	d0010000 	andle	r0, r1, r0
    8414:	000009a0 	andeq	r0, r0, r0, lsr #19
                goto cont_u;
            case 'p':
                uval = (uint32)va_arg(ap, void *);
    8418:	1a679102 	bne	19ec828 <__etext+0x19e3b80>
    841c:	000024c0 	andeq	r2, r0, r0, asr #9
    8420:	09a0d001 	stmibeq	r0!, {r0, ip, lr, pc}
                vlen = printk_mknumstr(vstr,&uval,FALSE,16);
    8424:	91020000 	mrsls	r0, (UNDEF: 2)
    8428:	24841a66 	strcs	r1, [r4], #2662	; 0xa66
    842c:	d1010000 	mrsle	r0, (UNDEF: 1)
    8430:	000009b6 			; <UNDEFINED> instruction: 0x000009b6
    8434:	00689102 	rsbeq	r9, r8, r2, lsl #2
    8438:	253f011c 	ldrcs	r0, [pc, #-284]!	; 8324 <printk+0x41c>
    843c:	fe010000 	cdp2	0, 0, cr0, cr1, cr0, {0}
                goto cont_u;
            case 'u':
                uval = (uint32)va_arg(ap, uint32);
    8440:	0009a001 	andeq	sl, r9, r1
    8444:	005d8c00 	subseq	r8, sp, r0, lsl #24
    8448:	005e9c00 	subseq	r9, lr, r0, lsl #24
                vlen = printk_mknumstr(vstr,&uval,FALSE,10);
    844c:	00187e00 	andseq	r7, r8, r0, lsl #28
    8450:	0cbd0100 	ldfeqs	f0, [sp]
    8454:	d3180000 	tstle	r8, #0
    8458:	01000024 	tsteq	r0, r4, lsr #32
    845c:	00060bfe 	strdeq	r0, [r6], -lr
    8460:	64910200 	ldrvs	r0, [r1], #512	; 0x200
    8464:	6766631d 			; <UNDEFINED> instruction: 0x6766631d

                cont_u:
                    vstrp = &vstr[vlen];
    8468:	b6fe0100 	ldrbtlt	r0, [lr], r0, lsl #2
    846c:	02000009 	andeq	r0, r0, #9

                    if (IS_FLAG_ZERO(flags_used))
    8470:	45186091 	ldrmi	r6, [r8, #-145]	; 0x91
    8474:	01000026 	tsteq	r0, r6, lsr #32
    8478:	0009abfe 	strdeq	sl, [r9], -lr
                    {
                        printk_pad_zero (vlen, field_width, &count, info);
    847c:	5e910200 	cdppl	2, 9, cr0, cr1, cr0, {0}
    8480:	01006e1e 	tsteq	r0, lr, lsl lr
    8484:	09a00100 	stmibeq	r0!, {r8}
    8488:	91020000 	mrsls	r0, (UNDEF: 2)
                        vlen = field_width;
    848c:	25a51f77 	strcs	r1, [r5, #3959]!	; 0xf77
                    }
                    else
                    {
                        if (!IS_FLAG_MINUS(flags_used))
    8490:	01010000 	mrseq	r0, (UNDEF: 1)
    8494:	0009a001 	andeq	sl, r9, r1
    8498:	6f910200 	svcvs	0x00910200
                        {
                            printk_pad_space (vlen, field_width, &count, info);
    849c:	0024c01f 	eoreq	ip, r4, pc, lsl r0
    84a0:	01010100 	mrseq	r0, (UNDEF: 17)
    84a4:	000009a0 	andeq	r0, r0, r0, lsr #19
    84a8:	1f6e9102 	svcne	0x006e9102
                /* correct order */
                if (!dschar && schar)
                {
                    printk_putc(schar, &count, info);
                }
                goto cont_xd;
    84ac:	00002484 	andeq	r2, r0, r4, lsl #9
                {
                    printk_putc('0', &count, info);
                    printk_putc('x', &count, info);
                    vlen += 2;
                }
                goto cont_xd;
    84b0:	b6010201 	strlt	r0, [r1], -r1, lsl #4
                        }
                    }

                cont_xd:
                    while (*vstrp)
                        printk_putc(*vstrp--, &count, info);
    84b4:	02000009 	andeq	r0, r0, #9
    84b8:	20007091 	mulcs	r0, r1, r0
    84bc:	00245101 	eoreq	r5, r4, r1, lsl #2
    84c0:	011b0100 	tsteq	fp, r0, lsl #2
    84c4:	005e9c01 	subseq	r9, lr, r1, lsl #24
    84c8:	005f7a00 	subseq	r7, pc, r0, lsl #20
    84cc:	0018b600 	andseq	fp, r8, r0, lsl #12
    84d0:	f7210100 			; <UNDEFINED> instruction: 0xf7210100
                            printk_pad_space (vlen, field_width, &count, info);
                        }
                    }

                cont_xd:
                    while (*vstrp)
    84d4:	0600000b 	streq	r0, [r0], -fp
    84d8:	0009b620 	andeq	fp, r9, r0, lsr #12
                        printk_putc(*vstrp--, &count, info);

                    if (IS_FLAG_MINUS(flags_used))
    84dc:	0c010100 	stfeqs	f0, [r1], {-0}
    84e0:	000009f4 	strdeq	r0, [r0], -r4
    84e4:	00000cf1 	strdeq	r0, [r0], -r1
                    {
                        printk_pad_space (vlen, field_width, &count, info);
    84e8:	0005300d 	andeq	r3, r5, sp
    84ec:	22000000 	andcs	r0, r0, #0
    84f0:	0000256f 	andeq	r2, r0, pc, ror #10
    84f4:	0ce11a01 	vstmiaeq	r1!, {s3}
                    }
                break;

            case 'c':
                cval = (int8)va_arg(ap, uint32);
    84f8:	05010000 	streq	r0, [r1, #-0]
    84fc:	ff166c03 			; <UNDEFINED> instruction: 0xff166c03
    8500:	24b5221f 	ldrtcs	r2, [r5], #543	; 0x21f
    8504:	1b010000 	blne	4850c <__etext+0x3f864>
                printk_putc(cval,&count, info);
    8508:	00000ce1 	andeq	r0, r0, r1, ror #25
    850c:	68030501 	stmdavs	r3, {r0, r8, sl}
    8510:	0c1fff16 	ldceq	15, cr15, [pc], {22}
    8514:	000009a0 	andeq	r0, r0, r0, lsr #19
                break;
            case 's':
                sval = (int8 *)va_arg(ap, int8 *);
    8518:	00000d25 	andeq	r0, r0, r5, lsr #26
    851c:	0005300d 	andeq	r3, r5, sp
    8520:	22000300 	andcs	r0, r0, #0
                if (sval)
    8524:	000025e2 	andeq	r2, r0, r2, ror #11
    8528:	0d371e01 	ldceq	14, cr1, [r7, #-4]!
                {
                    vlen = strlen((const char *)sval);
    852c:	05010000 	streq	r0, [r1, #-0]
    8530:	008ca403 	addeq	sl, ip, r3, lsl #8
                    if (!IS_FLAG_MINUS(flags_used))
    8534:	0d152300 	ldceq	3, cr2, [r5, #-0]
    8538:	3b000000 	blcc	8540 <printk+0x638>
    853c:	02000006 	andeq	r0, r0, #6
                    {
                        printk_pad_space (vlen, field_width, &count, info);
    8540:	00148600 	andseq	r8, r4, r0, lsl #12
    8544:	34010400 	strcc	r0, [r1], #-1024	; 0x400
    8548:	01000002 	tsteq	r0, r2
    854c:	00002789 	andeq	r2, r0, r9, lsl #15
                    }
                    while (*sval)
                        printk_putc(*sval++,&count, info);
    8550:	00000827 	andeq	r0, r0, r7, lsr #16
    8554:	00005f7c 	andeq	r5, r0, ip, ror pc
    8558:	000064c6 	andeq	r6, r0, r6, asr #9
    855c:	00001665 	andeq	r1, r0, r5, ror #12
    8560:	0b060102 	bleq	188970 <__etext+0x17fcc8>
    8564:	03000007 	movweq	r0, #7
    8568:	000009dd 	ldrdeq	r0, [r0], -sp
    856c:	00372a02 	eorseq	r2, r7, r2, lsl #20
                    vlen = strlen((const char *)sval);
                    if (!IS_FLAG_MINUS(flags_used))
                    {
                        printk_pad_space (vlen, field_width, &count, info);
                    }
                    while (*sval)
    8570:	01020000 	mrseq	r0, (UNDEF: 2)
    8574:	00070908 	andeq	r0, r7, r8, lsl #18
                        printk_putc(*sval++,&count, info);
                    if (IS_FLAG_MINUS(flags_used))
    8578:	05020200 	streq	r0, [r2, #-512]	; 0x200
    857c:	0000073b 	andeq	r0, r0, fp, lsr r7
    8580:	92070202 	andls	r0, r7, #536870912	; 0x20000000
                    {
                        printk_pad_space (vlen, field_width, &count, info);
    8584:	02000004 	andeq	r0, r0, #4
    8588:	01960504 	orrseq	r0, r6, r4, lsl #10
    858c:	9b030000 	blls	c8594 <__etext+0xbf8ec>
    8590:	02000007 	andeq	r0, r0, #7
                    }
                }
                break;
            case 'n':
                ivalp = (int32 *)va_arg(ap, int32 *);
    8594:	00005e50 	andeq	r5, r0, r0, asr lr
    8598:	07040200 	streq	r0, [r4, -r0, lsl #4]
    859c:	000001e4 	andeq	r0, r0, r4, ror #3
                *ivalp = count;
    85a0:	91050802 	tstls	r5, r2, lsl #16
    85a4:	02000001 	andeq	r0, r0, #1
                break;
            default:
                printk_putc(c,&count, info);
    85a8:	01df0708 	bicseq	r0, pc, r8, lsl #14
    85ac:	04040000 	streq	r0, [r4], #-0
    85b0:	746e6905 	strbtvc	r6, [lr], #-2309	; 0x905
    85b4:	07040200 	streq	r0, [r4, -r0, lsl #4]

                    if (IS_FLAG_MINUS(flags_used))
                    {
                        printk_pad_space (vlen, field_width, &count, info);
                    }
                break;
    85b8:	000001e9 	andeq	r0, r0, r9, ror #3
                    if (IS_FLAG_MINUS(flags_used))
                    {
                        printk_pad_space (vlen, field_width, &count, info);
                    }
                }
                break;
    85bc:	74070402 	strvc	r0, [r7], #-1026	; 0x402

    /*
     * Start parsing apart the format string and display appropriate
     * formats and data.
     */
    for (p = (int8 *)fmt; (c = *p) != 0; p++)
    85c0:	05000005 	streq	r0, [r0, #-5]
    85c4:	0000002c 	andeq	r0, r0, ip, lsr #32
    85c8:	00000098 	muleq	r0, r8, r0
    85cc:	00008106 	andeq	r8, r0, r6, lsl #2
    85d0:	0500fb00 	streq	pc, [r0, #-2816]	; 0xb00
    85d4:	0000002c 	andeq	r0, r0, ip, lsr #32
                printk_putc(c,&count, info);
                break;
        }
    }
    return count;
}
    85d8:	000000a8 	andeq	r0, r0, r8, lsr #1
    85dc:	00008106 	andeq	r8, r0, r6, lsl #2
    85e0:	05000300 	streq	r0, [r0, #-768]	; 0x300

/********************************************************************/
int printf (const char *fmt, ...)
{
    85e4:	0000002c 	andeq	r0, r0, ip, lsr #32
    85e8:	000000b8 	strheq	r0, [r0], -r8
    va_list ap;
    int32 rvalue;
    PRINTK_INFO info;


    info.dest = DEST_CONSOLE;
    85ec:	00008106 	andeq	r8, r0, r6, lsl #2
    85f0:	07000700 	streq	r0, [r0, -r0, lsl #14]
    info.func = &out_char;
    85f4:	34b70310 	ldrtcc	r0, [r7], #784	; 0x310
    85f8:	000000fe 	strdeq	r0, [r0], -lr
    /*
     * Initialize the pointer to the variable length argument list.
     */
    va_start(ap, fmt);
    85fc:	00265f08 	eoreq	r5, r6, r8, lsl #30
    8600:	34b80300 	ldrtcc	r0, [r8], #768	; 0x300
    rvalue = printk(&info, fmt, ap);
    8604:	00000053 	andeq	r0, r0, r3, asr r0
    8608:	08002302 	stmdaeq	r0, {r1, r8, r9, sp}
    860c:	0000279f 	muleq	r0, pc, r7	; <UNPREDICTABLE>
    8610:	5334b903 	teqpl	r4, #49152	; 0xc000
    /*
     * Cleanup the variable length argument list.
     */
    va_end(ap);
    return rvalue;
}
    8614:	02000000 	andeq	r0, r0, #0
    8618:	3e080423 	cdpcc	4, 0, cr0, cr8, cr3, {1}
    861c:	0300001e 	movweq	r0, #30
    8620:	005334ba 	ldrheq	r3, [r3], #-74	; 0xffffffb6

/********************************************************************/
int sprintf (char *s, const char *fmt, ...)
{
    8624:	23020000 	movwcs	r0, #8192	; 0x2000
    8628:	275c0808 	ldrbcs	r0, [ip, -r8, lsl #16]
    862c:	bb030000 	bllt	c8634 <__etext+0xbf98c>
    va_list ap;
    int32 rvalue = 0;
    8630:	00005334 	andeq	r5, r0, r4, lsr r3
    PRINTK_INFO info;

    /*
     * Initialize the pointer to the variable length argument list.
     */
    if (s != 0)
    8634:	0c230200 	sfmeq	f0, 4, [r3], #-0
    8638:	27090900 	strcs	r0, [r9, -r0, lsl #18]
    {
        info.dest = DEST_STRING;
    863c:	01400000 	mrseq	r0, (UNDEF: 64)
        info.loc = (int8 *)s;
    8640:	3b34b403 	blcc	d35654 <__etext+0xd2c9ac>
        va_start(ap, fmt);
    8644:	0a000001 	beq	8650 <sprintf+0x2c>
    8648:	0052434d 	subseq	r4, r2, sp, asr #6
        rvalue = printk(&info, fmt, ap);
    864c:	5334b503 	teqpl	r4, #12582912	; 0xc00000
    8650:	02000000 	andeq	r0, r0, #0
    8654:	12080023 	andne	r0, r8, #35	; 0x23
    8658:	03000003 	movweq	r0, #3
        *info.loc = '\0';
    865c:	008834b6 			; <UNDEFINED> instruction: 0x008834b6
    8660:	23020000 	movwcs	r0, #8192	; 0x2000
        va_end(ap);
    }
    return rvalue;
}
    8664:	27b10804 	ldrcs	r0, [r1, r4, lsl #16]!
    8668:	bc030000 	stclt	0, cr0, [r3], {-0}
    866c:	00013b34 	andeq	r3, r1, r4, lsr fp
    8670:	80230300 	eorhi	r0, r3, r0, lsl #6
    8674:	b8050002 	stmdalt	r5, {r1}
    8678:	4b000000 	blmi	8680 <__addsf3>
    867c:	06000001 	streq	r0, [r0], -r1
    8680:	00000081 	andeq	r0, r0, r1, lsl #1
    8684:	e20b0003 	and	r0, fp, #3
    8688:	03000026 	movweq	r0, #38	; 0x26
    868c:	015734bd 	ldrheq	r3, [r7, #-77]	; 0xffffffb3
    8690:	040c0000 	streq	r0, [ip], #-0
    8694:	0000015d 	andeq	r0, r0, sp, asr r1
    8698:	0000fe0d 	andeq	pc, r0, sp, lsl #28
    869c:	10440900 	subne	r0, r4, r0, lsl #18
    86a0:	10700000 	rsbsne	r0, r0, r0
    86a4:	3e3d9503 	cdpcc	5, 3, cr9, cr13, cr3, {0}
    86a8:	08000003 	stmdaeq	r0, {r0, r1}
    86ac:	00001038 	andeq	r1, r0, r8, lsr r0
    86b0:	533d9603 	teqpl	sp, #3145728	; 0x300000
    86b4:	02000000 	andeq	r0, r0, #0
    86b8:	02080023 	andeq	r0, r8, #35	; 0x23
    86bc:	0300000d 	movweq	r0, #13
    86c0:	00533d97 			; <UNDEFINED> instruction: 0x00533d97
    86c4:	23020000 	movwcs	r0, #8192	; 0x2000
    86c8:	03120804 	tsteq	r2, #262144	; 0x40000
    86cc:	98030000 	stmdals	r3, {}	; <UNPREDICTABLE>
    86d0:	00033e3d 	andeq	r3, r3, sp, lsr lr
    86d4:	08230200 	stmdaeq	r3!, {r9}
    86d8:	00103e08 	andseq	r3, r0, r8, lsl #28
    86dc:	3d990300 	ldccc	3, cr0, [r9]
    86e0:	00000053 	andeq	r0, r0, r3, asr r0
    86e4:	20842303 	addcs	r2, r4, r3, lsl #6
    86e8:	00031d08 	andeq	r1, r3, r8, lsl #26
    86ec:	3d9a0300 	ldccc	3, cr0, [sl]
    86f0:	00000098 	muleq	r0, r8, r0
    86f4:	20882303 	addcs	r2, r8, r3, lsl #6
    86f8:	00104f08 	andseq	r4, r0, r8, lsl #30
    86fc:	3d9b0300 	ldccc	3, cr0, [fp]
    8700:	00000053 	andeq	r0, r0, r3, asr r0
    8704:	208c2303 	addcs	r2, ip, r3, lsl #6
    8708:	00105508 	andseq	r5, r0, r8, lsl #10
    870c:	3d9c0300 	ldccc	3, cr0, [ip]
    8710:	00000053 	andeq	r0, r0, r3, asr r0
    8714:	20902303 	addscs	r2, r0, r3, lsl #6
    8718:	00105b08 	andseq	r5, r0, r8, lsl #22
    871c:	3d9d0300 	ldccc	3, cr0, [sp]
    8720:	00000053 	andeq	r0, r0, r3, asr r0
    8724:	20942303 	addscs	r2, r4, r3, lsl #6
    8728:	00106108 	andseq	r6, r0, r8, lsl #2
    872c:	3d9e0300 	ldccc	3, cr0, [lr]
    8730:	00000053 	andeq	r0, r0, r3, asr r0
    8734:	20982303 	addscs	r2, r8, r3, lsl #6
    8738:	000a9a08 	andeq	r9, sl, r8, lsl #20
    873c:	3d9f0300 	ldccc	3, cr0, [pc]	; 8744 <__addsf3+0xc4>
    8740:	000000a8 	andeq	r0, r0, r8, lsr #1
    8744:	209c2303 	addscs	r2, ip, r3, lsl #6
    8748:	000c6408 	andeq	r6, ip, r8, lsl #8
    874c:	3da00300 	stccc	3, cr0, [r0]
    8750:	00000053 	andeq	r0, r0, r3, asr r0
    8754:	20a42303 	adccs	r2, r4, r3, lsl #6
    8758:	000c6908 	andeq	r6, ip, r8, lsl #18
    875c:	3da10300 	stccc	3, cr0, [r1]
    8760:	00000053 	andeq	r0, r0, r3, asr r0
    8764:	20a82303 	adccs	r2, r8, r3, lsl #6
    8768:	000c6f08 	andeq	r6, ip, r8, lsl #30
    876c:	3da20300 	stccc	3, cr0, [r2]
    8770:	00000053 	andeq	r0, r0, r3, asr r0
    8774:	20ac2303 	adccs	r2, ip, r3, lsl #6
    8778:	000c7508 	andeq	r7, ip, r8, lsl #10
    877c:	3da30300 	stccc	3, cr0, [r3]
    8780:	00000053 	andeq	r0, r0, r3, asr r0
    8784:	20b02303 	adcscs	r2, r0, r3, lsl #6
    8788:	000c7b08 	andeq	r7, ip, r8, lsl #22
    878c:	3da40300 	stccc	3, cr0, [r4]
    8790:	00000053 	andeq	r0, r0, r3, asr r0
    8794:	20b42303 	adcscs	r2, r4, r3, lsl #6
    8798:	000c8108 	andeq	r8, ip, r8, lsl #2
    879c:	3da50300 	stccc	3, cr0, [r5]
    87a0:	00000053 	andeq	r0, r0, r3, asr r0
    87a4:	20b82303 	adcscs	r2, r8, r3, lsl #6
    87a8:	000c8708 	andeq	r8, ip, r8, lsl #14
    87ac:	3da60300 	stccc	3, cr0, [r6]
    87b0:	00000053 	andeq	r0, r0, r3, asr r0
    87b4:	20bc2303 	adcscs	r2, ip, r3, lsl #6
    87b8:	000c8d08 	andeq	r8, ip, r8, lsl #26
    87bc:	3da70300 	stccc	3, cr0, [r7]
    87c0:	00000053 	andeq	r0, r0, r3, asr r0
    87c4:	20c02303 	sbccs	r2, r0, r3, lsl #6
    87c8:	000fec08 	andeq	lr, pc, r8, lsl #24
    87cc:	3da80300 	stccc	3, cr0, [r8]
    87d0:	00000053 	andeq	r0, r0, r3, asr r0
    87d4:	20c42303 	sbccs	r2, r4, r3, lsl #6
    87d8:	000ff408 	andeq	pc, pc, r8, lsl #8
    87dc:	3da90300 	stccc	3, cr0, [r9]
    87e0:	00000053 	andeq	r0, r0, r3, asr r0
    87e4:	20c82303 	sbccs	r2, r8, r3, lsl #6
    87e8:	000f2908 	andeq	r2, pc, r8, lsl #18
    87ec:	3daa0300 	stccc	3, cr0, [sl]
    87f0:	00000053 	andeq	r0, r0, r3, asr r0
    87f4:	20cc2303 	sbccs	r2, ip, r3, lsl #6
    87f8:	000f2f08 	andeq	r2, pc, r8, lsl #30
    87fc:	3dab0300 	stccc	3, cr0, [fp]
    8800:	00000053 	andeq	r0, r0, r3, asr r0
    8804:	20d02303 	sbcscs	r2, r0, r3, lsl #6
    8808:	000bcb08 	andeq	ip, fp, r8, lsl #22
    880c:	3dac0300 	stccc	3, cr0, [ip]
    8810:	00000053 	andeq	r0, r0, r3, asr r0
    8814:	20d42303 	sbcscs	r2, r4, r3, lsl #6
    8818:	000e0908 	andeq	r0, lr, r8, lsl #18
    881c:	3dad0300 	stccc	3, cr0, [sp]
    8820:	00000053 	andeq	r0, r0, r3, asr r0
    8824:	20d82303 	sbcscs	r2, r8, r3, lsl #6
    8828:	000e0f08 	andeq	r0, lr, r8, lsl #30
    882c:	3dae0300 	stccc	3, cr0, [lr]
    8830:	00000053 	andeq	r0, r0, r3, asr r0
    8834:	20dc2303 	sbcscs	r2, ip, r3, lsl #6
    8838:	000bd008 	andeq	sp, fp, r8
    883c:	3daf0300 	stccc	3, cr0, [pc]	; 8844 <__aeabi_l2f+0x30>
    8840:	00000053 	andeq	r0, r0, r3, asr r0
    8844:	20e02303 	rsccs	r2, r0, r3, lsl #6
    8848:	00033108 	andeq	r3, r3, r8, lsl #2
    884c:	3db00300 	ldccc	3, cr0, [r0]
    8850:	00000098 	muleq	r0, r8, r0
    8854:	20e42303 	rsccs	r2, r4, r3, lsl #6
    8858:	000e9f08 	andeq	r9, lr, r8, lsl #30
    885c:	3db10300 	ldccc	3, cr0, [r1]
    8860:	00000053 	andeq	r0, r0, r3, asr r0
    8864:	20e82303 	rsccs	r2, r8, r3, lsl #6
    8868:	52434d0a 	subpl	r4, r3, #640	; 0x280
    886c:	3db20300 	ldccc	3, cr0, [r2]
    8870:	00000053 	andeq	r0, r0, r3, asr r0
    8874:	20ec2303 	rsccs	r2, ip, r3, lsl #6
    8878:	002c0500 	eoreq	r0, ip, r0, lsl #10
    887c:	034f0000 	movteq	r0, #61440	; 0xf000
    8880:	810e0000 	mrshi	r0, (UNDEF: 14)
    8884:	fb000000 	blx	888e <__aeabi_l2f+0x7a>
    8888:	470b000f 	strmi	r0, [fp, -pc]
    888c:	0300000f 	movweq	r0, #15
    8890:	035b3db3 	cmpeq	fp, #11456	; 0x2cc0
    8894:	040c0000 	streq	r0, [ip], #-0
    8898:	00000361 	andeq	r0, r0, r1, ror #6
    889c:	0001620d 	andeq	r6, r1, sp, lsl #4
    88a0:	04830300 	streq	r0, [r3], #768	; 0x300
    88a4:	1b040000 	blne	1088ac <__etext+0xffc04>
    88a8:	00000037 	andeq	r0, r0, r7, lsr r0
    88ac:	001d7b03 	andseq	r7, sp, r3, lsl #22
    88b0:	5e1d0400 	cfmulspl	mvf0, mvf13, mvf0
    88b4:	02000000 	andeq	r0, r0, #0
    88b8:	06690404 	strbteq	r0, [r9], -r4, lsl #8
    88bc:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
    88c0:	000a8704 	andeq	r8, sl, r4, lsl #14
    88c4:	90040c00 	andls	r0, r4, r0, lsl #24
    88c8:	0f000003 	svceq	0x00000003
    88cc:	08010201 	stmdaeq	r1, {r0, r9}
    88d0:	00000712 	andeq	r0, r0, r2, lsl r7
    88d4:	00267503 	eoreq	r7, r6, r3, lsl #10
    88d8:	8a0d0500 	bhi	349ce0 <__etext+0x341038>
    88dc:	10000003 	andne	r0, r0, r3
    88e0:	000027c2 	andeq	r2, r0, r2, asr #15
    88e4:	c9100501 	ldmdbgt	r0, {r0, r8, sl}
    88e8:	11000003 	tstne	r0, r3
    88ec:	0000047e 	andeq	r0, r0, lr, ror r4
    88f0:	00321100 	eorseq	r1, r2, r0, lsl #2
    88f4:	11010000 	mrsne	r0, (UNDEF: 1)
    88f8:	000007cf 	andeq	r0, r0, pc, asr #15
    88fc:	00491102 	subeq	r1, r9, r2, lsl #2
    8900:	00030000 	andeq	r0, r3, r0
    8904:	0027c203 	eoreq	ip, r7, r3, lsl #4
    8908:	a4160500 	ldrge	r0, [r6], #-1280	; 0x500
    890c:	12000003 	andne	r0, r0, #3
    8910:	23190514 	tstcs	r9, #83886080	; 0x5000000
    8914:	13000004 	movwne	r0, #4
    8918:	000026f0 	strdeq	r2, [r0], -r0
    891c:	03c92305 	biceq	r2, r9, #335544320	; 0x14000000
    8920:	23020000 	movwcs	r0, #8192	; 0x2000
    8924:	27a41300 	strcs	r1, [r4, r0, lsl #6]!
    8928:	2d050000 	stccs	0, cr0, [r5, #-0]
    892c:	00000371 	andeq	r0, r0, r1, ror r3
    8930:	13042302 	movwne	r2, #17154	; 0x4302
    8934:	00002761 	andeq	r2, r0, r1, ror #14
    8938:	03713705 	cmneq	r1, #1310720	; 0x140000
    893c:	23020000 	movwcs	r0, #8192	; 0x2000
    8940:	27371308 	ldrcs	r1, [r7, -r8, lsl #6]!
    8944:	41050000 	mrsmi	r0, (UNDEF: 5)
    8948:	00000371 	andeq	r0, r0, r1, ror r3
    894c:	130c2302 	movwne	r2, #49922	; 0xc302
    8950:	000026ca 	andeq	r2, r0, sl, asr #13
    8954:	03994b05 	orrseq	r4, r9, #5120	; 0x1400
    8958:	23020000 	movwcs	r0, #8192	; 0x2000
    895c:	ba030010 	blt	c89a4 <__etext+0xbfcfc>
    8960:	05000026 	streq	r0, [r0, #-38]	; 0x26
    8964:	0003d44c 	andeq	sp, r3, ip, asr #8
    8968:	86011400 	strhi	r1, [r1], -r0, lsl #8
    896c:	01000026 	tsteq	r0, r6, lsr #32
    8970:	0366011b 	cmneq	r6, #-1073741818	; 0xc0000006
    8974:	5f7c0000 	svcpl	0x007c0000
    8978:	60ea0000 	rscvs	r0, sl, r0
    897c:	18e20000 	stmiane	r2!, {}^	; <UNPREDICTABLE>
    8980:	85010000 	strhi	r0, [r1, #-0]
    8984:	15000004 	strne	r0, [r0, #-4]
    8988:	0000276e 	andeq	r2, r0, lr, ror #14
    898c:	04231b01 	strteq	r1, [r3], #-2817	; 0xb01
    8990:	91020000 	mrsls	r0, (UNDEF: 2)
    8994:	27431670 	smlsldxcs	r1, r3, r0, r6
    8998:	1e010000 	cdpne	0, 0, cr0, cr1, cr0, {0}
    899c:	00000371 	andeq	r0, r0, r1, ror r3
    89a0:	16649102 	strbtne	r9, [r4], -r2, lsl #2
    89a4:	000027bd 			; <UNDEFINED> instruction: 0x000027bd
    89a8:	03c92101 	biceq	r2, r9, #1073741824	; 0x40000000
    89ac:	91020000 	mrsls	r0, (UNDEF: 2)
    89b0:	17831663 	strne	r1, [r3, r3, ror #12]
    89b4:	22010000 	andcs	r0, r1, #0
    89b8:	00000399 	muleq	r0, r9, r3
    89bc:	005c9102 	subseq	r9, ip, r2, lsl #2
    89c0:	26650117 			; <UNDEFINED> instruction: 0x26650117
    89c4:	4f010000 	svcmi	0x00010000
    89c8:	0060ec01 	rsbeq	lr, r0, r1, lsl #24
    89cc:	00613400 	rsbeq	r3, r1, r0, lsl #8
    89d0:	00192600 	andseq	r2, r9, r0, lsl #12
    89d4:	04bc0100 	ldrteq	r0, [ip], #256	; 0x100
    89d8:	6e150000 	cdpvs	0, 1, cr0, cr5, cr0, {0}
    89dc:	01000027 	tsteq	r0, r7, lsr #32
    89e0:	0004234f 	andeq	r2, r4, pc, asr #6
    89e4:	70910200 	addsvc	r0, r1, r0, lsl #4
    89e8:	0027bd16 	eoreq	fp, r7, r6, lsl sp
    89ec:	c9510100 	ldmdbgt	r1, {r8}^
    89f0:	02000003 	andeq	r0, r0, #3
    89f4:	17006791 			; <UNDEFINED> instruction: 0x17006791
    89f8:	00274901 	eoreq	r4, r7, r1, lsl #18
    89fc:	01680100 	cmneq	r8, r0, lsl #2
    8a00:	00006134 	andeq	r6, r0, r4, lsr r1
    8a04:	00006162 	andeq	r6, r0, r2, ror #2
    8a08:	0000196a 	andeq	r1, r0, sl, ror #18
    8a0c:	0004f301 	andeq	pc, r4, r1, lsl #6
    8a10:	276e1500 	strbcs	r1, [lr, -r0, lsl #10]!
    8a14:	68010000 	stmdavs	r1, {}	; <UNPREDICTABLE>
    8a18:	00000423 	andeq	r0, r0, r3, lsr #8
    8a1c:	16709102 	ldrbtne	r9, [r0], -r2, lsl #2
    8a20:	000027bd 			; <UNDEFINED> instruction: 0x000027bd
    8a24:	03c96a01 	biceq	r6, r9, #4096	; 0x1000
    8a28:	91020000 	mrsls	r0, (UNDEF: 2)
    8a2c:	01170067 	tsteq	r7, r7, rrx
    8a30:	000027c7 	andeq	r2, r0, r7, asr #15
    8a34:	64017e01 	strvs	r7, [r1], #-3585	; 0xe01
    8a38:	92000061 	andls	r0, r0, #97	; 0x61
    8a3c:	ae000061 	cdpge	0, 0, cr0, cr0, cr1, {3}
    8a40:	01000019 	tsteq	r0, r9, lsl r0
    8a44:	0000052a 	andeq	r0, r0, sl, lsr #10
    8a48:	00276e15 	eoreq	r6, r7, r5, lsl lr
    8a4c:	237e0100 	cmncs	lr, #0
    8a50:	02000004 	andeq	r0, r0, #4
    8a54:	bd167091 	ldclt	0, cr7, [r6, #-580]	; 0xfffffdbc
    8a58:	01000027 	tsteq	r0, r7, lsr #32
    8a5c:	0003c980 	andeq	ip, r3, r0, lsl #19
    8a60:	67910200 	ldrvs	r0, [r1, r0, lsl #4]
    8a64:	a7011800 	strge	r1, [r1, -r0, lsl #16]
    8a68:	01000026 	tsteq	r0, r6, lsr #32
    8a6c:	61940189 	orrsvs	r0, r4, r9, lsl #3
    8a70:	62ac0000 	adcvs	r0, ip, #0
    8a74:	19f20000 	ldmibne	r2!, {}^	; <UNPREDICTABLE>
    8a78:	53010000 	movwpl	r0, #4096	; 0x1000
    8a7c:	15000005 	strne	r0, [r0, #-5]
    8a80:	000027b9 			; <UNDEFINED> instruction: 0x000027b9
    8a84:	03c98901 	biceq	r8, r9, #16384	; 0x4000
    8a88:	91020000 	mrsls	r0, (UNDEF: 2)
    8a8c:	01140077 	tsteq	r4, r7, ror r0
    8a90:	00002694 	muleq	r0, r4, r6
    8a94:	71019f01 	tstvc	r1, r1, lsl #30
    8a98:	ac000003 	stcge	0, cr0, [r0], {3}
    8a9c:	92000062 	andls	r0, r0, #98	; 0x62
    8aa0:	2a000063 	bcs	8c34 <strlen+0xc4>
    8aa4:	0100001a 	tsteq	r0, sl, lsl r0
    8aa8:	0000058e 	andeq	r0, r0, lr, lsl #11
    8aac:	0027b915 	eoreq	fp, r7, r5, lsl r9
    8ab0:	c99f0100 	ldmibgt	pc, {r8}	; <UNPREDICTABLE>
    8ab4:	02000003 	andeq	r0, r0, #3
    8ab8:	76196f91 	sadd8vc	r6, r9, r1
    8abc:	01006c61 	tsteq	r0, r1, ror #24
    8ac0:	000371a1 	andeq	r7, r3, r1, lsr #3
    8ac4:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    8ac8:	24011800 	strcs	r1, [r1], #-2048	; 0x800
    8acc:	01000027 	tsteq	r0, r7, lsr #32
    8ad0:	639401b5 	orrsvs	r0, r4, #1073741869	; 0x4000002d
    8ad4:	64080000 	strvs	r0, [r8], #-0
    8ad8:	1a620000 	bne	1888ae0 <__etext+0x187fe38>
    8adc:	b7010000 	strlt	r0, [r1, -r0]
    8ae0:	15000005 	strne	r0, [r0, #-5]
    8ae4:	000027b9 			; <UNDEFINED> instruction: 0x000027b9
    8ae8:	03c9b501 	biceq	fp, r9, #4194304	; 0x400000
    8aec:	91020000 	mrsls	r0, (UNDEF: 2)
    8af0:	011a0077 	tsteq	sl, r7, ror r0
    8af4:	00002714 	andeq	r2, r0, r4, lsl r7
    8af8:	0801c301 	stmdaeq	r1, {r0, r8, r9, lr, pc}
    8afc:	36000064 	strcc	r0, [r0], -r4, rrx
    8b00:	9a000064 	bls	8c98 <strlen+0x128>
    8b04:	0100001a 	tsteq	r0, sl, lsl r0
    8b08:	264f011a 			; <UNDEFINED> instruction: 0x264f011a
    8b0c:	d5010000 	strle	r0, [r1, #-0]
    8b10:	00643801 	rsbeq	r3, r4, r1, lsl #16
    8b14:	00646600 	rsbeq	r6, r4, r0, lsl #12
    8b18:	001ac600 	andseq	ip, sl, r0, lsl #12
    8b1c:	011a0100 	tsteq	sl, r0, lsl #2
    8b20:	000026f9 	strdeq	r2, [r0], -r9
    8b24:	6801e701 	stmdavs	r1, {r0, r8, r9, sl, sp, lr, pc}
    8b28:	96000064 	strls	r0, [r0], -r4, rrx
    8b2c:	f2000064 	vhadd.s8	q0, q0, q10
    8b30:	0100001a 	tsteq	r0, sl, lsl r0
    8b34:	26d2011a 			; <UNDEFINED> instruction: 0x26d2011a
    8b38:	f9010000 			; <UNDEFINED> instruction: 0xf9010000
    8b3c:	00649801 	rsbeq	r9, r4, r1, lsl #16
    8b40:	0064c600 	rsbeq	ip, r4, r0, lsl #12
    8b44:	001b1e00 	andseq	r1, fp, r0, lsl #28
    8b48:	f71b0100 			; <UNDEFINED> instruction: 0xf71b0100
    8b4c:	0600000b 	streq	r0, [r0], -fp
    8b50:	00037120 	andeq	r7, r3, r0, lsr #2
    8b54:	05010100 	streq	r0, [r1, #-256]	; 0x100
    8b58:	00000399 	muleq	r0, r9, r3
    8b5c:	0000062c 	andeq	r0, r0, ip, lsr #12
    8b60:	00008106 	andeq	r8, r0, r6, lsl #2
    8b64:	1c000300 	stcne	3, cr0, [r0], {-0}
    8b68:	00002781 	andeq	r2, r0, r1, lsl #15
    8b6c:	061c0d01 	ldreq	r0, [ip], -r1, lsl #26
    8b70:	05010000 	streq	r0, [r1, #-0]
    8b74:	ff167003 			; <UNDEFINED> instruction: 0xff167003
    8b78:	10d0001f 	sbcsne	r0, r0, pc, lsl r0
    8b7c:	00020000 	andeq	r0, r2, r0
    8b80:	00001621 	andeq	r1, r0, r1, lsr #12
    8b84:	02340104 	eorseq	r0, r4, #1
    8b88:	e6010000 	str	r0, [r1], -r0
    8b8c:	27000027 	strcs	r0, [r0, -r7, lsr #32]
    8b90:	c8000008 	stmdagt	r0, {r3}
    8b94:	3c000064 	stccc	0, cr0, [r0], {100}	; 0x64
    8b98:	ed000073 	stc	0, cr0, [r0, #-460]	; 0xfffffe34
    8b9c:	02000017 	andeq	r0, r0, #23
    8ba0:	070b0601 	streq	r0, [fp, -r1, lsl #12]
    8ba4:	dd030000 	stcle	0, cr0, [r3, #-0]
    8ba8:	02000009 	andeq	r0, r0, #9
    8bac:	0000372a 	andeq	r3, r0, sl, lsr #14
    8bb0:	08010200 	stmdaeq	r1, {r9}
    8bb4:	00000709 	andeq	r0, r0, r9, lsl #14
    8bb8:	3b050202 	blcc	1493c8 <__etext+0x140720>
    8bbc:	02000007 	andeq	r0, r0, #7
    8bc0:	04920702 	ldreq	r0, [r2], #1794	; 0x702
    8bc4:	04020000 	streq	r0, [r2], #-0
    8bc8:	00019605 	andeq	r9, r1, r5, lsl #12
    8bcc:	079b0300 	ldreq	r0, [fp, r0, lsl #6]
    8bd0:	50020000 	andpl	r0, r2, r0
    8bd4:	0000005e 	andeq	r0, r0, lr, asr r0
    8bd8:	e4070402 	str	r0, [r7], #-1026	; 0x402
    8bdc:	02000001 	andeq	r0, r0, #1
    8be0:	01910508 	orrseq	r0, r1, r8, lsl #10
    8be4:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
    8be8:	0001df07 	andeq	sp, r1, r7, lsl #30
    8bec:	05040400 	streq	r0, [r4, #-1024]	; 0x400
    8bf0:	00746e69 	rsbseq	r6, r4, r9, ror #28
    8bf4:	e9070402 	stmdb	r7, {r1, sl}
    8bf8:	05000001 	streq	r0, [r0, #-1]
    8bfc:	a04b0301 	subge	r0, fp, r1, lsl #6
    8c00:	06000003 	streq	r0, [r0], -r3
    8c04:	00000aa5 	andeq	r0, r0, r5, lsr #21
    8c08:	069a0600 	ldreq	r0, [sl], r0, lsl #12
    8c0c:	06010000 	streq	r0, [r1], -r0
    8c10:	0000020a 	andeq	r0, r0, sl, lsl #4
    8c14:	00000602 	andeq	r0, r0, r2, lsl #12
    8c18:	06030000 	streq	r0, [r3], -r0
    8c1c:	000000c4 	andeq	r0, r0, r4, asr #1
    8c20:	01bd0604 			; <UNDEFINED> instruction: 0x01bd0604
    8c24:	06050000 	streq	r0, [r5], -r0
    8c28:	000008bf 			; <UNDEFINED> instruction: 0x000008bf
    8c2c:	027d0606 	rsbseq	r0, sp, #6291456	; 0x600000
    8c30:	06070000 	streq	r0, [r7], -r0
    8c34:	0000028b 	andeq	r0, r0, fp, lsl #5
    8c38:	02990608 	addseq	r0, r9, #8388608	; 0x800000
    8c3c:	06090000 	streq	r0, [r9], -r0
    8c40:	000009a4 	andeq	r0, r0, r4, lsr #19
    8c44:	0a11060a 	beq	44a474 <__etext+0x4417cc>
    8c48:	060b0000 	streq	r0, [fp], -r0
    8c4c:	0000059a 	muleq	r0, sl, r5
    8c50:	09c5060c 	stmibeq	r5, {r2, r3, r9, sl}^
    8c54:	060d0000 	streq	r0, [sp], -r0
    8c58:	0000054b 	andeq	r0, r0, fp, asr #10
    8c5c:	03de060e 	bicseq	r0, lr, #14680064	; 0xe00000
    8c60:	060f0000 	streq	r0, [pc], -r0
    8c64:	00000108 	andeq	r0, r0, r8, lsl #2
    8c68:	068b0610 	pkhbteq	r0, fp, r0, lsl #12
    8c6c:	06110000 	ldreq	r0, [r1], -r0
    8c70:	00000148 	andeq	r0, r0, r8, asr #2
    8c74:	06f10612 	usateq	r0, #17, r2, lsl #12
    8c78:	06130000 	ldreq	r0, [r3], -r0
    8c7c:	0000037a 	andeq	r0, r0, sl, ror r3
    8c80:	08180614 	ldmdaeq	r8, {r2, r4, r9, sl}
    8c84:	06150000 	ldreq	r0, [r5], -r0
    8c88:	000003cf 	andeq	r0, r0, pc, asr #7
    8c8c:	08b00616 	ldmeq	r0!, {r1, r2, r4, r9, sl}
    8c90:	06170000 	ldreq	r0, [r7], -r0
    8c94:	0000042f 	andeq	r0, r0, pc, lsr #8
    8c98:	01390618 	teqeq	r9, r8, lsl r6
    8c9c:	06190000 	ldreq	r0, [r9], -r0
    8ca0:	000003bf 			; <UNDEFINED> instruction: 0x000003bf
    8ca4:	0898061a 	ldmeq	r8, {r1, r3, r4, r9, sl}
    8ca8:	061b0000 	ldreq	r0, [fp], -r0
    8cac:	0000040d 	andeq	r0, r0, sp, lsl #8
    8cb0:	08e8061c 	stmiaeq	r8!, {r2, r3, r4, r9, sl}^
    8cb4:	061d0000 	ldreq	r0, [sp], -r0
    8cb8:	0000051f 	andeq	r0, r0, pc, lsl r5
    8cbc:	03af061e 			; <UNDEFINED> instruction: 0x03af061e
    8cc0:	061f0000 	ldreq	r0, [pc], -r0
    8cc4:	000008cf 	andeq	r0, r0, pc, asr #17
    8cc8:	02120620 	andseq	r0, r2, #33554432	; 0x2000000
    8ccc:	06210000 	strteq	r0, [r1], -r0
    8cd0:	000003f3 	strdeq	r0, [r0], -r3
    8cd4:	01170622 	tsteq	r7, r2, lsr #12
    8cd8:	06230000 	strteq	r0, [r3], -r0
    8cdc:	000005e0 	andeq	r0, r0, r0, ror #11
    8ce0:	04d30624 	ldrbeq	r0, [r3], #1572	; 0x624
    8ce4:	06250000 	strteq	r0, [r5], -r0
    8ce8:	00000a37 	andeq	r0, r0, r7, lsr sl
    8cec:	06530626 	ldrbeq	r0, [r3], -r6, lsr #12
    8cf0:	06270000 	strteq	r0, [r7], -r0
    8cf4:	0000075e 	andeq	r0, r0, lr, asr r7
    8cf8:	0a530628 	beq	14ca5a0 <__etext+0x14c18f8>
    8cfc:	06290000 	strteq	r0, [r9], -r0
    8d00:	00000a67 	andeq	r0, r0, r7, ror #20
    8d04:	077f062a 	ldrbeq	r0, [pc, -sl, lsr #12]!
    8d08:	062b0000 	strteq	r0, [fp], -r0
    8d0c:	00000a70 	andeq	r0, r0, r0, ror sl
    8d10:	0089062c 	addeq	r0, r9, ip, lsr #12
    8d14:	062d0000 	strteq	r0, [sp], -r0
    8d18:	00000166 	andeq	r0, r0, r6, ror #2
    8d1c:	058b062e 	streq	r0, [fp, #1582]	; 0x62e
    8d20:	062f0000 	strteq	r0, [pc], -r0
    8d24:	00000877 	andeq	r0, r0, r7, ror r8
    8d28:	08630630 	stmdaeq	r3!, {r4, r5, r9, sl}^
    8d2c:	06310000 	ldrteq	r0, [r1], -r0
    8d30:	000002b7 			; <UNDEFINED> instruction: 0x000002b7
    8d34:	03680632 	cmneq	r8, #52428800	; 0x3200000
    8d38:	06330000 	ldrteq	r0, [r3], -r0
    8d3c:	00000a8e 	andeq	r0, r0, lr, lsl #21
    8d40:	006c0634 	rsbeq	r0, ip, r4, lsr r6
    8d44:	06350000 	ldrteq	r0, [r5], -r0
    8d48:	00000399 	muleq	r0, r9, r3
    8d4c:	01ae0636 			; <UNDEFINED> instruction: 0x01ae0636
    8d50:	06370000 	ldrteq	r0, [r7], -r0
    8d54:	000001f6 	strdeq	r0, [r0], -r6
    8d58:	01cb0638 	biceq	r0, fp, r8, lsr r6
    8d5c:	06390000 	ldrteq	r0, [r9], -r0
    8d60:	0000043e 	andeq	r0, r0, lr, lsr r4
    8d64:	04db063a 	ldrbeq	r0, [fp], #1594	; 0x63a
    8d68:	063b0000 	ldrteq	r0, [fp], -r0
    8d6c:	00000745 	andeq	r0, r0, r5, asr #14
    8d70:	0918063c 	ldmdbeq	r8, {r2, r3, r4, r5, r9, sl}
    8d74:	063d0000 	ldrteq	r0, [sp], -r0
    8d78:	00000454 	andeq	r0, r0, r4, asr r4
    8d7c:	046a063e 	strbteq	r0, [sl], #-1598	; 0x63e
    8d80:	063f0000 	ldrteq	r0, [pc], -r0
    8d84:	00000a79 	andeq	r0, r0, r9, ror sl
    8d88:	940600c0 	strls	r0, [r6], #-192	; 0xc0
    8d8c:	c1000009 	tstgt	r0, r9
    8d90:	057d0600 	ldrbeq	r0, [sp, #-1536]!	; 0x600
    8d94:	00c20000 	sbceq	r0, r2, r0
    8d98:	0004a506 	andeq	sl, r4, r6, lsl #10
    8d9c:	0600c300 	streq	ip, [r0], -r0, lsl #6
    8da0:	00000a21 	andeq	r0, r0, r1, lsr #20
    8da4:	f80600c4 			; <UNDEFINED> instruction: 0xf80600c4
    8da8:	c5000009 	strgt	r0, [r0, #-9]
    8dac:	097a0600 	ldmdbeq	sl!, {r9, sl}^
    8db0:	00c60000 	sbceq	r0, r6, r0
    8db4:	0004c306 	andeq	ip, r4, r6, lsl #6
    8db8:	0600c700 	streq	ip, [r0], -r0, lsl #14
    8dbc:	0000053d 	andeq	r0, r0, sp, lsr r5
    8dc0:	040600c8 	streq	r0, [r6], #-200	; 0xc8
    8dc4:	c9000004 	stmdbgt	r0, {r2}
    8dc8:	022b0600 	eoreq	r0, fp, #0
    8dcc:	00ca0000 	sbceq	r0, sl, r0
    8dd0:	0009b306 	andeq	fp, r9, r6, lsl #6
    8dd4:	0600cb00 	streq	ip, [r0], -r0, lsl #22
    8dd8:	0000066f 	andeq	r0, r0, pc, ror #12
    8ddc:	780600cc 	stmdavc	r6, {r2, r3, r6, r7}
    8de0:	cd000006 	stcgt	0, cr0, [r0, #-24]	; 0xffffffe8
    8de4:	02cd0600 	sbceq	r0, sp, #0
    8de8:	00ce0000 	sbceq	r0, lr, r0
    8dec:	0002d606 	andeq	sp, r2, r6, lsl #12
    8df0:	0600cf00 	streq	ip, [r0], -r0, lsl #30
    8df4:	000002df 	ldrdeq	r0, [r0], -pc	; <UNPREDICTABLE>
    8df8:	1a0600d0 	bne	189140 <__etext+0x180498>
    8dfc:	d1000002 	tstle	r0, r2
    8e00:	04620600 	strbteq	r0, [r2], #-1536	; 0x600
    8e04:	00d20000 	sbcseq	r0, r2, r0
    8e08:	00038906 	andeq	r8, r3, r6, lsl #18
    8e0c:	0600d300 	streq	sp, [r0], -r0, lsl #6
    8e10:	0000047a 	andeq	r0, r0, sl, ror r4
    8e14:	2e0600d4 	mcrcs	0, 0, r0, cr6, cr4, {6}
    8e18:	d5000000 	strle	r0, [r0, #-0]
    8e1c:	07cb0600 	strbeq	r0, [fp, r0, lsl #12]
    8e20:	00d60000 	sbcseq	r0, r6, r0
    8e24:	00004506 	andeq	r4, r0, r6, lsl #10
    8e28:	0600d700 	streq	sp, [r0], -r0, lsl #14
    8e2c:	000005ec 	andeq	r0, r0, ip, ror #11
    8e30:	220600d8 	andcs	r0, r6, #216	; 0xd8
    8e34:	d9000002 	stmdble	r0, {r1}
    8e38:	07530600 	ldrbeq	r0, [r3, -r0, lsl #12]
    8e3c:	00da0000 	sbcseq	r0, sl, r0
    8e40:	00090406 	andeq	r0, r9, r6, lsl #8
    8e44:	0600db00 	streq	sp, [r0], -r0, lsl #22
    8e48:	000000de 	ldrdeq	r0, [r0], -lr
    8e4c:	560600dc 			; <UNDEFINED> instruction: 0x560600dc
    8e50:	dd000000 	stcle	0, cr0, [r0, #-0]
    8e54:	019f0600 	orrseq	r0, pc, r0, lsl #12
    8e58:	00de0000 	sbcseq	r0, lr, r0
    8e5c:	000a4406 	andeq	r4, sl, r6, lsl #8
    8e60:	0600df00 	streq	sp, [r0], -r0, lsl #30
    8e64:	000000a6 	andeq	r0, r0, r6, lsr #1
    8e68:	d70600e0 	strle	r0, [r6, -r0, ror #1]
    8e6c:	e1000005 	tst	r0, r5
    8e70:	04ea0600 	strbteq	r0, [sl], #1536	; 0x600
    8e74:	00e20000 	rsceq	r0, r2, r0
    8e78:	0003ea06 	andeq	lr, r3, r6, lsl #20
    8e7c:	0600e300 	streq	lr, [r0], -r0, lsl #6
    8e80:	0000004e 	andeq	r0, r0, lr, asr #32
    8e84:	060600e4 	streq	r0, [r6], -r4, ror #1
    8e88:	e5000003 	str	r0, [r0, #-3]
    8e8c:	00b40600 	adcseq	r0, r4, r0, lsl #12
    8e90:	00e60000 	rsceq	r0, r6, r0
    8e94:	0005f506 	andeq	pc, r5, r6, lsl #10
    8e98:	0600e700 	streq	lr, [r0], -r0, lsl #14
    8e9c:	0000012a 	andeq	r0, r0, sl, lsr #2
    8ea0:	100600e8 	andne	r0, r6, r8, ror #1
    8ea4:	e9000006 	stmdb	r0, {r1, r2}
    8ea8:	07310600 	ldreq	r0, [r1, -r0, lsl #12]!
    8eac:	00ea0000 	rsceq	r0, sl, r0
    8eb0:	00062c06 	andeq	r2, r6, r6, lsl #24
    8eb4:	0600eb00 	streq	lr, [r0], -r0, lsl #22
    8eb8:	00000636 	andeq	r0, r0, r6, lsr r6
    8ebc:	900600ec 	andls	r0, r6, ip, ror #1
    8ec0:	ed000008 	stc	0, cr0, [r0, #-32]	; 0xffffffe0
    8ec4:	06610600 	strbteq	r0, [r1], -r0, lsl #12
    8ec8:	00ee0000 	rsceq	r0, lr, r0
    8ecc:	0005c306 	andeq	ip, r5, r6, lsl #6
    8ed0:	0600ef00 	streq	lr, [r0], -r0, lsl #30
    8ed4:	00000681 	andeq	r0, r0, r1, lsl #13
    8ed8:	f80600f0 			; <UNDEFINED> instruction: 0xf80600f0
    8edc:	f1000000 	cps	#0
    8ee0:	09e50600 	stmibeq	r5!, {r9, sl}^
    8ee4:	00f20000 	rscseq	r0, r2, r0
    8ee8:	00035d06 	andeq	r5, r3, r6, lsl #26
    8eec:	0600f300 	streq	pc, [r0], -r0, lsl #6
    8ef0:	000002a7 	andeq	r0, r0, r7, lsr #5
    8ef4:	e80600f4 	stmda	r6, {r2, r4, r5, r6, r7}
    8ef8:	f5000002 			; <UNDEFINED> instruction: 0xf5000002
    8efc:	041d0600 	ldreq	r0, [sp], #-1536	; 0x600
    8f00:	00f60000 	rscseq	r0, r6, r0
    8f04:	00042606 	andeq	r2, r4, r6, lsl #12
    8f08:	0600f700 	streq	pc, [r0], -r0, lsl #14
    8f0c:	00000185 	andeq	r0, r0, r5, lsl #3
    8f10:	880600f8 	stmdahi	r6, {r3, r4, r5, r6, r7}
    8f14:	f9000009 			; <UNDEFINED> instruction: 0xf9000009
    8f18:	53070000 	movwpl	r0, #28672	; 0x7000
    8f1c:	b0000000 	andlt	r0, r0, r0
    8f20:	08000003 	stmdaeq	r0, {r0, r1}
    8f24:	000003b0 			; <UNDEFINED> instruction: 0x000003b0
    8f28:	04020001 	streq	r0, [r2], #-1
    8f2c:	00057407 	andeq	r7, r5, r7, lsl #8
    8f30:	002c0700 	eoreq	r0, ip, r0, lsl #14
    8f34:	03c70000 	biceq	r0, r7, #0
    8f38:	b0080000 	andlt	r0, r8, r0
    8f3c:	1b000003 	blne	8f50 <__etext+0x2a8>
    8f40:	002c0700 	eoreq	r0, ip, r0, lsl #14
    8f44:	03d70000 	bicseq	r0, r7, #0
    8f48:	b0080000 	andlt	r0, r8, r0
    8f4c:	03000003 	movweq	r0, #3
    8f50:	002c0700 	eoreq	r0, ip, r0, lsl #14
    8f54:	03e70000 	mvneq	r0, #0
    8f58:	b0080000 	andlt	r0, r8, r0
    8f5c:	07000003 	streq	r0, [r0, -r3]
    8f60:	002c0700 	eoreq	r0, ip, r0, lsl #14
    8f64:	03f70000 	mvnseq	r0, #0
    8f68:	b0080000 	andlt	r0, r8, r0
    8f6c:	2f000003 	svccs	0x00000003
    8f70:	002c0700 	eoreq	r0, ip, r0, lsl #14
    8f74:	04070000 	streq	r0, [r7], #-0
    8f78:	b0080000 	andlt	r0, r8, r0
    8f7c:	17000003 	strne	r0, [r0, -r3]
    8f80:	00530700 	subseq	r0, r3, r0, lsl #14
    8f84:	04170000 	ldreq	r0, [r7], #-0
    8f88:	b0080000 	andlt	r0, r8, r0
    8f8c:	1f000003 	svcne	0x00000003
    8f90:	00530700 	subseq	r0, r3, r0, lsl #14
    8f94:	04270000 	strteq	r0, [r7], #-0
    8f98:	b0080000 	andlt	r0, r8, r0
    8f9c:	00000003 	andeq	r0, r0, r3
    8fa0:	12610900 	rsbne	r0, r1, #0
    8fa4:	03cc0000 	biceq	r0, ip, #0
    8fa8:	04c435a5 	strbeq	r3, [r4], #1445	; 0x5a5
    8fac:	500a0000 	andpl	r0, sl, r0
    8fb0:	03005243 	movweq	r5, #579	; 0x243
    8fb4:	040735a6 	streq	r3, [r7], #-1446	; 0x5a6
    8fb8:	23020000 	movwcs	r0, #8192	; 0x2000
    8fbc:	11110b00 	tstne	r1, r0, lsl #22
    8fc0:	a7030000 	strge	r0, [r3, -r0]
    8fc4:	00005335 	andeq	r5, r0, r5, lsr r3
    8fc8:	80230300 	eorhi	r0, r3, r0, lsl #6
    8fcc:	145a0b01 	ldrbne	r0, [sl], #-2817	; 0xb01
    8fd0:	a8030000 	stmdage	r3, {}	; <UNPREDICTABLE>
    8fd4:	00005335 	andeq	r5, r0, r5, lsr r3
    8fd8:	84230300 	strthi	r0, [r3], #-768	; 0x300
    8fdc:	03120b01 	tsteq	r2, #1024	; 0x400
    8fe0:	a9030000 	stmdbge	r3, {}	; <UNPREDICTABLE>
    8fe4:	0003f735 	andeq	pc, r3, r5, lsr r7	; <UNPREDICTABLE>
    8fe8:	88230300 	stmdahi	r3!, {r8, r9}
    8fec:	12380b01 	eorsne	r0, r8, #1024	; 0x400
    8ff0:	aa030000 	bge	c8ff8 <__etext+0xc0350>
    8ff4:	00005335 	andeq	r5, r0, r5, lsr r3
    8ff8:	a0230300 	eorge	r0, r3, r0, lsl #6
    8ffc:	031d0b01 	tsteq	sp, #1024	; 0x400
    9000:	ab030000 	blge	c9008 <__etext+0xc0360>
    9004:	0003b735 	andeq	fp, r3, r5, lsr r7
    9008:	a4230300 	strtge	r0, [r3], #-768	; 0x300
    900c:	126d0b01 	rsbne	r0, sp, #1024	; 0x400
    9010:	ac030000 	stcge	0, cr0, [r3], {-0}
    9014:	00005335 	andeq	r5, r0, r5, lsr r3
    9018:	c0230300 	eorgt	r0, r3, r0, lsl #6
    901c:	114a0b01 	cmpne	sl, r1, lsl #22
    9020:	ad030000 	stcge	0, cr0, [r3, #-0]
    9024:	00005335 	andeq	r5, r0, r5, lsr r3
    9028:	c4230300 	strtgt	r0, [r3], #-768	; 0x300
    902c:	12950b01 	addsne	r0, r5, #1024	; 0x400
    9030:	ae030000 	cdpge	0, 0, cr0, cr3, cr0, {0}
    9034:	00005335 	andeq	r5, r0, r5, lsr r3
    9038:	c8230300 	stmdagt	r3!, {r8, r9}
    903c:	b10c0001 	tstlt	ip, r1
    9040:	03000011 	movweq	r0, #17
    9044:	04d035af 	ldrbeq	r3, [r0], #1455	; 0x5af
    9048:	040d0000 	streq	r0, [sp], #-0
    904c:	000004d6 	ldrdeq	r0, [r0], -r6
    9050:	0004270e 	andeq	r2, r4, lr, lsl #14
    9054:	10440f00 	subne	r0, r4, r0, lsl #30
    9058:	10700000 	rsbsne	r0, r0, r0
    905c:	b73d9503 	ldrlt	r9, [sp, -r3, lsl #10]!
    9060:	0b000006 	bleq	9080 <__etext+0x3d8>
    9064:	00001038 	andeq	r1, r0, r8, lsr r0
    9068:	533d9603 	teqpl	sp, #3145728	; 0x300000
    906c:	02000000 	andeq	r0, r0, #0
    9070:	020b0023 	andeq	r0, fp, #35	; 0x23
    9074:	0300000d 	movweq	r0, #13
    9078:	00533d97 			; <UNDEFINED> instruction: 0x00533d97
    907c:	23020000 	movwcs	r0, #8192	; 0x2000
    9080:	03120b04 	tsteq	r2, #4096	; 0x1000
    9084:	98030000 	stmdals	r3, {}	; <UNPREDICTABLE>
    9088:	0006b73d 	andeq	fp, r6, sp, lsr r7
    908c:	08230200 	stmdaeq	r3!, {r9}
    9090:	00103e0b 	andseq	r3, r0, fp, lsl #28
    9094:	3d990300 	ldccc	3, cr0, [r9]
    9098:	00000053 	andeq	r0, r0, r3, asr r0
    909c:	20842303 	addcs	r2, r4, r3, lsl #6
    90a0:	00031d0b 	andeq	r1, r3, fp, lsl #26
    90a4:	3d9a0300 	ldccc	3, cr0, [sl]
    90a8:	000003c7 	andeq	r0, r0, r7, asr #7
    90ac:	20882303 	addcs	r2, r8, r3, lsl #6
    90b0:	00104f0b 	andseq	r4, r0, fp, lsl #30
    90b4:	3d9b0300 	ldccc	3, cr0, [fp]
    90b8:	00000053 	andeq	r0, r0, r3, asr r0
    90bc:	208c2303 	addcs	r2, ip, r3, lsl #6
    90c0:	0010550b 	andseq	r5, r0, fp, lsl #10
    90c4:	3d9c0300 	ldccc	3, cr0, [ip]
    90c8:	00000053 	andeq	r0, r0, r3, asr r0
    90cc:	20902303 	addscs	r2, r0, r3, lsl #6
    90d0:	00105b0b 	andseq	r5, r0, fp, lsl #22
    90d4:	3d9d0300 	ldccc	3, cr0, [sp]
    90d8:	00000053 	andeq	r0, r0, r3, asr r0
    90dc:	20942303 	addscs	r2, r4, r3, lsl #6
    90e0:	0010610b 	andseq	r6, r0, fp, lsl #2
    90e4:	3d9e0300 	ldccc	3, cr0, [lr]
    90e8:	00000053 	andeq	r0, r0, r3, asr r0
    90ec:	20982303 	addscs	r2, r8, r3, lsl #6
    90f0:	000a9a0b 	andeq	r9, sl, fp, lsl #20
    90f4:	3d9f0300 	ldccc	3, cr0, [pc]	; 90fc <__etext+0x454>
    90f8:	000003d7 	ldrdeq	r0, [r0], -r7
    90fc:	209c2303 	addscs	r2, ip, r3, lsl #6
    9100:	000c640b 	andeq	r6, ip, fp, lsl #8
    9104:	3da00300 	stccc	3, cr0, [r0]
    9108:	00000053 	andeq	r0, r0, r3, asr r0
    910c:	20a42303 	adccs	r2, r4, r3, lsl #6
    9110:	000c690b 	andeq	r6, ip, fp, lsl #18
    9114:	3da10300 	stccc	3, cr0, [r1]
    9118:	00000053 	andeq	r0, r0, r3, asr r0
    911c:	20a82303 	adccs	r2, r8, r3, lsl #6
    9120:	000c6f0b 	andeq	r6, ip, fp, lsl #30
    9124:	3da20300 	stccc	3, cr0, [r2]
    9128:	00000053 	andeq	r0, r0, r3, asr r0
    912c:	20ac2303 	adccs	r2, ip, r3, lsl #6
    9130:	000c750b 	andeq	r7, ip, fp, lsl #10
    9134:	3da30300 	stccc	3, cr0, [r3]
    9138:	00000053 	andeq	r0, r0, r3, asr r0
    913c:	20b02303 	adcscs	r2, r0, r3, lsl #6
    9140:	000c7b0b 	andeq	r7, ip, fp, lsl #22
    9144:	3da40300 	stccc	3, cr0, [r4]
    9148:	00000053 	andeq	r0, r0, r3, asr r0
    914c:	20b42303 	adcscs	r2, r4, r3, lsl #6
    9150:	000c810b 	andeq	r8, ip, fp, lsl #2
    9154:	3da50300 	stccc	3, cr0, [r5]
    9158:	00000053 	andeq	r0, r0, r3, asr r0
    915c:	20b82303 	adcscs	r2, r8, r3, lsl #6
    9160:	000c870b 	andeq	r8, ip, fp, lsl #14
    9164:	3da60300 	stccc	3, cr0, [r6]
    9168:	00000053 	andeq	r0, r0, r3, asr r0
    916c:	20bc2303 	adcscs	r2, ip, r3, lsl #6
    9170:	000c8d0b 	andeq	r8, ip, fp, lsl #26
    9174:	3da70300 	stccc	3, cr0, [r7]
    9178:	00000053 	andeq	r0, r0, r3, asr r0
    917c:	20c02303 	sbccs	r2, r0, r3, lsl #6
    9180:	000fec0b 	andeq	lr, pc, fp, lsl #24
    9184:	3da80300 	stccc	3, cr0, [r8]
    9188:	00000053 	andeq	r0, r0, r3, asr r0
    918c:	20c42303 	sbccs	r2, r4, r3, lsl #6
    9190:	000ff40b 	andeq	pc, pc, fp, lsl #8
    9194:	3da90300 	stccc	3, cr0, [r9]
    9198:	00000053 	andeq	r0, r0, r3, asr r0
    919c:	20c82303 	sbccs	r2, r8, r3, lsl #6
    91a0:	000f290b 	andeq	r2, pc, fp, lsl #18
    91a4:	3daa0300 	stccc	3, cr0, [sl]
    91a8:	00000053 	andeq	r0, r0, r3, asr r0
    91ac:	20cc2303 	sbccs	r2, ip, r3, lsl #6
    91b0:	000f2f0b 	andeq	r2, pc, fp, lsl #30
    91b4:	3dab0300 	stccc	3, cr0, [fp]
    91b8:	00000053 	andeq	r0, r0, r3, asr r0
    91bc:	20d02303 	sbcscs	r2, r0, r3, lsl #6
    91c0:	000bcb0b 	andeq	ip, fp, fp, lsl #22
    91c4:	3dac0300 	stccc	3, cr0, [ip]
    91c8:	00000053 	andeq	r0, r0, r3, asr r0
    91cc:	20d42303 	sbcscs	r2, r4, r3, lsl #6
    91d0:	000e090b 	andeq	r0, lr, fp, lsl #18
    91d4:	3dad0300 	stccc	3, cr0, [sp]
    91d8:	00000053 	andeq	r0, r0, r3, asr r0
    91dc:	20d82303 	sbcscs	r2, r8, r3, lsl #6
    91e0:	000e0f0b 	andeq	r0, lr, fp, lsl #30
    91e4:	3dae0300 	stccc	3, cr0, [lr]
    91e8:	00000053 	andeq	r0, r0, r3, asr r0
    91ec:	20dc2303 	sbcscs	r2, ip, r3, lsl #6
    91f0:	000bd00b 	andeq	sp, fp, fp
    91f4:	3daf0300 	stccc	3, cr0, [pc]	; 91fc <__etext+0x554>
    91f8:	00000053 	andeq	r0, r0, r3, asr r0
    91fc:	20e02303 	rsccs	r2, r0, r3, lsl #6
    9200:	0003310b 	andeq	r3, r3, fp, lsl #2
    9204:	3db00300 	ldccc	3, cr0, [r0]
    9208:	000003c7 	andeq	r0, r0, r7, asr #7
    920c:	20e42303 	rsccs	r2, r4, r3, lsl #6
    9210:	000e9f0b 	andeq	r9, lr, fp, lsl #30
    9214:	3db10300 	ldccc	3, cr0, [r1]
    9218:	00000053 	andeq	r0, r0, r3, asr r0
    921c:	20e82303 	rsccs	r2, r8, r3, lsl #6
    9220:	52434d0a 	subpl	r4, r3, #640	; 0x280
    9224:	3db20300 	ldccc	3, cr0, [r2]
    9228:	00000053 	andeq	r0, r0, r3, asr r0
    922c:	20ec2303 	rsccs	r2, ip, r3, lsl #6
    9230:	002c0700 	eoreq	r0, ip, r0, lsl #14
    9234:	06c80000 	strbeq	r0, [r8], r0
    9238:	b0100000 	andslt	r0, r0, r0
    923c:	fb000003 	blx	9252 <__etext+0x5aa>
    9240:	470c000f 	strmi	r0, [ip, -pc]
    9244:	0300000f 	movweq	r0, #15
    9248:	06d43db3 			; <UNDEFINED> instruction: 0x06d43db3
    924c:	040d0000 	streq	r0, [sp], #-0
    9250:	000006da 	ldrdeq	r0, [r0], -sl
    9254:	0004db0e 	andeq	sp, r4, lr, lsl #22
    9258:	03081100 	movweq	r1, #33024	; 0x8100
    925c:	07014024 	streq	r4, [r1, -r4, lsr #32]
    9260:	65120000 	ldrvs	r0, [r2, #-0]
    9264:	0300002c 	movweq	r0, #44	; 0x2c
    9268:	03a04025 	moveq	r4, #37	; 0x25
    926c:	db120000 	blle	489274 <__etext+0x4805cc>
    9270:	03000027 	movweq	r0, #39	; 0x27
    9274:	04174026 	ldreq	r4, [r7], #-38	; 0x26
    9278:	11000000 	mrsne	r0, (UNDEF: 0)
    927c:	402b0304 	eormi	r0, fp, r4, lsl #6
    9280:	00000723 	andeq	r0, r0, r3, lsr #14
    9284:	002bee12 	eoreq	lr, fp, r2, lsl lr
    9288:	402c0300 	eormi	r0, ip, r0, lsl #6
    928c:	00000053 	andeq	r0, r0, r3, asr r0
    9290:	002b9612 	eoreq	r9, fp, r2, lsl r6
    9294:	402d0300 	eormi	r0, sp, r0, lsl #6
    9298:	00000053 	andeq	r0, r0, r3, asr r0
    929c:	2b120900 	blcs	48b6a4 <__etext+0x4829fc>
    92a0:	038c0000 	orreq	r0, ip, #0
    92a4:	08334020 	ldmdaeq	r3!, {r5, lr}
    92a8:	4d0a0000 	stcmi	0, cr0, [sl, #-0]
    92ac:	03005243 	movweq	r5, #579	; 0x243
    92b0:	00534021 	subseq	r4, r3, r1, lsr #32
    92b4:	23020000 	movwcs	r0, #8192	; 0x2000
    92b8:	03120b00 	tsteq	r2, #0
    92bc:	22030000 	andcs	r0, r3, #0
    92c0:	0003c740 	andeq	ip, r3, r0, asr #14
    92c4:	04230200 	strteq	r0, [r3], #-512	; 0x200
    92c8:	5243540a 	subpl	r5, r3, #167772160	; 0xa000000
    92cc:	40230300 	eormi	r0, r3, r0, lsl #6
    92d0:	00000053 	andeq	r0, r0, r3, asr r0
    92d4:	13082302 	movwne	r2, #33538	; 0x8302
    92d8:	000006df 	ldrdeq	r0, [r0], -pc	; <UNPREDICTABLE>
    92dc:	0b0c2302 	bleq	311eec <__etext+0x309244>
    92e0:	0000031d 	andeq	r0, r0, sp, lsl r3
    92e4:	f7402803 			; <UNDEFINED> instruction: 0xf7402803
    92e8:	02000003 	andeq	r0, r0, #3
    92ec:	530a1423 	movwpl	r1, #42019	; 0xa423
    92f0:	29030052 	stmdbcs	r3, {r1, r4, r6}
    92f4:	00005340 	andeq	r5, r0, r0, asr #6
    92f8:	2c230200 	sfmcs	f0, 4, [r3], #-0
    92fc:	0029ec0b 	eoreq	lr, r9, fp, lsl #24
    9300:	402a0300 	eormi	r0, sl, r0, lsl #6
    9304:	00000053 	andeq	r0, r0, r3, asr r0
    9308:	13302302 	teqne	r0, #134217728	; 0x8000000
    930c:	00000701 	andeq	r0, r0, r1, lsl #14
    9310:	0b342302 	bleq	d11f20 <__etext+0xd09278>
    9314:	000029d2 	ldrdeq	r2, [r0], -r2	; <UNPREDICTABLE>
    9318:	53402f03 	movtpl	r2, #3843	; 0xf03
    931c:	02000000 	andeq	r0, r0, #0
    9320:	d10b3823 	tstle	fp, r3, lsr #16
    9324:	0300002a 	movweq	r0, #42	; 0x2a
    9328:	00534030 	subseq	r4, r3, r0, lsr r0
    932c:	23020000 	movwcs	r0, #8192	; 0x2000
    9330:	29370b3c 	ldmdbcs	r7!, {r2, r3, r4, r5, r8, r9, fp}
    9334:	31030000 	mrscc	r0, (UNDEF: 3)
    9338:	00005340 	andeq	r5, r0, r0, asr #6
    933c:	40230200 	eormi	r0, r3, r0, lsl #4
    9340:	00293d0b 	eoreq	r3, r9, fp, lsl #26
    9344:	40320300 	eorsmi	r0, r2, r0, lsl #6
    9348:	00000053 	andeq	r0, r0, r3, asr r0
    934c:	0b442302 	bleq	1111f5c <__etext+0x11092b4>
    9350:	00002ad7 	ldrdeq	r2, [r0], -r7
    9354:	53403303 	movtpl	r3, #771	; 0x303
    9358:	02000000 	andeq	r0, r0, #0
    935c:	9a0b4823 	bls	2db3f0 <__etext+0x2d2748>
    9360:	0300000a 	movweq	r0, #10
    9364:	03e74034 	mvneq	r4, #52	; 0x34
    9368:	23020000 	movwcs	r0, #8192	; 0x2000
    936c:	29690b4c 	stmdbcs	r9!, {r2, r3, r6, r8, r9, fp}^
    9370:	35030000 	strcc	r0, [r3, #-0]
    9374:	00005340 	andeq	r5, r0, r0, asr #6
    9378:	7c230200 	sfmvc	f0, 4, [r3], #-0
    937c:	0029a90b 	eoreq	sl, r9, fp, lsl #18
    9380:	40360300 	eorsmi	r0, r6, r0, lsl #6
    9384:	00000053 	andeq	r0, r0, r3, asr r0
    9388:	01802303 	orreq	r2, r0, r3, lsl #6
    938c:	0029af0b 	eoreq	sl, r9, fp, lsl #30
    9390:	40370300 	eorsmi	r0, r7, r0, lsl #6
    9394:	00000053 	andeq	r0, r0, r3, asr r0
    9398:	01842303 	orreq	r2, r4, r3, lsl #6
    939c:	00296f0b 	eoreq	r6, r9, fp, lsl #30
    93a0:	40380300 	eorsmi	r0, r8, r0, lsl #6
    93a4:	00000053 	andeq	r0, r0, r3, asr r0
    93a8:	01882303 	orreq	r2, r8, r3, lsl #6
    93ac:	2b880c00 	blcs	fe20c3b4 <__StackLimit+0xde20c3b4>
    93b0:	39030000 	stmdbcc	r3, {}	; <UNPREDICTABLE>
    93b4:	00083f40 	andeq	r3, r8, r0, asr #30
    93b8:	45040d00 	strmi	r0, [r4, #-3328]	; 0xd00
    93bc:	0e000008 	cdpeq	0, 0, cr0, cr0, cr8, {0}
    93c0:	00000723 	andeq	r0, r0, r3, lsr #14
    93c4:	00048303 	andeq	r8, r4, r3, lsl #6
    93c8:	371b0400 	ldrcc	r0, [fp, -r0, lsl #8]
    93cc:	02000000 	andeq	r0, r0, #0
    93d0:	06690404 	strbteq	r0, [r9], -r4, lsl #8
    93d4:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
    93d8:	000a8704 	andeq	r8, sl, r4, lsl #14
    93dc:	0dc80300 	stcleq	3, cr0, [r8]
    93e0:	2e040000 	cdpcs	0, 0, cr0, cr4, cr0, {0}
    93e4:	00000037 	andeq	r0, r0, r7, lsr r0
    93e8:	000f3514 	andeq	r3, pc, r4, lsl r5	; <UNPREDICTABLE>
    93ec:	0f050100 	svceq	0x00050100
    93f0:	00000b05 	andeq	r0, r0, r5, lsl #22
    93f4:	000cc206 	andeq	ip, ip, r6, lsl #4
    93f8:	c7060000 	strgt	r0, [r6, -r0]
    93fc:	0100000c 	tsteq	r0, ip
    9400:	000ccc06 	andeq	ip, ip, r6, lsl #24
    9404:	d1060200 	mrsle	r0, LR_usr
    9408:	0300000c 	movweq	r0, #12
    940c:	000cd606 	andeq	sp, ip, r6, lsl #12
    9410:	db060400 	blle	18a418 <__etext+0x181770>
    9414:	0500000c 	streq	r0, [r0, #-12]
    9418:	000ce006 	andeq	lr, ip, r6
    941c:	e5060600 	str	r0, [r6, #-1536]	; 0x600
    9420:	0700000c 	streq	r0, [r0, -ip]
    9424:	000cea06 	andeq	lr, ip, r6, lsl #20
    9428:	ef060800 	svc	0x00060800
    942c:	0900000c 	stmdbeq	r0, {r2, r3}
    9430:	000e5f06 	andeq	r5, lr, r6, lsl #30
    9434:	65060a00 	strvs	r0, [r6, #-2560]	; 0xa00
    9438:	0b00000e 	bleq	9478 <__etext+0x7d0>
    943c:	000e6b06 	andeq	r6, lr, r6, lsl #22
    9440:	71060c00 	tstvc	r6, r0, lsl #24
    9444:	0d00000e 	stceq	0, cr0, [r0, #-56]	; 0xffffffc8
    9448:	000e7706 	andeq	r7, lr, r6, lsl #14
    944c:	7d060e00 	stcvc	14, cr0, [r6, #-0]
    9450:	0f00000e 	svceq	0x0000000e
    9454:	000e8306 	andeq	r8, lr, r6, lsl #6
    9458:	89061000 	stmdbhi	r6, {ip}
    945c:	1100000e 	tstne	r0, lr
    9460:	000e8f06 	andeq	r8, lr, r6, lsl #30
    9464:	7d061200 	sfmvc	f1, 4, [r6, #-0]
    9468:	1300000b 	movwne	r0, #11
    946c:	000efa06 	andeq	pc, lr, r6, lsl #20
    9470:	00061800 	andeq	r1, r6, r0, lsl #16
    9474:	1900000f 	stmdbne	r0, {r0, r1, r2, r3}
    9478:	000f0606 	andeq	r0, pc, r6, lsl #12
    947c:	0c061a00 	stceq	10, cr1, [r6], {-0}
    9480:	1b00000f 	blne	94c4 <__etext+0x81c>
    9484:	000f1206 	andeq	r1, pc, r6, lsl #4
    9488:	18061c00 	stmdane	r6, {sl, fp, ip}
    948c:	1d00000f 	stcne	0, cr0, [r0, #-60]	; 0xffffffc4
    9490:	000d5906 	andeq	r5, sp, r6, lsl #18
    9494:	5e062000 	cdppl	0, 0, cr2, cr6, cr0, {0}
    9498:	2100000d 	tstcs	r0, sp
    949c:	000d6306 	andeq	r6, sp, r6, lsl #6
    94a0:	68062200 	stmdavs	r6, {r9, sp}
    94a4:	2300000d 	movwcs	r0, #13
    94a8:	000d6d06 	andeq	r6, sp, r6, lsl #26
    94ac:	72062400 	andvc	r2, r6, #0
    94b0:	2500000d 	strcs	r0, [r0, #-13]
    94b4:	000d7706 	andeq	r7, sp, r6, lsl #14
    94b8:	7c062600 	stcvc	6, cr2, [r6], {-0}
    94bc:	2700000d 	strcs	r0, [r0, -sp]
    94c0:	000d8106 	andeq	r8, sp, r6, lsl #2
    94c4:	86062800 	strhi	r2, [r6], -r0, lsl #16
    94c8:	2900000d 	stmdbcs	r0, {r0, r2, r3}
    94cc:	0010bb06 	andseq	fp, r0, r6, lsl #22
    94d0:	c1062a00 	tstgt	r6, r0, lsl #20
    94d4:	2b000010 	blcs	951c <__etext+0x874>
    94d8:	0010c706 	andseq	ip, r0, r6, lsl #14
    94dc:	cd063000 	stcgt	0, cr3, [r6, #-0]
    94e0:	31000010 	tstcc	r0, r0, lsl r0
    94e4:	0010d306 	andseq	sp, r0, r6, lsl #6
    94e8:	d9063200 	stmdble	r6, {r9, ip, sp}
    94ec:	33000010 	movwcc	r0, #16
    94f0:	000b8306 	andeq	r8, fp, r6, lsl #6
    94f4:	89063400 	stmdbhi	r6, {sl, ip, sp}
    94f8:	3500000b 	strcc	r0, [r0, #-11]
    94fc:	000b8f06 	andeq	r8, fp, r6, lsl #30
    9500:	95063600 	strls	r3, [r6, #-1536]	; 0x600
    9504:	3700000b 	strcc	r0, [r0, -fp]
    9508:	000dd006 	andeq	sp, sp, r6
    950c:	d5063c00 	strle	r3, [r6, #-3072]	; 0xc00
    9510:	3d00000d 	stccc	0, cr0, [r0, #-52]	; 0xffffffcc
    9514:	000dda06 	andeq	sp, sp, r6, lsl #20
    9518:	df063e00 	svcle	0x00063e00
    951c:	3f00000d 	svccc	0x0000000d
    9520:	000de406 	andeq	lr, sp, r6, lsl #8
    9524:	0600c000 	streq	ip, [r0], -r0
    9528:	00000de9 	andeq	r0, r0, r9, ror #27
    952c:	ee0600c1 	cdp	0, 0, cr0, cr6, cr1, {6}
    9530:	c200000d 	andgt	r0, r0, #13
    9534:	0df30600 	ldcleq	6, cr0, [r3]
    9538:	00c30000 	sbceq	r0, r3, r0
    953c:	000e5a06 	andeq	r5, lr, r6, lsl #20
    9540:	0600c400 	streq	ip, [r0], -r0, lsl #8
    9544:	00000df8 	strdeq	r0, [r0], -r8
    9548:	0b0600c5 	bleq	189864 <__etext+0x180bbc>
    954c:	c600000d 	strgt	r0, [r0], -sp
    9550:	0d110600 	ldceq	6, cr0, [r1, #-0]
    9554:	00c70000 	sbceq	r0, r7, r0
    9558:	000d1706 	andeq	r1, sp, r6, lsl #14
    955c:	0600c800 	streq	ip, [r0], -r0, lsl #16
    9560:	00000d1d 	andeq	r0, r0, sp, lsl sp
    9564:	e90600c9 	stmdb	r6, {r0, r3, r6, r7}
    9568:	ca00000e 	bgt	95a8 <__etext+0x900>
    956c:	0eef0600 	cdpeq	6, 14, cr0, cr15, cr0, {0}
    9570:	00cb0000 	sbceq	r0, fp, r0
    9574:	000d4106 	andeq	r4, sp, r6, lsl #2
    9578:	0600cc00 	streq	ip, [r0], -r0, lsl #24
    957c:	00000d47 	andeq	r0, r0, r7, asr #26
    9580:	4d0600cd 	stcmi	0, cr0, [r6, #-820]	; 0xfffffccc
    9584:	ce00000d 	cdpgt	0, 0, cr0, cr0, cr13, {0}
    9588:	0d530600 	ldcleq	6, cr0, [r3, #-0]
    958c:	00cf0000 	sbceq	r0, pc, r0
    9590:	000e1506 	andeq	r1, lr, r6, lsl #10
    9594:	0600dc00 	streq	sp, [r0], -r0, lsl #24
    9598:	00000e1a 	andeq	r0, r0, sl, lsl lr
    959c:	1f0600dd 	svcne	0x000600dd
    95a0:	de00000e 	cdple	0, 0, cr0, cr0, cr14, {0}
    95a4:	0e240600 	cfmadda32eq	mvax0, mvax0, mvfx4, mvfx0
    95a8:	00df0000 	sbcseq	r0, pc, r0
    95ac:	000e2906 	andeq	r2, lr, r6, lsl #18
    95b0:	0600e000 	streq	lr, [r0], -r0
    95b4:	00000e2e 	andeq	r0, r0, lr, lsr #28
    95b8:	330600e1 	movwcc	r0, #24801	; 0x60e1
    95bc:	e200000e 	and	r0, r0, #14
    95c0:	0e380600 	cfmsuba32eq	mvax0, mvax0, mvfx8, mvfx0
    95c4:	00e30000 	rsceq	r0, r3, r0
    95c8:	000e3d06 	andeq	r3, lr, r6, lsl #26
    95cc:	0600e400 	streq	lr, [r0], -r0, lsl #8
    95d0:	00000e42 	andeq	r0, r0, r2, asr #28
    95d4:	7f0600e5 	svcvc	0x000600e5
    95d8:	e600000f 	str	r0, [r0], -pc
    95dc:	0f850600 	svceq	0x00850600
    95e0:	00e70000 	rsceq	r0, r7, r0
    95e4:	000f8b06 	andeq	r8, pc, r6, lsl #22
    95e8:	0600e800 	streq	lr, [r0], -r0, lsl #16
    95ec:	00000f91 	muleq	r0, r1, pc	; <UNPREDICTABLE>
    95f0:	930600e9 	movwls	r0, #24809	; 0x60e9
    95f4:	ea00000d 	b	9630 <__etext+0x988>
    95f8:	0d990600 	ldceq	6, cr0, [r9]
    95fc:	00eb0000 	rsceq	r0, fp, r0
    9600:	000ea706 	andeq	sl, lr, r6, lsl #14
    9604:	0600fc00 	streq	pc, [r0], -r0, lsl #24
    9608:	00000eac 	andeq	r0, r0, ip, lsr #29
    960c:	b10600fd 	strdlt	r0, [r6, -sp]
    9610:	fe00000e 	cdp2	0, 0, cr0, cr0, cr14, {0}
    9614:	0eb60600 	cdpeq	6, 11, cr0, cr6, cr0, {0}
    9618:	00ff0000 	rscseq	r0, pc, r0
    961c:	000ebb06 	andeq	fp, lr, r6, lsl #22
    9620:	06018000 	streq	r8, [r1], -r0
    9624:	00000ec0 	andeq	r0, r0, r0, asr #29
    9628:	c5060181 	strgt	r0, [r6, #-385]	; 0x181
    962c:	8200000e 	andhi	r0, r0, #14
    9630:	0eca0601 	cdpeq	6, 12, cr0, cr10, cr1, {0}
    9634:	01830000 	orreq	r0, r3, r0
    9638:	000ecf06 	andeq	ip, lr, r6, lsl #30
    963c:	06018400 	streq	r8, [r1], -r0, lsl #8
    9640:	00000ed4 	ldrdeq	r0, [r0], -r4
    9644:	dc060185 	stfles	f0, [r6], {133}	; 0x85
    9648:	8600000b 	strhi	r0, [r0], -fp
    964c:	0be20601 	bleq	ff88ae58 <__StackLimit+0xdf88ae58>
    9650:	01870000 	orreq	r0, r7, r0
    9654:	000c3906 	andeq	r3, ip, r6, lsl #18
    9658:	06018800 	streq	r8, [r1], -r0, lsl #16
    965c:	00000cfc 	strdeq	r0, [r0], -ip
    9660:	3f060194 	svccc	0x00060194
    9664:	9500000c 	strls	r0, [r0, #-12]
    9668:	0c450601 	mcrreq	6, 0, r0, r5, cr1
    966c:	01960000 	orrseq	r0, r6, r0
    9670:	000c4b06 	andeq	r4, ip, r6, lsl #22
    9674:	06019700 	streq	r9, [r1], -r0, lsl #14
    9678:	00000c51 	andeq	r0, r0, r1, asr ip
    967c:	03000198 	movweq	r0, #408	; 0x198
    9680:	00001067 	andeq	r1, r0, r7, rrx
    9684:	086e4505 	stmdaeq	lr!, {r0, r2, r8, sl, lr}^
    9688:	040d0000 	streq	r0, [sp], #-0
    968c:	00000b16 	andeq	r0, r0, r6, lsl fp
    9690:	01020115 	tsteq	r2, r5, lsl r1
    9694:	00071208 	andeq	r1, r7, r8, lsl #4
    9698:	2cd90300 	ldclcs	3, cr0, [r9], {0}
    969c:	20060000 	andcs	r0, r6, r0
    96a0:	00000b10 	andeq	r0, r0, r0, lsl fp
    96a4:	4c063416 	cfstrsmi	mvf3, [r6], {22}
    96a8:	00000cc9 	andeq	r0, r0, r9, asr #25
    96ac:	002c9d17 	eoreq	r9, ip, r7, lsl sp
    96b0:	33580600 	cmpcc	r8, #0
    96b4:	02000008 	andeq	r0, r0, #8
    96b8:	df170023 	svcle	0x00170023
    96bc:	0600002b 	streq	r0, [r0], -fp, lsr #32
    96c0:	00084a63 	andeq	r4, r8, r3, ror #20
    96c4:	04230200 	strteq	r0, [r3], #-512	; 0x200
    96c8:	002c2017 	eoreq	r2, ip, r7, lsl r0
    96cc:	4a7d0600 	bmi	1f4aed4 <__etext+0x1f4222c>
    96d0:	02000008 	andeq	r0, r0, #8
    96d4:	98170523 	ldmdals	r7, {r0, r1, r5, r8, sl}
    96d8:	06000029 	streq	r0, [r0], -r9, lsr #32
    96dc:	00086388 	andeq	r6, r8, r8, lsl #7
    96e0:	06230200 	strteq	r0, [r3], -r0, lsl #4
    96e4:	0028bf17 	eoreq	fp, r8, r7, lsl pc
    96e8:	63930600 	orrsvs	r0, r3, #0
    96ec:	02000008 	andeq	r0, r0, #8
    96f0:	08170723 	ldmdaeq	r7, {r0, r1, r5, r8, r9, sl}
    96f4:	0600002c 	streq	r0, [r0], -ip, lsr #32
    96f8:	0008639e 	muleq	r8, lr, r3
    96fc:	08230200 	stmdaeq	r3!, {r9}
    9700:	002c3f17 	eoreq	r3, ip, r7, lsl pc
    9704:	63a90600 			; <UNDEFINED> instruction: 0x63a90600
    9708:	02000008 	andeq	r0, r0, #8
    970c:	d0170923 	andsle	r0, r7, r3, lsr #18
    9710:	06000028 	streq	r0, [r0], -r8, lsr #32
    9714:	000863b4 			; <UNDEFINED> instruction: 0x000863b4
    9718:	0a230200 	beq	8c9f20 <__etext+0x8c1278>
    971c:	0029b517 	eoreq	fp, r9, r7, lsl r5
    9720:	63bf0600 			; <UNDEFINED> instruction: 0x63bf0600
    9724:	02000008 	andeq	r0, r0, #8
    9728:	29170b23 	ldmdbcs	r7, {r0, r1, r5, r8, r9, fp}
    972c:	0600002a 	streq	r0, [r0], -sl, lsr #32
    9730:	000863ca 	andeq	r6, r8, sl, asr #7
    9734:	0c230200 	sfmeq	f0, 4, [r3], #-0
    9738:	0028ee17 	eoreq	lr, r8, r7, lsl lr
    973c:	63d50600 	bicsvs	r0, r5, #0
    9740:	02000008 	andeq	r0, r0, #8
    9744:	dd170d23 	ldcle	13, cr0, [r7, #-140]	; 0xffffff74
    9748:	0600002a 	streq	r0, [r0], -sl, lsr #32
    974c:	000863e0 	andeq	r6, r8, r0, ror #7
    9750:	0e230200 	cdpeq	2, 2, cr0, cr3, cr0, {0}
    9754:	002cc017 	eoreq	ip, ip, r7, lsl r0
    9758:	63eb0600 	mvnvs	r0, #0
    975c:	02000008 	andeq	r0, r0, #8
    9760:	bd170f23 	ldclt	15, cr0, [r7, #-140]	; 0xffffff74
    9764:	0600002b 	streq	r0, [r0], -fp, lsr #32
    9768:	000b05f7 	strdeq	r0, [fp], -r7
    976c:	10230200 	eorne	r0, r3, r0, lsl #4
    9770:	0029e00b 	eoreq	lr, r9, fp
    9774:	01030600 	tsteq	r3, r0, lsl #12
    9778:	00000b05 	andeq	r0, r0, r5, lsl #22
    977c:	0b112302 	bleq	45238c <__etext+0x4496e4>
    9780:	00002a87 	andeq	r2, r0, r7, lsl #21
    9784:	05010e06 	streq	r0, [r1, #-3590]	; 0xe06
    9788:	0200000b 	andeq	r0, r0, #11
    978c:	050b1223 	streq	r1, [fp, #-547]	; 0x223
    9790:	06000028 	streq	r0, [r0], -r8, lsr #32
    9794:	0b050119 	bleq	149c00 <__etext+0x140f58>
    9798:	23020000 	movwcs	r0, #8192	; 0x2000
    979c:	285e0b13 	ldmdacs	lr, {r0, r1, r4, r8, r9, fp}^
    97a0:	23060000 	movwcs	r0, #24576	; 0x6000
    97a4:	000b0501 	andeq	r0, fp, r1, lsl #10
    97a8:	14230200 	strtne	r0, [r3], #-512	; 0x200
    97ac:	002b260b 	eoreq	r2, fp, fp, lsl #12
    97b0:	012d0600 	teqeq	sp, r0, lsl #12
    97b4:	00000b05 	andeq	r0, r0, r5, lsl #22
    97b8:	0b152302 	bleq	5523c8 <__etext+0x549720>
    97bc:	00002a7c 	andeq	r2, r0, ip, ror sl
    97c0:	05013906 	streq	r3, [r1, #-2310]	; 0x906
    97c4:	0200000b 	andeq	r0, r0, #11
    97c8:	2b0b1623 	blcs	2cf05c <__etext+0x2c63b4>
    97cc:	06000029 	streq	r0, [r0], -r9, lsr #32
    97d0:	0b050145 	bleq	149cec <__etext+0x141044>
    97d4:	23020000 	movwcs	r0, #8192	; 0x2000
    97d8:	28440b17 	stmdacs	r4, {r0, r1, r2, r4, r8, r9, fp}^
    97dc:	51060000 	mrspl	r0, (UNDEF: 6)
    97e0:	000b0501 	andeq	r0, fp, r1, lsl #10
    97e4:	18230200 	stmdane	r3!, {r9}
    97e8:	0029080b 	eoreq	r0, r9, fp, lsl #16
    97ec:	015b0600 	cmpeq	fp, r0, lsl #12
    97f0:	00000b1f 	andeq	r0, r0, pc, lsl fp
    97f4:	0b1c2302 	bleq	712404 <__etext+0x70975c>
    97f8:	00002a4a 	andeq	r2, r0, sl, asr #20
    97fc:	1f016506 	svcne	0x00016506
    9800:	0200000b 	andeq	r0, r0, #11
    9804:	a10b2023 	tstge	fp, r3, lsr #32
    9808:	0600002a 	streq	r0, [r0], -sl, lsr #32
    980c:	0b1f016f 	bleq	7c9dd0 <__etext+0x7c1128>
    9810:	23020000 	movwcs	r0, #8192	; 0x2000
    9814:	2c6a0b24 	stclcs	11, cr0, [sl], #-144	; 0xffffff70
    9818:	79060000 	stmdbvc	r6, {}	; <UNPREDICTABLE>
    981c:	000b1f01 	andeq	r1, fp, r1, lsl #30
    9820:	28230200 	stmdacs	r3!, {r9}
    9824:	002a130b 	eoreq	r1, sl, fp, lsl #6
    9828:	01830600 	orreq	r0, r3, r0, lsl #12
    982c:	00000b1f 	andeq	r0, r0, pc, lsl fp
    9830:	0b2c2302 	bleq	b12440 <__etext+0xb09798>
    9834:	0000287f 	andeq	r2, r0, pc, ror r8
    9838:	1f018d06 	svcne	0x00018d06
    983c:	0200000b 	andeq	r0, r0, #11
    9840:	0c003023 	stceq	0, cr3, [r0], {35}	; 0x23
    9844:	00002b6c 	andeq	r2, r0, ip, ror #22
    9848:	2a018f06 	bcs	6d468 <__etext+0x647c0>
    984c:	1800000b 	stmdane	r0, {r0, r1, r3}
    9850:	002c8401 	eoreq	r8, ip, r1, lsl #8
    9854:	012c0100 	teqeq	ip, r0, lsl #2
    9858:	0000084a 	andeq	r0, r0, sl, asr #16
    985c:	000064c8 	andeq	r6, r0, r8, asr #9
    9860:	00006c72 	andeq	r6, r0, r2, ror ip
    9864:	00001b4a 	andeq	r1, r0, sl, asr #22
    9868:	000e8d01 	andeq	r8, lr, r1, lsl #26
    986c:	2aff1900 	bcs	fffcfc74 <__StackLimit+0xdffcfc74>
    9870:	2c010000 	stccs	0, cr0, [r1], {-0}
    9874:	00000cc9 	andeq	r0, r0, r9, asr #25
    9878:	1a709102 	bne	1c2dc88 <__etext+0x1c24fe0>
    987c:	00002926 	andeq	r2, r0, r6, lsr #18
    9880:	08332e01 	ldmdaeq	r3!, {r0, r9, sl, fp, sp}
    9884:	91020000 	mrsls	r0, (UNDEF: 2)
    9888:	2b1d1a64 	blcs	750220 <__etext+0x747578>
    988c:	2f010000 	svccs	0x00010000
    9890:	0000084a 	andeq	r0, r0, sl, asr #16
    9894:	1a639102 	bne	18edca4 <__etext+0x18e4ffc>
    9898:	00002b52 	andeq	r2, r0, r2, asr fp
    989c:	084a3001 	stmdaeq	sl, {r0, ip, sp}^
    98a0:	91020000 	mrsls	r0, (UNDEF: 2)
    98a4:	2a931a62 	bcs	fe4d0234 <__StackLimit+0xde4d0234>
    98a8:	31010000 	mrscc	r0, (UNDEF: 1)
    98ac:	00000863 	andeq	r0, r0, r3, ror #16
    98b0:	1a619102 	bne	186dcc0 <__etext+0x1865018>
    98b4:	00002a5d 	andeq	r2, r0, sp, asr sl
    98b8:	08633201 	stmdaeq	r3!, {r0, r9, ip, sp}^
    98bc:	91020000 	mrsls	r0, (UNDEF: 2)
    98c0:	29881a60 	stmibcs	r8, {r5, r6, r9, fp, ip}
    98c4:	34010000 	strcc	r0, [r1], #-0
    98c8:	00000863 	andeq	r0, r0, r3, ror #16
    98cc:	1a5f9102 	bne	17edcdc <__etext+0x17e5034>
    98d0:	0000286a 	andeq	r2, r0, sl, ror #16
    98d4:	08633501 	stmdaeq	r3!, {r0, r8, sl, ip, sp}^
    98d8:	91020000 	mrsls	r0, (UNDEF: 2)
    98dc:	2abc1a5e 	bcs	fef1025c <__StackLimit+0xdef1025c>
    98e0:	36010000 	strcc	r0, [r1], -r0
    98e4:	00000863 	andeq	r0, r0, r3, ror #16
    98e8:	1a5d9102 	bne	176dcf8 <__etext+0x1765050>
    98ec:	00002896 	muleq	r0, r6, r8
    98f0:	08633701 	stmdaeq	r3!, {r0, r8, r9, sl, ip, sp}^
    98f4:	91020000 	mrsls	r0, (UNDEF: 2)
    98f8:	2b321a5c 	blcs	c90270 <__etext+0xc875c8>
    98fc:	38010000 	stmdacc	r1, {}	; <UNPREDICTABLE>
    9900:	00000863 	andeq	r0, r0, r3, ror #16
    9904:	1a5b9102 	bne	16edd14 <__etext+0x16e506c>
    9908:	00002a6b 	andeq	r2, r0, fp, ror #20
    990c:	08633901 	stmdaeq	r3!, {r0, r8, fp, ip, sp}^
    9910:	91020000 	mrsls	r0, (UNDEF: 2)
    9914:	2c921a5a 	vldmiacs	r2, {s2-s91}
    9918:	3a010000 	bcc	49920 <__etext+0x40c78>
    991c:	00000863 	andeq	r0, r0, r3, ror #16
    9920:	1a599102 	bne	166dd30 <__etext+0x1665088>
    9924:	00002cb5 			; <UNDEFINED> instruction: 0x00002cb5
    9928:	08633b01 	stmdaeq	r3!, {r0, r8, r9, fp, ip, sp}^
    992c:	91020000 	mrsls	r0, (UNDEF: 2)
    9930:	2b5a1a58 	blcs	1690298 <__etext+0x16875f0>
    9934:	3d010000 	stccc	0, cr0, [r1, #-0]
    9938:	00000b05 	andeq	r0, r0, r5, lsl #22
    993c:	1a579102 	bne	15edd4c <__etext+0x15e50a4>
    9940:	0000291d 	andeq	r2, r0, sp, lsl r9
    9944:	0b053e01 	bleq	159150 <__etext+0x1504a8>
    9948:	91020000 	mrsls	r0, (UNDEF: 2)
    994c:	2a421a56 	bcs	10902ac <__etext+0x1087604>
    9950:	3f010000 	svccc	0x00010000
    9954:	00000b05 	andeq	r0, r0, r5, lsl #22
    9958:	1a559102 	bne	156dd68 <__etext+0x15650c0>
    995c:	00002a01 	andeq	r2, r0, r1, lsl #20
    9960:	0b054001 	bleq	15996c <__etext+0x150cc4>
    9964:	91020000 	mrsls	r0, (UNDEF: 2)
    9968:	28551a54 	ldmdacs	r5, {r2, r4, r6, r9, fp, ip}^
    996c:	41010000 	mrsmi	r0, (UNDEF: 1)
    9970:	00000b05 	andeq	r0, r0, r5, lsl #22
    9974:	1a539102 	bne	14edd84 <__etext+0x14e50dc>
    9978:	00002b63 	andeq	r2, r0, r3, ror #22
    997c:	0b054201 	bleq	15a188 <__etext+0x1514e0>
    9980:	91020000 	mrsls	r0, (UNDEF: 2)
    9984:	29d71a52 	ldmibcs	r7, {r1, r4, r6, r9, fp, ip}^
    9988:	43010000 	movwmi	r0, #4096	; 0x1000
    998c:	00000b05 	andeq	r0, r0, r5, lsl #22
    9990:	1a519102 	bne	146dda0 <__etext+0x14650f8>
    9994:	0000282b 	andeq	r2, r0, fp, lsr #16
    9998:	0b054401 	bleq	15a9a4 <__etext+0x151cfc>
    999c:	91020000 	mrsls	r0, (UNDEF: 2)
    99a0:	2a0a1a50 	bcs	2902e8 <__etext+0x287640>
    99a4:	45010000 	strmi	r0, [r1, #-0]
    99a8:	00000b05 	andeq	r0, r0, r5, lsl #22
    99ac:	1a4f9102 	bne	13eddbc <__etext+0x13e5114>
    99b0:	00002ca6 	andeq	r2, r0, r6, lsr #25
    99b4:	0b1f4701 	bleq	7db5c0 <__etext+0x7d2918>
    99b8:	91020000 	mrsls	r0, (UNDEF: 2)
    99bc:	2b421a48 	blcs	10902e4 <__etext+0x108763c>
    99c0:	48010000 	stmdami	r1, {}	; <UNPREDICTABLE>
    99c4:	00000b1f 	andeq	r0, r0, pc, lsl fp
    99c8:	1a449102 	bne	112ddd8 <__etext+0x1125130>
    99cc:	00002bac 	andeq	r2, r0, ip, lsr #23
    99d0:	0b1f4901 	bleq	7dbddc <__etext+0x7d3134>
    99d4:	91020000 	mrsls	r0, (UNDEF: 2)
    99d8:	29f11a40 	ldmibcs	r1!, {r6, r9, fp, ip}^
    99dc:	4a010000 	bmi	499e4 <__etext+0x40d3c>
    99e0:	00000b1f 	andeq	r0, r0, pc, lsl fp
    99e4:	7fbc9103 	svcvc	0x00bc9103
    99e8:	002b7c1a 	eoreq	r7, fp, sl, lsl ip
    99ec:	1f4b0100 	svcne	0x004b0100
    99f0:	0300000b 	movweq	r0, #11
    99f4:	1a7fb891 	bne	1ff7c40 <__etext+0x1feef98>
    99f8:	00002943 	andeq	r2, r0, r3, asr #18
    99fc:	0b1f4c01 	bleq	7dca08 <__etext+0x7d3d60>
    9a00:	91030000 	mrsls	r0, (UNDEF: 3)
    9a04:	1b007fb4 	blne	298dc <__etext+0x20c34>
    9a08:	00295001 	eoreq	r5, r9, r1
    9a0c:	01d90100 	bicseq	r0, r9, r0, lsl #2
    9a10:	00084a01 	andeq	r4, r8, r1, lsl #20
    9a14:	006c7400 	rsbeq	r7, ip, r0, lsl #8
    9a18:	006d6e00 	rsbeq	r6, sp, r0, lsl #28
    9a1c:	001b9000 	andseq	r9, fp, r0
    9a20:	0ecb0100 	poleqe	f0, f3, f0
    9a24:	ff1c0000 			; <UNDEFINED> instruction: 0xff1c0000
    9a28:	0100002a 	tsteq	r0, sl, lsr #32
    9a2c:	0cc901d9 	stfeqe	f0, [r9], {217}	; 0xd9
    9a30:	91020000 	mrsls	r0, (UNDEF: 2)
    9a34:	29261d70 	stmdbcs	r6!, {r4, r5, r6, r8, sl, fp, ip}
    9a38:	db010000 	blle	49a40 <__etext+0x40d98>
    9a3c:	00083301 	andeq	r3, r8, r1, lsl #6
    9a40:	64910200 	ldrvs	r0, [r1], #512	; 0x200
    9a44:	75011b00 	strvc	r1, [r1, #-2816]	; 0xb00
    9a48:	01000029 	tsteq	r0, r9, lsr #32
    9a4c:	4a0101fd 	bmi	4a248 <__etext+0x415a0>
    9a50:	70000008 	andvc	r0, r0, r8
    9a54:	e600006d 	str	r0, [r0], -sp, rrx
    9a58:	d400006d 	strle	r0, [r0], #-109	; 0x6d
    9a5c:	0100001b 	tsteq	r0, fp, lsl r0
    9a60:	00000f09 	andeq	r0, r0, r9, lsl #30
    9a64:	002aff1c 	eoreq	pc, sl, ip, lsl pc	; <UNPREDICTABLE>
    9a68:	01fd0100 	mvnseq	r0, r0, lsl #2
    9a6c:	00000cc9 	andeq	r0, r0, r9, asr #25
    9a70:	1d709102 	ldfnep	f1, [r0, #-8]!
    9a74:	00002926 	andeq	r2, r0, r6, lsr #18
    9a78:	3301ff01 	movwcc	pc, #7937	; 0x1f01	; <UNPREDICTABLE>
    9a7c:	02000008 	andeq	r0, r0, #8
    9a80:	1b006491 	blne	22ccc <__etext+0x1a024>
    9a84:	002bf401 	eoreq	pc, fp, r1, lsl #8
    9a88:	021e0100 	andseq	r0, lr, #0
    9a8c:	00084a01 	andeq	r4, r8, r1, lsl #20
    9a90:	006de800 	rsbeq	lr, sp, r0, lsl #16
    9a94:	006e5e00 	rsbeq	r5, lr, r0, lsl #28
    9a98:	001c1800 	andseq	r1, ip, r0, lsl #16
    9a9c:	0f470100 	svceq	0x00470100
    9aa0:	ff1c0000 			; <UNDEFINED> instruction: 0xff1c0000
    9aa4:	0100002a 	tsteq	r0, sl, lsr #32
    9aa8:	0cc9021e 	sfmeq	f0, 2, [r9], {30}
    9aac:	91020000 	mrsls	r0, (UNDEF: 2)
    9ab0:	29261d70 	stmdbcs	r6!, {r4, r5, r6, r8, sl, fp, ip}
    9ab4:	20010000 	andcs	r0, r1, r0
    9ab8:	00083302 	andeq	r3, r8, r2, lsl #6
    9abc:	64910200 	ldrvs	r0, [r1], #512	; 0x200
    9ac0:	11011e00 	tstne	r1, r0, lsl #28
    9ac4:	01000028 	tsteq	r0, r8, lsr #32
    9ac8:	4a01024a 	bmi	4a3f8 <__etext+0x41750>
    9acc:	60000008 	andvs	r0, r0, r8
    9ad0:	cc00006e 	stcgt	0, cr0, [r0], {110}	; 0x6e
    9ad4:	5c00006e 	stcpl	0, cr0, [r0], {110}	; 0x6e
    9ad8:	0100001c 	tsteq	r0, ip, lsl r0
    9adc:	00000fb2 			; <UNDEFINED> instruction: 0x00000fb2
    9ae0:	0029261c 	eoreq	r2, r9, ip, lsl r6
    9ae4:	024a0100 	subeq	r0, sl, #0
    9ae8:	00000833 	andeq	r0, r0, r3, lsr r8
    9aec:	1c6c9102 	stfnep	f1, [ip], #-8
    9af0:	00000b22 	andeq	r0, r0, r2, lsr #22
    9af4:	4a024a01 	bmi	9c300 <__etext+0x93658>
    9af8:	02000008 	andeq	r0, r0, #8
    9afc:	501c6b91 	mulspl	ip, r1, fp
    9b00:	01000028 	tsteq	r0, r8, lsr #32
    9b04:	084a024a 	stmdaeq	sl, {r1, r3, r6, r9}^
    9b08:	91020000 	mrsls	r0, (UNDEF: 2)
    9b0c:	2ba21c6a 	blcs	fe890cbc <__StackLimit+0xde890cbc>
    9b10:	4a010000 	bmi	49b18 <__etext+0x40e70>
    9b14:	00084a02 	andeq	r4, r8, r2, lsl #20
    9b18:	69910200 	ldmibvs	r1, {r9}
    9b1c:	000f421d 	andeq	r4, pc, sp, lsl r2	; <UNPREDICTABLE>
    9b20:	024c0100 	subeq	r0, ip, #0
    9b24:	0000084a 	andeq	r0, r0, sl, asr #16
    9b28:	00779102 	rsbseq	r9, r7, r2, lsl #2
    9b2c:	28aa011e 	stmiacs	sl!, {r1, r2, r3, r4, r8}
    9b30:	69010000 	stmdbvs	r1, {}	; <UNPREDICTABLE>
    9b34:	084a0102 	stmdaeq	sl, {r1, r8}^
    9b38:	6ecc0000 	cdpvs	0, 12, cr0, cr12, cr0, {0}
    9b3c:	6f020000 	svcvs	0x00020000
    9b40:	1c940000 	ldcne	0, cr0, [r4], {0}
    9b44:	f0010000 			; <UNDEFINED> instruction: 0xf0010000
    9b48:	1c00000f 	stcne	0, cr0, [r0], {15}
    9b4c:	00002926 	andeq	r2, r0, r6, lsr #18
    9b50:	33026901 	movwcc	r6, #10497	; 0x2901
    9b54:	02000008 	andeq	r0, r0, #8
    9b58:	421d6c91 	andsmi	r6, sp, #37120	; 0x9100
    9b5c:	0100000f 	tsteq	r0, pc
    9b60:	084a026b 	stmdaeq	sl, {r0, r1, r3, r5, r6, r9}^
    9b64:	91020000 	mrsls	r0, (UNDEF: 2)
    9b68:	011f0077 	tsteq	pc, r7, ror r0	; <UNPREDICTABLE>
    9b6c:	00002bc9 	andeq	r2, r0, r9, asr #23
    9b70:	01028901 	tsteq	r2, r1, lsl #18
    9b74:	00006f04 	andeq	r6, r0, r4, lsl #30
    9b78:	00006f4c 	andeq	r6, r0, ip, asr #30
    9b7c:	00001ccc 	andeq	r1, r0, ip, asr #25
    9b80:	00104801 	andseq	r4, r0, r1, lsl #16
    9b84:	29261c00 	stmdbcs	r6!, {sl, fp, ip}
    9b88:	89010000 	stmdbhi	r1, {}	; <UNPREDICTABLE>
    9b8c:	00083302 	andeq	r3, r8, r2, lsl #6
    9b90:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    9b94:	000b221c 	andeq	r2, fp, ip, lsl r2
    9b98:	02890100 	addeq	r0, r9, #0
    9b9c:	0000084a 	andeq	r0, r0, sl, asr #16
    9ba0:	1c739102 	ldfnep	f1, [r3], #-8
    9ba4:	00002850 	andeq	r2, r0, r0, asr r8
    9ba8:	4a028901 	bmi	abfb4 <__etext+0xa330c>
    9bac:	02000008 	andeq	r0, r0, #8
    9bb0:	a21c7291 	andsge	r7, ip, #268435465	; 0x10000009
    9bb4:	0100002b 	tsteq	r0, fp, lsr #32
    9bb8:	084a0289 	stmdaeq	sl, {r0, r3, r7, r9}^
    9bbc:	91020000 	mrsls	r0, (UNDEF: 2)
    9bc0:	01200071 	teqeq	r0, r1, ror r0
    9bc4:	00002834 	andeq	r2, r0, r4, lsr r8
    9bc8:	01029601 	tsteq	r2, r1, lsl #12
    9bcc:	00006f4c 	andeq	r6, r0, ip, asr #30
    9bd0:	0000709c 	muleq	r0, ip, r0
    9bd4:	00001d04 	andeq	r1, r0, r4, lsl #26
    9bd8:	2f012001 	svccs	0x00012001
    9bdc:	0100002c 	tsteq	r0, ip, lsr #32
    9be0:	9c0102c2 	sfmls	f0, 4, [r1], {194}	; 0xc2
    9be4:	ec000070 	stc	0, cr0, [r0], {112}	; 0x70
    9be8:	30000071 	andcc	r0, r0, r1, ror r0
    9bec:	0100001d 	tsteq	r0, sp, lsl r0
    9bf0:	2c550120 	ldfcse	f0, [r5], {32}
    9bf4:	ee010000 	cdp	0, 0, cr0, cr1, cr0, {0}
    9bf8:	71ec0102 	mvnvc	r0, r2, lsl #2
    9bfc:	733c0000 	teqvc	ip, #0
    9c00:	1d5c0000 	ldclne	0, cr0, [ip, #-0]
    9c04:	07010000 	streq	r0, [r1, -r0]
    9c08:	00000b1f 	andeq	r0, r0, pc, lsl fp
    9c0c:	0000109d 	muleq	r0, sp, r0
    9c10:	0003b008 	andeq	fp, r3, r8
    9c14:	21000500 	tstcs	r0, r0, lsl #10
    9c18:	000027fc 	strdeq	r2, [r0], -ip
    9c1c:	108d1901 	addne	r1, sp, r1, lsl #18
    9c20:	05010000 	streq	r0, [r1, #-0]
    9c24:	ff169803 			; <UNDEFINED> instruction: 0xff169803
    9c28:	2af6211f 	bcs	ffd920ac <__StackLimit+0xdfd920ac>
    9c2c:	1a010000 	bne	49c34 <__etext+0x40f8c>
    9c30:	0000108d 	andeq	r1, r0, sp, lsl #1
    9c34:	b0030501 	andlt	r0, r3, r1, lsl #10
    9c38:	211fff16 	tstcs	pc, r6, lsl pc	; <UNPREDICTABLE>
    9c3c:	00002960 	andeq	r2, r0, r0, ror #18
    9c40:	108d1b01 	addne	r1, sp, r1, lsl #22
    9c44:	05010000 	streq	r0, [r1, #-0]
    9c48:	ff168003 			; <UNDEFINED> instruction: 0xff168003
    9c4c:	1022001f 	eorne	r0, r2, pc, lsl r0
    9c50:	00020000 	andeq	r0, r2, r0
    9c54:	0000180a 	andeq	r1, r0, sl, lsl #16
    9c58:	02340104 	eorseq	r0, r4, #1
    9c5c:	15010000 	strne	r0, [r1, #-0]
    9c60:	2700002e 	strcs	r0, [r0, -lr, lsr #32]
    9c64:	3c000008 	stccc	0, cr0, [r0], {8}
    9c68:	ca000073 	bgt	9e3c <__etext+0x1194>
    9c6c:	a200007c 	andge	r0, r0, #124	; 0x7c
    9c70:	0200001a 	andeq	r0, r0, #26
    9c74:	070b0601 	streq	r0, [fp, -r1, lsl #12]
    9c78:	dd030000 	stcle	0, cr0, [r3, #-0]
    9c7c:	02000009 	andeq	r0, r0, #9
    9c80:	0000372a 	andeq	r3, r0, sl, lsr #14
    9c84:	08010200 	stmdaeq	r1, {r9}
    9c88:	00000709 	andeq	r0, r0, r9, lsl #14
    9c8c:	3b050202 	blcc	14a49c <__etext+0x1417f4>
    9c90:	02000007 	andeq	r0, r0, #7
    9c94:	04920702 	ldreq	r0, [r2], #1794	; 0x702
    9c98:	04020000 	streq	r0, [r2], #-0
    9c9c:	00019605 	andeq	r9, r1, r5, lsl #12
    9ca0:	079b0300 	ldreq	r0, [fp, r0, lsl #6]
    9ca4:	50020000 	andpl	r0, r2, r0
    9ca8:	0000005e 	andeq	r0, r0, lr, asr r0
    9cac:	e4070402 	str	r0, [r7], #-1026	; 0x402
    9cb0:	02000001 	andeq	r0, r0, #1
    9cb4:	01910508 	orrseq	r0, r1, r8, lsl #10
    9cb8:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
    9cbc:	0001df07 	andeq	sp, r1, r7, lsl #30
    9cc0:	05040400 	streq	r0, [r4, #-1024]	; 0x400
    9cc4:	00746e69 	rsbseq	r6, r4, r9, ror #28
    9cc8:	e9070402 	stmdb	r7, {r1, sl}
    9ccc:	05000001 	streq	r0, [r0, #-1]
    9cd0:	a04b0301 	subge	r0, fp, r1, lsl #6
    9cd4:	06000003 	streq	r0, [r0], -r3
    9cd8:	00000aa5 	andeq	r0, r0, r5, lsr #21
    9cdc:	069a0600 	ldreq	r0, [sl], r0, lsl #12
    9ce0:	06010000 	streq	r0, [r1], -r0
    9ce4:	0000020a 	andeq	r0, r0, sl, lsl #4
    9ce8:	00000602 	andeq	r0, r0, r2, lsl #12
    9cec:	06030000 	streq	r0, [r3], -r0
    9cf0:	000000c4 	andeq	r0, r0, r4, asr #1
    9cf4:	01bd0604 			; <UNDEFINED> instruction: 0x01bd0604
    9cf8:	06050000 	streq	r0, [r5], -r0
    9cfc:	000008bf 			; <UNDEFINED> instruction: 0x000008bf
    9d00:	027d0606 	rsbseq	r0, sp, #6291456	; 0x600000
    9d04:	06070000 	streq	r0, [r7], -r0
    9d08:	0000028b 	andeq	r0, r0, fp, lsl #5
    9d0c:	02990608 	addseq	r0, r9, #8388608	; 0x800000
    9d10:	06090000 	streq	r0, [r9], -r0
    9d14:	000009a4 	andeq	r0, r0, r4, lsr #19
    9d18:	0a11060a 	beq	44b548 <__etext+0x4428a0>
    9d1c:	060b0000 	streq	r0, [fp], -r0
    9d20:	0000059a 	muleq	r0, sl, r5
    9d24:	09c5060c 	stmibeq	r5, {r2, r3, r9, sl}^
    9d28:	060d0000 	streq	r0, [sp], -r0
    9d2c:	0000054b 	andeq	r0, r0, fp, asr #10
    9d30:	03de060e 	bicseq	r0, lr, #14680064	; 0xe00000
    9d34:	060f0000 	streq	r0, [pc], -r0
    9d38:	00000108 	andeq	r0, r0, r8, lsl #2
    9d3c:	068b0610 	pkhbteq	r0, fp, r0, lsl #12
    9d40:	06110000 	ldreq	r0, [r1], -r0
    9d44:	00000148 	andeq	r0, r0, r8, asr #2
    9d48:	06f10612 	usateq	r0, #17, r2, lsl #12
    9d4c:	06130000 	ldreq	r0, [r3], -r0
    9d50:	0000037a 	andeq	r0, r0, sl, ror r3
    9d54:	08180614 	ldmdaeq	r8, {r2, r4, r9, sl}
    9d58:	06150000 	ldreq	r0, [r5], -r0
    9d5c:	000003cf 	andeq	r0, r0, pc, asr #7
    9d60:	08b00616 	ldmeq	r0!, {r1, r2, r4, r9, sl}
    9d64:	06170000 	ldreq	r0, [r7], -r0
    9d68:	0000042f 	andeq	r0, r0, pc, lsr #8
    9d6c:	01390618 	teqeq	r9, r8, lsl r6
    9d70:	06190000 	ldreq	r0, [r9], -r0
    9d74:	000003bf 			; <UNDEFINED> instruction: 0x000003bf
    9d78:	0898061a 	ldmeq	r8, {r1, r3, r4, r9, sl}
    9d7c:	061b0000 	ldreq	r0, [fp], -r0
    9d80:	0000040d 	andeq	r0, r0, sp, lsl #8
    9d84:	08e8061c 	stmiaeq	r8!, {r2, r3, r4, r9, sl}^
    9d88:	061d0000 	ldreq	r0, [sp], -r0
    9d8c:	0000051f 	andeq	r0, r0, pc, lsl r5
    9d90:	03af061e 			; <UNDEFINED> instruction: 0x03af061e
    9d94:	061f0000 	ldreq	r0, [pc], -r0
    9d98:	000008cf 	andeq	r0, r0, pc, asr #17
    9d9c:	02120620 	andseq	r0, r2, #33554432	; 0x2000000
    9da0:	06210000 	strteq	r0, [r1], -r0
    9da4:	000003f3 	strdeq	r0, [r0], -r3
    9da8:	01170622 	tsteq	r7, r2, lsr #12
    9dac:	06230000 	strteq	r0, [r3], -r0
    9db0:	000005e0 	andeq	r0, r0, r0, ror #11
    9db4:	04d30624 	ldrbeq	r0, [r3], #1572	; 0x624
    9db8:	06250000 	strteq	r0, [r5], -r0
    9dbc:	00000a37 	andeq	r0, r0, r7, lsr sl
    9dc0:	06530626 	ldrbeq	r0, [r3], -r6, lsr #12
    9dc4:	06270000 	strteq	r0, [r7], -r0
    9dc8:	0000075e 	andeq	r0, r0, lr, asr r7
    9dcc:	0a530628 	beq	14cb674 <__etext+0x14c29cc>
    9dd0:	06290000 	strteq	r0, [r9], -r0
    9dd4:	00000a67 	andeq	r0, r0, r7, ror #20
    9dd8:	077f062a 	ldrbeq	r0, [pc, -sl, lsr #12]!
    9ddc:	062b0000 	strteq	r0, [fp], -r0
    9de0:	00000a70 	andeq	r0, r0, r0, ror sl
    9de4:	0089062c 	addeq	r0, r9, ip, lsr #12
    9de8:	062d0000 	strteq	r0, [sp], -r0
    9dec:	00000166 	andeq	r0, r0, r6, ror #2
    9df0:	058b062e 	streq	r0, [fp, #1582]	; 0x62e
    9df4:	062f0000 	strteq	r0, [pc], -r0
    9df8:	00000877 	andeq	r0, r0, r7, ror r8
    9dfc:	08630630 	stmdaeq	r3!, {r4, r5, r9, sl}^
    9e00:	06310000 	ldrteq	r0, [r1], -r0
    9e04:	000002b7 			; <UNDEFINED> instruction: 0x000002b7
    9e08:	03680632 	cmneq	r8, #52428800	; 0x3200000
    9e0c:	06330000 	ldrteq	r0, [r3], -r0
    9e10:	00000a8e 	andeq	r0, r0, lr, lsl #21
    9e14:	006c0634 	rsbeq	r0, ip, r4, lsr r6
    9e18:	06350000 	ldrteq	r0, [r5], -r0
    9e1c:	00000399 	muleq	r0, r9, r3
    9e20:	01ae0636 			; <UNDEFINED> instruction: 0x01ae0636
    9e24:	06370000 	ldrteq	r0, [r7], -r0
    9e28:	000001f6 	strdeq	r0, [r0], -r6
    9e2c:	01cb0638 	biceq	r0, fp, r8, lsr r6
    9e30:	06390000 	ldrteq	r0, [r9], -r0
    9e34:	0000043e 	andeq	r0, r0, lr, lsr r4
    9e38:	04db063a 	ldrbeq	r0, [fp], #1594	; 0x63a
    9e3c:	063b0000 	ldrteq	r0, [fp], -r0
    9e40:	00000745 	andeq	r0, r0, r5, asr #14
    9e44:	0918063c 	ldmdbeq	r8, {r2, r3, r4, r5, r9, sl}
    9e48:	063d0000 	ldrteq	r0, [sp], -r0
    9e4c:	00000454 	andeq	r0, r0, r4, asr r4
    9e50:	046a063e 	strbteq	r0, [sl], #-1598	; 0x63e
    9e54:	063f0000 	ldrteq	r0, [pc], -r0
    9e58:	00000a79 	andeq	r0, r0, r9, ror sl
    9e5c:	940600c0 	strls	r0, [r6], #-192	; 0xc0
    9e60:	c1000009 	tstgt	r0, r9
    9e64:	057d0600 	ldrbeq	r0, [sp, #-1536]!	; 0x600
    9e68:	00c20000 	sbceq	r0, r2, r0
    9e6c:	0004a506 	andeq	sl, r4, r6, lsl #10
    9e70:	0600c300 	streq	ip, [r0], -r0, lsl #6
    9e74:	00000a21 	andeq	r0, r0, r1, lsr #20
    9e78:	f80600c4 			; <UNDEFINED> instruction: 0xf80600c4
    9e7c:	c5000009 	strgt	r0, [r0, #-9]
    9e80:	097a0600 	ldmdbeq	sl!, {r9, sl}^
    9e84:	00c60000 	sbceq	r0, r6, r0
    9e88:	0004c306 	andeq	ip, r4, r6, lsl #6
    9e8c:	0600c700 	streq	ip, [r0], -r0, lsl #14
    9e90:	0000053d 	andeq	r0, r0, sp, lsr r5
    9e94:	040600c8 	streq	r0, [r6], #-200	; 0xc8
    9e98:	c9000004 	stmdbgt	r0, {r2}
    9e9c:	022b0600 	eoreq	r0, fp, #0
    9ea0:	00ca0000 	sbceq	r0, sl, r0
    9ea4:	0009b306 	andeq	fp, r9, r6, lsl #6
    9ea8:	0600cb00 	streq	ip, [r0], -r0, lsl #22
    9eac:	0000066f 	andeq	r0, r0, pc, ror #12
    9eb0:	780600cc 	stmdavc	r6, {r2, r3, r6, r7}
    9eb4:	cd000006 	stcgt	0, cr0, [r0, #-24]	; 0xffffffe8
    9eb8:	02cd0600 	sbceq	r0, sp, #0
    9ebc:	00ce0000 	sbceq	r0, lr, r0
    9ec0:	0002d606 	andeq	sp, r2, r6, lsl #12
    9ec4:	0600cf00 	streq	ip, [r0], -r0, lsl #30
    9ec8:	000002df 	ldrdeq	r0, [r0], -pc	; <UNPREDICTABLE>
    9ecc:	1a0600d0 	bne	18a214 <__etext+0x18156c>
    9ed0:	d1000002 	tstle	r0, r2
    9ed4:	04620600 	strbteq	r0, [r2], #-1536	; 0x600
    9ed8:	00d20000 	sbcseq	r0, r2, r0
    9edc:	00038906 	andeq	r8, r3, r6, lsl #18
    9ee0:	0600d300 	streq	sp, [r0], -r0, lsl #6
    9ee4:	0000047a 	andeq	r0, r0, sl, ror r4
    9ee8:	2e0600d4 	mcrcs	0, 0, r0, cr6, cr4, {6}
    9eec:	d5000000 	strle	r0, [r0, #-0]
    9ef0:	07cb0600 	strbeq	r0, [fp, r0, lsl #12]
    9ef4:	00d60000 	sbcseq	r0, r6, r0
    9ef8:	00004506 	andeq	r4, r0, r6, lsl #10
    9efc:	0600d700 	streq	sp, [r0], -r0, lsl #14
    9f00:	000005ec 	andeq	r0, r0, ip, ror #11
    9f04:	220600d8 	andcs	r0, r6, #216	; 0xd8
    9f08:	d9000002 	stmdble	r0, {r1}
    9f0c:	07530600 	ldrbeq	r0, [r3, -r0, lsl #12]
    9f10:	00da0000 	sbcseq	r0, sl, r0
    9f14:	00090406 	andeq	r0, r9, r6, lsl #8
    9f18:	0600db00 	streq	sp, [r0], -r0, lsl #22
    9f1c:	000000de 	ldrdeq	r0, [r0], -lr
    9f20:	560600dc 			; <UNDEFINED> instruction: 0x560600dc
    9f24:	dd000000 	stcle	0, cr0, [r0, #-0]
    9f28:	019f0600 	orrseq	r0, pc, r0, lsl #12
    9f2c:	00de0000 	sbcseq	r0, lr, r0
    9f30:	000a4406 	andeq	r4, sl, r6, lsl #8
    9f34:	0600df00 	streq	sp, [r0], -r0, lsl #30
    9f38:	000000a6 	andeq	r0, r0, r6, lsr #1
    9f3c:	d70600e0 	strle	r0, [r6, -r0, ror #1]
    9f40:	e1000005 	tst	r0, r5
    9f44:	04ea0600 	strbteq	r0, [sl], #1536	; 0x600
    9f48:	00e20000 	rsceq	r0, r2, r0
    9f4c:	0003ea06 	andeq	lr, r3, r6, lsl #20
    9f50:	0600e300 	streq	lr, [r0], -r0, lsl #6
    9f54:	0000004e 	andeq	r0, r0, lr, asr #32
    9f58:	060600e4 	streq	r0, [r6], -r4, ror #1
    9f5c:	e5000003 	str	r0, [r0, #-3]
    9f60:	00b40600 	adcseq	r0, r4, r0, lsl #12
    9f64:	00e60000 	rsceq	r0, r6, r0
    9f68:	0005f506 	andeq	pc, r5, r6, lsl #10
    9f6c:	0600e700 	streq	lr, [r0], -r0, lsl #14
    9f70:	0000012a 	andeq	r0, r0, sl, lsr #2
    9f74:	100600e8 	andne	r0, r6, r8, ror #1
    9f78:	e9000006 	stmdb	r0, {r1, r2}
    9f7c:	07310600 	ldreq	r0, [r1, -r0, lsl #12]!
    9f80:	00ea0000 	rsceq	r0, sl, r0
    9f84:	00062c06 	andeq	r2, r6, r6, lsl #24
    9f88:	0600eb00 	streq	lr, [r0], -r0, lsl #22
    9f8c:	00000636 	andeq	r0, r0, r6, lsr r6
    9f90:	900600ec 	andls	r0, r6, ip, ror #1
    9f94:	ed000008 	stc	0, cr0, [r0, #-32]	; 0xffffffe0
    9f98:	06610600 	strbteq	r0, [r1], -r0, lsl #12
    9f9c:	00ee0000 	rsceq	r0, lr, r0
    9fa0:	0005c306 	andeq	ip, r5, r6, lsl #6
    9fa4:	0600ef00 	streq	lr, [r0], -r0, lsl #30
    9fa8:	00000681 	andeq	r0, r0, r1, lsl #13
    9fac:	f80600f0 			; <UNDEFINED> instruction: 0xf80600f0
    9fb0:	f1000000 	cps	#0
    9fb4:	09e50600 	stmibeq	r5!, {r9, sl}^
    9fb8:	00f20000 	rscseq	r0, r2, r0
    9fbc:	00035d06 	andeq	r5, r3, r6, lsl #26
    9fc0:	0600f300 	streq	pc, [r0], -r0, lsl #6
    9fc4:	000002a7 	andeq	r0, r0, r7, lsr #5
    9fc8:	e80600f4 	stmda	r6, {r2, r4, r5, r6, r7}
    9fcc:	f5000002 			; <UNDEFINED> instruction: 0xf5000002
    9fd0:	041d0600 	ldreq	r0, [sp], #-1536	; 0x600
    9fd4:	00f60000 	rscseq	r0, r6, r0
    9fd8:	00042606 	andeq	r2, r4, r6, lsl #12
    9fdc:	0600f700 	streq	pc, [r0], -r0, lsl #14
    9fe0:	00000185 	andeq	r0, r0, r5, lsl #3
    9fe4:	880600f8 	stmdahi	r6, {r3, r4, r5, r6, r7}
    9fe8:	f9000009 			; <UNDEFINED> instruction: 0xf9000009
    9fec:	04020000 	streq	r0, [r2], #-0
    9ff0:	00057407 	andeq	r7, r5, r7, lsl #8
    9ff4:	002c0700 	eoreq	r0, ip, r0, lsl #14
    9ff8:	03b70000 			; <UNDEFINED> instruction: 0x03b70000
    9ffc:	a0080000 	andge	r0, r8, r0
    a000:	1b000003 	blne	a014 <__etext+0x136c>
    a004:	002c0700 	eoreq	r0, ip, r0, lsl #14
    a008:	03c70000 	biceq	r0, r7, #0
    a00c:	a0080000 	andge	r0, r8, r0
    a010:	03000003 	movweq	r0, #3
    a014:	002c0700 	eoreq	r0, ip, r0, lsl #14
    a018:	03d70000 	bicseq	r0, r7, #0
    a01c:	a0080000 	andge	r0, r8, r0
    a020:	07000003 	streq	r0, [r0, -r3]
    a024:	002c0700 	eoreq	r0, ip, r0, lsl #14
    a028:	03e70000 	mvneq	r0, #0
    a02c:	a0080000 	andge	r0, r8, r0
    a030:	17000003 	strne	r0, [r0, -r3]
    a034:	00530700 	subseq	r0, r3, r0, lsl #14
    a038:	03f70000 	mvnseq	r0, #0
    a03c:	a0080000 	andge	r0, r8, r0
    a040:	1f000003 	svcne	0x00000003
    a044:	002c0700 	eoreq	r0, ip, r0, lsl #14
    a048:	04070000 	streq	r0, [r7], #-0
    a04c:	a0080000 	andge	r0, r8, r0
    a050:	00000003 	andeq	r0, r0, r3
    a054:	12610900 	rsbne	r0, r1, #0
    a058:	03cc0000 	biceq	r0, ip, #0
    a05c:	04a435a5 	strteq	r3, [r4], #1445	; 0x5a5
    a060:	500a0000 	andpl	r0, sl, r0
    a064:	03005243 	movweq	r5, #579	; 0x243
    a068:	03e735a6 	mvneq	r3, #696254464	; 0x29800000
    a06c:	23020000 	movwcs	r0, #8192	; 0x2000
    a070:	11110b00 	tstne	r1, r0, lsl #22
    a074:	a7030000 	strge	r0, [r3, -r0]
    a078:	00005335 	andeq	r5, r0, r5, lsr r3
    a07c:	80230300 	eorhi	r0, r3, r0, lsl #6
    a080:	145a0b01 	ldrbne	r0, [sl], #-2817	; 0xb01
    a084:	a8030000 	stmdage	r3, {}	; <UNPREDICTABLE>
    a088:	00005335 	andeq	r5, r0, r5, lsr r3
    a08c:	84230300 	strthi	r0, [r3], #-768	; 0x300
    a090:	03120b01 	tsteq	r2, #1024	; 0x400
    a094:	a9030000 	stmdbge	r3, {}	; <UNPREDICTABLE>
    a098:	0003d735 	andeq	sp, r3, r5, lsr r7
    a09c:	88230300 	stmdahi	r3!, {r8, r9}
    a0a0:	12380b01 	eorsne	r0, r8, #1024	; 0x400
    a0a4:	aa030000 	bge	ca0ac <__etext+0xc1404>
    a0a8:	00005335 	andeq	r5, r0, r5, lsr r3
    a0ac:	a0230300 	eorge	r0, r3, r0, lsl #6
    a0b0:	031d0b01 	tsteq	sp, #1024	; 0x400
    a0b4:	ab030000 	blge	ca0bc <__etext+0xc1414>
    a0b8:	0003a735 	andeq	sl, r3, r5, lsr r7
    a0bc:	a4230300 	strtge	r0, [r3], #-768	; 0x300
    a0c0:	126d0b01 	rsbne	r0, sp, #1024	; 0x400
    a0c4:	ac030000 	stcge	0, cr0, [r3], {-0}
    a0c8:	00005335 	andeq	r5, r0, r5, lsr r3
    a0cc:	c0230300 	eorgt	r0, r3, r0, lsl #6
    a0d0:	114a0b01 	cmpne	sl, r1, lsl #22
    a0d4:	ad030000 	stcge	0, cr0, [r3, #-0]
    a0d8:	00005335 	andeq	r5, r0, r5, lsr r3
    a0dc:	c4230300 	strtgt	r0, [r3], #-768	; 0x300
    a0e0:	12950b01 	addsne	r0, r5, #1024	; 0x400
    a0e4:	ae030000 	cdpge	0, 0, cr0, cr3, cr0, {0}
    a0e8:	00005335 	andeq	r5, r0, r5, lsr r3
    a0ec:	c8230300 	stmdagt	r3!, {r8, r9}
    a0f0:	b10c0001 	tstlt	ip, r1
    a0f4:	03000011 	movweq	r0, #17
    a0f8:	04b035af 	ldrteq	r3, [r0], #1455	; 0x5af
    a0fc:	040d0000 	streq	r0, [sp], #-0
    a100:	000004b6 			; <UNDEFINED> instruction: 0x000004b6
    a104:	0004070e 	andeq	r0, r4, lr, lsl #14
    a108:	10440f00 	subne	r0, r4, r0, lsl #30
    a10c:	10700000 	rsbsne	r0, r0, r0
    a110:	973d9503 	ldrls	r9, [sp, -r3, lsl #10]!
    a114:	0b000006 	bleq	a134 <__etext+0x148c>
    a118:	00001038 	andeq	r1, r0, r8, lsr r0
    a11c:	533d9603 	teqpl	sp, #3145728	; 0x300000
    a120:	02000000 	andeq	r0, r0, #0
    a124:	020b0023 	andeq	r0, fp, #35	; 0x23
    a128:	0300000d 	movweq	r0, #13
    a12c:	00533d97 			; <UNDEFINED> instruction: 0x00533d97
    a130:	23020000 	movwcs	r0, #8192	; 0x2000
    a134:	03120b04 	tsteq	r2, #4096	; 0x1000
    a138:	98030000 	stmdals	r3, {}	; <UNPREDICTABLE>
    a13c:	0006973d 	andeq	r9, r6, sp, lsr r7
    a140:	08230200 	stmdaeq	r3!, {r9}
    a144:	00103e0b 	andseq	r3, r0, fp, lsl #28
    a148:	3d990300 	ldccc	3, cr0, [r9]
    a14c:	00000053 	andeq	r0, r0, r3, asr r0
    a150:	20842303 	addcs	r2, r4, r3, lsl #6
    a154:	00031d0b 	andeq	r1, r3, fp, lsl #26
    a158:	3d9a0300 	ldccc	3, cr0, [sl]
    a15c:	000003b7 			; <UNDEFINED> instruction: 0x000003b7
    a160:	20882303 	addcs	r2, r8, r3, lsl #6
    a164:	00104f0b 	andseq	r4, r0, fp, lsl #30
    a168:	3d9b0300 	ldccc	3, cr0, [fp]
    a16c:	00000053 	andeq	r0, r0, r3, asr r0
    a170:	208c2303 	addcs	r2, ip, r3, lsl #6
    a174:	0010550b 	andseq	r5, r0, fp, lsl #10
    a178:	3d9c0300 	ldccc	3, cr0, [ip]
    a17c:	00000053 	andeq	r0, r0, r3, asr r0
    a180:	20902303 	addscs	r2, r0, r3, lsl #6
    a184:	00105b0b 	andseq	r5, r0, fp, lsl #22
    a188:	3d9d0300 	ldccc	3, cr0, [sp]
    a18c:	00000053 	andeq	r0, r0, r3, asr r0
    a190:	20942303 	addscs	r2, r4, r3, lsl #6
    a194:	0010610b 	andseq	r6, r0, fp, lsl #2
    a198:	3d9e0300 	ldccc	3, cr0, [lr]
    a19c:	00000053 	andeq	r0, r0, r3, asr r0
    a1a0:	20982303 	addscs	r2, r8, r3, lsl #6
    a1a4:	000a9a0b 	andeq	r9, sl, fp, lsl #20
    a1a8:	3d9f0300 	ldccc	3, cr0, [pc]	; a1b0 <__etext+0x1508>
    a1ac:	000003c7 	andeq	r0, r0, r7, asr #7
    a1b0:	209c2303 	addscs	r2, ip, r3, lsl #6
    a1b4:	000c640b 	andeq	r6, ip, fp, lsl #8
    a1b8:	3da00300 	stccc	3, cr0, [r0]
    a1bc:	00000053 	andeq	r0, r0, r3, asr r0
    a1c0:	20a42303 	adccs	r2, r4, r3, lsl #6
    a1c4:	000c690b 	andeq	r6, ip, fp, lsl #18
    a1c8:	3da10300 	stccc	3, cr0, [r1]
    a1cc:	00000053 	andeq	r0, r0, r3, asr r0
    a1d0:	20a82303 	adccs	r2, r8, r3, lsl #6
    a1d4:	000c6f0b 	andeq	r6, ip, fp, lsl #30
    a1d8:	3da20300 	stccc	3, cr0, [r2]
    a1dc:	00000053 	andeq	r0, r0, r3, asr r0
    a1e0:	20ac2303 	adccs	r2, ip, r3, lsl #6
    a1e4:	000c750b 	andeq	r7, ip, fp, lsl #10
    a1e8:	3da30300 	stccc	3, cr0, [r3]
    a1ec:	00000053 	andeq	r0, r0, r3, asr r0
    a1f0:	20b02303 	adcscs	r2, r0, r3, lsl #6
    a1f4:	000c7b0b 	andeq	r7, ip, fp, lsl #22
    a1f8:	3da40300 	stccc	3, cr0, [r4]
    a1fc:	00000053 	andeq	r0, r0, r3, asr r0
    a200:	20b42303 	adcscs	r2, r4, r3, lsl #6
    a204:	000c810b 	andeq	r8, ip, fp, lsl #2
    a208:	3da50300 	stccc	3, cr0, [r5]
    a20c:	00000053 	andeq	r0, r0, r3, asr r0
    a210:	20b82303 	adcscs	r2, r8, r3, lsl #6
    a214:	000c870b 	andeq	r8, ip, fp, lsl #14
    a218:	3da60300 	stccc	3, cr0, [r6]
    a21c:	00000053 	andeq	r0, r0, r3, asr r0
    a220:	20bc2303 	adcscs	r2, ip, r3, lsl #6
    a224:	000c8d0b 	andeq	r8, ip, fp, lsl #26
    a228:	3da70300 	stccc	3, cr0, [r7]
    a22c:	00000053 	andeq	r0, r0, r3, asr r0
    a230:	20c02303 	sbccs	r2, r0, r3, lsl #6
    a234:	000fec0b 	andeq	lr, pc, fp, lsl #24
    a238:	3da80300 	stccc	3, cr0, [r8]
    a23c:	00000053 	andeq	r0, r0, r3, asr r0
    a240:	20c42303 	sbccs	r2, r4, r3, lsl #6
    a244:	000ff40b 	andeq	pc, pc, fp, lsl #8
    a248:	3da90300 	stccc	3, cr0, [r9]
    a24c:	00000053 	andeq	r0, r0, r3, asr r0
    a250:	20c82303 	sbccs	r2, r8, r3, lsl #6
    a254:	000f290b 	andeq	r2, pc, fp, lsl #18
    a258:	3daa0300 	stccc	3, cr0, [sl]
    a25c:	00000053 	andeq	r0, r0, r3, asr r0
    a260:	20cc2303 	sbccs	r2, ip, r3, lsl #6
    a264:	000f2f0b 	andeq	r2, pc, fp, lsl #30
    a268:	3dab0300 	stccc	3, cr0, [fp]
    a26c:	00000053 	andeq	r0, r0, r3, asr r0
    a270:	20d02303 	sbcscs	r2, r0, r3, lsl #6
    a274:	000bcb0b 	andeq	ip, fp, fp, lsl #22
    a278:	3dac0300 	stccc	3, cr0, [ip]
    a27c:	00000053 	andeq	r0, r0, r3, asr r0
    a280:	20d42303 	sbcscs	r2, r4, r3, lsl #6
    a284:	000e090b 	andeq	r0, lr, fp, lsl #18
    a288:	3dad0300 	stccc	3, cr0, [sp]
    a28c:	00000053 	andeq	r0, r0, r3, asr r0
    a290:	20d82303 	sbcscs	r2, r8, r3, lsl #6
    a294:	000e0f0b 	andeq	r0, lr, fp, lsl #30
    a298:	3dae0300 	stccc	3, cr0, [lr]
    a29c:	00000053 	andeq	r0, r0, r3, asr r0
    a2a0:	20dc2303 	sbcscs	r2, ip, r3, lsl #6
    a2a4:	000bd00b 	andeq	sp, fp, fp
    a2a8:	3daf0300 	stccc	3, cr0, [pc]	; a2b0 <__etext+0x1608>
    a2ac:	00000053 	andeq	r0, r0, r3, asr r0
    a2b0:	20e02303 	rsccs	r2, r0, r3, lsl #6
    a2b4:	0003310b 	andeq	r3, r3, fp, lsl #2
    a2b8:	3db00300 	ldccc	3, cr0, [r0]
    a2bc:	000003b7 			; <UNDEFINED> instruction: 0x000003b7
    a2c0:	20e42303 	rsccs	r2, r4, r3, lsl #6
    a2c4:	000e9f0b 	andeq	r9, lr, fp, lsl #30
    a2c8:	3db10300 	ldccc	3, cr0, [r1]
    a2cc:	00000053 	andeq	r0, r0, r3, asr r0
    a2d0:	20e82303 	rsccs	r2, r8, r3, lsl #6
    a2d4:	52434d0a 	subpl	r4, r3, #640	; 0x280
    a2d8:	3db20300 	ldccc	3, cr0, [r2]
    a2dc:	00000053 	andeq	r0, r0, r3, asr r0
    a2e0:	20ec2303 	rsccs	r2, ip, r3, lsl #6
    a2e4:	002c0700 	eoreq	r0, ip, r0, lsl #14
    a2e8:	06a80000 	strteq	r0, [r8], r0
    a2ec:	a0100000 	andsge	r0, r0, r0
    a2f0:	fb000003 	blx	a306 <__etext+0x165e>
    a2f4:	470c000f 	strmi	r0, [ip, -pc]
    a2f8:	0300000f 	movweq	r0, #15
    a2fc:	06b43db3 			; <UNDEFINED> instruction: 0x06b43db3
    a300:	040d0000 	streq	r0, [sp], #-0
    a304:	000006ba 			; <UNDEFINED> instruction: 0x000006ba
    a308:	0004bb0e 	andeq	fp, r4, lr, lsl #22
    a30c:	03011100 	movweq	r1, #4352	; 0x1100
    a310:	06e143d2 	usateq	r4, #1, r2, asr #7
    a314:	23120000 	tstcs	r2, #0
    a318:	0300000d 	movweq	r0, #13
    a31c:	002c43d3 	ldrdeq	r4, [ip], -r3	; <UNPREDICTABLE>
    a320:	32120000 	andscc	r0, r2, #0
    a324:	0300000d 	movweq	r0, #13
    a328:	002c43d4 	ldrdeq	r4, [ip], -r4	; <UNPREDICTABLE>
    a32c:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
    a330:	0000102c 	andeq	r1, r0, ip, lsr #32
    a334:	43b60332 			; <UNDEFINED> instruction: 0x43b60332
    a338:	000009c6 	andeq	r0, r0, r6, asr #19
    a33c:	4844420a 	stmdami	r4, {r1, r3, r9, lr}^
    a340:	43b70300 			; <UNDEFINED> instruction: 0x43b70300
    a344:	0000002c 	andeq	r0, r0, ip, lsr #32
    a348:	0a002302 	beq	12f58 <__etext+0xa2b0>
    a34c:	004c4442 	subeq	r4, ip, r2, asr #8
    a350:	2c43b803 	mcrrcs	8, 0, fp, r3, cr3
    a354:	02000000 	andeq	r0, r0, #0
    a358:	430a0123 	movwmi	r0, #41251	; 0xa123
    a35c:	b9030031 	stmdblt	r3, {r0, r4, r5}
    a360:	00002c43 	andeq	r2, r0, r3, asr #24
    a364:	02230200 	eoreq	r0, r3, #0
    a368:	0032430a 	eorseq	r4, r2, sl, lsl #6
    a36c:	2c43ba03 	mcrrcs	10, 0, fp, r3, cr3
    a370:	02000000 	andeq	r0, r0, #0
    a374:	530a0323 	movwpl	r0, #41763	; 0xa323
    a378:	bb030031 	bllt	ca444 <__etext+0xc179c>
    a37c:	00002c43 	andeq	r2, r0, r3, asr #24
    a380:	04230200 	strteq	r0, [r3], #-512	; 0x200
    a384:	0032530a 	eorseq	r5, r2, sl, lsl #6
    a388:	2c43bc03 	mcrrcs	12, 0, fp, r3, cr3
    a38c:	02000000 	andeq	r0, r0, #0
    a390:	430a0523 	movwmi	r0, #42275	; 0xa523
    a394:	bd030033 	stclt	0, cr0, [r3, #-204]	; 0xffffff34
    a398:	00002c43 	andeq	r2, r0, r3, asr #24
    a39c:	06230200 	strteq	r0, [r3], -r0, lsl #4
    a3a0:	0300440a 	movweq	r4, #1034	; 0x40a
    a3a4:	002c43be 			; <UNDEFINED> instruction: 0x002c43be
    a3a8:	23020000 	movwcs	r0, #8192	; 0x2000
    a3ac:	414d0a07 	cmpmi	sp, r7, lsl #20
    a3b0:	bf030031 	svclt	0x00030031
    a3b4:	00002c43 	andeq	r2, r0, r3, asr #24
    a3b8:	08230200 	stmdaeq	r3!, {r9}
    a3bc:	32414d0a 	subcc	r4, r1, #640	; 0x280
    a3c0:	43c00300 	bicmi	r0, r0, #0
    a3c4:	0000002c 	andeq	r0, r0, ip, lsr #32
    a3c8:	0a092302 	beq	252fd8 <__etext+0x24a330>
    a3cc:	03003443 	movweq	r3, #1091	; 0x443
    a3d0:	002c43c1 	eoreq	r4, ip, r1, asr #7
    a3d4:	23020000 	movwcs	r0, #8192	; 0x2000
    a3d8:	35430a0a 	strbcc	r0, [r3, #-2570]	; 0xa0a
    a3dc:	43c20300 	bicmi	r0, r2, #0
    a3e0:	0000002c 	andeq	r0, r0, ip, lsr #32
    a3e4:	0a0b2302 	beq	2d2ff4 <__etext+0x2ca34c>
    a3e8:	03004445 	movweq	r4, #1093	; 0x445
    a3ec:	002c43c3 	eoreq	r4, ip, r3, asr #7
    a3f0:	23020000 	movwcs	r0, #8192	; 0x2000
    a3f4:	0c570b0c 	mrrceq	11, 0, r0, r7, cr12
    a3f8:	c4030000 	strgt	r0, [r3], #-0
    a3fc:	00002c43 	andeq	r2, r0, r3, asr #24
    a400:	0d230200 	sfmeq	f0, 4, [r3, #-0]
    a404:	0052490a 	subseq	r4, r2, sl, lsl #18
    a408:	2c43c503 	cfstr64cs	mvdx12, [r3], {3}
    a40c:	02000000 	andeq	r0, r0, #0
    a410:	120b0e23 	andne	r0, fp, #560	; 0x230
    a414:	03000003 	movweq	r0, #3
    a418:	03f743c6 	mvnseq	r4, #402653187	; 0x18000003
    a41c:	23020000 	movwcs	r0, #8192	; 0x2000
    a420:	0bb50b0f 	bleq	fed4d064 <__StackLimit+0xded4d064>
    a424:	c7030000 	strgt	r0, [r3, -r0]
    a428:	00002c43 	andeq	r2, r0, r3, asr #24
    a42c:	10230200 	eorne	r0, r3, r0, lsl #4
    a430:	000f980b 	andeq	r9, pc, fp, lsl #16
    a434:	43c80300 	bicmi	r0, r8, #0
    a438:	0000002c 	andeq	r0, r0, ip, lsr #32
    a43c:	0b112302 	bleq	45304c <__etext+0x44a3a4>
    a440:	00000b77 	andeq	r0, r0, r7, ror fp
    a444:	2c43c903 	mcrrcs	9, 0, ip, r3, cr3
    a448:	02000000 	andeq	r0, r0, #0
    a44c:	a80b1223 	stmdage	fp, {r0, r1, r5, r9, ip}
    a450:	0300000b 	movweq	r0, #11
    a454:	002c43ca 	eoreq	r4, ip, sl, asr #7
    a458:	23020000 	movwcs	r0, #8192	; 0x2000
    a45c:	0b9b0b13 	bleq	fe6cd0b0 <__StackLimit+0xde6cd0b0>
    a460:	cb030000 	blgt	ca468 <__etext+0xc17c0>
    a464:	00002c43 	andeq	r2, r0, r3, asr #24
    a468:	14230200 	strtne	r0, [r3], #-512	; 0x200
    a46c:	000fb30b 	andeq	fp, pc, fp, lsl #6
    a470:	43cc0300 	bicmi	r0, ip, #0
    a474:	0000002c 	andeq	r0, r0, ip, lsr #32
    a478:	0b152302 	bleq	553088 <__etext+0x54a3e0>
    a47c:	00000f97 	muleq	r0, r7, pc	; <UNPREDICTABLE>
    a480:	2c43cd03 	mcrrcs	13, 0, ip, r3, cr3
    a484:	02000000 	andeq	r0, r0, #0
    a488:	1d0b1623 	stcne	6, cr1, [fp, #-140]	; 0xffffff74
    a48c:	03000003 	movweq	r0, #3
    a490:	03f743ce 	mvnseq	r4, #939524099	; 0x38000003
    a494:	23020000 	movwcs	r0, #8192	; 0x2000
    a498:	0fc80b17 	svceq	0x00c80b17
    a49c:	cf030000 	svcgt	0x00030000
    a4a0:	00002c43 	andeq	r2, r0, r3, asr #24
    a4a4:	18230200 	stmdane	r3!, {r9}
    a4a8:	000c5d0b 	andeq	r5, ip, fp, lsl #26
    a4ac:	43d00300 	bicsmi	r0, r0, #0
    a4b0:	0000002c 	andeq	r0, r0, ip, lsr #32
    a4b4:	0b192302 	bleq	6530c4 <__etext+0x64a41c>
    a4b8:	000010a9 	andeq	r1, r0, r9, lsr #1
    a4bc:	2c43d103 	stfcsp	f5, [r3], {3}
    a4c0:	02000000 	andeq	r0, r0, #0
    a4c4:	bf131a23 	svclt	0x00131a23
    a4c8:	02000006 	andeq	r0, r0, #6
    a4cc:	320b1b23 	andcc	r1, fp, #35840	; 0x8c00
    a4d0:	0300000c 	movweq	r0, #12
    a4d4:	002c43d6 	ldrdeq	r4, [ip], -r6	; <UNPREDICTABLE>
    a4d8:	23020000 	movwcs	r0, #8192	; 0x2000
    a4dc:	0b520b1c 	bleq	148d154 <__etext+0x14844ac>
    a4e0:	d7030000 	strle	r0, [r3, -r0]
    a4e4:	00002c43 	andeq	r2, r0, r3, asr #24
    a4e8:	1d230200 	sfmne	f0, 4, [r3, #-0]
    a4ec:	000be80b 	andeq	lr, fp, fp, lsl #16
    a4f0:	43d80300 	bicsmi	r0, r8, #0
    a4f4:	0000002c 	andeq	r0, r0, ip, lsr #32
    a4f8:	0b1e2302 	bleq	793108 <__etext+0x78a460>
    a4fc:	00000bd5 	ldrdeq	r0, [r0], -r5
    a500:	2c43d903 	mcrrcs	9, 0, sp, r3, cr3
    a504:	02000000 	andeq	r0, r0, #0
    a508:	9a0b1f23 	bls	2d219c <__etext+0x2c94f4>
    a50c:	0300000a 	movweq	r0, #10
    a510:	03f743da 	mvnseq	r4, #1744830467	; 0x68000003
    a514:	23020000 	movwcs	r0, #8192	; 0x2000
    a518:	36430a20 	strbcc	r0, [r3], -r0, lsr #20
    a51c:	43db0300 	bicsmi	r0, fp, #0
    a520:	0000002c 	andeq	r0, r0, ip, lsr #32
    a524:	0b212302 	bleq	853134 <__etext+0x84a48c>
    a528:	00000f24 	andeq	r0, r0, r4, lsr #30
    a52c:	2c43dc03 	mcrrcs	12, 0, sp, r3, cr3
    a530:	02000000 	andeq	r0, r0, #0
    a534:	270b2223 	strcs	r2, [fp, -r3, lsr #4]
    a538:	03000010 	movweq	r0, #16
    a53c:	002c43dd 	ldrdeq	r4, [ip], -sp	; <UNPREDICTABLE>
    a540:	23020000 	movwcs	r0, #8192	; 0x2000
    a544:	31420a23 	cmpcc	r2, r3, lsr #20
    a548:	de030054 	mcrle	0, 0, r0, cr3, cr4, {2}
    a54c:	00002c43 	andeq	r2, r0, r3, asr #24
    a550:	24230200 	strtcs	r0, [r3], #-512	; 0x200
    a554:	000b3a0b 	andeq	r3, fp, fp, lsl #20
    a558:	43df0300 	bicsmi	r0, pc, #0
    a55c:	0000002c 	andeq	r0, r0, ip, lsr #32
    a560:	0b252302 	bleq	953170 <__etext+0x94a4c8>
    a564:	00000b3f 	andeq	r0, r0, pc, lsr fp
    a568:	2c43e003 	mcrrcs	0, 0, lr, r3, cr3
    a56c:	02000000 	andeq	r0, r0, #0
    a570:	500a2623 	andpl	r2, sl, r3, lsr #12
    a574:	03004552 	movweq	r4, #1362	; 0x552
    a578:	002c43e1 	eoreq	r4, ip, r1, ror #7
    a57c:	23020000 	movwcs	r0, #8192	; 0x2000
    a580:	50540a27 	subspl	r0, r4, r7, lsr #20
    a584:	e203004c 	and	r0, r3, #76	; 0x4c
    a588:	00002c43 	andeq	r2, r0, r3, asr #24
    a58c:	28230200 	stmdacs	r3!, {r9}
    a590:	0045490a 	subeq	r4, r5, sl, lsl #18
    a594:	2c43e303 	mcrrcs	3, 0, lr, r3, cr3
    a598:	02000000 	andeq	r0, r0, #0
    a59c:	570a2923 	strpl	r2, [sl, -r3, lsr #18]
    a5a0:	e4030042 	str	r0, [r3], #-66	; 0x42
    a5a4:	00002c43 	andeq	r2, r0, r3, asr #24
    a5a8:	2a230200 	bcs	8cadb0 <__etext+0x8c2108>
    a5ac:	0033530a 	eorseq	r5, r3, sl, lsl #6
    a5b0:	2c43e503 	cfstr64cs	mvdx14, [r3], {3}
    a5b4:	02000000 	andeq	r0, r0, #0
    a5b8:	530a2b23 	movwpl	r2, #43811	; 0xab23
    a5bc:	e6030034 			; <UNDEFINED> instruction: 0xe6030034
    a5c0:	00002c43 	andeq	r2, r0, r3, asr #24
    a5c4:	2c230200 	sfmcs	f0, 4, [r3], #-0
    a5c8:	4c50520a 	lfmmi	f5, 2, [r0], {10}
    a5cc:	43e70300 	mvnmi	r0, #0
    a5d0:	0000002c 	andeq	r0, r0, ip, lsr #32
    a5d4:	0b2d2302 	bleq	b531e4 <__etext+0xb4a53c>
    a5d8:	00000f1e 	andeq	r0, r0, lr, lsl pc
    a5dc:	2c43e803 	mcrrcs	8, 0, lr, r3, cr3
    a5e0:	02000000 	andeq	r0, r0, #0
    a5e4:	430a2e23 	movwmi	r2, #44579	; 0xae23
    a5e8:	03005750 	movweq	r5, #1872	; 0x750
    a5ec:	002c43e9 	eoreq	r4, ip, r9, ror #7
    a5f0:	23020000 	movwcs	r0, #8192	; 0x2000
    a5f4:	10070b2f 	andne	r0, r7, pc, lsr #22
    a5f8:	ea030000 	b	ca600 <__etext+0xc1958>
    a5fc:	00002c43 	andeq	r2, r0, r3, asr #24
    a600:	30230200 	eorcc	r0, r3, r0, lsl #4
    a604:	000e040b 	andeq	r0, lr, fp, lsl #8
    a608:	43eb0300 	mvnmi	r0, #0
    a60c:	0000002c 	andeq	r0, r0, ip, lsr #32
    a610:	00312302 	eorseq	r2, r1, r2, lsl #6
    a614:	000c030c 	andeq	r0, ip, ip, lsl #6
    a618:	43ec0300 	mvnmi	r0, #0
    a61c:	000009d2 	ldrdeq	r0, [r0], -r2
    a620:	09d8040d 	ldmibeq	r8, {r0, r2, r3, sl}^
    a624:	e10e0000 	mrs	r0, (UNDEF: 14)
    a628:	03000006 	movweq	r0, #6
    a62c:	00000483 	andeq	r0, r0, r3, lsl #9
    a630:	00371b04 	eorseq	r1, r7, r4, lsl #22
    a634:	e0030000 	and	r0, r3, r0
    a638:	04000012 	streq	r0, [r0], #-18
    a63c:	0000451c 	andeq	r4, r0, ip, lsl r5
    a640:	1d7b0300 	ldclne	3, cr0, [fp, #-0]
    a644:	1d040000 	stcne	0, cr0, [r4, #-0]
    a648:	0000005e 	andeq	r0, r0, lr, asr r0
    a64c:	69040402 	stmdbvs	r4, {r1, sl}
    a650:	02000006 	andeq	r0, r0, #6
    a654:	0a870408 	beq	fe1cb67c <__StackLimit+0xde1cb67c>
    a658:	c8030000 	stmdagt	r3, {}	; <UNPREDICTABLE>
    a65c:	0400000d 	streq	r0, [r0], #-13
    a660:	0000372e 	andeq	r3, r0, lr, lsr #14
    a664:	0f351400 	svceq	0x00351400
    a668:	05010000 	streq	r0, [r1, #-0]
    a66c:	000cae0f 	andeq	sl, ip, pc, lsl #28
    a670:	0cc20600 	stcleq	6, cr0, [r2], {0}
    a674:	06000000 	streq	r0, [r0], -r0
    a678:	00000cc7 	andeq	r0, r0, r7, asr #25
    a67c:	0ccc0601 	stcleq	6, cr0, [ip], {1}
    a680:	06020000 	streq	r0, [r2], -r0
    a684:	00000cd1 	ldrdeq	r0, [r0], -r1
    a688:	0cd60603 	ldcleq	6, cr0, [r6], {3}
    a68c:	06040000 	streq	r0, [r4], -r0
    a690:	00000cdb 	ldrdeq	r0, [r0], -fp
    a694:	0ce00605 	stcleq	6, cr0, [r0], #20
    a698:	06060000 	streq	r0, [r6], -r0
    a69c:	00000ce5 	andeq	r0, r0, r5, ror #25
    a6a0:	0cea0607 	stcleq	6, cr0, [sl], #28
    a6a4:	06080000 	streq	r0, [r8], -r0
    a6a8:	00000cef 	andeq	r0, r0, pc, ror #25
    a6ac:	0e5f0609 	cdpeq	6, 5, cr0, cr15, cr9, {0}
    a6b0:	060a0000 	streq	r0, [sl], -r0
    a6b4:	00000e65 	andeq	r0, r0, r5, ror #28
    a6b8:	0e6b060b 	cdpeq	6, 6, cr0, cr11, cr11, {0}
    a6bc:	060c0000 	streq	r0, [ip], -r0
    a6c0:	00000e71 	andeq	r0, r0, r1, ror lr
    a6c4:	0e77060d 	cdpeq	6, 7, cr0, cr7, cr13, {0}
    a6c8:	060e0000 	streq	r0, [lr], -r0
    a6cc:	00000e7d 	andeq	r0, r0, sp, ror lr
    a6d0:	0e83060f 	cdpeq	6, 8, cr0, cr3, cr15, {0}
    a6d4:	06100000 	ldreq	r0, [r0], -r0
    a6d8:	00000e89 	andeq	r0, r0, r9, lsl #29
    a6dc:	0e8f0611 	mcreq	6, 4, r0, cr15, cr1, {0}
    a6e0:	06120000 	ldreq	r0, [r2], -r0
    a6e4:	00000b7d 	andeq	r0, r0, sp, ror fp
    a6e8:	0efa0613 	mrceq	6, 7, r0, cr10, cr3, {0}
    a6ec:	06180000 	ldreq	r0, [r8], -r0
    a6f0:	00000f00 	andeq	r0, r0, r0, lsl #30
    a6f4:	0f060619 	svceq	0x00060619
    a6f8:	061a0000 	ldreq	r0, [sl], -r0
    a6fc:	00000f0c 	andeq	r0, r0, ip, lsl #30
    a700:	0f12061b 	svceq	0x0012061b
    a704:	061c0000 	ldreq	r0, [ip], -r0
    a708:	00000f18 	andeq	r0, r0, r8, lsl pc
    a70c:	0d59061d 	ldcleq	6, cr0, [r9, #-116]	; 0xffffff8c
    a710:	06200000 	strteq	r0, [r0], -r0
    a714:	00000d5e 	andeq	r0, r0, lr, asr sp
    a718:	0d630621 	stcleq	6, cr0, [r3, #-132]!	; 0xffffff7c
    a71c:	06220000 	strteq	r0, [r2], -r0
    a720:	00000d68 	andeq	r0, r0, r8, ror #26
    a724:	0d6d0623 	stcleq	6, cr0, [sp, #-140]!	; 0xffffff74
    a728:	06240000 	strteq	r0, [r4], -r0
    a72c:	00000d72 	andeq	r0, r0, r2, ror sp
    a730:	0d770625 	ldcleq	6, cr0, [r7, #-148]!	; 0xffffff6c
    a734:	06260000 	strteq	r0, [r6], -r0
    a738:	00000d7c 	andeq	r0, r0, ip, ror sp
    a73c:	0d810627 	stceq	6, cr0, [r1, #156]	; 0x9c
    a740:	06280000 	strteq	r0, [r8], -r0
    a744:	00000d86 	andeq	r0, r0, r6, lsl #27
    a748:	10bb0629 	adcsne	r0, fp, r9, lsr #12
    a74c:	062a0000 	strteq	r0, [sl], -r0
    a750:	000010c1 	andeq	r1, r0, r1, asr #1
    a754:	10c7062b 	sbcne	r0, r7, fp, lsr #12
    a758:	06300000 	ldrteq	r0, [r0], -r0
    a75c:	000010cd 	andeq	r1, r0, sp, asr #1
    a760:	10d30631 	sbcsne	r0, r3, r1, lsr r6
    a764:	06320000 	ldrteq	r0, [r2], -r0
    a768:	000010d9 	ldrdeq	r1, [r0], -r9
    a76c:	0b830633 	bleq	fe0cc040 <__StackLimit+0xde0cc040>
    a770:	06340000 	ldrteq	r0, [r4], -r0
    a774:	00000b89 	andeq	r0, r0, r9, lsl #23
    a778:	0b8f0635 	bleq	fe3cc054 <__StackLimit+0xde3cc054>
    a77c:	06360000 	ldrteq	r0, [r6], -r0
    a780:	00000b95 	muleq	r0, r5, fp
    a784:	0dd00637 	ldcleq	6, cr0, [r0, #220]	; 0xdc
    a788:	063c0000 	ldrteq	r0, [ip], -r0
    a78c:	00000dd5 	ldrdeq	r0, [r0], -r5
    a790:	0dda063d 	ldcleq	6, cr0, [sl, #244]	; 0xf4
    a794:	063e0000 	ldrteq	r0, [lr], -r0
    a798:	00000ddf 	ldrdeq	r0, [r0], -pc	; <UNPREDICTABLE>
    a79c:	0de4063f 	stcleq	6, cr0, [r4, #252]!	; 0xfc
    a7a0:	00c00000 	sbceq	r0, r0, r0
    a7a4:	000de906 	andeq	lr, sp, r6, lsl #18
    a7a8:	0600c100 	streq	ip, [r0], -r0, lsl #2
    a7ac:	00000dee 	andeq	r0, r0, lr, ror #27
    a7b0:	f30600c2 	vhadd.u8	q0, q11, q1
    a7b4:	c300000d 	movwgt	r0, #13
    a7b8:	0e5a0600 	cdpeq	6, 5, cr0, cr10, cr0, {0}
    a7bc:	00c40000 	sbceq	r0, r4, r0
    a7c0:	000df806 	andeq	pc, sp, r6, lsl #16
    a7c4:	0600c500 	streq	ip, [r0], -r0, lsl #10
    a7c8:	00000d0b 	andeq	r0, r0, fp, lsl #26
    a7cc:	110600c6 	smlabtne	r6, r6, r0, r0
    a7d0:	c700000d 	strgt	r0, [r0, -sp]
    a7d4:	0d170600 	ldceq	6, cr0, [r7, #-0]
    a7d8:	00c80000 	sbceq	r0, r8, r0
    a7dc:	000d1d06 	andeq	r1, sp, r6, lsl #26
    a7e0:	0600c900 	streq	ip, [r0], -r0, lsl #18
    a7e4:	00000ee9 	andeq	r0, r0, r9, ror #29
    a7e8:	ef0600ca 	svc	0x000600ca
    a7ec:	cb00000e 	blgt	a82c <__etext+0x1b84>
    a7f0:	0d410600 	stcleq	6, cr0, [r1, #-0]
    a7f4:	00cc0000 	sbceq	r0, ip, r0
    a7f8:	000d4706 	andeq	r4, sp, r6, lsl #14
    a7fc:	0600cd00 	streq	ip, [r0], -r0, lsl #26
    a800:	00000d4d 	andeq	r0, r0, sp, asr #26
    a804:	530600ce 	movwpl	r0, #24782	; 0x60ce
    a808:	cf00000d 	svcgt	0x0000000d
    a80c:	0e150600 	cfmsub32eq	mvax0, mvfx0, mvfx5, mvfx0
    a810:	00dc0000 	sbcseq	r0, ip, r0
    a814:	000e1a06 	andeq	r1, lr, r6, lsl #20
    a818:	0600dd00 	streq	sp, [r0], -r0, lsl #26
    a81c:	00000e1f 	andeq	r0, r0, pc, lsl lr
    a820:	240600de 	strcs	r0, [r6], #-222	; 0xde
    a824:	df00000e 	svcle	0x0000000e
    a828:	0e290600 	cfmadda32eq	mvax0, mvax0, mvfx9, mvfx0
    a82c:	00e00000 	rsceq	r0, r0, r0
    a830:	000e2e06 	andeq	r2, lr, r6, lsl #28
    a834:	0600e100 	streq	lr, [r0], -r0, lsl #2
    a838:	00000e33 	andeq	r0, r0, r3, lsr lr
    a83c:	380600e2 	stmdacc	r6, {r1, r5, r6, r7}
    a840:	e300000e 	movw	r0, #14
    a844:	0e3d0600 	cfmsuba32eq	mvax0, mvax0, mvfx13, mvfx0
    a848:	00e40000 	rsceq	r0, r4, r0
    a84c:	000e4206 	andeq	r4, lr, r6, lsl #4
    a850:	0600e500 	streq	lr, [r0], -r0, lsl #10
    a854:	00000f7f 	andeq	r0, r0, pc, ror pc
    a858:	850600e6 	strhi	r0, [r6, #-230]	; 0xe6
    a85c:	e700000f 	str	r0, [r0, -pc]
    a860:	0f8b0600 	svceq	0x008b0600
    a864:	00e80000 	rsceq	r0, r8, r0
    a868:	000f9106 	andeq	r9, pc, r6, lsl #2
    a86c:	0600e900 	streq	lr, [r0], -r0, lsl #18
    a870:	00000d93 	muleq	r0, r3, sp
    a874:	990600ea 	stmdbls	r6, {r1, r3, r5, r6, r7}
    a878:	eb00000d 	bl	a8b4 <__etext+0x1c0c>
    a87c:	0ea70600 	cdpeq	6, 10, cr0, cr7, cr0, {0}
    a880:	00fc0000 	rscseq	r0, ip, r0
    a884:	000eac06 	andeq	sl, lr, r6, lsl #24
    a888:	0600fd00 	streq	pc, [r0], -r0, lsl #26
    a88c:	00000eb1 			; <UNDEFINED> instruction: 0x00000eb1
    a890:	b60600fe 			; <UNDEFINED> instruction: 0xb60600fe
    a894:	ff00000e 			; <UNDEFINED> instruction: 0xff00000e
    a898:	0ebb0600 	cdpeq	6, 11, cr0, cr11, cr0, {0}
    a89c:	01800000 	orreq	r0, r0, r0
    a8a0:	000ec006 	andeq	ip, lr, r6
    a8a4:	06018100 	streq	r8, [r1], -r0, lsl #2
    a8a8:	00000ec5 	andeq	r0, r0, r5, asr #29
    a8ac:	ca060182 	bgt	18aebc <__etext+0x182214>
    a8b0:	8300000e 	movwhi	r0, #14
    a8b4:	0ecf0601 	cdpeq	6, 12, cr0, cr15, cr1, {0}
    a8b8:	01840000 	orreq	r0, r4, r0
    a8bc:	000ed406 	andeq	sp, lr, r6, lsl #8
    a8c0:	06018500 	streq	r8, [r1], -r0, lsl #10
    a8c4:	00000bdc 	ldrdeq	r0, [r0], -ip
    a8c8:	e2060186 	and	r0, r6, #-2147483615	; 0x80000021
    a8cc:	8700000b 	strhi	r0, [r0, -fp]
    a8d0:	0c390601 	ldceq	6, cr0, [r9], #-4
    a8d4:	01880000 	orreq	r0, r8, r0
    a8d8:	000cfc06 	andeq	pc, ip, r6, lsl #24
    a8dc:	06019400 	streq	r9, [r1], -r0, lsl #8
    a8e0:	00000c3f 	andeq	r0, r0, pc, lsr ip
    a8e4:	45060195 	strmi	r0, [r6, #-405]	; 0x195
    a8e8:	9600000c 	strls	r0, [r0], -ip
    a8ec:	0c4b0601 	mcrreq	6, 0, r0, fp, cr1
    a8f0:	01970000 	orrseq	r0, r7, r0
    a8f4:	000c5106 	andeq	r5, ip, r6, lsl #2
    a8f8:	00019800 	andeq	r9, r1, r0, lsl #16
    a8fc:	00106703 	andseq	r6, r0, r3, lsl #14
    a900:	17450500 	strbne	r0, [r5, -r0, lsl #10]
    a904:	0d00000a 	stceq	0, cr0, [r0, #-40]	; 0xffffffd8
    a908:	000cbf04 	andeq	fp, ip, r4, lsl #30
    a90c:	0d011500 	cfstr32eq	mvfx1, [r1, #-0]
    a910:	000cc704 	andeq	ip, ip, r4, lsl #14
    a914:	08010200 	stmdaeq	r1, {r9}
    a918:	00000712 	andeq	r0, r0, r2, lsl r7
    a91c:	000ca403 	andeq	sl, ip, r3, lsl #8
    a920:	b9150600 	ldmdblt	r5, {r9, sl}
    a924:	1600000c 	strne	r0, [r0], -ip
    a928:	52180614 	andspl	r0, r8, #20971520	; 0x1400000
    a92c:	1700000d 	strne	r0, [r0, -sp]
    a930:	00000db1 			; <UNDEFINED> instruction: 0x00000db1
    a934:	09c62206 	stmibeq	r6, {r1, r2, r9, sp}^
    a938:	23020000 	movwcs	r0, #8192	; 0x2000
    a93c:	0f551700 	svceq	0x00551700
    a940:	2c060000 	stccs	0, cr0, [r6], {-0}
    a944:	000009f3 	strdeq	r0, [r0], -r3
    a948:	17042302 	strne	r2, [r4, -r2, lsl #6]
    a94c:	0000100c 	andeq	r1, r0, ip
    a950:	0cae3b06 	vstmiaeq	lr!, {d3-d5}
    a954:	23020000 	movwcs	r0, #8192	; 0x2000
    a958:	0e471708 	cdpeq	7, 4, cr1, cr7, cr8, {0}
    a95c:	4a060000 	bmi	18a964 <__etext+0x181cbc>
    a960:	00000cae 	andeq	r0, r0, lr, lsr #25
    a964:	17092302 	strne	r2, [r9, -r2, lsl #6]
    a968:	00000fdb 	ldrdeq	r0, [r0], -fp
    a96c:	0a0c5506 	beq	31fd8c <__etext+0x3170e4>
    a970:	23020000 	movwcs	r0, #8192	; 0x2000
    a974:	0f6e170a 	svceq	0x006e170a
    a978:	60060000 	andvs	r0, r6, r0
    a97c:	00000a0c 	andeq	r0, r0, ip, lsl #20
    a980:	170b2302 	strne	r2, [fp, -r2, lsl #6]
    a984:	00000d9f 	muleq	r0, pc, sp	; <UNPREDICTABLE>
    a988:	0cce6a06 	vstmiaeq	lr, {s13-s18}
    a98c:	23020000 	movwcs	r0, #8192	; 0x2000
    a990:	0f63170c 	svceq	0x0063170c
    a994:	74060000 	strvc	r0, [r6], #-0
    a998:	00000cce 	andeq	r0, r0, lr, asr #25
    a99c:	00102302 	andseq	r2, r0, r2, lsl #6
    a9a0:	000c9303 	andeq	r9, ip, r3, lsl #6
    a9a4:	d9750600 	ldmdble	r5!, {r9, sl}^
    a9a8:	1800000c 	stmdane	r0, {r2, r3}
    a9ac:	002d0601 	eoreq	r0, sp, r1, lsl #12
    a9b0:	011d0100 	tsteq	sp, r0, lsl #2
    a9b4:	0000733c 	andeq	r7, r0, ip, lsr r3
    a9b8:	00007816 	andeq	r7, r0, r6, lsl r8
    a9bc:	00001d88 	andeq	r1, r0, r8, lsl #27
    a9c0:	000e1c01 	andeq	r1, lr, r1, lsl #24
    a9c4:	2d9b1900 	ldccs	9, cr1, [fp]
    a9c8:	1d010000 	stcne	0, cr0, [r1, #-0]
    a9cc:	00000d52 	andeq	r0, r0, r2, asr sp
    a9d0:	1a709102 	bne	1c2ede0 <__etext+0x1c26138>
    a9d4:	00726273 	rsbseq	r6, r2, r3, ror r2
    a9d8:	09e81f01 	stmibeq	r8!, {r0, r8, r9, sl, fp, ip}^
    a9dc:	54010000 	strpl	r0, [r1], #-0
    a9e0:	002d011b 	eoreq	r0, sp, fp, lsl r1
    a9e4:	e81f0100 	ldmda	pc, {r8}	; <UNPREDICTABLE>
    a9e8:	01000009 	tsteq	r0, r9
    a9ec:	2e2c1b54 	mcrcs	11, 1, r1, cr12, cr4, {2}
    a9f0:	20010000 	andcs	r0, r1, r0
    a9f4:	000009f3 	strdeq	r0, [r0], -r3
    a9f8:	1b649102 	blne	192ee08 <__etext+0x1926160>
    a9fc:	00000f42 	andeq	r0, r0, r2, asr #30
    aa00:	09dd2101 	ldmibeq	sp, {r0, r8, sp}^
    aa04:	91020000 	mrsls	r0, (UNDEF: 2)
    aa08:	00781a4b 	rsbseq	r1, r8, fp, asr #20
    aa0c:	09dd2101 	ldmibeq	sp, {r0, r8, sp}^
    aa10:	91020000 	mrsls	r0, (UNDEF: 2)
    aa14:	2de41b63 	stclcs	11, cr1, [r4, #396]!	; 0x18c
    aa18:	22010000 	andcs	r0, r1, #0
    aa1c:	000009c6 	andeq	r0, r0, r6, asr #19
    aa20:	1b5c9102 	blne	172ee30 <__etext+0x1726188>
    aa24:	00002d4e 	andeq	r2, r0, lr, asr #26
    aa28:	09f32301 	ldmibeq	r3!, {r0, r8, r9, sp}^
    aa2c:	91020000 	mrsls	r0, (UNDEF: 2)
    aa30:	2d271b58 	vstmdbcs	r7!, {d1-<overflow reg d44>}
    aa34:	24010000 	strcs	r0, [r1], #-0
    aa38:	00000cae 	andeq	r0, r0, lr, lsr #25
    aa3c:	1b579102 	blne	15eee4c <__etext+0x15e61a4>
    aa40:	00002e45 	andeq	r2, r0, r5, asr #28
    aa44:	0cae2501 	cfstr32eq	mvfx2, [lr], #4
    aa48:	91020000 	mrsls	r0, (UNDEF: 2)
    aa4c:	2ddd1b56 	vldrcs	d17, [sp, #344]	; 0x158
    aa50:	26010000 	strcs	r0, [r1], -r0
    aa54:	00000cce 	andeq	r0, r0, lr, asr #25
    aa58:	1b509102 	blne	142ee68 <__etext+0x14261c0>
    aa5c:	00002e6c 	andeq	r2, r0, ip, ror #28
    aa60:	0cce2701 	stcleq	7, cr2, [lr], {1}
    aa64:	91020000 	mrsls	r0, (UNDEF: 2)
    aa68:	011c004c 	tsteq	ip, ip, asr #32
    aa6c:	00002d15 	andeq	r2, r0, r5, lsl sp
    aa70:	2501dc01 	strcs	sp, [r1, #-3073]	; 0xc01
    aa74:	18000000 	stmdane	r0, {}	; <UNPREDICTABLE>
    aa78:	46000078 			; <UNDEFINED> instruction: 0x46000078
    aa7c:	cc000078 	stcgt	0, cr0, [r0], {120}	; 0x78
    aa80:	0100001d 	tsteq	r0, sp, lsl r0
    aa84:	00000e49 	andeq	r0, r0, r9, asr #28
    aa88:	002de419 	eoreq	lr, sp, r9, lsl r4
    aa8c:	c6dc0100 	ldrbgt	r0, [ip], r0, lsl #2
    aa90:	02000009 	andeq	r0, r0, #9
    aa94:	1c007491 	cfstrsne	mvf7, [r0], {145}	; 0x91
    aa98:	002d6a01 	eoreq	r6, sp, r1, lsl #20
    aa9c:	01f70100 	mvnseq	r0, r0, lsl #2
    aaa0:	00000073 	andeq	r0, r0, r3, ror r0
    aaa4:	00007848 	andeq	r7, r0, r8, asr #16
    aaa8:	00007866 	andeq	r7, r0, r6, ror #16
    aaac:	00001e04 	andeq	r1, r0, r4, lsl #28
    aab0:	000e7601 	andeq	r7, lr, r1, lsl #12
    aab4:	2de41900 	stclcs	9, cr1, [r4]
    aab8:	f7010000 			; <UNDEFINED> instruction: 0xf7010000
    aabc:	000009c6 	andeq	r0, r0, r6, asr #19
    aac0:	00749102 	rsbseq	r9, r4, r2, lsl #2
    aac4:	2e33011d 	mrccs	1, 1, r0, cr3, cr13, {0}
    aac8:	0f010000 	svceq	0x00010000
    aacc:	78680101 	stmdavc	r8!, {r0, r8}^
    aad0:	78940000 	ldmvc	r4, {}	; <UNPREDICTABLE>
    aad4:	1e3c0000 	cdpne	0, 3, cr0, cr12, cr0, {0}
    aad8:	af010000 	svcge	0x00010000
    aadc:	1e00000e 	cdpne	0, 0, cr0, cr0, cr14, {0}
    aae0:	00002de4 	andeq	r2, r0, r4, ror #27
    aae4:	c6010f01 	strgt	r0, [r1], -r1, lsl #30
    aae8:	02000009 	andeq	r0, r0, #9
    aaec:	631f7491 	tstvs	pc, #-1862270976	; 0x91000000
    aaf0:	0f010068 	svceq	0x00010068
    aaf4:	00002501 	andeq	r2, r0, r1, lsl #10
    aaf8:	73910200 	orrsvc	r0, r1, #0
    aafc:	4c012000 	stcmi	0, cr2, [r1], {-0}
    ab00:	0100002e 	tsteq	r0, lr, lsr #32
    ab04:	9401012c 	strls	r0, [r1], #-300	; 0x12c
    ab08:	da000078 	ble	acf0 <__etext+0x2048>
    ab0c:	74000078 	strvc	r0, [r0], #-120	; 0x78
    ab10:	0100001e 	tsteq	r0, lr, lsl r0
    ab14:	00000ef7 	strdeq	r0, [r0], -r7
    ab18:	002de41e 	eoreq	lr, sp, lr, lsl r4
    ab1c:	012c0100 	teqeq	ip, r0, lsl #2
    ab20:	000009c6 	andeq	r0, r0, r6, asr #19
    ab24:	1f749102 	svcne	0x00749102
    ab28:	01006863 	tsteq	r0, r3, ror #16
    ab2c:	0cc1012c 	stfeqe	f0, [r1], {44}	; 0x2c
    ab30:	91020000 	mrsls	r0, (UNDEF: 2)
    ab34:	656c1f70 	strbvs	r1, [ip, #-3952]!	; 0xf70
    ab38:	2c01006e 	stccs	0, cr0, [r1], {110}	; 0x6e
    ab3c:	00007301 	andeq	r7, r0, r1, lsl #6
    ab40:	6c910200 	lfmvs	f0, 4, [r1], {0}
    ab44:	ea012000 	b	52b4c <__etext+0x49ea4>
    ab48:	0100002d 	tsteq	r0, sp, lsr #32
    ab4c:	dc010140 	stfles	f0, [r1], {64}	; 0x40
    ab50:	82000078 	andhi	r0, r0, #120	; 0x78
    ab54:	ac000079 	stcge	0, cr0, [r0], {121}	; 0x79
    ab58:	0100001e 	tsteq	r0, lr, lsl r0
    ab5c:	00000f22 	andeq	r0, r0, r2, lsr #30
    ab60:	002d9b1e 	eoreq	r9, sp, lr, lsl fp
    ab64:	01400100 	mrseq	r0, (UNDEF: 80)
    ab68:	00000d52 	andeq	r0, r0, r2, asr sp
    ab6c:	00709102 	rsbseq	r9, r0, r2, lsl #2
    ab70:	2d2e0120 	stfcss	f0, [lr, #-128]!	; 0xffffff80
    ab74:	68010000 	stmdavs	r1, {}	; <UNPREDICTABLE>
    ab78:	79840101 	stmibvc	r4, {r0, r8}
    ab7c:	7a2a0000 	bvc	a8ab84 <__etext+0xa81edc>
    ab80:	1ee40000 	cdpne	0, 14, cr0, cr4, cr0, {0}
    ab84:	4d010000 	stcmi	0, cr0, [r1, #-0]
    ab88:	1e00000f 	cdpne	0, 0, cr0, cr0, cr15, {0}
    ab8c:	00002d9b 	muleq	r0, fp, sp
    ab90:	52016801 	andpl	r6, r1, #65536	; 0x10000
    ab94:	0200000d 	andeq	r0, r0, #13
    ab98:	21007091 	swpcs	r7, r1, [r0]
    ab9c:	002cea01 	eoreq	lr, ip, r1, lsl #20
    aba0:	017b0100 	cmneq	fp, r0, lsl #2
    aba4:	007a2c01 	rsbseq	r2, sl, r1, lsl #24
    aba8:	007a9a00 	rsbseq	r9, sl, r0, lsl #20
    abac:	001f1c00 	andseq	r1, pc, r0, lsl #24
    abb0:	01210100 	teqeq	r1, r0, lsl #2
    abb4:	00002d84 	andeq	r2, r0, r4, lsl #27
    abb8:	01018b01 	tsteq	r1, r1, lsl #22
    abbc:	00007a9c 	muleq	r0, ip, sl
    abc0:	00007b0a 	andeq	r7, r0, sl, lsl #22
    abc4:	00001f48 	andeq	r1, r0, r8, asr #30
    abc8:	fe012101 	cdp2	1, 0, cr2, cr1, cr1, {0}
    abcc:	0100002d 	tsteq	r0, sp, lsr #32
    abd0:	0c01019b 	stfeqs	f0, [r1], {155}	; 0x9b
    abd4:	7a00007b 	bvc	adc8 <__etext+0x2120>
    abd8:	7400007b 	strvc	r0, [r0], #-123	; 0x7b
    abdc:	0100001f 	tsteq	r0, pc, lsl r0
    abe0:	2daf0121 	stfcss	f0, [pc, #132]!	; ac6c <__etext+0x1fc4>
    abe4:	aa010000 	bge	4abec <__etext+0x41f44>
    abe8:	7b7c0101 	blvc	1f0aff4 <__etext+0x1f0234c>
    abec:	7bea0000 	blvc	ffa8abf4 <__StackLimit+0xdfa8abf4>
    abf0:	1fa00000 	svcne	0x00a00000
    abf4:	21010000 	mrscs	r0, (UNDEF: 1)
    abf8:	002d5301 	eoreq	r5, sp, r1, lsl #6
    abfc:	01b90100 			; <UNDEFINED> instruction: 0x01b90100
    ac00:	007bec01 	rsbseq	lr, fp, r1, lsl #24
    ac04:	007c5a00 	rsbseq	r5, ip, r0, lsl #20
    ac08:	001fcc00 	andseq	ip, pc, r0, lsl #24
    ac0c:	01210100 	teqeq	r1, r0, lsl #2
    ac10:	00002dc6 	andeq	r2, r0, r6, asr #27
    ac14:	0101c801 	tsteq	r1, r1, lsl #16
    ac18:	00007c5c 	andeq	r7, r0, ip, asr ip
    ac1c:	00007cca 	andeq	r7, r0, sl, asr #25
    ac20:	00001ff8 	strdeq	r1, [r0], -r8
    ac24:	0fce2201 	svceq	0x00ce2201
    ac28:	1f070000 	svcne	0x00070000
    ac2c:	000009f3 	strdeq	r0, [r0], -r3
    ac30:	f7220101 			; <UNDEFINED> instruction: 0xf7220101
    ac34:	0700000b 	streq	r0, [r0, -fp]
    ac38:	0009f320 	andeq	pc, r9, r0, lsr #6
    ac3c:	07010100 	streq	r0, [r1, -r0, lsl #2]
    ac40:	00000cce 	andeq	r0, r0, lr, asr #25
    ac44:	00001001 	andeq	r1, r0, r1
    ac48:	0003a008 	andeq	sl, r3, r8
    ac4c:	23000500 	movwcs	r0, #1280	; 0x500
    ac50:	00002e61 	andeq	r2, r0, r1, ror #28
    ac54:	0ff10c01 	svceq	0x00f10c01
    ac58:	05010000 	streq	r0, [r1, #-0]
    ac5c:	ff16e003 			; <UNDEFINED> instruction: 0xff16e003
    ac60:	2d43231f 	stclcs	3, cr2, [r3, #-124]	; 0xffffff84
    ac64:	0e010000 	cdpeq	0, 0, cr0, cr1, cr0, {0}
    ac68:	00000ff1 	strdeq	r0, [r0], -r1
    ac6c:	c8030501 	stmdagt	r3, {r0, r8, sl}
    ac70:	001fff16 	andseq	pc, pc, r6, lsl pc	; <UNPREDICTABLE>
    ac74:	00000419 	andeq	r0, r0, r9, lsl r4
    ac78:	1a0f0002 	bne	3cac88 <__etext+0x3c1fe0>
    ac7c:	01040000 	mrseq	r0, (UNDEF: 4)
    ac80:	00000234 	andeq	r0, r0, r4, lsr r2
    ac84:	002e8801 	eoreq	r8, lr, r1, lsl #16
    ac88:	00082700 	andeq	r2, r8, r0, lsl #14
    ac8c:	007ccc00 	rsbseq	ip, ip, r0, lsl #24
    ac90:	007d1e00 	rsbseq	r1, sp, r0, lsl #28
    ac94:	001d0900 	andseq	r0, sp, r0, lsl #18
    ac98:	06010200 	streq	r0, [r1], -r0, lsl #4
    ac9c:	0000070b 	andeq	r0, r0, fp, lsl #14
    aca0:	0009dd03 	andeq	sp, r9, r3, lsl #26
    aca4:	372a0300 	strcc	r0, [sl, -r0, lsl #6]!
    aca8:	02000000 	andeq	r0, r0, #0
    acac:	07090801 	streq	r0, [r9, -r1, lsl #16]
    acb0:	02020000 	andeq	r0, r2, #0
    acb4:	00073b05 	andeq	r3, r7, r5, lsl #22
    acb8:	07020200 	streq	r0, [r2, -r0, lsl #4]
    acbc:	00000492 	muleq	r0, r2, r4
    acc0:	96050402 	strls	r0, [r5], -r2, lsl #8
    acc4:	02000001 	andeq	r0, r0, #1
    acc8:	01e40704 	mvneq	r0, r4, lsl #14
    accc:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
    acd0:	00019105 	andeq	r9, r1, r5, lsl #2
    acd4:	07080200 	streq	r0, [r8, -r0, lsl #4]
    acd8:	000001df 	ldrdeq	r0, [r0], -pc	; <UNPREDICTABLE>
    acdc:	69050404 	stmdbvs	r5, {r2, sl}
    ace0:	0200746e 	andeq	r7, r0, #1845493760	; 0x6e000000
    ace4:	01e90704 	mvneq	r0, r4, lsl #14
    ace8:	04020000 	streq	r0, [r2], #-0
    acec:	00057407 	andeq	r7, r5, r7, lsl #8
    acf0:	002c0500 	eoreq	r0, ip, r0, lsl #10
    acf4:	008d0000 	addeq	r0, sp, r0
    acf8:	76060000 	strvc	r0, [r6], -r0
    acfc:	00000000 	andeq	r0, r0, r0
    ad00:	02010700 	andeq	r0, r1, #0
    ad04:	00af43d2 	ldrdeq	r4, [pc], r2	; <UNPREDICTABLE>
    ad08:	23080000 	movwcs	r0, #32768	; 0x8000
    ad0c:	0200000d 	andeq	r0, r0, #13
    ad10:	002c43d3 	ldrdeq	r4, [ip], -r3	; <UNPREDICTABLE>
    ad14:	32080000 	andcc	r0, r8, #0
    ad18:	0200000d 	andeq	r0, r0, #13
    ad1c:	002c43d4 	ldrdeq	r4, [ip], -r4	; <UNPREDICTABLE>
    ad20:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
    ad24:	0000102c 	andeq	r1, r0, ip, lsr #32
    ad28:	43b60232 			; <UNDEFINED> instruction: 0x43b60232
    ad2c:	00000394 	muleq	r0, r4, r3
    ad30:	4844420a 	stmdami	r4, {r1, r3, r9, lr}^
    ad34:	43b70200 			; <UNDEFINED> instruction: 0x43b70200
    ad38:	0000002c 	andeq	r0, r0, ip, lsr #32
    ad3c:	0a002302 	beq	1394c <__etext+0xaca4>
    ad40:	004c4442 	subeq	r4, ip, r2, asr #8
    ad44:	2c43b802 	mcrrcs	8, 0, fp, r3, cr2
    ad48:	02000000 	andeq	r0, r0, #0
    ad4c:	430a0123 	movwmi	r0, #41251	; 0xa123
    ad50:	b9020031 	stmdblt	r2, {r0, r4, r5}
    ad54:	00002c43 	andeq	r2, r0, r3, asr #24
    ad58:	02230200 	eoreq	r0, r3, #0
    ad5c:	0032430a 	eorseq	r4, r2, sl, lsl #6
    ad60:	2c43ba02 	mcrrcs	10, 0, fp, r3, cr2
    ad64:	02000000 	andeq	r0, r0, #0
    ad68:	530a0323 	movwpl	r0, #41763	; 0xa323
    ad6c:	bb020031 	bllt	8ae38 <__etext+0x82190>
    ad70:	00002c43 	andeq	r2, r0, r3, asr #24
    ad74:	04230200 	strteq	r0, [r3], #-512	; 0x200
    ad78:	0032530a 	eorseq	r5, r2, sl, lsl #6
    ad7c:	2c43bc02 	mcrrcs	12, 0, fp, r3, cr2
    ad80:	02000000 	andeq	r0, r0, #0
    ad84:	430a0523 	movwmi	r0, #42275	; 0xa523
    ad88:	bd020033 	stclt	0, cr0, [r2, #-204]	; 0xffffff34
    ad8c:	00002c43 	andeq	r2, r0, r3, asr #24
    ad90:	06230200 	strteq	r0, [r3], -r0, lsl #4
    ad94:	0200440a 	andeq	r4, r0, #167772160	; 0xa000000
    ad98:	002c43be 			; <UNDEFINED> instruction: 0x002c43be
    ad9c:	23020000 	movwcs	r0, #8192	; 0x2000
    ada0:	414d0a07 	cmpmi	sp, r7, lsl #20
    ada4:	bf020031 	svclt	0x00020031
    ada8:	00002c43 	andeq	r2, r0, r3, asr #24
    adac:	08230200 	stmdaeq	r3!, {r9}
    adb0:	32414d0a 	subcc	r4, r1, #640	; 0x280
    adb4:	43c00200 	bicmi	r0, r0, #0
    adb8:	0000002c 	andeq	r0, r0, ip, lsr #32
    adbc:	0a092302 	beq	2539cc <__etext+0x24ad24>
    adc0:	02003443 	andeq	r3, r0, #1124073472	; 0x43000000
    adc4:	002c43c1 	eoreq	r4, ip, r1, asr #7
    adc8:	23020000 	movwcs	r0, #8192	; 0x2000
    adcc:	35430a0a 	strbcc	r0, [r3, #-2570]	; 0xa0a
    add0:	43c20200 	bicmi	r0, r2, #0
    add4:	0000002c 	andeq	r0, r0, ip, lsr #32
    add8:	0a0b2302 	beq	2d39e8 <__etext+0x2cad40>
    addc:	02004445 	andeq	r4, r0, #1157627904	; 0x45000000
    ade0:	002c43c3 	eoreq	r4, ip, r3, asr #7
    ade4:	23020000 	movwcs	r0, #8192	; 0x2000
    ade8:	0c570b0c 	mrrceq	11, 0, r0, r7, cr12
    adec:	c4020000 	strgt	r0, [r2], #-0
    adf0:	00002c43 	andeq	r2, r0, r3, asr #24
    adf4:	0d230200 	sfmeq	f0, 4, [r3, #-0]
    adf8:	0052490a 	subseq	r4, r2, sl, lsl #18
    adfc:	2c43c502 	cfstr64cs	mvdx12, [r3], {2}
    ae00:	02000000 	andeq	r0, r0, #0
    ae04:	120b0e23 	andne	r0, fp, #560	; 0x230
    ae08:	02000003 	andeq	r0, r0, #3
    ae0c:	007d43c6 	rsbseq	r4, sp, r6, asr #7
    ae10:	23020000 	movwcs	r0, #8192	; 0x2000
    ae14:	0bb50b0f 	bleq	fed4da58 <__StackLimit+0xded4da58>
    ae18:	c7020000 	strgt	r0, [r2, -r0]
    ae1c:	00002c43 	andeq	r2, r0, r3, asr #24
    ae20:	10230200 	eorne	r0, r3, r0, lsl #4
    ae24:	000f980b 	andeq	r9, pc, fp, lsl #16
    ae28:	43c80200 	bicmi	r0, r8, #0
    ae2c:	0000002c 	andeq	r0, r0, ip, lsr #32
    ae30:	0b112302 	bleq	453a40 <__etext+0x44ad98>
    ae34:	00000b77 	andeq	r0, r0, r7, ror fp
    ae38:	2c43c902 	mcrrcs	9, 0, ip, r3, cr2
    ae3c:	02000000 	andeq	r0, r0, #0
    ae40:	a80b1223 	stmdage	fp, {r0, r1, r5, r9, ip}
    ae44:	0200000b 	andeq	r0, r0, #11
    ae48:	002c43ca 	eoreq	r4, ip, sl, asr #7
    ae4c:	23020000 	movwcs	r0, #8192	; 0x2000
    ae50:	0b9b0b13 	bleq	fe6cdaa4 <__StackLimit+0xde6cdaa4>
    ae54:	cb020000 	blgt	8ae5c <__etext+0x821b4>
    ae58:	00002c43 	andeq	r2, r0, r3, asr #24
    ae5c:	14230200 	strtne	r0, [r3], #-512	; 0x200
    ae60:	000fb30b 	andeq	fp, pc, fp, lsl #6
    ae64:	43cc0200 	bicmi	r0, ip, #0
    ae68:	0000002c 	andeq	r0, r0, ip, lsr #32
    ae6c:	0b152302 	bleq	553a7c <__etext+0x54add4>
    ae70:	00000f97 	muleq	r0, r7, pc	; <UNPREDICTABLE>
    ae74:	2c43cd02 	mcrrcs	13, 0, ip, r3, cr2
    ae78:	02000000 	andeq	r0, r0, #0
    ae7c:	1d0b1623 	stcne	6, cr1, [fp, #-140]	; 0xffffff74
    ae80:	02000003 	andeq	r0, r0, #3
    ae84:	007d43ce 	rsbseq	r4, sp, lr, asr #7
    ae88:	23020000 	movwcs	r0, #8192	; 0x2000
    ae8c:	0fc80b17 	svceq	0x00c80b17
    ae90:	cf020000 	svcgt	0x00020000
    ae94:	00002c43 	andeq	r2, r0, r3, asr #24
    ae98:	18230200 	stmdane	r3!, {r9}
    ae9c:	000c5d0b 	andeq	r5, ip, fp, lsl #26
    aea0:	43d00200 	bicsmi	r0, r0, #0
    aea4:	0000002c 	andeq	r0, r0, ip, lsr #32
    aea8:	0b192302 	bleq	653ab8 <__etext+0x64ae10>
    aeac:	000010a9 	andeq	r1, r0, r9, lsr #1
    aeb0:	2c43d102 	stfcsp	f5, [r3], {2}
    aeb4:	02000000 	andeq	r0, r0, #0
    aeb8:	8d0c1a23 	vstrhi	s2, [ip, #-140]	; 0xffffff74
    aebc:	02000000 	andeq	r0, r0, #0
    aec0:	320b1b23 	andcc	r1, fp, #35840	; 0x8c00
    aec4:	0200000c 	andeq	r0, r0, #12
    aec8:	002c43d6 	ldrdeq	r4, [ip], -r6	; <UNPREDICTABLE>
    aecc:	23020000 	movwcs	r0, #8192	; 0x2000
    aed0:	0b520b1c 	bleq	148db48 <__etext+0x1484ea0>
    aed4:	d7020000 	strle	r0, [r2, -r0]
    aed8:	00002c43 	andeq	r2, r0, r3, asr #24
    aedc:	1d230200 	sfmne	f0, 4, [r3, #-0]
    aee0:	000be80b 	andeq	lr, fp, fp, lsl #16
    aee4:	43d80200 	bicsmi	r0, r8, #0
    aee8:	0000002c 	andeq	r0, r0, ip, lsr #32
    aeec:	0b1e2302 	bleq	793afc <__etext+0x78ae54>
    aef0:	00000bd5 	ldrdeq	r0, [r0], -r5
    aef4:	2c43d902 	mcrrcs	9, 0, sp, r3, cr2
    aef8:	02000000 	andeq	r0, r0, #0
    aefc:	9a0b1f23 	bls	2d2b90 <__etext+0x2c9ee8>
    af00:	0200000a 	andeq	r0, r0, #10
    af04:	007d43da 	ldrsbteq	r4, [sp], #-58	; 0xffffffc6
    af08:	23020000 	movwcs	r0, #8192	; 0x2000
    af0c:	36430a20 	strbcc	r0, [r3], -r0, lsr #20
    af10:	43db0200 	bicsmi	r0, fp, #0
    af14:	0000002c 	andeq	r0, r0, ip, lsr #32
    af18:	0b212302 	bleq	853b28 <__etext+0x84ae80>
    af1c:	00000f24 	andeq	r0, r0, r4, lsr #30
    af20:	2c43dc02 	mcrrcs	12, 0, sp, r3, cr2
    af24:	02000000 	andeq	r0, r0, #0
    af28:	270b2223 	strcs	r2, [fp, -r3, lsr #4]
    af2c:	02000010 	andeq	r0, r0, #16
    af30:	002c43dd 	ldrdeq	r4, [ip], -sp	; <UNPREDICTABLE>
    af34:	23020000 	movwcs	r0, #8192	; 0x2000
    af38:	31420a23 	cmpcc	r2, r3, lsr #20
    af3c:	de020054 	mcrle	0, 0, r0, cr2, cr4, {2}
    af40:	00002c43 	andeq	r2, r0, r3, asr #24
    af44:	24230200 	strtcs	r0, [r3], #-512	; 0x200
    af48:	000b3a0b 	andeq	r3, fp, fp, lsl #20
    af4c:	43df0200 	bicsmi	r0, pc, #0
    af50:	0000002c 	andeq	r0, r0, ip, lsr #32
    af54:	0b252302 	bleq	953b64 <__etext+0x94aebc>
    af58:	00000b3f 	andeq	r0, r0, pc, lsr fp
    af5c:	2c43e002 	mcrrcs	0, 0, lr, r3, cr2
    af60:	02000000 	andeq	r0, r0, #0
    af64:	500a2623 	andpl	r2, sl, r3, lsr #12
    af68:	02004552 	andeq	r4, r0, #343932928	; 0x14800000
    af6c:	002c43e1 	eoreq	r4, ip, r1, ror #7
    af70:	23020000 	movwcs	r0, #8192	; 0x2000
    af74:	50540a27 	subspl	r0, r4, r7, lsr #20
    af78:	e202004c 	and	r0, r2, #76	; 0x4c
    af7c:	00002c43 	andeq	r2, r0, r3, asr #24
    af80:	28230200 	stmdacs	r3!, {r9}
    af84:	0045490a 	subeq	r4, r5, sl, lsl #18
    af88:	2c43e302 	mcrrcs	3, 0, lr, r3, cr2
    af8c:	02000000 	andeq	r0, r0, #0
    af90:	570a2923 	strpl	r2, [sl, -r3, lsr #18]
    af94:	e4020042 	str	r0, [r2], #-66	; 0x42
    af98:	00002c43 	andeq	r2, r0, r3, asr #24
    af9c:	2a230200 	bcs	8cb7a4 <__etext+0x8c2afc>
    afa0:	0033530a 	eorseq	r5, r3, sl, lsl #6
    afa4:	2c43e502 	cfstr64cs	mvdx14, [r3], {2}
    afa8:	02000000 	andeq	r0, r0, #0
    afac:	530a2b23 	movwpl	r2, #43811	; 0xab23
    afb0:	e6020034 			; <UNDEFINED> instruction: 0xe6020034
    afb4:	00002c43 	andeq	r2, r0, r3, asr #24
    afb8:	2c230200 	sfmcs	f0, 4, [r3], #-0
    afbc:	4c50520a 	lfmmi	f5, 2, [r0], {10}
    afc0:	43e70200 	mvnmi	r0, #0
    afc4:	0000002c 	andeq	r0, r0, ip, lsr #32
    afc8:	0b2d2302 	bleq	b53bd8 <__etext+0xb4af30>
    afcc:	00000f1e 	andeq	r0, r0, lr, lsl pc
    afd0:	2c43e802 	mcrrcs	8, 0, lr, r3, cr2
    afd4:	02000000 	andeq	r0, r0, #0
    afd8:	430a2e23 	movwmi	r2, #44579	; 0xae23
    afdc:	02005750 	andeq	r5, r0, #20971520	; 0x1400000
    afe0:	002c43e9 	eoreq	r4, ip, r9, ror #7
    afe4:	23020000 	movwcs	r0, #8192	; 0x2000
    afe8:	10070b2f 	andne	r0, r7, pc, lsr #22
    afec:	ea020000 	b	8aff4 <__etext+0x8234c>
    aff0:	00002c43 	andeq	r2, r0, r3, asr #24
    aff4:	30230200 	eorcc	r0, r3, r0, lsl #4
    aff8:	000e040b 	andeq	r0, lr, fp, lsl #8
    affc:	43eb0200 	mvnmi	r0, #0
    b000:	0000002c 	andeq	r0, r0, ip, lsr #32
    b004:	00312302 	eorseq	r2, r1, r2, lsl #6
    b008:	000c030d 	andeq	r0, ip, sp, lsl #6
    b00c:	43ec0200 	mvnmi	r0, #0
    b010:	000003a0 	andeq	r0, r0, r0, lsr #7
    b014:	03a6040e 			; <UNDEFINED> instruction: 0x03a6040e
    b018:	af0f0000 	svcge	0x000f0000
    b01c:	02000000 	andeq	r0, r0, #0
    b020:	06690404 	strbteq	r0, [r9], -r4, lsl #8
    b024:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
    b028:	000a8704 	andeq	r8, sl, r4, lsl #14
    b02c:	08010200 	stmdaeq	r1, {r9}
    b030:	00000712 	andeq	r0, r0, r2, lsl r7
    b034:	2e730110 	mrccs	1, 3, r0, cr3, cr0, {0}
    b038:	1d010000 	stcne	0, cr0, [r1, #-0]
    b03c:	00002501 	andeq	r2, r0, r1, lsl #10
    b040:	007ccc00 	rsbseq	ip, ip, r0, lsl #24
    b044:	007ce200 	rsbseq	lr, ip, r0, lsl #4
    b048:	00202400 	eoreq	r2, r0, r0, lsl #8
    b04c:	01110100 	tsteq	r1, r0, lsl #2
    b050:	00002e9e 	muleq	r0, lr, lr
    b054:	e4012201 	str	r2, [r1], #-513	; 0x201
    b058:	0800007c 	stmdaeq	r0, {r2, r3, r4, r5, r6}
    b05c:	5000007d 	andpl	r0, r0, sp, ror r0
    b060:	01000020 	tsteq	r0, r0, lsr #32
    b064:	00000402 	andeq	r0, r0, r2, lsl #8
    b068:	00686312 	rsbeq	r6, r8, r2, lsl r3
    b06c:	00252201 	eoreq	r2, r5, r1, lsl #4
    b070:	91020000 	mrsls	r0, (UNDEF: 2)
    b074:	01100077 	tsteq	r0, r7, ror r0
    b078:	00002e7b 	andeq	r2, r0, fp, ror lr
    b07c:	68012701 	stmdavs	r1, {r0, r8, r9, sl, sp}
    b080:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    b084:	1e00007d 	mcrne	0, 0, r0, cr0, cr13, {3}
    b088:	8800007d 	stmdahi	r0, {r0, r2, r3, r4, r5, r6}
    b08c:	01000020 	tsteq	r0, r0, lsr #32
    b090:	00051700 	andeq	r1, r5, r0, lsl #14
    b094:	08000200 	stmdaeq	r0, {r9}
    b098:	0400001b 	streq	r0, [r0], #-27
    b09c:	00023401 	andeq	r3, r2, r1, lsl #8
    b0a0:	2f490100 	svccs	0x00490100
    b0a4:	08270000 	stmdaeq	r7!, {}	; <UNPREDICTABLE>
    b0a8:	7d200000 	stcvc	0, cr0, [r0, #-0]
    b0ac:	86740000 	ldrbthi	r0, [r4], -r0
    b0b0:	1e010000 	cdpne	0, 0, cr0, cr1, cr0, {0}
    b0b4:	01020000 	mrseq	r0, (UNDEF: 2)
    b0b8:	00070b06 	andeq	r0, r7, r6, lsl #22
    b0bc:	08010200 	stmdaeq	r1, {r9}
    b0c0:	00000709 	andeq	r0, r0, r9, lsl #14
    b0c4:	3b050202 	blcc	14b8d4 <__etext+0x142c2c>
    b0c8:	02000007 	andeq	r0, r0, #7
    b0cc:	04920702 	ldreq	r0, [r2], #1794	; 0x702
    b0d0:	04020000 	streq	r0, [r2], #-0
    b0d4:	00019605 	andeq	r9, r1, r5, lsl #12
    b0d8:	07040200 	streq	r0, [r4, -r0, lsl #4]
    b0dc:	000001e4 	andeq	r0, r0, r4, ror #3
    b0e0:	91050802 	tstls	r5, r2, lsl #16
    b0e4:	02000001 	andeq	r0, r0, #1
    b0e8:	01df0708 	bicseq	r0, pc, r8, lsl #14
    b0ec:	04030000 	streq	r0, [r3], #-0
    b0f0:	746e6905 	strbtvc	r6, [lr], #-2309	; 0x905
    b0f4:	07040200 	streq	r0, [r4, -r0, lsl #4]
    b0f8:	000001e9 	andeq	r0, r0, r9, ror #3
    b0fc:	74070402 	strvc	r0, [r7], #-1026	; 0x402
    b100:	04000005 	streq	r0, [r0], #-5
    b104:	00000483 	andeq	r0, r0, r3, lsl #9
    b108:	002c1b02 	eoreq	r1, ip, r2, lsl #22
    b10c:	7b040000 	blvc	10b114 <__etext+0x10246c>
    b110:	0200001d 	andeq	r0, r0, #29
    b114:	0000481d 	andeq	r4, r0, sp, lsl r8
    b118:	04040200 	streq	r0, [r4], #-512	; 0x200
    b11c:	00000669 	andeq	r0, r0, r9, ror #12
    b120:	87040802 	strhi	r0, [r4, -r2, lsl #16]
    b124:	0400000a 	streq	r0, [r0], #-10
    b128:	00002f9f 	muleq	r0, pc, pc	; <UNPREDICTABLE>
    b12c:	00a12803 	adceq	r2, r1, r3, lsl #16
    b130:	ec050000 	stc	0, cr0, [r5], {-0}
    b134:	0400002e 	streq	r0, [r0], #-46	; 0x2e
    b138:	00bb0005 	adcseq	r0, fp, r5
    b13c:	2e060000 	cdpcs	0, 0, cr0, cr6, cr0, {0}
    b140:	bb00002f 	bllt	b204 <__etext+0x255c>
    b144:	02000000 	andeq	r0, r0, #0
    b148:	00010023 	andeq	r0, r1, r3, lsr #32
    b14c:	04080407 	streq	r0, [r8], #-1031	; 0x407
    b150:	000000c3 	andeq	r0, r0, r3, asr #1
    b154:	12080102 	andne	r0, r8, #-2147483648	; 0x80000000
    b158:	08000007 	stmdaeq	r0, {r0, r1, r2}
    b15c:	0000d004 	andeq	sp, r0, r4
    b160:	00c30900 	sbceq	r0, r3, r0, lsl #18
    b164:	ee040000 	cdp	0, 0, cr0, cr4, cr0, {0}
    b168:	0300002e 	movweq	r0, #46	; 0x2e
    b16c:	00009666 	andeq	r9, r0, r6, ror #12
    b170:	010c0a00 	tsteq	ip, r0, lsl #20
    b174:	0001131d 	andeq	r1, r1, sp, lsl r3
    b178:	2ec60b00 	vdivcs.f64	d16, d6, d0
    b17c:	1f010000 	svcne	0x00010000
    b180:	0000005d 	andeq	r0, r0, sp, asr r0
    b184:	0b002302 	bleq	13d94 <__etext+0xb0ec>
    b188:	00001787 	andeq	r1, r0, r7, lsl #15
    b18c:	011f2001 	tsteq	pc, r1
    b190:	23020000 	movwcs	r0, #8192	; 0x2000
    b194:	6f6c0c04 	svcvs	0x006c0c04
    b198:	21010063 	tstcs	r1, r3, rrx
    b19c:	00000125 	andeq	r0, r0, r5, lsr #2
    b1a0:	00082302 	andeq	r2, r8, r2, lsl #6
    b1a4:	011f010d 	tsteq	pc, sp, lsl #2
    b1a8:	250e0000 	strcs	r0, [lr, #-0]
    b1ac:	00000000 	andeq	r0, r0, r0
    b1b0:	01130408 	tsteq	r3, r8, lsl #8
    b1b4:	04080000 	streq	r0, [r8], #-0
    b1b8:	00000025 	andeq	r0, r0, r5, lsr #32
    b1bc:	002f1504 	eoreq	r1, pc, r4, lsl #10
    b1c0:	e0220100 	eor	r0, r2, r0, lsl #2
    b1c4:	0f000000 	svceq	0x00000000
    b1c8:	00002f3d 	andeq	r2, r0, sp, lsr pc
    b1cc:	20015501 	andcs	r5, r1, r1, lsl #10
    b1d0:	7800007d 	stmdavc	r0, {r0, r2, r3, r4, r5, r6}
    b1d4:	b400007d 	strlt	r0, [r0], #-125	; 0x7d
    b1d8:	01000020 	tsteq	r0, r0, lsr #32
    b1dc:	00000178 	andeq	r0, r0, r8, ror r1
    b1e0:	01006310 	tsteq	r0, r0, lsl r3
    b1e4:	00005d55 	andeq	r5, r0, r5, asr sp
    b1e8:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    b1ec:	0011fe11 	andseq	pc, r1, r1, lsl lr	; <UNPREDICTABLE>
    b1f0:	78550100 	ldmdavc	r5, {r8}^
    b1f4:	02000001 	andeq	r0, r0, #1
    b1f8:	85117091 	ldrhi	r7, [r1, #-145]	; 0x91
    b1fc:	0100002f 	tsteq	r0, pc, lsr #32
    b200:	00017e55 	andeq	r7, r1, r5, asr lr
    b204:	6c910200 	lfmvs	f0, 4, [r1], {0}
    b208:	5d040800 	stcpl	8, cr0, [r4, #-0]
    b20c:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    b210:	00012b04 	andeq	r2, r1, r4, lsl #22
    b214:	2f8a1200 	svccs	0x008a1200
    b218:	67010000 	strvs	r0, [r1, -r0]
    b21c:	00005d01 	andeq	r5, r0, r1, lsl #26
    b220:	007d7800 	rsbseq	r7, sp, r0, lsl #16
    b224:	007e9600 	rsbseq	r9, lr, r0, lsl #12
    b228:	0020ec00 	eoreq	lr, r0, r0, lsl #24
    b22c:	024c0100 	subeq	r0, ip, #0
    b230:	93110000 	tstls	r1, #0
    b234:	0100002f 	tsteq	r0, pc, lsr #32
    b238:	00012567 	andeq	r2, r1, r7, ror #10
    b23c:	54910200 	ldrpl	r0, [r1], #512	; 0x200
    b240:	002ee111 	eoreq	lr, lr, r1, lsl r1
    b244:	bb670100 	bllt	19cb64c <__etext+0x19c29a4>
    b248:	02000000 	andeq	r0, r0, #0
    b24c:	6e105091 	mrcvs	0, 0, r5, cr0, cr1, {4}
    b250:	01006765 	tsteq	r0, r5, ror #14
    b254:	00005d67 	andeq	r5, r0, r7, ror #26
    b258:	4c910200 	lfmmi	f0, 4, [r1], {0}
    b25c:	002f2111 	eoreq	r2, pc, r1, lsl r1	; <UNPREDICTABLE>
    b260:	5d670100 	stfple	f0, [r7, #-0]
    b264:	02000000 	andeq	r0, r0, #0
    b268:	61134891 			; <UNDEFINED> instruction: 0x61134891
    b26c:	5d690100 	stfple	f0, [r9, #-0]
    b270:	02000000 	andeq	r0, r0, #0
    b274:	62137491 	andsvs	r7, r3, #-1862270976	; 0x91000000
    b278:	5d690100 	stfple	f0, [r9, #-0]
    b27c:	02000000 	andeq	r0, r0, #0
    b280:	63135c91 	tstvs	r3, #37120	; 0x9100
    b284:	5d690100 	stfple	f0, [r9, #-0]
    b288:	02000000 	andeq	r0, r0, #0
    b28c:	75137091 	ldrvc	r7, [r3, #-145]	; 0x91
    b290:	6a010061 	bvs	4b41c <__etext+0x42774>
    b294:	0000007d 	andeq	r0, r0, sp, ror r0
    b298:	136c9102 	cmnne	ip, #-2147483648	; 0x80000000
    b29c:	01006275 	tsteq	r0, r5, ror r2
    b2a0:	00007d6a 	andeq	r7, r0, sl, ror #26
    b2a4:	58910200 	ldmpl	r1, {r9}
    b2a8:	00637513 	rsbeq	r7, r3, r3, lsl r5
    b2ac:	007d6a01 	rsbseq	r6, sp, r1, lsl #20
    b2b0:	91020000 	mrsls	r0, (UNDEF: 2)
    b2b4:	2ed71468 	cdpcs	4, 13, cr1, cr7, cr8, {3}
    b2b8:	6c010000 	stcvs	0, cr0, [r1], {-0}
    b2bc:	0000005d 	andeq	r0, r0, sp, asr r0
    b2c0:	14649102 	strbtne	r9, [r4], #-258	; 0x102
    b2c4:	00002ec0 	andeq	r2, r0, r0, asr #29
    b2c8:	01256d01 	teqeq	r5, r1, lsl #26
    b2cc:	91020000 	mrsls	r0, (UNDEF: 2)
    b2d0:	2f0b1560 	svccs	0x000b1560
    b2d4:	a7010000 	strge	r0, [r1, -r0]
    b2d8:	00007e88 	andeq	r7, r0, r8, lsl #29
    b2dc:	2f750f00 	svccs	0x00750f00
    b2e0:	ac010000 	stcge	0, cr0, [r1], {-0}
    b2e4:	007e9801 	rsbseq	r9, lr, r1, lsl #16
    b2e8:	007ed000 	rsbseq	sp, lr, r0
    b2ec:	00212400 	eoreq	r2, r1, r0, lsl #8
    b2f0:	02aa0100 	adceq	r0, sl, #0
    b2f4:	27110000 	ldrcs	r0, [r1, -r0]
    b2f8:	0100002f 	tsteq	r0, pc, lsr #32
    b2fc:	00005dac 	andeq	r5, r0, ip, lsr #27
    b300:	6c910200 	lfmvs	f0, 4, [r1], {0}
    b304:	002ecb11 	eoreq	ip, lr, r1, lsl fp
    b308:	5dac0100 	stfpls	f0, [ip]
    b30c:	02000000 	andeq	r0, r0, #0
    b310:	fe116891 	mrc2	8, 0, r6, cr1, cr1, {4}
    b314:	01000011 	tsteq	r0, r1, lsl r0
    b318:	000178ac 	andeq	r7, r1, ip, lsr #17
    b31c:	64910200 	ldrvs	r0, [r1], #512	; 0x200
    b320:	002f8511 	eoreq	r8, pc, r1, lsl r5	; <UNPREDICTABLE>
    b324:	7eac0100 	fdvvce	f0, f4, f0
    b328:	02000001 	andeq	r0, r0, #1
    b32c:	69136091 	ldmdbvs	r3, {r0, r4, r7, sp, lr}
    b330:	5dae0100 	stfpls	f0, [lr]
    b334:	02000000 	andeq	r0, r0, #0
    b338:	0f007491 	svceq	0x00007491
    b33c:	00002ea7 	andeq	r2, r0, r7, lsr #29
    b340:	d001b801 	andle	fp, r1, r1, lsl #16
    b344:	0800007e 	stmdaeq	r0, {r1, r2, r3, r4, r5, r6}
    b348:	5c00007f 	stcpl	0, cr0, [r0], {127}	; 0x7f
    b34c:	01000021 	tsteq	r0, r1, lsr #32
    b350:	00000308 	andeq	r0, r0, r8, lsl #6
    b354:	002f2711 	eoreq	r2, pc, r1, lsl r7	; <UNPREDICTABLE>
    b358:	5db80100 	ldfpls	f0, [r8]
    b35c:	02000000 	andeq	r0, r0, #0
    b360:	cb116c91 	blgt	4665ac <__etext+0x45d904>
    b364:	0100002e 	tsteq	r0, lr, lsr #32
    b368:	00005db8 			; <UNDEFINED> instruction: 0x00005db8
    b36c:	68910200 	ldmvs	r1, {r9}
    b370:	0011fe11 	andseq	pc, r1, r1, lsl lr	; <UNPREDICTABLE>
    b374:	78b80100 	ldmvc	r8!, {r8}
    b378:	02000001 	andeq	r0, r0, #1
    b37c:	85116491 	ldrhi	r6, [r1, #-1169]	; 0x491
    b380:	0100002f 	tsteq	r0, pc, lsr #32
    b384:	00017eb8 			; <UNDEFINED> instruction: 0x00017eb8
    b388:	60910200 	addsvs	r0, r1, r0, lsl #4
    b38c:	01006913 	tsteq	r0, r3, lsl r9
    b390:	00005dba 			; <UNDEFINED> instruction: 0x00005dba
    b394:	74910200 	ldrvc	r0, [r1], #512	; 0x200
    b398:	f6011600 			; <UNDEFINED> instruction: 0xf6011600
    b39c:	0100002e 	tsteq	r0, lr, lsr #32
    b3a0:	005d01c3 	subseq	r0, sp, r3, asr #3
    b3a4:	7f080000 	svcvc	0x00080000
    b3a8:	85e20000 	strbhi	r0, [r2, #0]!
    b3ac:	21940000 	orrscs	r0, r4, r0
    b3b0:	4b010000 	blmi	4b3b8 <__etext+0x42710>
    b3b4:	11000004 	tstne	r0, r4
    b3b8:	00002f85 	andeq	r2, r0, r5, lsl #31
    b3bc:	017ec301 	cmneq	lr, r1, lsl #6
    b3c0:	91030000 	mrsls	r0, (UNDEF: 3)
    b3c4:	66107f94 	sadd8vs	r7, r0, r4
    b3c8:	0100746d 	tsteq	r0, sp, ror #8
    b3cc:	0000cac3 	andeq	ip, r0, r3, asr #21
    b3d0:	90910300 	addsls	r0, r1, r0, lsl #6
    b3d4:	7061107f 	rsbvc	r1, r1, pc, ror r0
    b3d8:	d5c30100 	strble	r0, [r3, #256]	; 0x100
    b3dc:	03000000 	movweq	r0, #0
    b3e0:	137f8c91 	cmnne	pc, #37120	; 0x9100
    b3e4:	c6010070 			; <UNDEFINED> instruction: 0xc6010070
    b3e8:	00000125 	andeq	r0, r0, r5, lsr #2
    b3ec:	13749102 	cmnne	r4, #-2147483648	; 0x80000000
    b3f0:	c7010063 	strgt	r0, [r1, -r3, rrx]
    b3f4:	0000005d 	andeq	r0, r0, sp, asr r0
    b3f8:	14509102 	ldrbne	r9, [r0], #-258	; 0x102
    b3fc:	00002f9a 	muleq	r0, sl, pc	; <UNPREDICTABLE>
    b400:	044bc901 	strbeq	ip, [fp], #-2305	; 0x901
    b404:	91030000 	mrsls	r0, (UNDEF: 3)
    b408:	e6147fa4 	ldr	r7, [r4], -r4, lsr #31
    b40c:	0100002e 	tsteq	r0, lr, lsr #32
    b410:	000125ca 	andeq	r2, r1, sl, asr #11
    b414:	70910200 	addsvc	r0, r1, r0, lsl #4
    b418:	002f3814 	eoreq	r3, pc, r4, lsl r8	; <UNPREDICTABLE>
    b41c:	5dcb0100 	stfple	f0, [fp]
    b420:	02000000 	andeq	r0, r0, #0
    b424:	0b146c91 	bleq	526670 <__etext+0x51d9c8>
    b428:	0100002f 	tsteq	r0, pc, lsr #32
    b42c:	00005dcd 	andeq	r5, r0, sp, asr #27
    b430:	68910200 	ldmvs	r1, {r9}
    b434:	0011fe14 	andseq	pc, r1, r4, lsl lr	; <UNPREDICTABLE>
    b438:	5dce0100 	stfple	f0, [lr]
    b43c:	03000000 	movweq	r0, #0
    b440:	147fa091 	ldrbtne	sl, [pc], #-145	; b448 <__etext+0x27a0>
    b444:	00002f63 	andeq	r2, r0, r3, ror #30
    b448:	005dd001 	subseq	sp, sp, r1
    b44c:	91020000 	mrsls	r0, (UNDEF: 2)
    b450:	2ecb1464 	cdpcs	4, 12, cr1, cr11, cr4, {3}
    b454:	d1010000 	mrsle	r0, (UNDEF: 1)
    b458:	0000005d 	andeq	r0, r0, sp, asr r0
    b45c:	14609102 	strbtne	r9, [r0], #-258	; 0x102
    b460:	00002f10 	andeq	r2, r0, r0, lsl pc
    b464:	005dd801 	subseq	sp, sp, r1, lsl #16
    b468:	91030000 	mrsls	r0, (UNDEF: 3)
    b46c:	af147f9c 	svcge	0x00147f9c
    b470:	0100002f 	tsteq	r0, pc, lsr #32
    b474:	00005dd9 	ldrdeq	r5, [r0], -r9
    b478:	5c910200 	lfmpl	f0, 4, [r1], {0}
    b47c:	002fae14 	eoreq	sl, pc, r4, lsl lr	; <UNPREDICTABLE>
    b480:	5dd90100 	ldfple	f0, [r9]
    b484:	02000000 	andeq	r0, r0, #0
    b488:	05145891 	ldreq	r5, [r4, #-2193]	; 0x891
    b48c:	0100002f 	tsteq	r0, pc, lsr #32
    b490:	000178da 	ldrdeq	r7, [r1], -sl
    b494:	48910200 	ldmmi	r1, {r9}
    b498:	002f3314 	eoreq	r3, pc, r4, lsl r3	; <UNPREDICTABLE>
    b49c:	25db0100 	ldrbcs	r0, [fp, #256]	; 0x100
    b4a0:	02000001 	andeq	r0, r0, #1
    b4a4:	bc145491 	cfldrslt	mvf5, [r4], {145}	; 0x91
    b4a8:	0100002f 	tsteq	r0, pc, lsr #32
    b4ac:	00005ddc 	ldrdeq	r5, [r0], -ip
    b4b0:	4c910200 	lfmmi	f0, 4, [r1], {0}
    b4b4:	002edc14 	eoreq	sp, lr, r4, lsl ip
    b4b8:	7ddd0100 	ldfvce	f0, [sp]
    b4bc:	03000000 	movweq	r0, #0
    b4c0:	177f9891 			; <UNDEFINED> instruction: 0x177f9891
    b4c4:	00002eb8 			; <UNDEFINED> instruction: 0x00002eb8
    b4c8:	b2021c01 	andlt	r1, r2, #256	; 0x100
    b4cc:	17000084 	strne	r0, [r0, -r4, lsl #1]
    b4d0:	00002fb5 			; <UNDEFINED> instruction: 0x00002fb5
    b4d4:	66020c01 	strvs	r0, [r2], -r1, lsl #24
    b4d8:	00000084 	andeq	r0, r0, r4, lsl #1
    b4dc:	00002518 	andeq	r2, r0, r8, lsl r5
    b4e0:	00045b00 	andeq	r5, r4, r0, lsl #22
    b4e4:	006b1900 	rsbeq	r1, fp, r0, lsl #18
    b4e8:	00200000 	eoreq	r0, r0, r0
    b4ec:	2efe0116 	mrccs	1, 7, r0, cr14, cr6, {0}
    b4f0:	b6040000 	strlt	r0, [r4], -r0
    b4f4:	00005d01 	andeq	r5, r0, r1, lsl #26
    b4f8:	0085e400 	addeq	lr, r5, r0, lsl #8
    b4fc:	00862400 	addeq	r2, r6, r0, lsl #8
    b500:	0021ce00 	eoreq	ip, r1, r0, lsl #28
    b504:	04b60100 	ldrteq	r0, [r6], #256	; 0x100
    b508:	661a0000 	ldrvs	r0, [sl], -r0
    b50c:	0100746d 	tsteq	r0, sp, ror #8
    b510:	00ca0248 	sbceq	r0, sl, r8, asr #4
    b514:	91020000 	mrsls	r0, (UNDEF: 2)
    b518:	611c1b70 	tstvs	ip, r0, ror fp
    b51c:	4a010070 	bmi	4b6e4 <__etext+0x42a3c>
    b520:	0000d502 	andeq	sp, r0, r2, lsl #10
    b524:	60910200 	addsvs	r0, r1, r0, lsl #4
    b528:	002f6e1d 	eoreq	r6, pc, sp, lsl lr	; <UNPREDICTABLE>
    b52c:	024b0100 	subeq	r0, fp, #0
    b530:	0000005d 	andeq	r0, r0, sp, asr r0
    b534:	1d649102 	stfnep	f1, [r4, #-8]!
    b538:	00002f85 	andeq	r2, r0, r5, lsl #31
    b53c:	2b024c01 	blcs	9e548 <__etext+0x958a0>
    b540:	02000001 	andeq	r0, r0, #1
    b544:	1e005491 	mcrne	4, 0, r5, cr0, cr1, {4}
    b548:	002efd01 	eoreq	pc, lr, r1, lsl #26
    b54c:	01e20400 	mvneq	r0, r0, lsl #8
    b550:	0000005d 	andeq	r0, r0, sp, asr r0
    b554:	00008624 	andeq	r8, r0, r4, lsr #12
    b558:	00008674 	andeq	r8, r0, r4, ror r6
    b55c:	00002212 	andeq	r2, r0, r2, lsl r2
    b560:	00731a01 	rsbseq	r1, r3, r1, lsl #20
    b564:	bd025e01 	stclt	14, cr5, [r2, #-4]
    b568:	02000000 	andeq	r0, r0, #0
    b56c:	661a4c91 			; <UNDEFINED> instruction: 0x661a4c91
    b570:	0100746d 	tsteq	r0, sp, ror #8
    b574:	00ca025e 	sbceq	r0, sl, lr, asr r2
    b578:	91020000 	mrsls	r0, (UNDEF: 2)
    b57c:	611c1b74 	tstvs	ip, r4, ror fp
    b580:	60010070 	andvs	r0, r1, r0, ror r0
    b584:	0000d502 	andeq	sp, r0, r2, lsl #10
    b588:	60910200 	addsvs	r0, r1, r0, lsl #4
    b58c:	002f6e1d 	eoreq	r6, pc, sp, lsl lr	; <UNPREDICTABLE>
    b590:	02610100 	rsbeq	r0, r1, #0
    b594:	0000005d 	andeq	r0, r0, sp, asr r0
    b598:	1d649102 	stfnep	f1, [r4, #-8]!
    b59c:	00002f85 	andeq	r2, r0, r5, lsl #31
    b5a0:	2b026201 	blcs	a3dac <__etext+0x9b104>
    b5a4:	02000001 	andeq	r0, r0, #1
    b5a8:	00005491 	muleq	r0, r1, r4

Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:
       0:	25011101 	strcs	r1, [r1, #-257]	; 0x101
       4:	030b130e 	movweq	r1, #45838	; 0xb30e
       8:	110e1b0e 	tstne	lr, lr, lsl #22
       c:	10011201 	andne	r1, r1, r1, lsl #4
      10:	02000006 	andeq	r0, r0, #6
      14:	0b0b0024 	bleq	2c00ac <__etext+0x2b7404>
      18:	0e030b3e 	vmoveq.16	d3[0], r0
      1c:	16030000 	strne	r0, [r3], -r0
      20:	3a0e0300 	bcc	380c28 <__etext+0x377f80>
      24:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
      28:	04000013 	streq	r0, [r0], #-19
      2c:	0b0b0024 	bleq	2c00c4 <__etext+0x2b741c>
      30:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
      34:	04050000 	streq	r0, [r5], #-0
      38:	3a0b0b01 	bcc	2c2c44 <__etext+0x2b9f9c>
      3c:	010b3b0b 	tsteq	fp, fp, lsl #22
      40:	06000013 			; <UNDEFINED> instruction: 0x06000013
      44:	0e030028 	cdpeq	0, 0, cr0, cr3, cr8, {1}
      48:	00000d1c 	andeq	r0, r0, ip, lsl sp
      4c:	49010107 	stmdbmi	r1, {r0, r1, r2, r8}
      50:	00130113 	andseq	r0, r3, r3, lsl r1
      54:	00210800 	eoreq	r0, r1, r0, lsl #16
      58:	0b2f1349 	bleq	bc4d84 <__etext+0xbbc0dc>
      5c:	17090000 	strne	r0, [r9, -r0]
      60:	3a0b0b01 	bcc	2c2c6c <__etext+0x2b9fc4>
      64:	01053b0b 	tsteq	r5, fp, lsl #22
      68:	0a000013 	beq	bc <__vector_table+0xbc>
      6c:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
      70:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
      74:	00001349 	andeq	r1, r0, r9, asr #6
      78:	0b01130b 	bleq	44cac <__etext+0x3c004>
      7c:	3b0b3a0b 	blcc	2ce8b0 <__etext+0x2c5c08>
      80:	00130105 	andseq	r0, r3, r5, lsl #2
      84:	000d0c00 	andeq	r0, sp, r0, lsl #24
      88:	0b3a0e03 	bleq	e8389c <__etext+0xe7abf4>
      8c:	1349053b 	movtne	r0, #38203	; 0x953b
      90:	00000a38 	andeq	r0, r0, r8, lsr sl
      94:	49000d0d 	stmdbmi	r0, {r0, r2, r3, r8, sl, fp}
      98:	000a3813 	andeq	r3, sl, r3, lsl r8
      9c:	000d0e00 	andeq	r0, sp, r0, lsl #28
      a0:	0b3a0803 	bleq	e820b4 <__etext+0xe7940c>
      a4:	1349053b 	movtne	r0, #38203	; 0x953b
      a8:	00000a38 	andeq	r0, r0, r8, lsr sl
      ac:	0301130f 	movweq	r1, #4879	; 0x130f
      b0:	3a050b0e 	bcc	142cf0 <__etext+0x13a048>
      b4:	01053b0b 	tsteq	r5, fp, lsl #22
      b8:	10000013 	andne	r0, r0, r3, lsl r0
      bc:	13490021 	movtne	r0, #36897	; 0x9021
      c0:	0000052f 	andeq	r0, r0, pc, lsr #10
      c4:	03001611 	movweq	r1, #1553	; 0x611
      c8:	3b0b3a0e 	blcc	2ce908 <__etext+0x2c5c60>
      cc:	00134905 	andseq	r4, r3, r5, lsl #18
      d0:	000f1200 	andeq	r1, pc, r0, lsl #4
      d4:	13490b0b 	movtne	r0, #39691	; 0x9b0b
      d8:	35130000 	ldrcc	r0, [r3, #-0]
      dc:	00134900 	andseq	r4, r3, r0, lsl #18
      e0:	01131400 	tsteq	r3, r0, lsl #8
      e4:	0b0b0e03 	bleq	2c38f8 <__etext+0x2bac50>
      e8:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
      ec:	00001301 	andeq	r1, r0, r1, lsl #6
      f0:	27001515 	smladcs	r0, r5, r5, r1
      f4:	1600000c 	strne	r0, [r0], -ip
      f8:	0c3f002e 	ldceq	0, cr0, [pc], #-184	; 48 <__vector_table+0x48>
      fc:	0b3a0e03 	bleq	e83910 <__etext+0xe7ac68>
     100:	0c270b3b 	stceq	11, cr0, [r7], #-236	; 0xffffff14
     104:	01111349 	tsteq	r1, r9, asr #6
     108:	06400112 			; <UNDEFINED> instruction: 0x06400112
     10c:	000c4296 	muleq	ip, r6, r2
     110:	00341700 	eorseq	r1, r4, r0, lsl #14
     114:	0b3a0e03 	bleq	e83928 <__etext+0xe7ac80>
     118:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     11c:	0a020c3f 	beq	83220 <__etext+0x7a578>
     120:	34180000 	ldrcc	r0, [r8], #-0
     124:	3a080300 	bcc	200d2c <__etext+0x1f8084>
     128:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     12c:	020c3f13 	andeq	r3, ip, #76	; 0x4c
     130:	1900000a 	stmdbne	r0, {r1, r3}
     134:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     138:	0b3b0b3a 	bleq	ec2e28 <__etext+0xeba180>
     13c:	0c3f1349 	ldceq	3, cr1, [pc], #-292	; 20 <__vector_table+0x20>
     140:	00000c3c 	andeq	r0, r0, ip, lsr ip
     144:	01110100 	tsteq	r1, r0, lsl #2
     148:	0b130e25 	bleq	4c39e4 <__etext+0x4bad3c>
     14c:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
     150:	01120111 	tsteq	r2, r1, lsl r1
     154:	00000610 	andeq	r0, r0, r0, lsl r6
     158:	0b002402 	bleq	9168 <__etext+0x4c0>
     15c:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     160:	0300000e 	movweq	r0, #14
     164:	0b0b0024 	bleq	2c01fc <__etext+0x2b7554>
     168:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
     16c:	0f040000 	svceq	0x00040000
     170:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
     174:	05000013 	streq	r0, [r0, #-19]
     178:	0c270015 	stceq	0, cr0, [r7], #-84	; 0xffffffac
     17c:	2e060000 	cdpcs	0, 0, cr0, cr6, cr0, {0}
     180:	030c3f01 	movweq	r3, #52993	; 0xcf01
     184:	3b0b3a0e 	blcc	2ce9c4 <__etext+0x2c5d1c>
     188:	110c2705 	tstne	ip, r5, lsl #14
     18c:	40011201 	andmi	r1, r1, r1, lsl #4
     190:	0c429606 	mcrreq	6, 0, r9, r2, cr6
     194:	00001301 	andeq	r1, r0, r1, lsl #6
     198:	03003407 	movweq	r3, #1031	; 0x407
     19c:	3b0b3a08 	blcc	2ce9c4 <__etext+0x2c5d1c>
     1a0:	02134905 	andseq	r4, r3, #81920	; 0x14000
     1a4:	0800000a 	stmdaeq	r0, {r1, r3}
     1a8:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     1ac:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     1b0:	0a021349 	beq	84edc <__etext+0x7c234>
     1b4:	34090000 	strcc	r0, [r9], #-0
     1b8:	3a0e0300 	bcc	380dc0 <__etext+0x378118>
     1bc:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     1c0:	3c0c3f13 	stccc	15, cr3, [ip], {19}
     1c4:	0a00000c 	beq	1fc <__vector_table+0x1fc>
     1c8:	13490101 	movtne	r0, #37121	; 0x9101
     1cc:	00001301 	andeq	r1, r0, r1, lsl #6
     1d0:	4900210b 	stmdbmi	r0, {r0, r1, r3, r8, sp}
     1d4:	00052f13 	andeq	r2, r5, r3, lsl pc
     1d8:	00340c00 	eorseq	r0, r4, r0, lsl #24
     1dc:	0b3a0e03 	bleq	e839f0 <__etext+0xe7ad48>
     1e0:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     1e4:	0a020c3f 	beq	832e8 <__etext+0x7a640>
     1e8:	260d0000 	strcs	r0, [sp], -r0
     1ec:	00134900 	andseq	r4, r3, r0, lsl #18
     1f0:	11010000 	mrsne	r0, (UNDEF: 1)
     1f4:	130e2501 	movwne	r2, #58625	; 0xe501
     1f8:	1b0e030b 	blne	380e2c <__etext+0x378184>
     1fc:	1201110e 	andne	r1, r1, #-2147483645	; 0x80000003
     200:	00061001 	andeq	r1, r6, r1
     204:	00240200 	eoreq	r0, r4, r0, lsl #4
     208:	0b3e0b0b 	bleq	f82e3c <__etext+0xf7a194>
     20c:	00000e03 	andeq	r0, r0, r3, lsl #28
     210:	03001603 	movweq	r1, #1539	; 0x603
     214:	3b0b3a0e 	blcc	2cea54 <__etext+0x2c5dac>
     218:	0013490b 	andseq	r4, r3, fp, lsl #18
     21c:	00240400 	eoreq	r0, r4, r0, lsl #8
     220:	0b3e0b0b 	bleq	f82e54 <__etext+0xf7a1ac>
     224:	00000803 	andeq	r0, r0, r3, lsl #16
     228:	49010105 	stmdbmi	r1, {r0, r2, r8}
     22c:	00130113 	andseq	r0, r3, r3, lsl r1
     230:	00210600 	eoreq	r0, r1, r0, lsl #12
     234:	0b2f1349 	bleq	bc4f60 <__etext+0xbbc2b8>
     238:	13070000 	movwne	r0, #28672	; 0x7000
     23c:	0b0e0301 	bleq	380e48 <__etext+0x3781a0>
     240:	3b0b3a0b 	blcc	2cea74 <__etext+0x2c5dcc>
     244:	00130105 	andseq	r0, r3, r5, lsl #2
     248:	000d0800 	andeq	r0, sp, r0, lsl #16
     24c:	0b3a0803 	bleq	e82260 <__etext+0xe795b8>
     250:	1349053b 	movtne	r0, #38203	; 0x953b
     254:	00000a38 	andeq	r0, r0, r8, lsr sl
     258:	03000d09 	movweq	r0, #3337	; 0xd09
     25c:	3b0b3a0e 	blcc	2cea9c <__etext+0x2c5df4>
     260:	38134905 	ldmdacc	r3, {r0, r2, r8, fp, lr}
     264:	0a00000a 	beq	294 <__vector_table+0x294>
     268:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
     26c:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     270:	00001349 	andeq	r1, r0, r9, asr #6
     274:	0b000f0b 	bleq	3ea8 <LPLD_FTM_PinInit+0x274>
     278:	0013490b 	andseq	r4, r3, fp, lsl #18
     27c:	00350c00 	eorseq	r0, r5, r0, lsl #24
     280:	00001349 	andeq	r1, r0, r9, asr #6
     284:	0301130d 	movweq	r1, #4877	; 0x130d
     288:	3a050b0e 	bcc	142ec8 <__etext+0x13a220>
     28c:	01053b0b 	tsteq	r5, fp, lsl #22
     290:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
     294:	13490021 	movtne	r0, #36897	; 0x9021
     298:	0000052f 	andeq	r0, r0, pc, lsr #10
     29c:	0b01170f 	bleq	45ee0 <__etext+0x3d238>
     2a0:	3b0b3a0b 	blcc	2cead4 <__etext+0x2c5e2c>
     2a4:	00130105 	andseq	r0, r3, r5, lsl #2
     2a8:	000d1000 	andeq	r1, sp, r0
     2ac:	0b3a0e03 	bleq	e83ac0 <__etext+0xe7ae18>
     2b0:	1349053b 	movtne	r0, #38203	; 0x953b
     2b4:	0d110000 	ldceq	0, cr0, [r1, #-0]
     2b8:	38134900 	ldmdacc	r3, {r8, fp, lr}
     2bc:	1200000a 	andne	r0, r0, #10
     2c0:	0e030104 	adfeqs	f0, f3, f4
     2c4:	0b3a0b0b 	bleq	e82ef8 <__etext+0xe7a250>
     2c8:	13010b3b 	movwne	r0, #6971	; 0x1b3b
     2cc:	28130000 	ldmdacs	r3, {}	; <UNPREDICTABLE>
     2d0:	1c0e0300 	stcne	3, cr0, [lr], {-0}
     2d4:	1400000d 	strne	r0, [r0], #-13
     2d8:	0c270015 	stceq	0, cr0, [r7], #-84	; 0xffffffac
     2dc:	13150000 	tstne	r5, #0
     2e0:	3a0b0b01 	bcc	2c2eec <__etext+0x2ba244>
     2e4:	010b3b0b 	tsteq	fp, fp, lsl #22
     2e8:	16000013 			; <UNDEFINED> instruction: 0x16000013
     2ec:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
     2f0:	0b3b0b3a 	bleq	ec2fe0 <__etext+0xeba338>
     2f4:	0a381349 	beq	e05020 <__etext+0xdfc378>
     2f8:	2e170000 	cdpcs	0, 1, cr0, cr7, cr0, {0}
     2fc:	030c3f00 	movweq	r3, #52992	; 0xcf00
     300:	3b0b3a0e 	blcc	2ceb40 <__etext+0x2c5e98>
     304:	110c270b 	tstne	ip, fp, lsl #14
     308:	40011201 	andmi	r1, r1, r1, lsl #4
     30c:	0c429606 	mcrreq	6, 0, r9, r2, cr6
     310:	2e180000 	cdpcs	0, 1, cr0, cr8, cr0, {0}
     314:	030c3f01 	movweq	r3, #52993	; 0xcf01
     318:	3b0b3a0e 	blcc	2ceb58 <__etext+0x2c5eb0>
     31c:	110c270b 	tstne	ip, fp, lsl #14
     320:	40011201 	andmi	r1, r1, r1, lsl #4
     324:	0c429706 	mcrreq	7, 0, r9, r2, cr6
     328:	00001301 	andeq	r1, r0, r1, lsl #6
     32c:	03003419 	movweq	r3, #1049	; 0x419
     330:	3b0b3a0e 	blcc	2ceb70 <__etext+0x2c5ec8>
     334:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     338:	1a00000a 	bne	368 <__vector_table+0x368>
     33c:	08030005 	stmdaeq	r3, {r0, r2}
     340:	0b3b0b3a 	bleq	ec3030 <__etext+0xeba388>
     344:	0a021349 	beq	85070 <__etext+0x7c3c8>
     348:	341b0000 	ldrcc	r0, [fp], #-0
     34c:	3a080300 	bcc	200f54 <__etext+0x1f82ac>
     350:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     354:	000a0213 	andeq	r0, sl, r3, lsl r2
     358:	012e1c00 	teqeq	lr, r0, lsl #24
     35c:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     360:	0b3b0b3a 	bleq	ec3050 <__etext+0xeba3a8>
     364:	01110c27 	tsteq	r1, r7, lsr #24
     368:	06400112 			; <UNDEFINED> instruction: 0x06400112
     36c:	010c4296 			; <UNDEFINED> instruction: 0x010c4296
     370:	1d000013 	stcne	0, cr0, [r0, #-76]	; 0xffffffb4
     374:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     378:	0b3b0b3a 	bleq	ec3068 <__etext+0xeba3c0>
     37c:	0c3f1349 	ldceq	3, cr1, [pc], #-292	; 260 <__vector_table+0x260>
     380:	00000a02 	andeq	r0, r0, r2, lsl #20
     384:	0300341e 	movweq	r3, #1054	; 0x41e
     388:	3b0b3a0e 	blcc	2cebc8 <__etext+0x2c5f20>
     38c:	3f13490b 	svccc	0x0013490b
     390:	000c3c0c 	andeq	r3, ip, ip, lsl #24
     394:	11010000 	mrsne	r0, (UNDEF: 1)
     398:	130e2501 	movwne	r2, #58625	; 0xe501
     39c:	1b0e030b 	blne	380fd0 <__etext+0x378328>
     3a0:	1201110e 	andne	r1, r1, #-2147483645	; 0x80000003
     3a4:	00061001 	andeq	r1, r6, r1
     3a8:	00240200 	eoreq	r0, r4, r0, lsl #4
     3ac:	0b3e0b0b 	bleq	f82fe0 <__etext+0xf7a338>
     3b0:	00000e03 	andeq	r0, r0, r3, lsl #28
     3b4:	03001603 	movweq	r1, #1539	; 0x603
     3b8:	3b0b3a0e 	blcc	2cebf8 <__etext+0x2c5f50>
     3bc:	0013490b 	andseq	r4, r3, fp, lsl #18
     3c0:	00240400 	eoreq	r0, r4, r0, lsl #8
     3c4:	0b3e0b0b 	bleq	f82ff8 <__etext+0xf7a350>
     3c8:	00000803 	andeq	r0, r0, r3, lsl #16
     3cc:	0b010405 	bleq	413e8 <__etext+0x38740>
     3d0:	3b0b3a0b 	blcc	2cec04 <__etext+0x2c5f5c>
     3d4:	0013010b 	andseq	r0, r3, fp, lsl #2
     3d8:	00280600 	eoreq	r0, r8, r0, lsl #12
     3dc:	0d1c0e03 	ldceq	14, cr0, [ip, #-12]
     3e0:	01070000 	mrseq	r0, (UNDEF: 7)
     3e4:	01134901 	tsteq	r3, r1, lsl #18
     3e8:	08000013 	stmdaeq	r0, {r0, r1, r4}
     3ec:	13490021 	movtne	r0, #36897	; 0x9021
     3f0:	00000b2f 	andeq	r0, r0, pc, lsr #22
     3f4:	0b011709 	bleq	46020 <__etext+0x3d378>
     3f8:	3b0b3a0b 	blcc	2cec2c <__etext+0x2c5f84>
     3fc:	00130105 	andseq	r0, r3, r5, lsl #2
     400:	000d0a00 	andeq	r0, sp, r0, lsl #20
     404:	0b3a0e03 	bleq	e83c18 <__etext+0xe7af70>
     408:	1349053b 	movtne	r0, #38203	; 0x953b
     40c:	130b0000 	movwne	r0, #45056	; 0xb000
     410:	3a0b0b01 	bcc	2c301c <__etext+0x2ba374>
     414:	01053b0b 	tsteq	r5, fp, lsl #22
     418:	0c000013 	stceq	0, cr0, [r0], {19}
     41c:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
     420:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     424:	0a381349 	beq	e05150 <__etext+0xdfc4a8>
     428:	0d0d0000 	stceq	0, cr0, [sp, #-0]
     42c:	38134900 	ldmdacc	r3, {r8, fp, lr}
     430:	0e00000a 	cdpeq	0, 0, cr0, cr0, cr10, {0}
     434:	0803000d 	stmdaeq	r3, {r0, r2, r3}
     438:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     43c:	0a381349 	beq	e05168 <__etext+0xdfc4c0>
     440:	130f0000 	movwne	r0, #61440	; 0xf000
     444:	0b0e0301 	bleq	381050 <__etext+0x3783a8>
     448:	3b0b3a05 	blcc	2cec64 <__etext+0x2c5fbc>
     44c:	00130105 	andseq	r0, r3, r5, lsl #2
     450:	00211000 	eoreq	r1, r1, r0
     454:	052f1349 	streq	r1, [pc, #-841]!	; 113 <__vector_table+0x113>
     458:	16110000 	ldrne	r0, [r1], -r0
     45c:	3a0e0300 	bcc	381064 <__etext+0x3783bc>
     460:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     464:	12000013 	andne	r0, r0, #19
     468:	0b0b000f 	bleq	2c04ac <__etext+0x2b7804>
     46c:	00001349 	andeq	r1, r0, r9, asr #6
     470:	49003513 	stmdbmi	r0, {r0, r1, r4, r8, sl, ip, sp}
     474:	14000013 	strne	r0, [r0], #-19
     478:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
     47c:	0b3a0b0b 	bleq	e830b0 <__etext+0xe7a408>
     480:	1301053b 	movwne	r0, #5435	; 0x153b
     484:	04150000 	ldreq	r0, [r5], #-0
     488:	0b0e0301 	bleq	381094 <__etext+0x3783ec>
     48c:	3b0b3a0b 	blcc	2cecc0 <__etext+0x2c6018>
     490:	0013010b 	andseq	r0, r3, fp, lsl #2
     494:	00151600 	andseq	r1, r5, r0, lsl #12
     498:	00000c27 	andeq	r0, r0, r7, lsr #24
     49c:	0b000f17 	bleq	4100 <LPLD_FTM_PinInit+0x4cc>
     4a0:	1800000b 	stmdane	r0, {r0, r1, r3}
     4a4:	0b0b0113 	bleq	2c08f8 <__etext+0x2b7c50>
     4a8:	0b3b0b3a 	bleq	ec3198 <__etext+0xeba4f0>
     4ac:	00001301 	andeq	r1, r0, r1, lsl #6
     4b0:	03000d19 	movweq	r0, #3353	; 0xd19
     4b4:	3b0b3a0e 	blcc	2cecf4 <__etext+0x2c604c>
     4b8:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
     4bc:	1a00000a 	bne	4ec <__vector_table+0x4ec>
     4c0:	0803000d 	stmdaeq	r3, {r0, r2, r3}
     4c4:	0b3b0b3a 	bleq	ec31b4 <__etext+0xeba50c>
     4c8:	0a381349 	beq	e051f4 <__etext+0xdfc54c>
     4cc:	2e1b0000 	cdpcs	0, 1, cr0, cr11, cr0, {0}
     4d0:	030c3f01 	movweq	r3, #52993	; 0xcf01
     4d4:	3b0b3a0e 	blcc	2ced14 <__etext+0x2c606c>
     4d8:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
     4dc:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     4e0:	96064001 	strls	r4, [r6], -r1
     4e4:	13010c42 	movwne	r0, #7234	; 0x1c42
     4e8:	341c0000 	ldrcc	r0, [ip], #-0
     4ec:	3a080300 	bcc	2010f4 <__etext+0x1f844c>
     4f0:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     4f4:	000a0213 	andeq	r0, sl, r3, lsl r2
     4f8:	00341d00 	eorseq	r1, r4, r0, lsl #26
     4fc:	0b3a0e03 	bleq	e83d10 <__etext+0xe7b068>
     500:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     504:	00000a02 	andeq	r0, r0, r2, lsl #20
     508:	3f012e1e 	svccc	0x00012e1e
     50c:	3a0e030c 	bcc	381144 <__etext+0x37849c>
     510:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
     514:	1201110c 	andne	r1, r1, #3
     518:	97064001 	strls	r4, [r6, -r1]
     51c:	13010c42 	movwne	r0, #7234	; 0x1c42
     520:	2e1f0000 	cdpcs	0, 1, cr0, cr15, cr0, {0}
     524:	030c3f00 	movweq	r3, #52992	; 0xcf00
     528:	3b0b3a0e 	blcc	2ced68 <__etext+0x2c60c0>
     52c:	110c270b 	tstne	ip, fp, lsl #14
     530:	40011201 	andmi	r1, r1, r1, lsl #4
     534:	0c429606 	mcrreq	6, 0, r9, r2, cr6
     538:	05200000 	streq	r0, [r0, #-0]!
     53c:	3a080300 	bcc	201144 <__etext+0x1f849c>
     540:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     544:	000a0213 	andeq	r0, sl, r3, lsl r2
     548:	00052100 	andeq	r2, r5, r0, lsl #2
     54c:	0b3a0e03 	bleq	e83d60 <__etext+0xe7b0b8>
     550:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     554:	00000a02 	andeq	r0, r0, r2, lsl #20
     558:	3f012e22 	svccc	0x00012e22
     55c:	3a0e030c 	bcc	381194 <__etext+0x3784ec>
     560:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
     564:	1201110c 	andne	r1, r1, #3
     568:	96064001 	strls	r4, [r6], -r1
     56c:	13010c42 	movwne	r0, #7234	; 0x1c42
     570:	05230000 	streq	r0, [r3, #-0]!
     574:	3a0e0300 	bcc	38117c <__etext+0x3784d4>
     578:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     57c:	000a0213 	andeq	r0, sl, r3, lsl r2
     580:	00342400 	eorseq	r2, r4, r0, lsl #8
     584:	0b3a0803 	bleq	e82598 <__etext+0xe798f0>
     588:	1349053b 	movtne	r0, #38203	; 0x953b
     58c:	00000a02 	andeq	r0, r0, r2, lsl #20
     590:	3f002e25 	svccc	0x00002e25
     594:	3a0e030c 	bcc	3811cc <__etext+0x378524>
     598:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
     59c:	1201110c 	andne	r1, r1, #3
     5a0:	96064001 	strls	r4, [r6], -r1
     5a4:	00000c42 	andeq	r0, r0, r2, asr #24
     5a8:	03003426 	movweq	r3, #1062	; 0x426
     5ac:	3b0b3a0e 	blcc	2cedec <__etext+0x2c6144>
     5b0:	02134905 	andseq	r4, r3, #81920	; 0x14000
     5b4:	2700000a 	strcs	r0, [r0, -sl]
     5b8:	0c3f012e 	ldfeqs	f0, [pc], #-184	; 508 <__vector_table+0x508>
     5bc:	0b3a0e03 	bleq	e83dd0 <__etext+0xe7b128>
     5c0:	0c27053b 	cfstr32eq	mvfx0, [r7], #-236	; 0xffffff14
     5c4:	01120111 	tsteq	r2, r1, lsl r1
     5c8:	42970640 	addsmi	r0, r7, #67108864	; 0x4000000
     5cc:	0013010c 	andseq	r0, r3, ip, lsl #2
     5d0:	00052800 	andeq	r2, r5, r0, lsl #16
     5d4:	0b3a0803 	bleq	e825e8 <__etext+0xe79940>
     5d8:	1349053b 	movtne	r0, #38203	; 0x953b
     5dc:	00000a02 	andeq	r0, r0, r2, lsl #20
     5e0:	03003429 	movweq	r3, #1065	; 0x429
     5e4:	3b0b3a0e 	blcc	2cee24 <__etext+0x2c617c>
     5e8:	3f13490b 	svccc	0x0013490b
     5ec:	000a020c 	andeq	r0, sl, ip, lsl #4
     5f0:	00342a00 	eorseq	r2, r4, r0, lsl #20
     5f4:	0b3a0803 	bleq	e82608 <__etext+0xe79960>
     5f8:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     5fc:	0a020c3f 	beq	83700 <__etext+0x7aa58>
     600:	01000000 	mrseq	r0, (UNDEF: 0)
     604:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
     608:	0e030b13 	vmoveq.32	d3[0], r0
     60c:	01110e1b 	tsteq	r1, fp, lsl lr
     610:	06100112 			; <UNDEFINED> instruction: 0x06100112
     614:	24020000 	strcs	r0, [r2], #-0
     618:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     61c:	000e030b 	andeq	r0, lr, fp, lsl #6
     620:	00160300 	andseq	r0, r6, r0, lsl #6
     624:	0b3a0e03 	bleq	e83e38 <__etext+0xe7b190>
     628:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     62c:	24040000 	strcs	r0, [r4], #-0
     630:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     634:	0008030b 	andeq	r0, r8, fp, lsl #6
     638:	01130500 	tsteq	r3, r0, lsl #10
     63c:	0b0b0e03 	bleq	2c3e50 <__etext+0x2bb1a8>
     640:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     644:	00001301 	andeq	r1, r0, r1, lsl #6
     648:	03000d06 	movweq	r0, #3334	; 0xd06
     64c:	3b0b3a0e 	blcc	2cee8c <__etext+0x2c61e4>
     650:	38134905 	ldmdacc	r3, {r0, r2, r8, fp, lr}
     654:	0700000a 	streq	r0, [r0, -sl]
     658:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
     65c:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     660:	00001349 	andeq	r1, r0, r9, asr #6
     664:	0b000f08 	bleq	428c <LPLD_FTM_PinInit+0x658>
     668:	0013490b 	andseq	r4, r3, fp, lsl #18
     66c:	00350900 	eorseq	r0, r5, r0, lsl #18
     670:	00001349 	andeq	r1, r0, r9, asr #6
     674:	0301040a 	movweq	r0, #5130	; 0x140a
     678:	3a0b0b0e 	bcc	2c32b8 <__etext+0x2ba610>
     67c:	010b3b0b 	tsteq	fp, fp, lsl #22
     680:	0b000013 	bleq	6d4 <__vector_table+0x6d4>
     684:	0e030028 	cdpeq	0, 0, cr0, cr3, cr8, {1}
     688:	00000d1c 	andeq	r0, r0, ip, lsl sp
     68c:	2700150c 	strcs	r1, [r0, -ip, lsl #10]
     690:	0d00000c 	stceq	0, cr0, [r0, #-48]	; 0xffffffd0
     694:	0b0b0113 	bleq	2c0ae8 <__etext+0x2b7e40>
     698:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     69c:	00001301 	andeq	r1, r0, r1, lsl #6
     6a0:	3f012e0e 	svccc	0x00012e0e
     6a4:	3a0e030c 	bcc	3812dc <__etext+0x378634>
     6a8:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
     6ac:	1201110c 	andne	r1, r1, #3
     6b0:	96064001 	strls	r4, [r6], -r1
     6b4:	13010c42 	movwne	r0, #7234	; 0x1c42
     6b8:	340f0000 	strcc	r0, [pc], #-0	; 6c0 <__vector_table+0x6c0>
     6bc:	3a080300 	bcc	2012c4 <__etext+0x1f861c>
     6c0:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     6c4:	000a0213 	andeq	r0, sl, r3, lsl r2
     6c8:	012e1000 	teqeq	lr, r0
     6cc:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     6d0:	0b3b0b3a 	bleq	ec33c0 <__etext+0xeba718>
     6d4:	13490c27 	movtne	r0, #39975	; 0x9c27
     6d8:	01120111 	tsteq	r2, r1, lsl r1
     6dc:	42960640 	addsmi	r0, r6, #67108864	; 0x4000000
     6e0:	0013010c 	andseq	r0, r3, ip, lsl #2
     6e4:	00051100 	andeq	r1, r5, r0, lsl #2
     6e8:	0b3a0e03 	bleq	e83efc <__etext+0xe7b254>
     6ec:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     6f0:	00000a02 	andeq	r0, r0, r2, lsl #20
     6f4:	3f002e12 	svccc	0x00002e12
     6f8:	3a0e030c 	bcc	381330 <__etext+0x378688>
     6fc:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
     700:	1113490c 	tstne	r3, ip, lsl #18
     704:	40011201 	andmi	r1, r1, r1, lsl #4
     708:	0c429606 	mcrreq	6, 0, r9, r2, cr6
     70c:	2e130000 	cdpcs	0, 1, cr0, cr3, cr0, {0}
     710:	3a0e0300 	bcc	381318 <__etext+0x378670>
     714:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
     718:	1201110c 	andne	r1, r1, #3
     71c:	96064001 	strls	r4, [r6], -r1
     720:	00000c42 	andeq	r0, r0, r2, asr #24
     724:	03002e14 	movweq	r2, #3604	; 0xe14
     728:	3b0b3a0e 	blcc	2cef68 <__etext+0x2c62c0>
     72c:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
     730:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     734:	96064001 	strls	r4, [r6], -r1
     738:	00000c42 	andeq	r0, r0, r2, asr #24
     73c:	03012e15 	movweq	r2, #7701	; 0x1e15
     740:	3b0b3a0e 	blcc	2cef80 <__etext+0x2c62d8>
     744:	110c2705 	tstne	ip, r5, lsl #14
     748:	40011201 	andmi	r1, r1, r1, lsl #4
     74c:	0c429606 	mcrreq	6, 0, r9, r2, cr6
     750:	00001301 	andeq	r1, r0, r1, lsl #6
     754:	03000516 	movweq	r0, #1302	; 0x516
     758:	3b0b3a0e 	blcc	2cef98 <__etext+0x2c62f0>
     75c:	02134905 	andseq	r4, r3, #81920	; 0x14000
     760:	1700000a 	strne	r0, [r0, -sl]
     764:	08030034 	stmdaeq	r3, {r2, r4, r5}
     768:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     76c:	0a021349 	beq	85498 <__etext+0x7c7f0>
     770:	2e180000 	cdpcs	0, 1, cr0, cr8, cr0, {0}
     774:	3a0e0301 	bcc	381380 <__etext+0x3786d8>
     778:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
     77c:	1113490c 	tstne	r3, ip, lsl #18
     780:	40011201 	andmi	r1, r1, r1, lsl #4
     784:	0c429606 	mcrreq	6, 0, r9, r2, cr6
     788:	00001301 	andeq	r1, r0, r1, lsl #6
     78c:	03003419 	movweq	r3, #1049	; 0x419
     790:	3b0b3a0e 	blcc	2cefd0 <__etext+0x2c6328>
     794:	02134905 	andseq	r4, r3, #81920	; 0x14000
     798:	1a00000a 	bne	7c8 <__vector_table+0x7c8>
     79c:	0e03012e 	adfeqsp	f0, f3, #0.5
     7a0:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     7a4:	01110c27 	tsteq	r1, r7, lsr #24
     7a8:	06400112 			; <UNDEFINED> instruction: 0x06400112
     7ac:	000c4297 	muleq	ip, r7, r2
     7b0:	00051b00 	andeq	r1, r5, r0, lsl #22
     7b4:	0b3a0803 	bleq	e827c8 <__etext+0xe79b20>
     7b8:	1349053b 	movtne	r0, #38203	; 0x953b
     7bc:	00000a02 	andeq	r0, r0, r2, lsl #20
     7c0:	01110100 	tsteq	r1, r0, lsl #2
     7c4:	0b130e25 	bleq	4c4060 <__etext+0x4bb3b8>
     7c8:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
     7cc:	01120111 	tsteq	r2, r1, lsl r1
     7d0:	00000610 	andeq	r0, r0, r0, lsl r6
     7d4:	0b002402 	bleq	97e4 <__etext+0xb3c>
     7d8:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     7dc:	0300000e 	movweq	r0, #14
     7e0:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
     7e4:	0b3b0b3a 	bleq	ec34d4 <__etext+0xeba82c>
     7e8:	00001349 	andeq	r1, r0, r9, asr #6
     7ec:	0b002404 	bleq	9804 <__etext+0xb5c>
     7f0:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     7f4:	05000008 	streq	r0, [r0, #-8]
     7f8:	0b0b0104 	bleq	2c0c10 <__etext+0x2b7f68>
     7fc:	0b3b0b3a 	bleq	ec34ec <__etext+0xeba844>
extern GPIO_InitTypeDef OV_PTA_init;

extern char ready_send_flag;

int main (void)
{
     800:	00001301 	andeq	r1, r0, r1, lsl #6
     804:	03002806 	movweq	r2, #2054	; 0x806

    Ov7725_Init ();
     808:	000d1c0e 	andeq	r1, sp, lr, lsl #24
    Ov7725_Delay();
     80c:	01130700 	tsteq	r3, r0, lsl #14

    //Ov7725_Dma_Init();
    Ov7725_Gpio_Init ();
     810:	0b0b0e03 	bleq	2c4024 <__etext+0x2bb37c>
    dma_portx2buff_init (DMA_CH0, (void *)(&GPIOB_PDIR), (void *)img,PORTA_DMAREQ ,DMA_BYTE1, PHOTO_SIZE / 8, DADDR_KEEPON);
     814:	0b3b0b3a 	bleq	ec3504 <__etext+0xeba85c>
     818:	00001301 	andeq	r1, r0, r1, lsl #6
     81c:	03000d08 	movweq	r0, #3336	; 0xd08
     820:	3b0b3a08 	blcc	2cf048 <__etext+0x2c63a0>
     824:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
     828:	0900000a 	stmdbeq	r0, {r1, r3}
     82c:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
     830:	0b3b0b3a 	bleq	ec3520 <__etext+0xeba878>
     834:	0a381349 	beq	e05560 <__etext+0xdfc8b8>
     838:	0d0a0000 	stceq	0, cr0, [sl, #-0]
     83c:	3a0e0300 	bcc	381444 <__etext+0x37879c>
    //装载DMA中断
    DMA_ISR[DMA_CH0] = Ov7725_eagle_dma;
     840:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     844:	000a3813 	andeq	r3, sl, r3, lsl r8
     848:	000d0b00 	andeq	r0, sp, r0, lsl #22
     84c:	0b3a0803 	bleq	e82860 <__etext+0xe79bb8>
     850:	1349053b 	movtne	r0, #38203	; 0x953b
    //关闭DMA通道
    DMA_DIS(DMA_CH0);
     854:	00000a38 	andeq	r0, r0, r8, lsr sl
     858:	4901010c 	stmdbmi	r1, {r2, r3, r8}
     85c:	00130113 	andseq	r0, r3, r3, lsl r1
     860:	00210d00 	eoreq	r0, r1, r0, lsl #26
     864:	0b2f1349 	bleq	bc5590 <__etext+0xbbc8e8>
     868:	160e0000 	strne	r0, [lr], -r0
    //关GPIO中断
    disable_irq(INT_PORTA - 16);
     86c:	3a0e0300 	bcc	381474 <__etext+0x3787cc>
     870:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    //清DMA中断置为标志
    DMA_IRQ_CLEAN(DMA_CH0);
     874:	0f000013 	svceq	0x00000013
     878:	0b0b000f 	bleq	2c08bc <__etext+0x2b7c14>
     87c:	00001349 	andeq	r1, r0, r9, asr #6
     880:	49003510 	stmdbmi	r0, {r4, r8, sl, ip, sp}
     884:	11000013 	tstne	r0, r3, lsl r0
     888:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
    //使能DMA中断
    DMA_IRQ_EN (DMA_CH0);
     88c:	0b3a0b0b 	bleq	e834c0 <__etext+0xe7a818>
     890:	1301053b 	movwne	r0, #5435	; 0x153b
    //开启GPIO中断
    LPLD_GPIO_EnableIrq(OV_PTA_init);
     894:	13120000 	tstne	r2, #0
     898:	0b0e0301 	bleq	3814a4 <__etext+0x3787fc>
     89c:	3b0b3a05 	blcc	2cf0b8 <__etext+0x2c6410>
     8a0:	00130105 	andseq	r0, r3, r5, lsl #2
     8a4:	00211300 	eoreq	r1, r1, r0, lsl #6
    {
        //获取图像
        //Ov7725_eagle_get_img ();
        //解压图像
        //Ov7725_img_extract (Pix_Data, img, PHOTO_SIZE/8);
        if(ready_send_flag)
     8a8:	052f1349 	streq	r1, [pc, #-841]!	; 567 <__vector_table+0x567>
     8ac:	15140000 	ldrne	r0, [r4, #-0]
     8b0:	000c2700 	andeq	r2, ip, r0, lsl #14
     8b4:	01041500 	tsteq	r4, r0, lsl #10
        {
            //发送图片到上位机
            //get_midline(Pix_Data, 60, 80);
            Ov7725_sendimg (Pix_Data, PHOTO_SIZE);
     8b8:	0b0b0e03 	bleq	2c40cc <__etext+0x2bb424>
     8bc:	0b3b0b3a 	bleq	ec35ac <__etext+0xeba904>
     8c0:	00001301 	andeq	r1, r0, r1, lsl #6
     8c4:	03002816 	movweq	r2, #2070	; 0x816
            ready_send_flag = 0;
     8c8:	000d1c08 	andeq	r1, sp, r8, lsl #24
     8cc:	01131700 	tsteq	r3, r0, lsl #14
     8d0:	0b3a0b0b 	bleq	e83504 <__etext+0xe7a85c>
        }
    }
     8d4:	13010b3b 	movwne	r0, #6971	; 0x1b3b
 * \param  void
 *
 * \return void
 */
void Default_Handler(void)
{
     8d8:	2e180000 	cdpcs	0, 1, cr0, cr8, cr0, {0}
     8dc:	030c3f01 	movweq	r3, #52993	; 0xcf01
#define VECTORNUM       (*(volatile char *) (0xE000ED04))
  //while (1);
  char vtr = VECTORNUM;
     8e0:	3b0b3a0e 	blcc	2cf120 <__etext+0x2c6478>
     8e4:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
     8e8:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
  printf ("\n ******************\n");
     8ec:	96064001 	strls	r4, [r6], -r1
     8f0:	13010c42 	movwne	r0, #7234	; 0x1c42
     8f4:	05190000 	ldreq	r0, [r9, #-0]
  printf ("Default Handler Error\n");
     8f8:	3a0e0300 	bcc	381500 <__etext+0x378858>
     8fc:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     900:	000a0213 	andeq	r0, sl, r3, lsl r2
  printf ("On vector %d **** Interrupt\n", vtr);
     904:	00341a00 	eorseq	r1, r4, r0, lsl #20
     908:	0b3a0803 	bleq	e8291c <__etext+0xe79c74>
     90c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     910:	00000a02 	andeq	r0, r0, r2, lsl #20
 * \param  void
 *
 * \return void
 */
void Reset_Handler(void)
{
     914:	0300341b 	movweq	r3, #1051	; 0x41b
     918:	3b0b3a0e 	blcc	2cf158 <__etext+0x2c64b0>
  unsigned char *source;
  unsigned char *destination;

  /* watchdog disable */
  *((volatile unsigned short *)0x4005200E) = 0xC520;
     91c:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     920:	1c00000a 	stcne	0, cr0, [r0], {10}
     924:	0c3f012e 	ldfeqs	f0, [pc], #-184	; 874 <main+0x74>
  *((volatile unsigned short *)0x4005200E) = 0xD928;
     928:	0b3a0e03 	bleq	e8413c <__etext+0xe7b494>
     92c:	0c270b3b 	stceq	11, cr0, [r7], #-236	; 0xffffff14
     930:	01111349 	tsteq	r1, r9, asr #6
     934:	06400112 			; <UNDEFINED> instruction: 0x06400112
  *((volatile unsigned short *)0x40052000) = 0x01D2;
     938:	010c4297 			; <UNDEFINED> instruction: 0x010c4297
     93c:	1d000013 	stcne	0, cr0, [r0, #-76]	; 0xffffffb4
     940:	08030005 	stmdaeq	r3, {r0, r2}

  /* copy data values from ROM to RAM */
  source = (unsigned char *)&_etext;
     944:	0b3b0b3a 	bleq	ec3634 <__etext+0xeba98c>
     948:	0a021349 	beq	85674 <__etext+0x7c9cc>
     94c:	2e1e0000 	cdpcs	0, 1, cr0, cr14, cr0, {0}
  destination = (unsigned char *)&_sdata;
     950:	030c3f01 	movweq	r3, #52993	; 0xcf01
     954:	3b0b3a0e 	blcc	2cf194 <__etext+0x2c64ec>
  while (destination < (unsigned char*)&_edata) {
     958:	110c270b 	tstne	ip, fp, lsl #14
    *(destination++) = *(source++);
     95c:	40011201 	andmi	r1, r1, r1, lsl #4
     960:	0c429706 	mcrreq	7, 0, r9, r2, cr6
     964:	00001301 	andeq	r1, r0, r1, lsl #6
     968:	3f012e1f 	svccc	0x00012e1f
     96c:	3a0e030c 	bcc	3815a4 <__etext+0x3788fc>
     970:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
  *((volatile unsigned short *)0x40052000) = 0x01D2;

  /* copy data values from ROM to RAM */
  source = (unsigned char *)&_etext;
  destination = (unsigned char *)&_sdata;
  while (destination < (unsigned char*)&_edata) {
     974:	1113490c 	tstne	r3, ip, lsl #18
     978:	40011201 	andmi	r1, r1, r1, lsl #4
     97c:	0c429706 	mcrreq	7, 0, r9, r2, cr6
    *(destination++) = *(source++);
  }

  /* clear bss section */
  source = (unsigned char *)&_sbss;
     980:	00001301 	andeq	r1, r0, r1, lsl #6
     984:	03000520 	movweq	r0, #1312	; 0x520
     988:	3b0b3a0e 	blcc	2cf1c8 <__etext+0x2c6520>
  destination = (unsigned char *)&_ebss;
     98c:	02134905 	andseq	r4, r3, #81920	; 0x14000
     990:	2100000a 	tstcs	r0, sl
  while (source < destination ) {
     994:	08030005 	stmdaeq	r3, {r0, r2}
    *source++ = 0;
     998:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     99c:	0a021349 	beq	856c8 <__etext+0x7ca20>
     9a0:	2e220000 	cdpcs	0, 2, cr0, cr2, cr0, {0}
     9a4:	030c3f01 	movweq	r3, #52993	; 0xcf01
  }

  /* clear bss section */
  source = (unsigned char *)&_sbss;
  destination = (unsigned char *)&_ebss;
  while (source < destination ) {
     9a8:	3b0b3a0e 	blcc	2cf1e8 <__etext+0x2c6540>
     9ac:	490c2705 	stmdbmi	ip, {r0, r2, r8, r9, sl, sp}
    *source++ = 0;
  }
 //进入系统初始化函数
  SystemInit();
     9b0:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
 //进入用户函数
  main();
     9b4:	96064001 	strls	r4, [r6], -r1
 * \param  void
 *
 * \return void
 */
void SystemInit(void)
{
     9b8:	13010c42 	movwne	r0, #7234	; 0x1c42
  //使能所有IO口时钟
  SIM_SCGC5 |= (SIM_SCGC5_PORTA_MASK | SIM_SCGC5_PORTB_MASK
     9bc:	34230000 	strtcc	r0, [r3], #-0
     9c0:	3a0e0300 	bcc	3815c8 <__etext+0x378920>
     9c4:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     9c8:	000a0213 	andeq	r0, sl, r3, lsl r2
     9cc:	00342400 	eorseq	r2, r4, r0, lsl #8
     9d0:	0b3a0803 	bleq	e829e4 <__etext+0xe79d3c>
     9d4:	1349053b 	movtne	r0, #38203	; 0x953b
     9d8:	00000a02 	andeq	r0, r0, r2, lsl #20
     9dc:	03012e25 	movweq	r2, #7717	; 0x1e25
     9e0:	3b0b3a0e 	blcc	2cf220 <__etext+0x2c6578>
              | SIM_SCGC5_PORTC_MASK | SIM_SCGC5_PORTD_MASK
              | SIM_SCGC5_PORTE_MASK);
  //初始化各部分时钟：系统内核主频、总线时钟、FlexBus时钟、Flash时钟
  LPLD_PLL_Setup(CORE_CLK_MHZ);
     9e4:	490c2705 	stmdbmi	ip, {r0, r2, r8, r9, sl, sp}
     9e8:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
  
  //更新内核主频
  SystemCoreClockUpdate();
     9ec:	97064001 	strls	r4, [r6, -r1]
  
  //获取各部分时钟
  g_core_clock = SystemCoreClock;
     9f0:	13010c42 	movwne	r0, #7234	; 0x1c42
     9f4:	2e260000 	cdpcs	0, 2, cr0, cr6, cr0, {0}
     9f8:	030c3f00 	movweq	r3, #52992	; 0xcf00
     9fc:	3b0b3a0e 	blcc	2cf23c <__etext+0x2c6594>
     a00:	110c2705 	tstne	ip, r5, lsl #14
  g_bus_clock = g_core_clock / ((uint32_t)((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV2_MASK) >> SIM_CLKDIV1_OUTDIV2_SHIFT)+ 1u);
     a04:	40011201 	andmi	r1, r1, r1, lsl #4
     a08:	0c429606 	mcrreq	6, 0, r9, r2, cr6
     a0c:	34270000 	strtcc	r0, [r7], #-0
     a10:	3a0e0300 	bcc	381618 <__etext+0x378970>
     a14:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     a18:	020c3f13 	andeq	r3, ip, #76	; 0x4c
     a1c:	0000000a 	andeq	r0, r0, sl
     a20:	25011101 	strcs	r1, [r1, #-257]	; 0x101
     a24:	030b130e 	movweq	r1, #45838	; 0xb30e
     a28:	110e1b0e 	tstne	lr, lr, lsl #22
     a2c:	10011201 	andne	r1, r1, r1, lsl #4
     a30:	02000006 	andeq	r0, r0, #6
     a34:	0b0b0024 	bleq	2c0acc <__etext+0x2b7e24>
     a38:	0e030b3e 	vmoveq.16	d3[0], r0
  g_flexbus_clock =  g_core_clock / ((uint32_t)((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV3_MASK) >> SIM_CLKDIV1_OUTDIV3_SHIFT)+ 1u);
     a3c:	16030000 	strne	r0, [r3], -r0
     a40:	3a0e0300 	bcc	381648 <__etext+0x3789a0>
     a44:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     a48:	04000013 	streq	r0, [r0], #-19
     a4c:	0b0b0024 	bleq	2c0ae4 <__etext+0x2b7e3c>
     a50:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
     a54:	04050000 	streq	r0, [r5], #-0
     a58:	3a0b0b01 	bcc	2c3664 <__etext+0x2ba9bc>
     a5c:	010b3b0b 	tsteq	fp, fp, lsl #22
     a60:	06000013 			; <UNDEFINED> instruction: 0x06000013
     a64:	0e030028 	cdpeq	0, 0, cr0, cr3, cr8, {1}
     a68:	00000d1c 	andeq	r0, r0, ip, lsl sp
     a6c:	49010107 	stmdbmi	r1, {r0, r1, r2, r8}
  g_flash_clock =  g_core_clock / ((uint32_t)((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV4_MASK) >> SIM_CLKDIV1_OUTDIV4_SHIFT)+ 1u);
     a70:	00130113 	andseq	r0, r3, r3, lsl r1
     a74:	00210800 	eoreq	r0, r1, r0, lsl #16
     a78:	0b2f1349 	bleq	bc57a4 <__etext+0xbbcafc>
     a7c:	17090000 	strne	r0, [r9, -r0]
     a80:	3a0b0b01 	bcc	2c368c <__etext+0x2ba9e4>
     a84:	01053b0b 	tsteq	r5, fp, lsl #22
     a88:	0a000013 	beq	adc <SystemCoreClockUpdate+0x30>
     a8c:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
     a90:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     a94:	00001349 	andeq	r1, r0, r9, asr #6
     a98:	0b01130b 	bleq	456cc <__etext+0x3ca24>
     a9c:	3b0b3a0b 	blcc	2cf2d0 <__etext+0x2c6628>
     aa0:	00130105 	andseq	r0, r3, r5, lsl #2
     aa4:	000d0c00 	andeq	r0, sp, r0, lsl #24
 
    //初始化系统终端
  systemTerm ();
     aa8:	0b3a0e03 	bleq	e842bc <__etext+0xe7b614>
 *
 * @brief  更新全局变量SystemCoreClock的值，以便获取最新的系统内核频率。
 *         
 */
void SystemCoreClockUpdate (void) 
{
     aac:	1349053b 	movtne	r0, #38203	; 0x953b
     ab0:	00000a38 	andeq	r0, r0, r8, lsr sl
    uint32_t temp;
    temp =  CPU_XTAL_CLK_HZ *((uint32_t)(MCG_C6 & MCG_C6_VDIV_MASK) + 16u );
     ab4:	49000d0d 	stmdbmi	r0, {r0, r2, r3, r8, sl, fp}
     ab8:	000a3813 	andeq	r3, sl, r3, lsl r8
     abc:	000d0e00 	andeq	r0, sp, r0, lsl #28
     ac0:	0b3a0803 	bleq	e82ad4 <__etext+0xe79e2c>
     ac4:	1349053b 	movtne	r0, #38203	; 0x953b
     ac8:	00000a38 	andeq	r0, r0, r8, lsr sl
     acc:	0301130f 	movweq	r1, #4879	; 0x130f
     ad0:	3a050b0e 	bcc	143710 <__etext+0x13aa68>
     ad4:	01053b0b 	tsteq	r5, fp, lsl #22
     ad8:	10000013 	andne	r0, r0, r3, lsl r0
    temp = (uint32_t)(temp/((uint32_t)(MCG_C5 & MCG_C5_PRDIV_MASK) +1u ))/2;
     adc:	13490021 	movtne	r0, #36897	; 0x9021
     ae0:	0000052f 	andeq	r0, r0, pc, lsr #10
     ae4:	03001611 	movweq	r1, #1553	; 0x611
     ae8:	3b0b3a0e 	blcc	2cf328 <__etext+0x2c6680>
     aec:	00134905 	andseq	r4, r3, r5, lsl #18
     af0:	000f1200 	andeq	r1, pc, r0, lsl #4
     af4:	13490b0b 	movtne	r0, #39691	; 0x9b0b
     af8:	35130000 	ldrcc	r0, [r3, #-0]
    SystemCoreClock = temp;
     afc:	00134900 	andseq	r4, r3, r0, lsl #18
     b00:	01131400 	tsteq	r3, r0, lsl #8
     b04:	0b0b0e03 	bleq	2c4318 <__etext+0x2bb670>
}
     b08:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     b0c:	00001301 	andeq	r1, r0, r1, lsl #6
/*
 * 使能中断
 */

void enable_irq (int irq)
{
     b10:	27001515 	smladcs	r0, r5, r5, r1
     b14:	1600000c 	strne	r0, [r0], -ip
    int div;
    if (irq > 105)
     b18:	0b0b0113 	bleq	2c0f6c <__etext+0x2b82c4>
     b1c:	0b3b0b3a 	bleq	ec380c <__etext+0xebab64>
        irq = 105;
     b20:	00001301 	andeq	r1, r0, r1, lsl #6
    div = irq / 32;
     b24:	03000d17 	movweq	r0, #3351	; 0xd17
     b28:	3b0b3a0e 	blcc	2cf368 <__etext+0x2c66c0>
     b2c:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
     b30:	1800000a 	stmdane	r0, {r1, r3}
    switch (div)
     b34:	0c3f012e 	ldfeqs	f0, [pc], #-184	; a84 <SystemInit+0xcc>
     b38:	0b3a0e03 	bleq	e8434c <__etext+0xe7b6a4>
     b3c:	0c270b3b 	stceq	11, cr0, [r7], #-236	; 0xffffff14
     b40:	01111349 	tsteq	r1, r9, asr #6
     b44:	06400112 			; <UNDEFINED> instruction: 0x06400112
     b48:	010c4297 			; <UNDEFINED> instruction: 0x010c4297
     b4c:	19000013 	stmdbne	r0, {r0, r1, r4}
     b50:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    {
        case 0x0:
            NVICICPR0 |= 1 << (irq & 0x1F);
     b54:	0b3b0b3a 	bleq	ec3844 <__etext+0xebab9c>
     b58:	0a021349 	beq	85884 <__etext+0x7cbdc>
     b5c:	341a0000 	ldrcc	r0, [sl], #-0
     b60:	3a080300 	bcc	201768 <__etext+0x1f8ac0>
     b64:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     b68:	000a0213 	andeq	r0, sl, r3, lsl r2
     b6c:	00341b00 	eorseq	r1, r4, r0, lsl #22
     b70:	0b3a0e03 	bleq	e84384 <__etext+0xe7b6dc>
     b74:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     b78:	00000a02 	andeq	r0, r0, r2, lsl #20
            NVICISER0 |= 1 << (irq & 0x1F);
     b7c:	3f012e1c 	svccc	0x00012e1c
     b80:	3a0e030c 	bcc	3817b8 <__etext+0x378b10>
     b84:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
     b88:	1113490c 	tstne	r3, ip, lsl #18
     b8c:	40011201 	andmi	r1, r1, r1, lsl #4
     b90:	0c429606 	mcrreq	6, 0, r9, r2, cr6
     b94:	00001301 	andeq	r1, r0, r1, lsl #6
     b98:	3f012e1d 	svccc	0x00012e1d
     b9c:	3a0e030c 	bcc	3817d4 <__etext+0x378b2c>
            break;
     ba0:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
        case 0x1:
            NVICICPR1 |= 1 << (irq & 0x1F);
     ba4:	1201110c 	andne	r1, r1, #3
     ba8:	97064001 	strls	r4, [r6, -r1]
     bac:	13010c42 	movwne	r0, #7234	; 0x1c42
     bb0:	2e1e0000 	cdpcs	0, 1, cr0, cr14, cr0, {0}
     bb4:	030c3f00 	movweq	r3, #52992	; 0xcf00
     bb8:	3b0b3a0e 	blcc	2cf3f8 <__etext+0x2c6750>
     bbc:	110c270b 	tstne	ip, fp, lsl #14
     bc0:	40011201 	andmi	r1, r1, r1, lsl #4
     bc4:	0c429606 	mcrreq	6, 0, r9, r2, cr6
     bc8:	2e1f0000 	cdpcs	0, 1, cr0, cr15, cr0, {0}
            NVICISER1 |= 1 << (irq & 0x1F);
     bcc:	030c3f00 	movweq	r3, #52992	; 0xcf00
     bd0:	3b0b3a0e 	blcc	2cf410 <__etext+0x2c6768>
     bd4:	110c2705 	tstne	ip, r5, lsl #14
     bd8:	40011201 	andmi	r1, r1, r1, lsl #4
     bdc:	0c429606 	mcrreq	6, 0, r9, r2, cr6
     be0:	34200000 	strtcc	r0, [r0], #-0
     be4:	3a0e0300 	bcc	3817ec <__etext+0x378b44>
     be8:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     bec:	020c3f13 	andeq	r3, ip, #76	; 0x4c
            break;
        case 0x2:
            NVICICPR2 |= 1 << (irq & 0x1F);
     bf0:	0000000a 	andeq	r0, r0, sl
     bf4:	25011101 	strcs	r1, [r1, #-257]	; 0x101
     bf8:	030b130e 	movweq	r1, #45838	; 0xb30e
     bfc:	110e1b0e 	tstne	lr, lr, lsl #22
     c00:	10011201 	andne	r1, r1, r1, lsl #4
     c04:	02000006 	andeq	r0, r0, #6
     c08:	0b0b0024 	bleq	2c0ca0 <__etext+0x2b7ff8>
     c0c:	0e030b3e 	vmoveq.16	d3[0], r0
     c10:	16030000 	strne	r0, [r3], -r0
     c14:	3a0e0300 	bcc	38181c <__etext+0x378b74>
            NVICISER2 |= 1 << (irq & 0x1F);
     c18:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     c1c:	04000013 	streq	r0, [r0], #-19
     c20:	0b0b0024 	bleq	2c0cb8 <__etext+0x2b8010>
     c24:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
     c28:	01050000 	mrseq	r0, (UNDEF: 5)
     c2c:	01134901 	tsteq	r3, r1, lsl #18
     c30:	06000013 			; <UNDEFINED> instruction: 0x06000013
     c34:	13490021 	movtne	r0, #36897	; 0x9021
     c38:	00000b2f 	andeq	r0, r0, pc, lsr #22
            break;
     c3c:	0b011307 	bleq	45860 <__etext+0x3cbb8>
        case 0x3:
            NVICICPR3 |= 1 << (irq & 0x1F);
     c40:	3b0b3a0b 	blcc	2cf474 <__etext+0x2c67cc>
     c44:	00130105 	andseq	r0, r3, r5, lsl #2
     c48:	000d0800 	andeq	r0, sp, r0, lsl #16
     c4c:	0b3a0e03 	bleq	e84460 <__etext+0xe7b7b8>
     c50:	1349053b 	movtne	r0, #38203	; 0x953b
     c54:	00000a38 	andeq	r0, r0, r8, lsr sl
     c58:	03000d09 	movweq	r0, #3337	; 0xd09
     c5c:	3b0b3a08 	blcc	2cf484 <__etext+0x2c67dc>
     c60:	38134905 	ldmdacc	r3, {r0, r2, r8, fp, lr}
     c64:	0a00000a 	beq	c94 <enable_irq+0x184>
            NVICISER3 |= 1 << (irq & 0x1F);
     c68:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
     c6c:	0b3a0b0b 	bleq	e838a0 <__etext+0xe7abf8>
     c70:	1301053b 	movwne	r0, #5435	; 0x153b
     c74:	160b0000 	strne	r0, [fp], -r0
     c78:	3a0e0300 	bcc	381880 <__etext+0x378bd8>
     c7c:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     c80:	0c000013 	stceq	0, cr0, [r0], {19}
     c84:	0b0b000f 	bleq	2c0cc8 <__etext+0x2b8020>
     c88:	00001349 	andeq	r1, r0, r9, asr #6
            break;
    }
}
     c8c:	4900350d 	stmdbmi	r0, {r0, r2, r3, r8, sl, ip, sp}
     c90:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
     c94:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
/*
 * 关闭中断
 */

void disable_irq (int irq)
{
     c98:	0b3a050b 	bleq	e820cc <__etext+0xe79424>
     c9c:	1301053b 	movwne	r0, #5435	; 0x153b
    int div;
    if (irq > 105)
     ca0:	210f0000 	mrscs	r0, CPSR
     ca4:	2f134900 	svccs	0x00134900
        irq = 105;
     ca8:	10000005 	andne	r0, r0, r5
    div = irq / 32;
     cac:	0e030104 	adfeqs	f0, f3, f4
     cb0:	0b3a0b0b 	bleq	e838e4 <__etext+0xe7ac3c>
     cb4:	13010b3b 	movwne	r0, #6971	; 0x1b3b
     cb8:	28110000 	ldmdacs	r1, {}	; <UNPREDICTABLE>
    switch (div)
     cbc:	1c0e0300 	stcne	3, cr0, [lr], {-0}
     cc0:	1200000d 	andne	r0, r0, #13
     cc4:	0c270015 	stceq	0, cr0, [r7], #-84	; 0xffffffac
     cc8:	13130000 	tstne	r3, #0
     ccc:	3a0b0b01 	bcc	2c38d8 <__etext+0x2bac30>
     cd0:	010b3b0b 	tsteq	fp, fp, lsl #22
     cd4:	14000013 	strne	r0, [r0], #-19
    {
        case 0x0:
            NVICICPR0 |= 1 << (irq & 0x1F);
     cd8:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
     cdc:	0b3b0b3a 	bleq	ec39cc <__etext+0xebad24>
     ce0:	0a381349 	beq	e05a0c <__etext+0xdfcd64>
     ce4:	2e150000 	cdpcs	0, 1, cr0, cr5, cr0, {0}
     ce8:	030c3f01 	movweq	r3, #52993	; 0xcf01
     cec:	3b0b3a0e 	blcc	2cf52c <__etext+0x2c6884>
     cf0:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
     cf4:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     cf8:	96064001 	strls	r4, [r6], -r1
     cfc:	13010c42 	movwne	r0, #7234	; 0x1c42
            break;
     d00:	05160000 	ldreq	r0, [r6, #-0]
        case 0x1:
            NVICICPR1 |= 1 << (irq & 0x1F);
     d04:	3a0e0300 	bcc	38190c <__etext+0x378c64>
     d08:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     d0c:	000a0213 	andeq	r0, sl, r3, lsl r2
     d10:	00341700 	eorseq	r1, r4, r0, lsl #14
     d14:	0b3a0e03 	bleq	e84528 <__etext+0xe7b880>
     d18:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     d1c:	00000a02 	andeq	r0, r0, r2, lsl #20
     d20:	03003418 	movweq	r3, #1048	; 0x418
     d24:	3b0b3a08 	blcc	2cf54c <__etext+0x2c68a4>
     d28:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
            break;
        case 0x2:
            NVICICPR2 |= 1 << (irq & 0x1F);
     d2c:	1900000a 	stmdbne	r0, {r1, r3}
     d30:	08030005 	stmdaeq	r3, {r0, r2}
     d34:	0b3b0b3a 	bleq	ec3a24 <__etext+0xebad7c>
     d38:	0a021349 	beq	85a64 <__etext+0x7cdbc>
     d3c:	2e1a0000 	cdpcs	0, 1, cr0, cr10, cr0, {0}
     d40:	030c3f01 	movweq	r3, #52993	; 0xcf01
     d44:	3b0b3a0e 	blcc	2cf584 <__etext+0x2c68dc>
     d48:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
     d4c:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     d50:	97064001 	strls	r4, [r6, -r1]
            break;
     d54:	13010c42 	movwne	r0, #7234	; 0x1c42
        case 0x3:
            NVICICPR3 |= 1 << (irq & 0x1F);
     d58:	2e1b0000 	cdpcs	0, 1, cr0, cr11, cr0, {0}
     d5c:	030c3f01 	movweq	r3, #52993	; 0xcf01
     d60:	3b0b3a0e 	blcc	2cf5a0 <__etext+0x2c68f8>
     d64:	490c2705 	stmdbmi	ip, {r0, r2, r8, r9, sl, sp}
     d68:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     d6c:	96064001 	strls	r4, [r6], -r1
     d70:	13010c42 	movwne	r0, #7234	; 0x1c42
     d74:	051c0000 	ldreq	r0, [ip, #-0]
     d78:	3a0e0300 	bcc	381980 <__etext+0x378cd8>
     d7c:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
            break;
    }
}
     d80:	000a0213 	andeq	r0, sl, r3, lsl r2
     d84:	00051d00 	andeq	r1, r5, r0, lsl #26
     d88:	0b3a0803 	bleq	e82d9c <__etext+0xe7a0f4>
/*
 * 系统终端初始化函数
 */

 void systemTerm (void)
 {
     d8c:	1349053b 	movtne	r0, #38203	; 0x953b
     d90:	00000a02 	andeq	r0, r0, r2, lsl #20
     UART_InitTypeDef uart_init_struct;
     uart_init_struct.UART_Uartx = TERM_PORT;
     d94:	3f012e1e 	svccc	0x00012e1e
     d98:	3a0e030c 	bcc	3819d0 <__etext+0x378d28>
     uart_init_struct.UART_BaudRate = TERM_BAUD;
     d9c:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
     da0:	1113490c 	tstne	r3, ip, lsl #18
     uart_init_struct.UART_RxPin = TERM_RX;
     da4:	40011201 	andmi	r1, r1, r1, lsl #4
     uart_init_struct.UART_TxPin = TERM_TX;
     da8:	0c429706 	mcrreq	7, 0, r9, r2, cr6
     dac:	00001301 	andeq	r1, r0, r1, lsl #6
     uart_init_struct.UART_RxIntEnable = TERM_RX_IRQ;
     db0:	3f012e1f 	svccc	0x00012e1f
     uart_init_struct.UART_RxIsr = TERM_RX_FUN;
     db4:	3a0e030c 	bcc	3819ec <__etext+0x378d44>
     db8:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]

     LPLD_UART_Init (uart_init_struct);
     dbc:	1201110c 	andne	r1, r1, #3
     dc0:	97064001 	strls	r4, [r6, -r1]
     dc4:	13010c42 	movwne	r0, #7234	; 0x1c42
#if (TERM_RX_IRQ == TRUE)
     LPLD_UART_EnableIrq (uart_init_struct);
#endif

 }
     dc8:	34200000 	strtcc	r0, [r0], #-0
     dcc:	3a080300 	bcc	2019d4 <__etext+0x1f8d2c>
//图像状态
volatile IMG_STATUS_e ov7725_eagle_img_flag = IMG_FINISH;

//ov7725初始化 
uint8 Ov7725_Init (void)
{
     dd0:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     dd4:	000a0213 	andeq	r0, sl, r3, lsl r2
    uint16 i = 0;
     dd8:	00342100 	eorseq	r2, r4, r0, lsl #2
    uint8 device_Id = 0;
     ddc:	0b3a0e03 	bleq	e845f0 <__etext+0xe7b948>
     de0:	1349053b 	movtne	r0, #38203	; 0x953b
    uint8 reg_Buff[50] = {0};
     de4:	00000a02 	andeq	r0, r0, r2, lsl #20
     de8:	03012e22 	movweq	r2, #7714	; 0x1e22
     dec:	3b0b3a0e 	blcc	2cf62c <__etext+0x2c6984>
     df0:	490c2705 	stmdbmi	ip, {r0, r2, r8, r9, sl, sp}
     df4:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     df8:	97064001 	strls	r4, [r6, -r1]
     dfc:	13010c42 	movwne	r0, #7234	; 0x1c42
     e00:	2e230000 	cdpcs	0, 2, cr0, cr3, cr0, {0}
     e04:	030c3f00 	movweq	r3, #52992	; 0xcf00
     e08:	3b0b3a0e 	blcc	2cf648 <__etext+0x2c69a0>
     e0c:	110c2705 	tstne	ip, r5, lsl #14
     e10:	40011201 	andmi	r1, r1, r1, lsl #4
     e14:	0c429606 	mcrreq	6, 0, r9, r2, cr6
     e18:	34240000 	strtcc	r0, [r4], #-0
     e1c:	3a0e0300 	bcc	381a24 <__etext+0x378d7c>
     e20:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     e24:	3c0c3f13 	stccc	15, cr3, [ip], {19}
     e28:	2500000c 	strcs	r0, [r0, #-12]
     e2c:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     e30:	0b3b0b3a 	bleq	ec3b20 <__etext+0xebae78>
     e34:	0c3f1349 	ldceq	3, cr1, [pc], #-292	; d18 <disable_irq+0x80>
     e38:	00000a02 	andeq	r0, r0, r2, lsl #20
     e3c:	01110100 	tsteq	r1, r0, lsl #2
     e40:	0b130e25 	bleq	4c46dc <__etext+0x4bba34>
     e44:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
     e48:	01120111 	tsteq	r2, r1, lsl r1
     e4c:	00000610 	andeq	r0, r0, r0, lsl r6
     e50:	0b002402 	bleq	9e60 <__etext+0x11b8>
     e54:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     e58:	0300000e 	movweq	r0, #14
     e5c:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
     e60:	0b3b0b3a 	bleq	ec3b50 <__etext+0xebaea8>
     e64:	00001349 	andeq	r1, r0, r9, asr #6

    LPLD_SCCB_Init ();
     e68:	0b002404 	bleq	9e80 <__etext+0x11d8>
    
    Ov7725_Delay();
     e6c:	030b3e0b 	movweq	r3, #48651	; 0xbe0b

    while (!LPLD_SCCB_WriteReg (OV7725_COM7, 0x80))
     e70:	05000008 	streq	r0, [r0, #-8]
    {
        if (i ++ >= 500)
     e74:	13490101 	movtne	r0, #37121	; 0x9101
     e78:	00001301 	andeq	r1, r0, r1, lsl #6
     e7c:	49002106 	stmdbmi	r0, {r1, r2, r8, sp}
     e80:	000b2f13 	andeq	r2, fp, r3, lsl pc
     e84:	01130700 	tsteq	r3, r0, lsl #14
     e88:	0b0b0e03 	bleq	2c469c <__etext+0x2bb9f4>
     e8c:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
            return 0;
     e90:	00001301 	andeq	r1, r0, r1, lsl #6

    LPLD_SCCB_Init ();
    
    Ov7725_Delay();

    while (!LPLD_SCCB_WriteReg (OV7725_COM7, 0x80))
     e94:	03000d08 	movweq	r0, #3336	; 0xd08
     e98:	3b0b3a0e 	blcc	2cf6d8 <__etext+0x2c6a30>
     e9c:	38134905 	ldmdacc	r3, {r0, r2, r8, fp, lr}
     ea0:	0900000a 	stmdbeq	r0, {r1, r3}
     ea4:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
    {
        if (i ++ >= 500)
            return 0;
    }

    Ov7725_Delay();
     ea8:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    
    while (0 == LPLD_SCCB_ReadReg (OV7725_VER, &device_Id, 1));
     eac:	00001349 	andeq	r1, r0, r9, asr #6
     eb0:	0b000f0a 	bleq	4ae0 <LPLD_FTM_PinDeinit+0x570>
     eb4:	0013490b 	andseq	r4, r3, fp, lsl #18
     eb8:	00350b00 	eorseq	r0, r5, r0, lsl #22
     ebc:	00001349 	andeq	r1, r0, r9, asr #6
     ec0:	03000d0c 	movweq	r0, #3340	; 0xd0c

    printf ("You get ID success, SENSOR ID is 0x%x", device_Id);
     ec4:	3b0b3a08 	blcc	2cf6ec <__etext+0x2c6a44>
     ec8:	38134905 	ldmdacc	r3, {r0, r2, r8, fp, lr}
     ecc:	0d00000a 	stceq	0, cr0, [r0, #-40]	; 0xffffffd8
     ed0:	0c270015 	stceq	0, cr0, [r7], #-84	; 0xffffffac
     ed4:	130e0000 	movwne	r0, #57344	; 0xe000
    printf ("nconfig register Number is %d\n", ov7725_eagle_cfgnum);
     ed8:	3a0b0b01 	bcc	2c3ae4 <__etext+0x2bae3c>
     edc:	01053b0b 	tsteq	r5, fp, lsl #22
     ee0:	0f000013 	svceq	0x00000013
     ee4:	0c3f012e 	ldfeqs	f0, [pc], #-184	; e34 <Ov7725_Init+0x64>
     ee8:	0b3a0e03 	bleq	e846fc <__etext+0xe7ba54>
     eec:	0c270b3b 	stceq	11, cr0, [r7], #-236	; 0xffffff14

    //判断摄像头是否为ov7725
    if (device_Id == OV7725_ID)
     ef0:	01111349 	tsteq	r1, r9, asr #6
     ef4:	06400112 			; <UNDEFINED> instruction: 0x06400112
    {
        for (i = 0; i < ov7725_eagle_cfgnum; i++)
     ef8:	010c4297 			; <UNDEFINED> instruction: 0x010c4297
     efc:	10000013 	andne	r0, r0, r3, lsl r0
        {
            if (0 == LPLD_SCCB_WriteReg(ov7725_eagle_reg[i].addr, ov7725_eagle_reg[i].val))
     f00:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
     f04:	0b3b0b3a 	bleq	ec3bf4 <__etext+0xebaf4c>
     f08:	0a021349 	beq	85c34 <__etext+0x7cf8c>
     f0c:	34110000 	ldrcc	r0, [r1], #-0
     f10:	3a080300 	bcc	201b18 <__etext+0x1f8e70>
     f14:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     f18:	000a0213 	andeq	r0, sl, r3, lsl r2
     f1c:	00341200 	eorseq	r1, r4, r0, lsl #4
     f20:	0b3a0e03 	bleq	e84734 <__etext+0xe7ba8c>
     f24:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     f28:	00000a02 	andeq	r0, r0, r2, lsl #20
     f2c:	3f012e13 	svccc	0x00012e13
            {
               printf ("error: writeReg error 0x%x\n", ov7725_eagle_reg[i].addr);
     f30:	3a0e030c 	bcc	381b68 <__etext+0x378ec0>
     f34:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
     f38:	1113490c 	tstne	r3, ip, lsl #18
     f3c:	40011201 	andmi	r1, r1, r1, lsl #4
     f40:	0c429606 	mcrreq	6, 0, r9, r2, cr6
     f44:	00001301 	andeq	r1, r0, r1, lsl #6
     f48:	3f012e14 	svccc	0x00012e14
                return 0;
     f4c:	3a0e030c 	bcc	381b84 <__etext+0x378edc>
            }
            if (LPLD_SCCB_ReadReg(ov7725_eagle_reg[i].addr, &reg_Buff[i], 1))
     f50:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
     f54:	1201110c 	andne	r1, r1, #3
     f58:	97064001 	strls	r4, [r6, -r1]
     f5c:	13010c42 	movwne	r0, #7234	; 0x1c42
     f60:	05150000 	ldreq	r0, [r5, #-0]
     f64:	3a080300 	bcc	201b6c <__etext+0x1f8ec4>
     f68:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     f6c:	000a0213 	andeq	r0, sl, r3, lsl r2
     f70:	002e1600 	eoreq	r1, lr, r0, lsl #12
     f74:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
            {
                printf ("writeRe 0x%x success: 0x%x\n", ov7725_eagle_reg[i].addr, reg_Buff[i]);
     f78:	0b3b0b3a 	bleq	ec3c68 <__etext+0xebafc0>
     f7c:	01110c27 	tsteq	r1, r7, lsr #24
     f80:	06400112 			; <UNDEFINED> instruction: 0x06400112
     f84:	000c4296 	muleq	ip, r6, r2
     f88:	00341700 	eorseq	r1, r4, r0, lsl #14
     f8c:	0b3a0e03 	bleq	e847a0 <__etext+0xe7baf8>
     f90:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     f94:	0a020c3f 	beq	84098 <__etext+0x7b3f0>
     f98:	01000000 	mrseq	r0, (UNDEF: 0)
     f9c:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
     fa0:	0e030b13 	vmoveq.32	d3[0], r0
    printf ("nconfig register Number is %d\n", ov7725_eagle_cfgnum);

    //判断摄像头是否为ov7725
    if (device_Id == OV7725_ID)
    {
        for (i = 0; i < ov7725_eagle_cfgnum; i++)
     fa4:	01110e1b 	tsteq	r1, fp, lsl lr
     fa8:	06100112 			; <UNDEFINED> instruction: 0x06100112
     fac:	24020000 	strcs	r0, [r2], #-0
     fb0:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     fb4:	000e030b 	andeq	r0, lr, fp, lsl #6
     fb8:	00160300 	andseq	r0, r6, r0, lsl #6
            }
        }
    }
    else
    {
        return 0;
     fbc:	0b3a0e03 	bleq	e847d0 <__etext+0xe7bb28>
     fc0:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    }
    return 1;
     fc4:	24040000 	strcs	r0, [r4], #-0

}
     fc8:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     fcc:	0008030b 	andeq	r0, r8, fp, lsl #6

//ov7725延时函数
void Ov7725_Delay(void)
{
     fd0:	01040500 	tsteq	r4, r0, lsl #10
     fd4:	0b3a0b0b 	bleq	e83c08 <__etext+0xe7af60>
    uint16 i, n;
    for (i = 0; i < 3000; i++)
     fd8:	13010b3b 	movwne	r0, #6971	; 0x1b3b
     fdc:	28060000 	stmdacs	r6, {}	; <UNPREDICTABLE>
    {
        for (n = 0; n < 200; n++)
     fe0:	1c0e0300 	stcne	3, cr0, [lr], {-0}
     fe4:	0700000d 	streq	r0, [r0, -sp]
     fe8:	13490101 	movtne	r0, #37121	; 0x9101
     fec:	00001301 	andeq	r1, r0, r1, lsl #6
     ff0:	49002108 	stmdbmi	r0, {r3, r8, sp}
     ff4:	000b2f13 	andeq	r2, fp, r3, lsl pc

//ov7725延时函数
void Ov7725_Delay(void)
{
    uint16 i, n;
    for (i = 0; i < 3000; i++)
     ff8:	01130900 	tsteq	r3, r0, lsl #18
     ffc:	0b0b0e03 	bleq	2c4810 <__etext+0x2bbb68>
    1000:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    1004:	00001301 	andeq	r1, r0, r1, lsl #6
        for (n = 0; n < 200; n++)
        {
            asm("nop");
        }
    }
}
    1008:	03000d0a 	movweq	r0, #3338	; 0xd0a
    100c:	3b0b3a08 	blcc	2cf834 <__etext+0x2c6b8c>
    1010:	38134905 	ldmdacc	r3, {r0, r2, r8, fp, lr}

//DMA中断触发函数
void Ov7725_eagle_dma (void)
{
    1014:	0b00000a 	bleq	1044 <Ov7725_eagle_dma+0x30>
    1018:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
    ov7725_eagle_img_flag = IMG_FINISH;
    101c:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    1020:	00001349 	andeq	r1, r0, r9, asr #6
    1024:	0b000f0c 	bleq	4c5c <FTM0_IRQHandler+0x8>
    //关闭DMA通道
    DMA_DIS(DMA_CH0);
    1028:	0013490b 	andseq	r4, r3, fp, lsl #18
    102c:	00350d00 	eorseq	r0, r5, r0, lsl #26
    1030:	00001349 	andeq	r1, r0, r9, asr #6
    1034:	03000d0e 	movweq	r0, #3342	; 0xd0e
    1038:	3b0b3a0e 	blcc	2cf878 <__etext+0x2c6bd0>
    103c:	38134905 	ldmdacc	r3, {r0, r2, r8, fp, lr}
    //DMA0->INT |= 0x1u << 0;
    //enable_irq(INT_PORTA - 16);
    //图片进行解压
    Ov7725_img_extract(Pix_Data, img, PHOTO_SIZE/8);
    1040:	0f00000a 	svceq	0x0000000a
    1044:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
    1048:	0b3a050b 	bleq	e8247c <__etext+0xe797d4>
    104c:	1301053b 	movwne	r0, #5435	; 0x153b
    1050:	21100000 	tstcs	r0, r0
    1054:	2f134900 	svccs	0x00134900
    //解压完成标志置位
    ready_send_flag = 1;
    1058:	11000005 	tstne	r0, r5
    105c:	0c270015 	stceq	0, cr0, [r7], #-84	; 0xffffffac
    1060:	13120000 	tstne	r2, #0
    1064:	3a0b0b01 	bcc	2c3c70 <__etext+0x2bafc8>
    get_midline(Pix_Data, 60, 80);
    1068:	010b3b0b 	tsteq	fp, fp, lsl #22
    106c:	13000013 	movwne	r0, #19
    1070:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
    1074:	0b3b0b3a 	bleq	ec3d64 <__etext+0xebb0bc>
    1078:	0a381349 	beq	e05da4 <__etext+0xdfd0fc>
         //重新装载DMA目标地址
        DMA_DADDR(DMA_CH0) = (uint32)img;
    107c:	2e140000 	cdpcs	0, 1, cr0, cr4, cr0, {0}
    1080:	030c3f01 	movweq	r3, #52993	; 0xcf01
    1084:	3b0b3a0e 	blcc	2cf8c4 <__etext+0x2c6c1c>
    1088:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
    108c:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    1090:	97064001 	strls	r4, [r6, -r1]
   //Ov7725_sendimg(Pix_Data, PHOTO_SIZE);
    //clear PORTA isr set bit
    PORTA_ISFR = ~0;
    1094:	13010c42 	movwne	r0, #7234	; 0x1c42
    1098:	05150000 	ldreq	r0, [r5, #-0]
    109c:	3a0e0300 	bcc	381ca4 <__etext+0x378ffc>
    10a0:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    LPLD_GPIO_EnableIrq(OV_PTA_init);
    10a4:	000a0213 	andeq	r0, sl, r3, lsl r2
    10a8:	00341600 	eorseq	r1, r4, r0, lsl #12
    10ac:	0b3a0e03 	bleq	e848c0 <__etext+0xe7bc18>
    10b0:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    10b4:	00000a02 	andeq	r0, r0, r2, lsl #20
    //DMA0->INT |= 0x1u << 0;
}
    10b8:	3f002e17 	svccc	0x00002e17

//场中断开始判断函数
void Ov7725_eagle_vsync(void)
{
    10bc:	3a0e030c 	bcc	381cf4 <__etext+0x37904c>
    //printf ("runing eagle_vsync\n");
    //判断场中断是否开始
    if (ov7725_eagle_img_flag == IMG_START)
    10c0:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    10c4:	1113490c 	tstne	r3, ip, lsl #18
    10c8:	40011201 	andmi	r1, r1, r1, lsl #4
    10cc:	0c429606 	mcrreq	6, 0, r9, r2, cr6
    {
        ov7725_eagle_img_flag = IMG_GATHER;
    10d0:	2e180000 	cdpcs	0, 1, cr0, cr8, cr0, {0}
    10d4:	030c3f00 	movweq	r3, #52992	; 0xcf00
    10d8:	3b0b3a0e 	blcc	2cf918 <__etext+0x2c6c70>
    10dc:	110c270b 	tstne	ip, fp, lsl #14
        disable_irq (INT_PORTA - 16);
    10e0:	40011201 	andmi	r1, r1, r1, lsl #4
    10e4:	0c429706 	mcrreq	7, 0, r9, r2, cr6
        //LPLD_GPIO_DisableIrq(OV_PTA_init);
        //enable_irq (DMA_CH0 + INT_DMA0_DMA16 - 16);
        DMA_EN(DMA_CH0);
    10e8:	2e190000 	cdpcs	0, 1, cr0, cr9, cr0, {0}
    10ec:	030c3f00 	movweq	r3, #52992	; 0xcf00
    10f0:	3b0b3a0e 	blcc	2cf930 <__etext+0x2c6c88>
    10f4:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
    10f8:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    10fc:	97064001 	strls	r4, [r6, -r1]
        //LPLD_DMA_EnableIrq(OV_dma_init);
        //重新装载DMA目标地址
        DMA_DADDR(DMA_CH0) = (uint32)img;
    1100:	00000c42 	andeq	r0, r0, r2, asr #24
    1104:	3f012e1a 	svccc	0x00012e1a
    1108:	3a0e030c 	bcc	381d40 <__etext+0x379098>
    110c:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    1110:	1201110c 	andne	r1, r1, #3
    1114:	97064001 	strls	r4, [r6, -r1]
    1118:	13010c42 	movwne	r0, #7234	; 0x1c42
    }
    else
    {
        //disable_irq (INT_PORTA);
        //LPLD_GPIO_DisableIrq(OV_PTA_init);
        disable_irq (INT_PORTA - 16);
    111c:	2e1b0000 	cdpcs	0, 1, cr0, cr11, cr0, {0}
    1120:	030c3f00 	movweq	r3, #52992	; 0xcf00
        ov7725_eagle_img_flag = IMG_FAIL;
    1124:	3b0b3a0e 	blcc	2cf964 <__etext+0x2c6cbc>
    1128:	110c270b 	tstne	ip, fp, lsl #14
    112c:	40011201 	andmi	r1, r1, r1, lsl #4
    }
}
    1130:	0c429606 	mcrreq	6, 0, r9, r2, cr6

//ov7725开始采集图像
void Ov7725_eagle_get_img(void)
{
    1134:	341c0000 	ldrcc	r0, [ip], #-0
    1138:	3a0e0300 	bcc	381d40 <__etext+0x379098>
    ov7725_eagle_img_flag = IMG_START;
    113c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1140:	020c3f13 	andeq	r3, ip, #76	; 0x4c
    1144:	0000000a 	andeq	r0, r0, sl
    //write 1 clear int 
    PORTA_ISFR = ~0;
    1148:	25011101 	strcs	r1, [r1, #-257]	; 0x101
    114c:	030b130e 	movweq	r1, #45838	; 0xb30e
    1150:	110e1b0e 	tstne	lr, lr, lsl #22
    1154:	10011201 	andne	r1, r1, r1, lsl #4
    DMA_DADDR(DMA_CH0) = (uint32)img;
    1158:	02000006 	andeq	r0, r0, #6
    115c:	0b0b0024 	bleq	2c11f4 <__etext+0x2b854c>
    1160:	0e030b3e 	vmoveq.16	d3[0], r0
    1164:	16030000 	strne	r0, [r3], -r0
    1168:	3a0e0300 	bcc	381d70 <__etext+0x3790c8>
    116c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1170:	04000013 	streq	r0, [r0], #-19
    LPLD_GPIO_EnableIrq(OV_PTA_init);
    1174:	0b0b0024 	bleq	2c120c <__etext+0x2b8564>
    1178:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
    117c:	01050000 	mrseq	r0, (UNDEF: 5)
    1180:	01134901 	tsteq	r3, r1, lsl #18
}
    1184:	06000013 			; <UNDEFINED> instruction: 0x06000013
 *  @param      srclen          二值化图像的占用空间大小
 *  @since      v5.0            img_extract(img, imgbuff,CAMERA_SIZE);
 *  Sample usage:   sendimg(imgbuff, CAMERA_W * CAMERA_H);                    //发送到上位机
 */
void Ov7725_img_extract(uint8 *dst, uint8 *src, uint32 srclen)
{
    1188:	13490021 	movtne	r0, #36897	; 0x9021
    118c:	00000b2f 	andeq	r0, r0, pc, lsr #22
    1190:	0b011307 	bleq	45db4 <__etext+0x3d10c>
    uint8 colour[2] = {255, 0}; //0 和 1 分别对应的颜色
    1194:	3b0b3a0b 	blcc	2cf9c8 <__etext+0x2c6d20>
    1198:	00130105 	andseq	r0, r3, r5, lsl #2
    119c:	000d0800 	andeq	r0, sp, r0, lsl #16
    //注：野火的摄像头 1(or255)表示 白色，0表示 黑色
    uint8 tmpsrc;
    while(srclen --)
    11a0:	0b3a0e03 	bleq	e849b4 <__etext+0xe7bd0c>
    {
        tmpsrc = *src++;
    11a4:	1349053b 	movtne	r0, #38203	; 0x953b
    11a8:	00000a38 	andeq	r0, r0, r8, lsr sl
    11ac:	03011309 	movweq	r1, #4873	; 0x1309
        *dst++ = colour[(tmpsrc >> 7) & 0x01];
    11b0:	3a050b0e 	bcc	143df0 <__etext+0x13b148>
    11b4:	01053b0b 	tsteq	r5, fp, lsl #22
    11b8:	0a000013 	beq	120c <Ov7725_img_extract+0x84>
    11bc:	0803000d 	stmdaeq	r3, {r0, r2, r3}
    11c0:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    11c4:	0a381349 	beq	e05ef0 <__etext+0xdfd248>
    11c8:	160b0000 	strne	r0, [fp], -r0
    11cc:	3a0e0300 	bcc	381dd4 <__etext+0x37912c>
    11d0:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
        *dst++ = colour[(tmpsrc >> 6) & 0x01];
    11d4:	0c000013 	stceq	0, cr0, [r0], {19}
    11d8:	0b0b000f 	bleq	2c121c <__etext+0x2b8574>
    11dc:	00001349 	andeq	r1, r0, r9, asr #6
    11e0:	4900350d 	stmdbmi	r0, {r0, r2, r3, r8, sl, ip, sp}
    11e4:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
    11e8:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
    11ec:	0b3a0b0b 	bleq	e83e20 <__etext+0xe7b178>
    11f0:	1301053b 	movwne	r0, #5435	; 0x153b
        *dst++ = colour[(tmpsrc >> 5) & 0x01];
    11f4:	210f0000 	mrscs	r0, CPSR
    11f8:	2f134900 	svccs	0x00134900
    11fc:	10000005 	andne	r0, r0, r5
    1200:	0e030104 	adfeqs	f0, f3, f4
    1204:	0b3a0b0b 	bleq	e83e38 <__etext+0xe7b190>
    1208:	13010b3b 	movwne	r0, #6971	; 0x1b3b
    120c:	28110000 	ldmdacs	r1, {}	; <UNPREDICTABLE>
    1210:	1c0e0300 	stcne	3, cr0, [lr], {-0}
    1214:	1200000d 	andne	r0, r0, #13
        *dst++ = colour[(tmpsrc >> 4) & 0x01];
    1218:	0c3f012e 	ldfeqs	f0, [pc], #-184	; 1168 <Ov7725_eagle_get_img+0x34>
    121c:	0b3a0e03 	bleq	e84a30 <__etext+0xe7bd88>
    1220:	0c270b3b 	stceq	11, cr0, [r7], #-236	; 0xffffff14
    1224:	01111349 	tsteq	r1, r9, asr #6
    1228:	06400112 			; <UNDEFINED> instruction: 0x06400112
    122c:	010c4296 			; <UNDEFINED> instruction: 0x010c4296
    1230:	13000013 	movwne	r0, #19
    1234:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
        *dst++ = colour[(tmpsrc >> 3) & 0x01];
    1238:	0b3b0b3a 	bleq	ec3f28 <__etext+0xebb280>
    123c:	0a021349 	beq	85f68 <__etext+0x7d2c0>
    1240:	34140000 	ldrcc	r0, [r4], #-0
    1244:	3a0e0300 	bcc	381e4c <__etext+0x3791a4>
    1248:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    124c:	000a0213 	andeq	r0, sl, r3, lsl r2
    1250:	012e1500 	teqeq	lr, r0, lsl #10
    1254:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    1258:	0b3b0b3a 	bleq	ec3f48 <__etext+0xebb2a0>
        *dst++ = colour[(tmpsrc >> 2) & 0x01];
    125c:	01110c27 	tsteq	r1, r7, lsr #24
    1260:	06400112 			; <UNDEFINED> instruction: 0x06400112
    1264:	010c4297 			; <UNDEFINED> instruction: 0x010c4297
    1268:	16000013 			; <UNDEFINED> instruction: 0x16000013
    126c:	08030034 	stmdaeq	r3, {r2, r4, r5}
    1270:	0b3b0b3a 	bleq	ec3f60 <__etext+0xebb2b8>
    1274:	0a021349 	beq	85fa0 <__etext+0x7d2f8>
    1278:	34170000 	ldrcc	r0, [r7], #-0
        *dst++ = colour[(tmpsrc >> 1) & 0x01];
    127c:	3a0e0300 	bcc	381e84 <__etext+0x3791dc>
    1280:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1284:	020c3f13 	andeq	r3, ip, #76	; 0x4c
    1288:	0000000a 	andeq	r0, r0, sl
    128c:	25011101 	strcs	r1, [r1, #-257]	; 0x101
    1290:	030b130e 	movweq	r1, #45838	; 0xb30e
    1294:	110e1b0e 	tstne	lr, lr, lsl #22
    1298:	10011201 	andne	r1, r1, r1, lsl #4
    129c:	02000006 	andeq	r0, r0, #6
        *dst++ = colour[(tmpsrc >> 0) & 0x01];
    12a0:	0b0b0024 	bleq	2c1338 <__etext+0x2b8690>
    12a4:	0e030b3e 	vmoveq.16	d3[0], r0
    12a8:	16030000 	strne	r0, [r3], -r0
    12ac:	3a0e0300 	bcc	381eb4 <__etext+0x37920c>
    12b0:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    12b4:	04000013 	streq	r0, [r0], #-19
    12b8:	0b0b0024 	bleq	2c1350 <__etext+0x2b86a8>
void Ov7725_img_extract(uint8 *dst, uint8 *src, uint32 srclen)
{
    uint8 colour[2] = {255, 0}; //0 和 1 分别对应的颜色
    //注：野火的摄像头 1(or255)表示 白色，0表示 黑色
    uint8 tmpsrc;
    while(srclen --)
    12bc:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
    12c0:	04050000 	streq	r0, [r5], #-0
    12c4:	3a0b0b01 	bcc	2c3ed0 <__etext+0x2bb228>
    12c8:	010b3b0b 	tsteq	fp, fp, lsl #22
    12cc:	06000013 			; <UNDEFINED> instruction: 0x06000013
    12d0:	0e030028 	cdpeq	0, 0, cr0, cr3, cr8, {1}
        *dst++ = colour[(tmpsrc >> 3) & 0x01];
        *dst++ = colour[(tmpsrc >> 2) & 0x01];
        *dst++ = colour[(tmpsrc >> 1) & 0x01];
        *dst++ = colour[(tmpsrc >> 0) & 0x01];
    }
}
    12d4:	00000d1c 	andeq	r0, r0, ip, lsl sp
    12d8:	03011307 	movweq	r1, #4871	; 0x1307
    12dc:	3a0b0b0e 	bcc	2c3f1c <__etext+0x2bb274>
 *  @note       不同的上位机，不同的命令，这里使用 eSmartCameraCar软件，
                如果使用其他上位机，则需要修改代码。
 *  Sample usage:   sendimg(imgbuff, CAMERA_W * CAMERA_H);                    //发送到上位机
 */
void Ov7725_sendimg(uint8 *imgaddr, uint32 imgsize)
{
    12e0:	010b3b0b 	tsteq	fp, fp, lsl #22
    12e4:	08000013 	stmdaeq	r0, {r0, r1, r4}
    12e8:	0803000d 	stmdaeq	r3, {r0, r2, r3}
    uint8 cmd[4] = {0, 255, 1, 0 };    //yy_摄像头串口调试 使用的命令
    12ec:	0b3b0b3a 	bleq	ec3fdc <__etext+0xebb334>
    12f0:	0a381349 	beq	e0601c <__etext+0xdfd374>
    12f4:	0d090000 	stceq	0, cr0, [r9, #-0]
    12f8:	3a0e0300 	bcc	381f00 <__etext+0x379258>
    
    LPLD_UART_PutCharArr(TERM_PORT, (char *)cmd, sizeof(cmd));
    12fc:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1300:	000a3813 	andeq	r3, sl, r3, lsl r8
    1304:	000d0a00 	andeq	r0, sp, r0, lsl #20
    1308:	0b3a0e03 	bleq	e84b1c <__etext+0xe7be74>
    130c:	1349053b 	movtne	r0, #38203	; 0x953b
    LPLD_UART_PutCharArr(TERM_PORT, (char *)imgaddr, imgsize);
    1310:	00000a38 	andeq	r0, r0, r8, lsr sl
    1314:	03000d0b 	movweq	r0, #3339	; 0xd0b
    1318:	3b0b3a08 	blcc	2cfb40 <__etext+0x2c6e98>
    131c:	38134905 	ldmdacc	r3, {r0, r2, r8, fp, lr}
    1320:	0c00000a 	stceq	0, cr0, [r0], {10}

    //uart_putbuff(FIRE_PORT, cmd, sizeof(cmd));    //先发送命令

    //uart_putbuff(FIRE_PORT, imgaddr, imgsize); //再发送图像
}
    1324:	13490101 	movtne	r0, #37121	; 0x9101
    1328:	00001301 	andeq	r1, r0, r1, lsl #6

//OV7725GPIO口初始化
void Ov7725_Gpio_Init(void)
{
    132c:	4900210d 	stmdbmi	r0, {r0, r2, r3, r8, sp}
    1330:	000b2f13 	andeq	r2, fp, r3, lsl pc
    //OV数据口初始化 B0～B7
    OV_PTB_init.GPIO_PTx = PTB;
    1334:	00160e00 	andseq	r0, r6, r0, lsl #28
    1338:	0b3a0e03 	bleq	e84b4c <__etext+0xe7bea4>
    133c:	1349053b 	movtne	r0, #38203	; 0x953b
    1340:	0f0f0000 	svceq	0x000f0000
    OV_PTB_init.GPIO_Dir = DIR_INPUT;
    1344:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
    1348:	10000013 	andne	r0, r0, r3, lsl r0
    134c:	13490035 	movtne	r0, #36917	; 0x9035
    1350:	13110000 	tstne	r1, #0
    OV_PTB_init.GPIO_Pins = GPIO_Pin0_7;
    1354:	3a0b0b01 	bcc	2c3f60 <__etext+0x2bb2b8>
    1358:	01053b0b 	tsteq	r5, fp, lsl #22
    135c:	12000013 	andne	r0, r0, #19
    //禁止中断和DMA请求 禁用PULL 输入源下拉
    OV_PTB_init.GPIO_PinControl = IRQC_DIS |
    1360:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
    1364:	0b3a0b0b 	bleq	e83f98 <__etext+0xe7b2f0>
    1368:	1301053b 	movwne	r0, #5435	; 0x153b
    136c:	13130000 	tstne	r3, #0
                                  INPUT_PULL_DIS|
                                  INPUT_PULL_DOWN;
    LPLD_GPIO_Init (OV_PTB_init);
    1370:	0b0e0301 	bleq	381f7c <__etext+0x3792d4>
    1374:	3b0b3a05 	blcc	2cfb90 <__etext+0x2c6ee8>
    1378:	00130105 	andseq	r0, r3, r5, lsl #2
    137c:	00211400 	eoreq	r1, r1, r0, lsl #8

    //OV场信号接口初始化 A29 
    OV_PTA_init.GPIO_PTx = PTA;
    1380:	052f1349 	streq	r1, [pc, #-841]!	; 103f <Ov7725_eagle_dma+0x2b>
    1384:	15150000 	ldrne	r0, [r5, #-0]
    1388:	000c2700 	andeq	r2, ip, r0, lsl #14
    138c:	01131600 	tsteq	r3, r0, lsl #12
    1390:	0b3a0b0b 	bleq	e83fc4 <__etext+0xe7b31c>
    OV_PTA_init.GPIO_Dir = DIR_INPUT;
    1394:	13010b3b 	movwne	r0, #6971	; 0x1b3b
    1398:	2e170000 	cdpcs	0, 1, cr0, cr7, cr0, {0}
    139c:	030c3f01 	movweq	r3, #52993	; 0xcf01
    OV_PTA_init.GPIO_Pins = GPIO_Pin29;
    13a0:	3b0b3a0e 	blcc	2cfbe0 <__etext+0x2c6f38>
    13a4:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
    13a8:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    13ac:	96064001 	strls	r4, [r6], -r1
    //场中断IO设置，上升沿触发IR，输入上拉，使能滤波
    OV_PTA_init.GPIO_PinControl = IRQC_RI |
    13b0:	13010c42 	movwne	r0, #7234	; 0x1c42
    13b4:	05180000 	ldreq	r0, [r8, #-0]
    13b8:	3a0e0300 	bcc	381fc0 <__etext+0x379318>
    13bc:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
                                    INPUT_PULL_UP|
                                    INPUT_PF_EN;
    OV_PTA_init.GPIO_Isr = Ov7725_isr;
    13c0:	000a0213 	andeq	r0, sl, r3, lsl r2
    13c4:	00341900 	eorseq	r1, r4, r0, lsl #18
    13c8:	0b3a0803 	bleq	e833dc <__etext+0xe7a734>
    13cc:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    13d0:	00000a02 	andeq	r0, r0, r2, lsl #20
    LPLD_GPIO_Init (OV_PTA_init);
    13d4:	0300341a 	movweq	r3, #1050	; 0x41a
    13d8:	3b0b3a0e 	blcc	2cfc18 <__etext+0x2c6f70>
    13dc:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    13e0:	1b00000a 	blne	1410 <Ov7725_Gpio_Init+0xe4>

    //OV PCLK信号接口初始化: PTA27-PCLK 
    OV_PTD_init.GPIO_PTx = PTA;
    13e4:	0c3f002e 	ldceq	0, cr0, [pc], #-184	; 1334 <Ov7725_Gpio_Init+0x8>
    13e8:	0b3a0e03 	bleq	e84bfc <__etext+0xe7bf54>
    13ec:	0c270b3b 	stceq	11, cr0, [r7], #-236	; 0xffffff14
    13f0:	01120111 	tsteq	r2, r1, lsl r1
    13f4:	42960640 	addsmi	r0, r6, #67108864	; 0x4000000
    OV_PTD_init.GPIO_Pins = GPIO_Pin27;
    13f8:	1c00000c 	stcne	0, cr0, [r0], {12}
    13fc:	0c3f012e 	ldfeqs	f0, [pc], #-184	; 134c <Ov7725_Gpio_Init+0x20>
    1400:	0b3a0e03 	bleq	e84c14 <__etext+0xe7bf6c>
    OV_PTD_init.GPIO_Dir = DIR_INPUT;
    1404:	0c270b3b 	stceq	11, cr0, [r7], #-236	; 0xffffff14
    1408:	01111349 	tsteq	r1, r9, asr #6
    140c:	06400112 			; <UNDEFINED> instruction: 0x06400112
    1410:	010c4297 			; <UNDEFINED> instruction: 0x010c4297
    //PCLK信号，下降沿触发DMA，输入上拉
    OV_PTD_init.GPIO_PinControl = IRQC_DMAFA | INPUT_PULL_UP;
    1414:	1d000013 	stcne	0, cr0, [r0, #-76]	; 0xffffffb4
    1418:	08030005 	stmdaeq	r3, {r0, r2}
    141c:	0b3b0b3a 	bleq	ec410c <__etext+0xebb464>
    1420:	0a021349 	beq	8614c <__etext+0x7d4a4>
    LPLD_GPIO_Init (OV_PTD_init);
    1424:	341e0000 	ldrcc	r0, [lr], #-0
    1428:	3a080300 	bcc	202030 <__etext+0x1f9388>
    142c:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    1430:	000a0213 	andeq	r0, sl, r3, lsl r2
    1434:	00341f00 	eorseq	r1, r4, r0, lsl #30

}
    1438:	0b3a0e03 	bleq	e84c4c <__etext+0xe7bfa4>
 
//OV7725 DMA初始化 
void Ov7725_Dma_Init (void)
{
    143c:	1349053b 	movtne	r0, #38203	; 0x953b
    1440:	00000a02 	andeq	r0, r0, r2, lsl #20
    OV_dma_init.DMA_CHx = DMA_CH0;
    1444:	3f002e20 	svccc	0x00002e20
    1448:	3a0e030c 	bcc	382080 <__etext+0x3793d8>
    144c:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
    OV_dma_init.DMA_Req = PORTA_DMAREQ;
    1450:	1201110c 	andne	r1, r1, #3
    1454:	96064001 	strls	r4, [r6], -r1
    1458:	00000c42 	andeq	r0, r0, r2, asr #24
    145c:	03003421 	movweq	r3, #1057	; 0x421
    OV_dma_init.DMA_MajorLoopCnt = PHOTO_SIZE / 8;
    1460:	3b0b3a0e 	blcc	2cfca0 <__etext+0x2c6ff8>
    1464:	3f13490b 	svccc	0x0013490b
    1468:	000c3c0c 	andeq	r3, ip, ip, lsl #24
    OV_dma_init.DMA_MinorByteCnt = 1;
    146c:	00342200 	eorseq	r2, r4, r0, lsl #4
    1470:	0b3a0e03 	bleq	e84c84 <__etext+0xe7bfdc>
    1474:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1478:	0a020c3f 	beq	8457c <__etext+0x7b8d4>
    
    OV_dma_init.DMA_SourceAddr = (uint32)(&GPIOB_PDIR);
    147c:	26230000 	strtcs	r0, [r3], -r0
    1480:	00134900 	andseq	r4, r3, r0, lsl #18
    1484:	11010000 	mrsne	r0, (UNDEF: 1)
    1488:	130e2501 	movwne	r2, #58625	; 0xe501
    OV_dma_init.DMA_DestAddr = (uint32)img;
    148c:	1b0e030b 	blne	3820c0 <__etext+0x379418>
    1490:	1201110e 	andne	r1, r1, #-2147483645	; 0x80000003
    1494:	00061001 	andeq	r1, r6, r1
    1498:	00240200 	eoreq	r0, r4, r0, lsl #4
    149c:	0b3e0b0b 	bleq	f840d0 <__etext+0xf7b428>
    OV_dma_init.DMA_DestAddrOffset = 1;
    14a0:	00000e03 	andeq	r0, r0, r3, lsl #28
    14a4:	03001603 	movweq	r1, #1539	; 0x603
    14a8:	3b0b3a0e 	blcc	2cfce8 <__etext+0x2c7040>
    OV_dma_init.DMA_Isr = Ov7725_eagle_dma;
    14ac:	0013490b 	andseq	r4, r3, fp, lsl #18
    14b0:	00240400 	eoreq	r0, r4, r0, lsl #8
    14b4:	0b3e0b0b 	bleq	f840e8 <__etext+0xf7b440>
    14b8:	00000803 	andeq	r0, r0, r3, lsl #16
    14bc:	49010105 	stmdbmi	r1, {r0, r2, r8}
    LPLD_DMA_Init (OV_dma_init);
    14c0:	00130113 	andseq	r0, r3, r3, lsl r1
    14c4:	00210600 	eoreq	r0, r1, r0, lsl #12
    14c8:	0b2f1349 	bleq	bc61f4 <__etext+0xbbd54c>
    14cc:	13070000 	movwne	r0, #28672	; 0x7000
    14d0:	3a0b0b01 	bcc	2c40dc <__etext+0x2bb434>
    14d4:	01053b0b 	tsteq	r5, fp, lsl #22
    14d8:	08000013 	stmdaeq	r0, {r0, r1, r4}
    14dc:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}

    LPLD_DMA_DisableReq(DMA_CH0);
    14e0:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    14e4:	0a381349 	beq	e06210 <__etext+0xdfd568>
    14e8:	13090000 	movwne	r0, #36864	; 0x9000
    14ec:	0b0e0301 	bleq	3820f8 <__etext+0x379450>
    14f0:	3b0b3a05 	blcc	2cfd0c <__etext+0x2c7064>
    14f4:	00130105 	andseq	r0, r3, r5, lsl #2
    //disable_irq (INT_PORTA - 16);
    LPLD_GPIO_EnableIrq (OV_PTA_init);
    14f8:	000d0a00 	andeq	r0, sp, r0, lsl #20
    14fc:	0b3a0803 	bleq	e83510 <__etext+0xe7a868>
    1500:	1349053b 	movtne	r0, #38203	; 0x953b
    1504:	00000a38 	andeq	r0, r0, r8, lsr sl
    1508:	0300160b 	movweq	r1, #1547	; 0x60b
    DMA0->INT |= 0x1u <<0;
    150c:	3b0b3a0e 	blcc	2cfd4c <__etext+0x2c70a4>
    1510:	00134905 	andseq	r4, r3, r5, lsl #18
    1514:	000f0c00 	andeq	r0, pc, r0, lsl #24
    1518:	13490b0b 	movtne	r0, #39691	; 0x9b0b
    151c:	350d0000 	strcc	r0, [sp, #-0]
    1520:	00134900 	andseq	r4, r3, r0, lsl #18
    //允许DMA通道传输完成中断
    //enable_irq (DMA_CH0);
    LPLD_DMA_EnableIrq (OV_dma_init);
    1524:	00210e00 	eoreq	r0, r1, r0, lsl #28
    1528:	052f1349 	streq	r1, [pc, #-841]!	; 11e7 <Ov7725_img_extract+0x5f>
    152c:	150f0000 	strne	r0, [pc, #-0]	; 1534 <Ov7725_Dma_Init+0xf8>
    1530:	000c2700 	andeq	r2, ip, r0, lsl #14
    1534:	01041000 	mrseq	r1, (UNDEF: 4)
    1538:	0b0b0e03 	bleq	2c4d4c <__etext+0x2bc0a4>
    153c:	0b3b0b3a 	bleq	ec422c <__etext+0xebb584>
    1540:	00001301 	andeq	r1, r0, r1, lsl #6
    //使能通道x的DMA请求
    //LPLD_DMA_EnableReq(DMA_CH0);
}
    1544:	03002811 	movweq	r2, #2065	; 0x811
    1548:	000d1c0e 	andeq	r1, sp, lr, lsl #24

//ov7725中断
void Ov7725_isr (void)
{
    154c:	01131200 	tsteq	r3, r0, lsl #4
    1550:	0b3a0b0b 	bleq	e84184 <__etext+0xe7b4dc>
    uint8 n = 0;
    1554:	13010b3b 	movwne	r0, #6971	; 0x1b3b
    while (!PORTA_ISFR);
    1558:	0d130000 	ldceq	0, cr0, [r3, #-0]
    155c:	3a0e0300 	bcc	382164 <__etext+0x3794bc>
    1560:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1564:	000a3813 	andeq	r3, sl, r3, lsl r8
    1568:	012e1400 	teqeq	lr, r0, lsl #8
    uint32 flag = (PORTA->ISFR);
    156c:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    1570:	0b3b0b3a 	bleq	ec4260 <__etext+0xebb5b8>
    1574:	13490c27 	movtne	r0, #39975	; 0x9c27
    (PORTA -> ISFR) = ~0;
    1578:	01120111 	tsteq	r2, r1, lsl r1
    157c:	42970640 	addsmi	r0, r7, #67108864	; 0x4000000
    1580:	0013010c 	andseq	r0, r3, ip, lsl #2
    1584:	00051500 	andeq	r1, r5, r0, lsl #10
   
    n = 29;
    1588:	0b3a0e03 	bleq	e84d9c <__etext+0xe7c0f4>
    158c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    //printf ("flag = %x\n", flag);
    if (flag & (1<<n))
    1590:	00000a02 	andeq	r0, r0, r2, lsl #20
    1594:	03003416 	movweq	r3, #1046	; 0x416
    1598:	3b0b3a0e 	blcc	2cfdd8 <__etext+0x2c7130>
    159c:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    15a0:	1700000a 	strne	r0, [r0, -sl]
    {
        //场中断开始 
        //set 場中断
        ov7725_eagle_img_flag = IMG_START;
    15a4:	0c3f012e 	ldfeqs	f0, [pc], #-184	; 14f4 <Ov7725_Dma_Init+0xb8>
    15a8:	0b3a0e03 	bleq	e84dbc <__etext+0xe7c114>
    15ac:	0c270b3b 	stceq	11, cr0, [r7], #-236	; 0xffffff14
        //关闭PORTA中断
        disable_irq (INT_PORTA - 16);
    15b0:	01120111 	tsteq	r2, r1, lsl r1
    15b4:	42960640 	addsmi	r0, r6, #67108864	; 0x4000000
        //LPLD_GPIO_DisableIrq(OV_PTA_init);
        //enable_irq (DMA_CH0 + INT_DMA0_DMA16 - 16);
        //重新装载DMA目标地址
        //DMA_DADDR(DMA_CH0) = (uint32)img;
        //开启DMA通道
        DMA_EN(DMA_CH0);
    15b8:	0013010c 	andseq	r0, r3, ip, lsl #2
    15bc:	012e1800 	teqeq	lr, r0, lsl #16
    15c0:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    15c4:	0b3b0b3a 	bleq	ec42b4 <__etext+0xebb60c>
    15c8:	01110c27 	tsteq	r1, r7, lsr #24
    15cc:	06400112 			; <UNDEFINED> instruction: 0x06400112
        //LPLD_DMA_EnableIrq(OV_dma_init);
    }
}
    15d0:	010c4297 			; <UNDEFINED> instruction: 0x010c4297
    15d4:	19000013 	stmdbne	r0, {r0, r1, r4}

//移植野火的函数
void dma_portx2buff_init(uint8 CHn, void *SADDR, void *DADDR, uint8 dma_req, DMA_BYTEn byten, uint32 count, uint32 cfg)
{
    15d8:	08030034 	stmdaeq	r3, {r2, r4, r5}
    15dc:	0b3b0b3a 	bleq	ec42cc <__etext+0xebb624>
    15e0:	0a021349 	beq	8630c <__etext+0x7d664>
    15e4:	2e1a0000 	cdpcs	0, 1, cr0, cr10, cr0, {0}
    uint8 BYTEs = (byten == DMA_BYTE1 ? 1 : (byten == DMA_BYTE2 ? 2 : (byten == DMA_BYTE4 ? 4 : 16)));
    15e8:	030c3f00 	movweq	r3, #52992	; 0xcf00
    15ec:	3b0b3a0e 	blcc	2cfe2c <__etext+0x2c7184>
    15f0:	110c270b 	tstne	ip, fp, lsl #14
    15f4:	40011201 	andmi	r1, r1, r1, lsl #4
    15f8:	0c429606 	mcrreq	6, 0, r9, r2, cr6
    15fc:	341b0000 	ldrcc	r0, [fp], #-0
    1600:	3a0e0300 	bcc	382208 <__etext+0x379560>
    1604:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1608:	3c0c3f13 	stccc	15, cr3, [ip], {19}
    160c:	1c00000c 	stcne	0, cr0, [r0], {12}
    1610:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    1614:	0b3b0b3a 	bleq	ec4304 <__etext+0xebb65c>
    
    SIM_SCGC7 |= SIM_SCGC7_DMA_MASK;
    1618:	0c3f1349 	ldceq	3, cr1, [pc], #-292	; 14fc <Ov7725_Dma_Init+0xc0>
    161c:	00000a02 	andeq	r0, r0, r2, lsl #20
    1620:	01110100 	tsteq	r1, r0, lsl #2
    1624:	0b130e25 	bleq	4c4ec0 <__etext+0x4bc218>
    1628:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
    162c:	01120111 	tsteq	r2, r1, lsl r1
    1630:	00000610 	andeq	r0, r0, r0, lsl r6
    1634:	0b002402 	bleq	a644 <__etext+0x199c>
    SIM_SCGC6 |= SIM_SCGC6_DMAMUX0_MASK;
    1638:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
    163c:	0300000e 	movweq	r0, #14
    1640:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
    1644:	0b3b0b3a 	bleq	ec4334 <__etext+0xebb68c>
    1648:	00001349 	andeq	r1, r0, r9, asr #6
    164c:	0b002404 	bleq	a664 <__etext+0x19bc>
    1650:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
    1654:	05000008 	streq	r0, [r0, #-8]
    1658:	0b0b0104 	bleq	2c1a70 <__etext+0x2b8dc8>
    165c:	0b3b0b3a 	bleq	ec434c <__etext+0xebb6a4>

    DMA_SADDR(CHn) = (uint32) SADDR;
    1660:	00001301 	andeq	r1, r0, r1, lsl #6
    1664:	03002806 	movweq	r2, #2054	; 0x806
    1668:	000d1c0e 	andeq	r1, sp, lr, lsl #24
    166c:	01010700 	tsteq	r1, r0, lsl #14
    1670:	13011349 	movwne	r1, #4937	; 0x1349
    1674:	21080000 	mrscs	r0, (UNDEF: 8)
    DMA_DADDR(CHn) = (uint32) DADDR;
    1678:	2f134900 	svccs	0x00134900
    167c:	0900000b 	stmdbeq	r0, {r0, r1, r3}
    1680:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
    1684:	0b3a0b0b 	bleq	e842b8 <__etext+0xe7b610>
    1688:	1301053b 	movwne	r0, #5435	; 0x153b
    168c:	0d0a0000 	stceq	0, cr0, [sl, #-0]
    1690:	3a080300 	bcc	202298 <__etext+0x1f95f0>
    DMA_SOFF(CHn) = 0x00u;
    1694:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    1698:	000a3813 	andeq	r3, sl, r3, lsl r8
    169c:	000d0b00 	andeq	r0, sp, r0, lsl #22
    16a0:	0b3a0e03 	bleq	e84eb4 <__etext+0xe7c20c>
    16a4:	1349053b 	movtne	r0, #38203	; 0x953b
    16a8:	00000a38 	andeq	r0, r0, r8, lsr sl
    16ac:	0300160c 	movweq	r1, #1548	; 0x60c
    DMA_DOFF(CHn) = BYTEs;
    16b0:	3b0b3a0e 	blcc	2cfef0 <__etext+0x2c7248>
    16b4:	00134905 	andseq	r4, r3, r5, lsl #18
    16b8:	000f0d00 	andeq	r0, pc, r0, lsl #26
    16bc:	13490b0b 	movtne	r0, #39691	; 0x9b0b
    16c0:	350e0000 	strcc	r0, [lr, #-0]
    16c4:	00134900 	andseq	r4, r3, r0, lsl #18
    16c8:	01130f00 	tsteq	r3, r0, lsl #30
    DMA_ATTR(CHn) = (0
    16cc:	050b0e03 	streq	r0, [fp, #-3587]	; 0xe03
    16d0:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    16d4:	00001301 	andeq	r1, r0, r1, lsl #6
                     |DMA_ATTR_SMOD(0x0)
                     |DMA_ATTR_SSIZE(byten)
    16d8:	49002110 	stmdbmi	r0, {r4, r8, sp}
    16dc:	00052f13 	andeq	r2, r5, r3, lsl pc
    16e0:	01171100 	tsteq	r7, r0, lsl #2

    DMA_SADDR(CHn) = (uint32) SADDR;
    DMA_DADDR(CHn) = (uint32) DADDR;
    DMA_SOFF(CHn) = 0x00u;
    DMA_DOFF(CHn) = BYTEs;
    DMA_ATTR(CHn) = (0
    16e4:	0b3a0b0b 	bleq	e84318 <__etext+0xe7b670>
    16e8:	1301053b 	movwne	r0, #5435	; 0x153b
    16ec:	0d120000 	ldceq	0, cr0, [r2, #-0]
    16f0:	3a0e0300 	bcc	3822f8 <__etext+0x379650>
    16f4:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    16f8:	13000013 	movwne	r0, #19
    16fc:	1349000d 	movtne	r0, #36877	; 0x900d
    1700:	00000a38 	andeq	r0, r0, r8, lsr sl
                     |DMA_ATTR_SMOD(0x0)
                     |DMA_ATTR_SSIZE(byten)
                     |DMA_ATTR_DMOD(0x0)
                     |DMA_ATTR_DSIZE(byten)
                    );
    DMA_CITER_ELINKNO(CHn) = DMA_CITER_ELINKNO_CITER(count);
    1704:	03010414 	movweq	r0, #5140	; 0x1414
    1708:	3a0b0b0e 	bcc	2c4348 <__etext+0x2bb6a0>
    170c:	010b3b0b 	tsteq	fp, fp, lsl #22
    1710:	15000013 	strne	r0, [r0, #-19]
    1714:	0c270015 	stceq	0, cr0, [r7], #-84	; 0xffffffac
    1718:	13160000 	tstne	r6, #0
    171c:	3a0b0b01 	bcc	2c4328 <__etext+0x2bb680>
    1720:	010b3b0b 	tsteq	fp, fp, lsl #22
    1724:	17000013 	smladne	r0, r3, r0, r0
    1728:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
    DMA_BITER_ELINKNO(CHn) = DMA_BITER_ELINKNO_BITER(count);
    172c:	0b3b0b3a 	bleq	ec441c <__etext+0xebb774>
    1730:	0a381349 	beq	e0645c <__etext+0xdfd7b4>
    1734:	2e180000 	cdpcs	0, 1, cr0, cr8, cr0, {0}
    1738:	030c3f01 	movweq	r3, #52993	; 0xcf01
    173c:	3b0b3a0e 	blcc	2cff7c <__etext+0x2c72d4>
    1740:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
    1744:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    1748:	97064001 	strls	r4, [r6, -r1]
    174c:	13010c42 	movwne	r0, #7234	; 0x1c42
    1750:	05190000 	ldreq	r0, [r9, #-0]

    DMA_CR &= ~DMA_CR_EMLM_MASK;
    1754:	3a0e0300 	bcc	38235c <__etext+0x3796b4>
    1758:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    175c:	000a0213 	andeq	r0, sl, r3, lsl r2
    1760:	00341a00 	eorseq	r1, r4, r0, lsl #20
    1764:	0b3a0e03 	bleq	e84f78 <__etext+0xe7c2d0>
    1768:	13490b3b 	movtne	r0, #39739	; 0x9b3b

    DMA_NBYTES_MLNO(CHn) = DMA_NBYTES_MLNO_NBYTES(BYTEs);
    176c:	00000a02 	andeq	r0, r0, r2, lsl #20
    1770:	3f012e1b 	svccc	0x00012e1b
    1774:	3a0e030c 	bcc	3823ac <__etext+0x379704>
    1778:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
    177c:	1113490c 	tstne	r3, ip, lsl #18
    1780:	40011201 	andmi	r1, r1, r1, lsl #4
    1784:	0c429606 	mcrreq	6, 0, r9, r2, cr6

    DMA_SLAST(CHn) = 0;
    1788:	00001301 	andeq	r1, r0, r1, lsl #6
    178c:	0300051c 	movweq	r0, #1308	; 0x51c
    1790:	3b0b3a0e 	blcc	2cffd0 <__etext+0x2c7328>
    1794:	02134905 	andseq	r4, r3, #81920	; 0x14000
    1798:	1d00000a 	stcne	0, cr0, [r0, #-40]	; 0xffffffd8
    179c:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    17a0:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    17a4:	0a021349 	beq	864d0 <__etext+0x7d828>
    DMA_DLAST_SGA(CHn) = (uint32)((cfg & DADDR_KEEPON) == 0 ? (-count) : 0);
    17a8:	2e1e0000 	cdpcs	0, 1, cr0, cr14, cr0, {0}
    17ac:	030c3f01 	movweq	r3, #52993	; 0xcf01
    17b0:	3b0b3a0e 	blcc	2cfff0 <__etext+0x2c7348>
    17b4:	490c2705 	stmdbmi	ip, {r0, r2, r8, r9, sl, sp}
    17b8:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    17bc:	97064001 	strls	r4, [r6, -r1]
    17c0:	13010c42 	movwne	r0, #7234	; 0x1c42
    17c4:	2e1f0000 	cdpcs	0, 1, cr0, cr15, cr0, {0}
    17c8:	030c3f01 	movweq	r3, #52993	; 0xcf01
    17cc:	3b0b3a0e 	blcc	2d000c <__etext+0x2c7364>
    17d0:	110c2705 	tstne	ip, r5, lsl #14
    17d4:	40011201 	andmi	r1, r1, r1, lsl #4
    DMA_CSR(CHn) = (0
    17d8:	0c429706 	mcrreq	7, 0, r9, r2, cr6
    17dc:	00001301 	andeq	r1, r0, r1, lsl #6
    17e0:	3f002e20 	svccc	0x00002e20
    17e4:	3a0e030c 	bcc	38241c <__etext+0x379774>
    17e8:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
    17ec:	1201110c 	andne	r1, r1, #3
    17f0:	96064001 	strls	r4, [r6], -r1
                    |DMA_CSR_BWC(3)
                    |DMA_CSR_DREQ_MASK
                    |DMA_CSR_INTMAJOR_MASK
                   );

    DMAMUX_CHCFG_REG(DMAMUX0_BASE_PTR, CHn) = (0                
    17f4:	00000c42 	andeq	r0, r0, r2, asr #24
    17f8:	03003421 	movweq	r3, #1057	; 0x421
    17fc:	3b0b3a0e 	blcc	2d003c <__etext+0x2c7394>
    1800:	3f13490b 	svccc	0x0013490b
    1804:	000a020c 	andeq	r0, sl, ip, lsl #4
    1808:	11010000 	mrsne	r0, (UNDEF: 1)
    180c:	130e2501 	movwne	r2, #58625	; 0xe501
    |DMAMUX_CHCFG_ENBL_MASK
    |DMAMUX_CHCFG_SOURCE(dma_req));
    DMA_DIS(CHn);
    1810:	1b0e030b 	blne	382444 <__etext+0x37979c>
    1814:	1201110e 	andne	r1, r1, #-2147483645	; 0x80000003
    1818:	00061001 	andeq	r1, r6, r1
    181c:	00240200 	eoreq	r0, r4, r0, lsl #4
    1820:	0b3e0b0b 	bleq	f84454 <__etext+0xf7b7ac>
    1824:	00000e03 	andeq	r0, r0, r3, lsl #28
    1828:	03001603 	movweq	r1, #1539	; 0x603
    182c:	3b0b3a0e 	blcc	2d006c <__etext+0x2c73c4>
    1830:	0013490b 	andseq	r4, r3, fp, lsl #18
    DMA_IRQ_CLEAN(CHn);
    1834:	00240400 	eoreq	r0, r4, r0, lsl #8
    1838:	0b3e0b0b 	bleq	f8446c <__etext+0xf7b7c4>
    183c:	00000803 	andeq	r0, r0, r3, lsl #16
    1840:	0b010405 	bleq	4285c <__etext+0x39bb4>
    1844:	3b0b3a0b 	blcc	2d0078 <__etext+0x2c73d0>
    1848:	0013010b 	andseq	r0, r3, fp, lsl #2
    184c:	00280600 	eoreq	r0, r8, r0, lsl #12
    1850:	0d1c0e03 	ldceq	14, cr0, [ip, #-12]
}
    1854:	01070000 	mrseq	r0, (UNDEF: 7)
    1858:	01134901 	tsteq	r3, r1, lsl #18


//提取中线
void get_midline(uint8 *img, uint8 h, uint8 w)
{
    185c:	08000013 	stmdaeq	r0, {r0, r1, r4}
    1860:	13490021 	movtne	r0, #36897	; 0x9021
    1864:	00000b2f 	andeq	r0, r0, pc, lsr #22
    1868:	03011309 	movweq	r1, #4873	; 0x1309
    int16 p = 0, i = 0, line_mid = 39;
    186c:	3a0b0b0e 	bcc	2c44ac <__etext+0x2bb804>
    1870:	01053b0b 	tsteq	r5, fp, lsl #22
    1874:	0a000013 	beq	18c8 <get_midline+0x6c>
    1878:	0803000d 	stmdaeq	r3, {r0, r2, r3}
    187c:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    int8 side_left = 0, side_right = 79;
    1880:	0a381349 	beq	e065ac <__etext+0xdfd904>
    1884:	0d0b0000 	stceq	0, cr0, [fp, #-0]
    1888:	3a0e0300 	bcc	382490 <__etext+0x3797e8>

    if (img[(h-1)*w + line_mid] == 0xff)
    188c:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    1890:	000a3813 	andeq	r3, sl, r3, lsl r8
    1894:	00160c00 	andseq	r0, r6, r0, lsl #24
    1898:	0b3a0e03 	bleq	e850ac <__etext+0xe7c404>
    189c:	1349053b 	movtne	r0, #38203	; 0x953b
    18a0:	0f0d0000 	svceq	0x000d0000
    18a4:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
    {
        for (i = h - 1; i >= 0; i --)
    18a8:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
    18ac:	13490035 	movtne	r0, #36917	; 0x9035
    18b0:	130f0000 	movwne	r0, #61440	; 0xf000
    18b4:	0b0e0301 	bleq	3824c0 <__etext+0x379818>
        {
            for (p = line_mid - 1; p > 0; p --)
    18b8:	3b0b3a05 	blcc	2d00d4 <__etext+0x2c742c>
    18bc:	00130105 	andseq	r0, r3, r5, lsl #2
    18c0:	00211000 	eoreq	r1, r1, r0
            {
                if (img[i * w + p] == 0)
    18c4:	052f1349 	streq	r1, [pc, #-841]!	; 1583 <Ov7725_isr+0x37>
    18c8:	17110000 	ldrne	r0, [r1, -r0]
    18cc:	3a0b0b01 	bcc	2c44d8 <__etext+0x2bb830>
    18d0:	01053b0b 	tsteq	r5, fp, lsl #22
    18d4:	12000013 	andne	r0, r0, #19
    18d8:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
                    if ((img[i * w + p - 1] == 0) 
    18dc:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    18e0:	00001349 	andeq	r1, r0, r9, asr #6
    18e4:	49000d13 	stmdbmi	r0, {r0, r1, r4, r8, sl, fp}
    18e8:	000a3813 	andeq	r3, sl, r3, lsl r8
    18ec:	01041400 	tsteq	r4, r0, lsl #8
    18f0:	0b0b0e03 	bleq	2c5104 <__etext+0x2bc45c>
    18f4:	0b3b0b3a 	bleq	ec45e4 <__etext+0xebb93c>
    18f8:	00001301 	andeq	r1, r0, r1, lsl #6
                            && (line_mid-p-1>= 0))
    18fc:	27001515 	smladcs	r0, r5, r5, r1
    1900:	1600000c 	strne	r0, [r0], -ip
    1904:	0b0b0113 	bleq	2c1d58 <__etext+0x2b90b0>
    1908:	0b3b0b3a 	bleq	ec45f8 <__etext+0xebb950>
                    {
                        side_left = p;
    190c:	00001301 	andeq	r1, r0, r1, lsl #6
                        p = p - 2;
    1910:	03000d17 	movweq	r0, #3351	; 0xd17
    1914:	3b0b3a0e 	blcc	2d0154 <__etext+0x2c74ac>
    1918:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
                        for (; p >= 0; p --)
                            img[i * w + p] = 0;
    191c:	1800000a 	stmdane	r0, {r1, r3}
    1920:	0c3f012e 	ldfeqs	f0, [pc], #-184	; 1870 <get_midline+0x14>
    1924:	0b3a0e03 	bleq	e85138 <__etext+0xe7c490>
    1928:	0c270b3b 	stceq	11, cr0, [r7], #-236	; 0xffffff14
    192c:	01120111 	tsteq	r2, r1, lsl r1
    1930:	42970640 	addsmi	r0, r7, #67108864	; 0x4000000
    1934:	0013010c 	andseq	r0, r3, ip, lsl #2
                    if ((img[i * w + p - 1] == 0) 
                            && (line_mid-p-1>= 0))
                    {
                        side_left = p;
                        p = p - 2;
                        for (; p >= 0; p --)
    1938:	00051900 	andeq	r1, r5, r0, lsl #18
    193c:	0b3a0e03 	bleq	e85150 <__etext+0xe7c4a8>
    1940:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1944:	00000a02 	andeq	r0, r0, r2, lsl #20

    if (img[(h-1)*w + line_mid] == 0xff)
    {
        for (i = h - 1; i >= 0; i --)
        {
            for (p = line_mid - 1; p > 0; p --)
    1948:	0300341a 	movweq	r3, #1050	; 0x41a
    194c:	3b0b3a08 	blcc	2d0174 <__etext+0x2c74cc>
    1950:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    1954:	1b00000a 	blne	1984 <get_midline+0x128>
                        p = p - 2;
                        for (; p >= 0; p --)
                            img[i * w + p] = 0;
                    }
            }
            for (p = line_mid + 1; p < w -1; p ++)
    1958:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    195c:	0b3b0b3a 	bleq	ec464c <__etext+0xebb9a4>
    1960:	0a021349 	beq	8668c <__etext+0x7d9e4>
            {
                if (img[i * w + p] == 0)
    1964:	2e1c0000 	cdpcs	0, 1, cr0, cr12, cr0, {0}
    1968:	030c3f01 	movweq	r3, #52993	; 0xcf01
    196c:	3b0b3a0e 	blcc	2d01ac <__etext+0x2c7504>
    1970:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
    1974:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    1978:	97064001 	strls	r4, [r6, -r1]
                {
                    if ((img[i * w + p + 1] == 0)&&(p+1<w))
    197c:	13010c42 	movwne	r0, #7234	; 0x1c42
    1980:	2e1d0000 	cdpcs	0, 1, cr0, cr13, cr0, {0}
    1984:	030c3f01 	movweq	r3, #52993	; 0xcf01
    1988:	3b0b3a0e 	blcc	2d01c8 <__etext+0x2c7520>
    198c:	110c2705 	tstne	ip, r5, lsl #14
    1990:	40011201 	andmi	r1, r1, r1, lsl #4
    1994:	0c429706 	mcrreq	7, 0, r9, r2, cr6
    1998:	00001301 	andeq	r1, r0, r1, lsl #6
    199c:	0300051e 	movweq	r0, #1310	; 0x51e
    19a0:	3b0b3a0e 	blcc	2d01e0 <__etext+0x2c7538>
    19a4:	02134905 	andseq	r4, r3, #81920	; 0x14000
                    {
                        side_right = p;
    19a8:	1f00000a 	svcne	0x0000000a
                        p = p + 2;
    19ac:	08030005 	stmdaeq	r3, {r0, r2}
    19b0:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    19b4:	0a021349 	beq	866e0 <__etext+0x7da38>
                        for (; p < w; p ++)
                            img[i * w + p] = 0;
    19b8:	2e200000 	cdpcs	0, 2, cr0, cr0, cr0, {0}
    19bc:	030c3f01 	movweq	r3, #52993	; 0xcf01
    19c0:	3b0b3a0e 	blcc	2d0200 <__etext+0x2c7558>
    19c4:	110c2705 	tstne	ip, r5, lsl #14
    19c8:	40011201 	andmi	r1, r1, r1, lsl #4
    19cc:	0c429606 	mcrreq	6, 0, r9, r2, cr6
    19d0:	00001301 	andeq	r1, r0, r1, lsl #6
                {
                    if ((img[i * w + p + 1] == 0)&&(p+1<w))
                    {
                        side_right = p;
                        p = p + 2;
                        for (; p < w; p ++)
    19d4:	3f002e21 	svccc	0x00002e21
    19d8:	3a0e030c 	bcc	382610 <__etext+0x379968>
    19dc:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
    19e0:	1201110c 	andne	r1, r1, #3
                        p = p - 2;
                        for (; p >= 0; p --)
                            img[i * w + p] = 0;
                    }
            }
            for (p = line_mid + 1; p < w -1; p ++)
    19e4:	96064001 	strls	r4, [r6], -r1
    19e8:	00000c42 	andeq	r0, r0, r2, asr #24
    19ec:	03003422 	movweq	r3, #1058	; 0x422
    19f0:	3b0b3a0e 	blcc	2d0230 <__etext+0x2c7588>
    19f4:	3f13490b 	svccc	0x0013490b
    19f8:	000c3c0c 	andeq	r3, ip, ip, lsl #24
                        for (; p < w; p ++)
                            img[i * w + p] = 0;
                    }
                }
            }
            line_mid = (side_left + side_right) / 2;
    19fc:	00342300 	eorseq	r2, r4, r0, lsl #6
    1a00:	0b3a0e03 	bleq	e85214 <__etext+0xe7c56c>
    1a04:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1a08:	0a020c3f 	beq	84b0c <__etext+0x7be64>
    1a0c:	01000000 	mrseq	r0, (UNDEF: 0)
            img[i * w + line_mid] = 0;
    1a10:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
    1a14:	0e030b13 	vmoveq.32	d3[0], r0
    1a18:	01110e1b 	tsteq	r1, fp, lsl lr
    1a1c:	06100112 			; <UNDEFINED> instruction: 0x06100112
    1a20:	24020000 	strcs	r0, [r2], #-0
    1a24:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    1a28:	000e030b 	andeq	r0, lr, fp, lsl #6
    int16 p = 0, i = 0, line_mid = 39;
    int8 side_left = 0, side_right = 79;

    if (img[(h-1)*w + line_mid] == 0xff)
    {
        for (i = h - 1; i >= 0; i --)
    1a2c:	00160300 	andseq	r0, r6, r0, lsl #6
    1a30:	0b3a0e03 	bleq	e85244 <__etext+0xe7c59c>
    1a34:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1a38:	24040000 	strcs	r0, [r4], #-0
            }
            line_mid = (side_left + side_right) / 2;
            img[i * w + line_mid] = 0;
        }
    }
}
    1a3c:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    1a40:	0008030b 	andeq	r0, r8, fp, lsl #6
    1a44:	01010500 	tsteq	r1, r0, lsl #10
  ptb.GPIO_PinControl = NULL;
  LPLD_GPIO_Init(ptb);
}*/

void LPLD_SCCB_Init(void)
{
    1a48:	13011349 	movwne	r1, #4937	; 0x1349
    1a4c:	21060000 	mrscs	r0, (UNDEF: 6)
  GPIO_InitTypeDef ptb;
  /********û޸ֵ ʼ***********/
  ptb.GPIO_PTx = PTA;
    1a50:	2f134900 	svccs	0x00134900
    1a54:	0700000b 	streq	r0, [r0, -fp]
  ptb.GPIO_Pins = GPIO_Pin25 | GPIO_Pin26;
    1a58:	0b0b0117 	bleq	2c1ebc <__etext+0x2b9214>
    1a5c:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
  /********û޸ֵ ***********/
  ptb.GPIO_Dir = DIR_OUTPUT;
    1a60:	00001301 	andeq	r1, r0, r1, lsl #6
  ptb.GPIO_Output = OUTPUT_H;
    1a64:	03000d08 	movweq	r0, #3336	; 0xd08
    1a68:	3b0b3a0e 	blcc	2d02a8 <__etext+0x2c7600>
  ptb.GPIO_PinControl = INPUT_PULL_UP;
    1a6c:	00134905 	andseq	r4, r3, r5, lsl #18
  LPLD_GPIO_Init(ptb);
    1a70:	01130900 	tsteq	r3, r0, lsl #18
    1a74:	0b0b0e03 	bleq	2c5288 <__etext+0x2bc5e0>
    1a78:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    1a7c:	00001301 	andeq	r1, r0, r1, lsl #6
}
    1a80:	03000d0a 	movweq	r0, #3338	; 0xd0a
    1a84:	3b0b3a08 	blcc	2d02ac <__etext+0x2c7604>
 * :
 *    1-ɹ
 *    0-ʧ
 */
uint8 LPLD_SCCB_WriteReg(uint16 reg_addr , uint8 data)
{		
    1a88:	38134905 	ldmdacc	r3, {r0, r2, r8, fp, lr}
    1a8c:	0b00000a 	bleq	1abc <LPLD_SCCB_WriteReg+0x34>
    1a90:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
    1a94:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
  if(!LPLD_SCCB_Start())
    1a98:	0a381349 	beq	e067c4 <__etext+0xdfdb1c>
    1a9c:	0d0c0000 	stceq	0, cr0, [ip, #-0]
  {
    return 0;
    1aa0:	38134900 	ldmdacc	r3, {r8, fp, lr}
    1aa4:	0d00000a 	stceq	0, cr0, [r0, #-40]	; 0xffffffd8
  }
  LPLD_SCCB_SendByte(SCCB_DEV_ADR ); 
    1aa8:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
    1aac:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
  if(!LPLD_SCCB_WaitAck())
    1ab0:	00001349 	andeq	r1, r0, r9, asr #6
    1ab4:	0b000f0e 	bleq	56f4 <LPLD_PLL_Setup+0x204>
  {
    LPLD_SCCB_Stop(); 
    1ab8:	0013490b 	andseq	r4, r3, fp, lsl #18
    return 0;
    1abc:	00350f00 	eorseq	r0, r5, r0, lsl #30
    1ac0:	00001349 	andeq	r1, r0, r9, asr #6
  }
  LPLD_SCCB_SendByte((uint8)(reg_addr & 0x00FF));   
    1ac4:	3f002e10 	svccc	0x00002e10
    1ac8:	3a0e030c 	bcc	382700 <__etext+0x379a58>
  LPLD_SCCB_WaitAck();	
    1acc:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
  LPLD_SCCB_SendByte(data);
    1ad0:	1113490c 	tstne	r3, ip, lsl #18
    1ad4:	40011201 	andmi	r1, r1, r1, lsl #4
  LPLD_SCCB_WaitAck();   
    1ad8:	0c429606 	mcrreq	6, 0, r9, r2, cr6
  LPLD_SCCB_Stop(); 
    1adc:	2e110000 	cdpcs	0, 1, cr0, cr1, cr0, {0}
  return 1;
    1ae0:	030c3f01 	movweq	r3, #52993	; 0xcf01
}									 
    1ae4:	3b0b3a0e 	blcc	2d0324 <__etext+0x2c767c>
    1ae8:	110c270b 	tstne	ip, fp, lsl #14
    1aec:	40011201 	andmi	r1, r1, r1, lsl #4
 * :
 *    1-ɹ
 *    0-ʧ
 */          
uint8 LPLD_SCCB_ReadReg(uint8 reg_addr, uint8* data, uint16 length)
{	
    1af0:	0c429606 	mcrreq	6, 0, r9, r2, cr6
    1af4:	00001301 	andeq	r1, r0, r1, lsl #6
    1af8:	03000512 	movweq	r0, #1298	; 0x512
    1afc:	3b0b3a08 	blcc	2d0324 <__etext+0x2c767c>
  if(!LPLD_SCCB_Start())
    1b00:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    1b04:	0000000a 	andeq	r0, r0, sl
    1b08:	25011101 	strcs	r1, [r1, #-257]	; 0x101
  {
    return 0;
    1b0c:	030b130e 	movweq	r1, #45838	; 0xb30e
  }
  LPLD_SCCB_SendByte( SCCB_DEV_ADR ); 
    1b10:	110e1b0e 	tstne	lr, lr, lsl #22
    1b14:	10011201 	andne	r1, r1, r1, lsl #4
  if( !LPLD_SCCB_WaitAck() )
    1b18:	02000006 	andeq	r0, r0, #6
    1b1c:	0b0b0024 	bleq	2c1bb4 <__etext+0x2b8f0c>
    1b20:	0e030b3e 	vmoveq.16	d3[0], r0
  {
    LPLD_SCCB_Stop(); 
    1b24:	24030000 	strcs	r0, [r3], #-0
    return 0;
    1b28:	3e0b0b00 	vmlacc.f64	d0, d11, d0
  }
  LPLD_SCCB_SendByte( reg_addr ); 
    1b2c:	0008030b 	andeq	r0, r8, fp, lsl #6
    1b30:	00160400 	andseq	r0, r6, r0, lsl #8
  LPLD_SCCB_WaitAck();	
    1b34:	0b3a0e03 	bleq	e85348 <__etext+0xe7c6a0>
  LPLD_SCCB_Stop(); 
    1b38:	13490b3b 	movtne	r0, #39739	; 0x9b3b
  
  if(!LPLD_SCCB_Start())
    1b3c:	13050000 	movwne	r0, #20480	; 0x5000
    1b40:	0b0e0301 	bleq	38274c <__etext+0x379aa4>
    1b44:	3b0b3a0b 	blcc	2d0378 <__etext+0x2c76d0>
  {
    return 0;
    1b48:	0013010b 	andseq	r0, r3, fp, lsl #2
  }
  LPLD_SCCB_SendByte( SCCB_DEV_ADR + 1 );
    1b4c:	000d0600 	andeq	r0, sp, r0, lsl #12
    1b50:	13490e03 	movtne	r0, #40451	; 0x9e03
  
  if(!LPLD_SCCB_WaitAck())
    1b54:	0c340a38 	ldceq	10, cr0, [r4], #-224	; 0xffffff20
    1b58:	0f070000 	svceq	0x00070000
    1b5c:	000b0b00 	andeq	r0, fp, r0, lsl #22
  {
    LPLD_SCCB_Stop(); 
    1b60:	000f0800 	andeq	r0, pc, r0, lsl #16
    return 0;
    1b64:	13490b0b 	movtne	r0, #39691	; 0x9b0b
  }
  while(length)
  {
    *data = LPLD_SCCB_ReceiveByte();
    1b68:	26090000 	strcs	r0, [r9], -r0
    1b6c:	00134900 	andseq	r4, r3, r0, lsl #18
    1b70:	01130a00 	tsteq	r3, r0, lsl #20
    if(length == 1)
    1b74:	0b3a0b0b 	bleq	e847a8 <__etext+0xe7bb00>
    1b78:	13010b3b 	movwne	r0, #6971	; 0x1b3b
    {
      LPLD_SCCB_NoAck();
    1b7c:	0d0b0000 	stceq	0, cr0, [fp, #-0]
    }
    else
    {
      LPLD_SCCB_Ack(); 
    1b80:	3a0e0300 	bcc	382788 <__etext+0x379ae0>
    }
    data++;
    1b84:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1b88:	000a3813 	andeq	r3, sl, r3, lsl r8
    length--;
    1b8c:	000d0c00 	andeq	r0, sp, r0, lsl #24
    1b90:	0b3a0803 	bleq	e83ba4 <__etext+0xe7aefc>
  if(!LPLD_SCCB_WaitAck())
  {
    LPLD_SCCB_Stop(); 
    return 0;
  }
  while(length)
    1b94:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1b98:	00000a38 	andeq	r0, r0, r8, lsr sl
      LPLD_SCCB_Ack(); 
    }
    data++;
    length--;
  }
  LPLD_SCCB_Stop();
    1b9c:	2701150d 	strcs	r1, [r1, -sp, lsl #10]
  return 1;
    1ba0:	0013010c 	andseq	r0, r3, ip, lsl #2
}
    1ba4:	00050e00 	andeq	r0, r5, r0, lsl #28
    1ba8:	00001349 	andeq	r1, r0, r9, asr #6
/*
 * LPLD_SCCB_Start
 * SCCBʼźţڲ
 */
uint8 LPLD_SCCB_Start(void)
{
    1bac:	03012e0f 	movweq	r2, #7695	; 0x1e0f
  SCCB_SDA_O=1;//ߵƽ
    1bb0:	3b0b3a0e 	blcc	2d03f0 <__etext+0x2c7748>
    1bb4:	110c270b 	tstne	ip, fp, lsl #14
    1bb8:	40011201 	andmi	r1, r1, r1, lsl #4
    1bbc:	0c429606 	mcrreq	6, 0, r9, r2, cr6
  SCCB_SCL=1;   //ʱߵƽ 
    1bc0:	00001301 	andeq	r1, r0, r1, lsl #6
    1bc4:	03000510 	movweq	r0, #1296	; 0x510
    1bc8:	3b0b3a08 	blcc	2d03f0 <__etext+0x2c7748>
  SCCB_DELAY();
    1bcc:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    1bd0:	1100000a 	tstne	r0, sl
  
  SCCB_SDA_IN();//Ϊ
    1bd4:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    1bd8:	0b3b0b3a 	bleq	ec48c8 <__etext+0xebbc20>
    1bdc:	0a021349 	beq	86908 <__etext+0x7dc60>
    1be0:	2e120000 	cdpcs	0, 1, cr0, cr2, cr0, {0}
  if(!SCCB_SDA_I)
    1be4:	3a0e0301 	bcc	3827f0 <__etext+0x379b48>
    1be8:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    1bec:	1113490c 	tstne	r3, ip, lsl #18
  {
    SCCB_SDA_OUT();	
    1bf0:	40011201 	andmi	r1, r1, r1, lsl #4
    1bf4:	0c429706 	mcrreq	7, 0, r9, r2, cr6
    1bf8:	00001301 	andeq	r1, r0, r1, lsl #6
    1bfc:	03003413 	movweq	r3, #1043	; 0x413
    return 0;
    1c00:	3b0b3a08 	blcc	2d0428 <__etext+0x2c7780>
  }
  SCCB_SDA_OUT();//Ϊ;	
    1c04:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    1c08:	1400000a 	strne	r0, [r0], #-10
    1c0c:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    1c10:	0b3b0b3a 	bleq	ec4900 <__etext+0xebbc58>
  SCCB_SDA_O=0; //͵ƽ
    1c14:	0a021349 	beq	86940 <__etext+0x7dc98>
    1c18:	0a150000 	beq	541c20 <__etext+0x538f78>
    1c1c:	3a0e0300 	bcc	382824 <__etext+0x379b7c>
  
  SCCB_DELAY();
    1c20:	110b3b0b 	tstne	fp, fp, lsl #22
    1c24:	16000001 	strne	r0, [r0], -r1
  
  SCCB_SDA_IN();//Ϊ
    1c28:	0c3f012e 	ldfeqs	f0, [pc], #-184	; 1b78 <LPLD_SCCB_ReadReg+0x88>
    1c2c:	0b3a0e03 	bleq	e85440 <__etext+0xe7c798>
    1c30:	0c270b3b 	stceq	11, cr0, [r7], #-236	; 0xffffff14
    1c34:	01111349 	tsteq	r1, r9, asr #6
  if(SCCB_SDA_I) 
    1c38:	06400112 			; <UNDEFINED> instruction: 0x06400112
    1c3c:	010c4296 			; <UNDEFINED> instruction: 0x010c4296
    1c40:	17000013 	smladne	r0, r3, r0, r0
  {
    SCCB_SDA_OUT();
    1c44:	0e03000a 	cdpeq	0, 0, cr0, cr3, cr10, {0}
    1c48:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    1c4c:	00000111 	andeq	r0, r0, r1, lsl r1
    1c50:	49010118 	stmdbmi	r1, {r3, r4, r8}
    return 0;
    1c54:	00130113 	andseq	r0, r3, r3, lsl r1
  }
  SCCB_SDA_OUT();//Ϊ
    1c58:	00211900 	eoreq	r1, r1, r0, lsl #18
    1c5c:	0b2f1349 	bleq	bc6988 <__etext+0xbbdce0>
    1c60:	051a0000 	ldreq	r0, [sl, #-0]
    1c64:	3a080300 	bcc	20286c <__etext+0x1f9bc4>
  SCCB_SDA_O=0;//͵ƽ
    1c68:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    1c6c:	000a0213 	andeq	r0, sl, r3, lsl r2
    1c70:	00181b00 	andseq	r1, r8, r0, lsl #22
  return 1;
    1c74:	341c0000 	ldrcc	r0, [ip], #-0
}
    1c78:	3a080300 	bcc	202880 <__etext+0x1f9bd8>
/*
 * LPLD_SCCB_Stop
 * SCCBֹͣźţڲ
 */
static void LPLD_SCCB_Stop(void)
{
    1c7c:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
  SCCB_SCL=0;
    1c80:	000a0213 	andeq	r0, sl, r3, lsl r2
    1c84:	00341d00 	eorseq	r1, r4, r0, lsl #26
    1c88:	0b3a0e03 	bleq	e8549c <__etext+0xe7c7f4>
    1c8c:	1349053b 	movtne	r0, #38203	; 0x953b
  SCCB_SDA_O=0;
    1c90:	00000a02 	andeq	r0, r0, r2, lsl #20
    1c94:	3f012e1e 	svccc	0x00012e1e
    1c98:	3a0e030c 	bcc	3828d0 <__etext+0x379c28>
  SCCB_DELAY();
    1c9c:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    1ca0:	1113490c 	tstne	r3, ip, lsl #18
  
  SCCB_SCL=1;
    1ca4:	40011201 	andmi	r1, r1, r1, lsl #4
    1ca8:	0c429606 	mcrreq	6, 0, r9, r2, cr6
    1cac:	Address 0x00001cac is out of bounds.


Disassembly of section .debug_loc:

00000000 <.debug_loc>:
       0:	00000000 	andeq	r0, r0, r0
       4:	00000002 	andeq	r0, r0, r2
       8:	007d0002 	rsbseq	r0, sp, r2
       c:	00000002 	andeq	r0, r0, r2
      10:	00000004 	andeq	r0, r0, r4
      14:	087d0002 	ldmdaeq	sp!, {r1}^
      18:	00000004 	andeq	r0, r0, r4
      1c:	00000006 	andeq	r0, r0, r6
      20:	187d0002 	ldmdane	sp!, {r1}^
      24:	00000006 	andeq	r0, r0, r6
      28:	000000d6 	ldrdeq	r0, [r0], -r6
      2c:	08770002 	ldmdaeq	r7!, {r1}^
	...
      3c:	00000002 	andeq	r0, r0, r2
      40:	007d0002 	rsbseq	r0, sp, r2
      44:	00000002 	andeq	r0, r0, r2
      48:	00000004 	andeq	r0, r0, r4
      4c:	087d0002 	ldmdaeq	sp!, {r1}^
      50:	00000004 	andeq	r0, r0, r4
      54:	00000006 	andeq	r0, r0, r6
      58:	107d0002 	rsbsne	r0, sp, r2
      5c:	00000006 	andeq	r0, r0, r6
      60:	0000003c 	andeq	r0, r0, ip, lsr r0
      64:	10770002 	rsbsne	r0, r7, r2
	...
      70:	0000003c 	andeq	r0, r0, ip, lsr r0
      74:	0000003e 	andeq	r0, r0, lr, lsr r0
      78:	007d0002 	rsbseq	r0, sp, r2
      7c:	0000003e 	andeq	r0, r0, lr, lsr r0
      80:	00000040 	andeq	r0, r0, r0, asr #32
      84:	087d0002 	ldmdaeq	sp!, {r1}^
      88:	00000040 	andeq	r0, r0, r0, asr #32
      8c:	00000042 	andeq	r0, r0, r2, asr #32
      90:	107d0002 	rsbsne	r0, sp, r2
      94:	00000042 	andeq	r0, r0, r2, asr #32
      98:	000000e0 	andeq	r0, r0, r0, ror #1
      9c:	10770002 	rsbsne	r0, r7, r2
	...
      ac:	00000002 	andeq	r0, r0, r2
      b0:	007d0002 	rsbseq	r0, sp, r2
      b4:	00000002 	andeq	r0, r0, r2
      b8:	00000004 	andeq	r0, r0, r4
      bc:	087d0002 	ldmdaeq	sp!, {r1}^
      c0:	00000004 	andeq	r0, r0, r4
      c4:	000000f4 	strdeq	r0, [r0], -r4
      c8:	08770002 	ldmdaeq	r7!, {r1}^
	...
      d4:	000000f4 	strdeq	r0, [r0], -r4
      d8:	000000f6 	strdeq	r0, [r0], -r6
      dc:	007d0002 	rsbseq	r0, sp, r2
      e0:	000000f6 	strdeq	r0, [r0], -r6
      e4:	000000f8 	strdeq	r0, [r0], -r8
      e8:	047d0002 	ldrbteq	r0, [sp], #-2
      ec:	000000f8 	strdeq	r0, [r0], -r8
      f0:	000000fa 	strdeq	r0, [r0], -sl
      f4:	107d0002 	rsbsne	r0, sp, r2
      f8:	000000fa 	strdeq	r0, [r0], -sl
      fc:	00000158 	andeq	r0, r0, r8, asr r1
     100:	10770002 	rsbsne	r0, r7, r2
	...
     10c:	00000158 	andeq	r0, r0, r8, asr r1
     110:	0000015a 	andeq	r0, r0, sl, asr r1
     114:	007d0002 	rsbseq	r0, sp, r2
     118:	0000015a 	andeq	r0, r0, sl, asr r1
     11c:	0000015c 	andeq	r0, r0, ip, asr r1
     120:	047d0002 	ldrbteq	r0, [sp], #-2
     124:	0000015c 	andeq	r0, r0, ip, asr r1
     128:	0000015e 	andeq	r0, r0, lr, asr r1
     12c:	187d0002 	ldmdane	sp!, {r1}^
     130:	0000015e 	andeq	r0, r0, lr, asr r1
     134:	000002de 	ldrdeq	r0, [r0], -lr
     138:	18770002 	ldmdane	r7!, {r1}^
	...
     144:	000002e0 	andeq	r0, r0, r0, ror #5
     148:	000002e2 	andeq	r0, r0, r2, ror #5
     14c:	007d0002 	rsbseq	r0, sp, r2
     150:	000002e2 	andeq	r0, r0, r2, ror #5
     154:	000002e4 	andeq	r0, r0, r4, ror #5
     158:	047d0002 	ldrbteq	r0, [sp], #-2
     15c:	000002e4 	andeq	r0, r0, r4, ror #5
     160:	000002e6 	andeq	r0, r0, r6, ror #5
     164:	187d0002 	ldmdane	sp!, {r1}^
     168:	000002e6 	andeq	r0, r0, r6, ror #5
     16c:	000003d2 	ldrdeq	r0, [r0], -r2
     170:	18770002 	ldmdane	r7!, {r1}^
	...
     17c:	000003d4 	ldrdeq	r0, [r0], -r4
     180:	000003d6 	ldrdeq	r0, [r0], -r6
     184:	007d0002 	rsbseq	r0, sp, r2
     188:	000003d6 	ldrdeq	r0, [r0], -r6
     18c:	000003d8 	ldrdeq	r0, [r0], -r8
     190:	087d0002 	ldmdaeq	sp!, {r1}^
     194:	000003d8 	ldrdeq	r0, [r0], -r8
     198:	000003da 	ldrdeq	r0, [r0], -sl
     19c:	287d0002 	ldmdacs	sp!, {r1}^
     1a0:	000003da 	ldrdeq	r0, [r0], -sl
     1a4:	00000418 	andeq	r0, r0, r8, lsl r4
     1a8:	20770002 	rsbscs	r0, r7, r2
	...
     1b8:	00000002 	andeq	r0, r0, r2
     1bc:	007d0002 	rsbseq	r0, sp, r2
     1c0:	00000002 	andeq	r0, r0, r2
     1c4:	00000004 	andeq	r0, r0, r4
     1c8:	087d0002 	ldmdaeq	sp!, {r1}^
     1cc:	00000004 	andeq	r0, r0, r4
     1d0:	00000006 	andeq	r0, r0, r6
     1d4:	c07d0003 	rsbsgt	r0, sp, r3
     1d8:	00000600 	andeq	r0, r0, r0, lsl #12
     1dc:	00020000 	andeq	r0, r2, r0
     1e0:	77000300 	strvc	r0, [r0, -r0, lsl #6]
     1e4:	000000c0 	andeq	r0, r0, r0, asr #1
     1e8:	00000000 	andeq	r0, r0, r0
     1ec:	02000000 	andeq	r0, r0, #0
     1f0:	02020000 	andeq	r0, r2, #0
     1f4:	00020000 	andeq	r0, r2, r0
     1f8:	0202007d 	andeq	r0, r2, #125	; 0x7d
     1fc:	02040000 	andeq	r0, r4, #0
     200:	00020000 	andeq	r0, r2, r0
     204:	0204047d 	andeq	r0, r4, #2097152000	; 0x7d000000
     208:	02060000 	andeq	r0, r6, #0
     20c:	00020000 	andeq	r0, r2, r0
     210:	0206107d 	andeq	r1, r6, #125	; 0x7d
     214:	02420000 	subeq	r0, r2, #0
     218:	00020000 	andeq	r0, r2, r0
     21c:	00001077 	andeq	r1, r0, r7, ror r0
     220:	00000000 	andeq	r0, r0, r0
     224:	02440000 	subeq	r0, r4, #0
     228:	02460000 	subeq	r0, r6, #0
     22c:	00020000 	andeq	r0, r2, r0
     230:	0246007d 	subeq	r0, r6, #125	; 0x7d
     234:	02480000 	subeq	r0, r8, #0
     238:	00020000 	andeq	r0, r2, r0
     23c:	0248087d 	subeq	r0, r8, #8192000	; 0x7d0000
     240:	024a0000 	subeq	r0, sl, #0
     244:	00020000 	andeq	r0, r2, r0
     248:	024a107d 	subeq	r1, sl, #125	; 0x7d
     24c:	02ea0000 	rsceq	r0, sl, #0
     250:	00020000 	andeq	r0, r2, r0
     254:	00000877 	andeq	r0, r0, r7, ror r8
     258:	00000000 	andeq	r0, r0, r0
     25c:	02ec0000 	rsceq	r0, ip, #0
     260:	02ee0000 	rsceq	r0, lr, #0
     264:	00020000 	andeq	r0, r2, r0
     268:	02ee007d 	rsceq	r0, lr, #125	; 0x7d
     26c:	02f00000 	rscseq	r0, r0, #0
     270:	00020000 	andeq	r0, r2, r0
     274:	02f0087d 	rscseq	r0, r0, #8192000	; 0x7d0000
     278:	03620000 	cmneq	r2, #0
     27c:	00020000 	andeq	r0, r2, r0
     280:	00000877 	andeq	r0, r0, r7, ror r8
     284:	00000000 	andeq	r0, r0, r0
     288:	03640000 	cmneq	r4, #0
     28c:	03660000 	cmneq	r6, #0
     290:	00020000 	andeq	r0, r2, r0
     294:	0366007d 	cmneq	r6, #125	; 0x7d
     298:	03680000 	cmneq	r8, #0
     29c:	00020000 	andeq	r0, r2, r0
     2a0:	0368087d 	cmneq	r8, #8192000	; 0x7d0000
     2a4:	036a0000 	cmneq	sl, #0
     2a8:	00020000 	andeq	r0, r2, r0
     2ac:	036a107d 	cmneq	sl, #125	; 0x7d
     2b0:	03b80000 			; <UNDEFINED> instruction: 0x03b80000
     2b4:	00020000 	andeq	r0, r2, r0
     2b8:	00000877 	andeq	r0, r0, r7, ror r8
     2bc:	00000000 	andeq	r0, r0, r0
     2c0:	03b80000 			; <UNDEFINED> instruction: 0x03b80000
     2c4:	03ba0000 			; <UNDEFINED> instruction: 0x03ba0000
     2c8:	00020000 	andeq	r0, r2, r0
     2cc:	03ba007d 			; <UNDEFINED> instruction: 0x03ba007d
     2d0:	03bc0000 			; <UNDEFINED> instruction: 0x03bc0000
     2d4:	00020000 	andeq	r0, r2, r0
     2d8:	03bc047d 			; <UNDEFINED> instruction: 0x03bc047d
     2dc:	03be0000 			; <UNDEFINED> instruction: 0x03be0000
     2e0:	00020000 	andeq	r0, r2, r0
     2e4:	03be207d 			; <UNDEFINED> instruction: 0x03be207d
     2e8:	050e0000 	streq	r0, [lr, #-0]
     2ec:	00020000 	andeq	r0, r2, r0
     2f0:	00002077 	andeq	r2, r0, r7, ror r0
     2f4:	00000000 	andeq	r0, r0, r0
     2f8:	05100000 	ldreq	r0, [r0, #-0]
     2fc:	05120000 	ldreq	r0, [r2, #-0]
     300:	00020000 	andeq	r0, r2, r0
     304:	0512007d 	ldreq	r0, [r2, #-125]	; 0x7d
     308:	05140000 	ldreq	r0, [r4, #-0]
     30c:	00020000 	andeq	r0, r2, r0
     310:	0514087d 	ldreq	r0, [r4, #-2173]	; 0x87d
     314:	05160000 	ldreq	r0, [r6, #-0]
     318:	00020000 	andeq	r0, r2, r0
     31c:	0516187d 	ldreq	r1, [r6, #-2173]	; 0x87d
     320:	055a0000 	ldrbeq	r0, [sl, #-0]
     324:	00020000 	andeq	r0, r2, r0
     328:	00001877 	andeq	r1, r0, r7, ror r8
     32c:	00000000 	andeq	r0, r0, r0
     330:	055c0000 	ldrbeq	r0, [ip, #-0]
     334:	055e0000 	ldrbeq	r0, [lr, #-0]
     338:	00020000 	andeq	r0, r2, r0
     33c:	055e007d 	ldrbeq	r0, [lr, #-125]	; 0x7d
     340:	05600000 	strbeq	r0, [r0, #-0]!
     344:	00020000 	andeq	r0, r2, r0
     348:	0560087d 	strbeq	r0, [r0, #-2173]!	; 0x87d
     34c:	05620000 	strbeq	r0, [r2, #-0]!
     350:	00020000 	andeq	r0, r2, r0
     354:	0562107d 	strbeq	r1, [r2, #-125]!	; 0x7d
     358:	066a0000 	strbteq	r0, [sl], -r0
     35c:	00020000 	andeq	r0, r2, r0
     360:	00000877 	andeq	r0, r0, r7, ror r8
     364:	00000000 	andeq	r0, r0, r0
     368:	066c0000 	strbteq	r0, [ip], -r0
     36c:	066e0000 	strbteq	r0, [lr], -r0
     370:	00020000 	andeq	r0, r2, r0
     374:	066e007d 			; <UNDEFINED> instruction: 0x066e007d
     378:	06700000 	ldrbteq	r0, [r0], -r0
     37c:	00020000 	andeq	r0, r2, r0
     380:	0670147d 			; <UNDEFINED> instruction: 0x0670147d
     384:	06720000 	ldrbteq	r0, [r2], -r0
     388:	00020000 	andeq	r0, r2, r0
     38c:	0672387d 			; <UNDEFINED> instruction: 0x0672387d
     390:	077c0000 	ldrbeq	r0, [ip, -r0]!
     394:	00020000 	andeq	r0, r2, r0
     398:	00001877 	andeq	r1, r0, r7, ror r8
     39c:	00000000 	andeq	r0, r0, r0
     3a0:	077c0000 	ldrbeq	r0, [ip, -r0]!
     3a4:	077e0000 	ldrbeq	r0, [lr, -r0]!
     3a8:	00020000 	andeq	r0, r2, r0
     3ac:	077e007d 			; <UNDEFINED> instruction: 0x077e007d
     3b0:	07800000 	streq	r0, [r0, r0]
     3b4:	00020000 	andeq	r0, r2, r0
     3b8:	0780087d 			; <UNDEFINED> instruction: 0x0780087d
     3bc:	07820000 	streq	r0, [r2, r0]
     3c0:	00020000 	andeq	r0, r2, r0
     3c4:	0782107d 			; <UNDEFINED> instruction: 0x0782107d
     3c8:	08080000 	stmdaeq	r8, {}	; <UNPREDICTABLE>
     3cc:	00020000 	andeq	r0, r2, r0
     3d0:	00001077 	andeq	r1, r0, r7, ror r0
     3d4:	00000000 	andeq	r0, r0, r0
     3d8:	08080000 	stmdaeq	r8, {}	; <UNPREDICTABLE>
     3dc:	080a0000 	stmdaeq	sl, {}	; <UNPREDICTABLE>
     3e0:	00020000 	andeq	r0, r2, r0
     3e4:	080a007d 	stmdaeq	sl, {r0, r2, r3, r4, r5, r6}
     3e8:	080c0000 	stmdaeq	ip, {}	; <UNPREDICTABLE>
     3ec:	00020000 	andeq	r0, r2, r0
     3f0:	080c047d 	stmdaeq	ip, {r0, r2, r3, r4, r5, r6, sl}
     3f4:	080e0000 	stmdaeq	lr, {}	; <UNPREDICTABLE>
     3f8:	00020000 	andeq	r0, r2, r0
     3fc:	080e207d 	stmdaeq	lr, {r0, r2, r3, r4, r5, r6, sp}
     400:	0a8c0000 	beq	fe300408 <__StackLimit+0xde300408>
     404:	00020000 	andeq	r0, r2, r0
     408:	00002077 	andeq	r2, r0, r7, ror r0
     40c:	00000000 	andeq	r0, r0, r0
     410:	0a8c0000 	beq	fe300418 <__StackLimit+0xde300418>
     414:	0a8e0000 	beq	fe38041c <__StackLimit+0xde38041c>
     418:	00020000 	andeq	r0, r2, r0
     41c:	0a8e007d 	beq	fe380618 <__StackLimit+0xde380618>
     420:	0a900000 	beq	fe400428 <__StackLimit+0xde400428>
     424:	00020000 	andeq	r0, r2, r0
     428:	0a90047d 	beq	fe401624 <__StackLimit+0xde401624>
     42c:	0a920000 	beq	fe480434 <__StackLimit+0xde480434>
     430:	00020000 	andeq	r0, r2, r0
     434:	0a92187d 	beq	fe486630 <__StackLimit+0xde486630>
     438:	0c760000 	ldcleq	0, cr0, [r6], #-0
     43c:	00020000 	andeq	r0, r2, r0
     440:	00001877 	andeq	r1, r0, r7, ror r8
	...
     44c:	00020000 	andeq	r0, r2, r0
     450:	00020000 	andeq	r0, r2, r0
     454:	0002007d 	andeq	r0, r2, sp, ror r0
     458:	00040000 	andeq	r0, r4, r0
     45c:	00020000 	andeq	r0, r2, r0
     460:	0004087d 	andeq	r0, r4, sp, ror r8
     464:	00060000 	andeq	r0, r6, r0
     468:	00020000 	andeq	r0, r2, r0
     46c:	0006287d 	andeq	r2, r6, sp, ror r8
     470:	003e0000 	eorseq	r0, lr, r0
     474:	00020000 	andeq	r0, r2, r0
     478:	00002077 	andeq	r2, r0, r7, ror r0
     47c:	00000000 	andeq	r0, r0, r0
     480:	00400000 	subeq	r0, r0, r0
     484:	00420000 	subeq	r0, r2, r0
     488:	00020000 	andeq	r0, r2, r0
     48c:	0042007d 	subeq	r0, r2, sp, ror r0
     490:	00440000 	subeq	r0, r4, r0
     494:	00020000 	andeq	r0, r2, r0
     498:	0044087d 	subeq	r0, r4, sp, ror r8
     49c:	00460000 	subeq	r0, r6, r0
     4a0:	00020000 	andeq	r0, r2, r0
     4a4:	0046107d 	subeq	r1, r6, sp, ror r0
     4a8:	00a60000 	adceq	r0, r6, r0
     4ac:	00020000 	andeq	r0, r2, r0
     4b0:	00001077 	andeq	r1, r0, r7, ror r0
     4b4:	00000000 	andeq	r0, r0, r0
     4b8:	00a80000 	adceq	r0, r8, r0
     4bc:	00aa0000 	adceq	r0, sl, r0
     4c0:	00020000 	andeq	r0, r2, r0
     4c4:	00aa007d 	adceq	r0, sl, sp, ror r0
     4c8:	00ac0000 	adceq	r0, ip, r0
     4cc:	00020000 	andeq	r0, r2, r0
     4d0:	00ac087d 	adceq	r0, ip, sp, ror r8
     4d4:	00ae0000 	adceq	r0, lr, r0
     4d8:	00020000 	andeq	r0, r2, r0
     4dc:	00ae107d 	adceq	r1, lr, sp, ror r0
     4e0:	01640000 	cmneq	r4, r0
     4e4:	00020000 	andeq	r0, r2, r0
     4e8:	00001077 	andeq	r1, r0, r7, ror r0
     4ec:	00000000 	andeq	r0, r0, r0
     4f0:	01640000 	cmneq	r4, r0
     4f4:	01660000 	cmneq	r6, r0
     4f8:	00020000 	andeq	r0, r2, r0
     4fc:	0166007d 	smceq	24589	; 0x600d
     500:	01680000 	cmneq	r8, r0
     504:	00020000 	andeq	r0, r2, r0
     508:	0168087d 	smceq	32909	; 0x808d
     50c:	02340000 	eorseq	r0, r4, #0
     510:	00020000 	andeq	r0, r2, r0
     514:	00000877 	andeq	r0, r0, r7, ror r8
     518:	00000000 	andeq	r0, r0, r0
     51c:	02340000 	eorseq	r0, r4, #0
     520:	02360000 	eorseq	r0, r6, #0
     524:	00020000 	andeq	r0, r2, r0
     528:	0236007d 	eorseq	r0, r6, #125	; 0x7d
     52c:	02380000 	eorseq	r0, r8, #0
     530:	00020000 	andeq	r0, r2, r0
     534:	0238087d 	eorseq	r0, r8, #8192000	; 0x7d0000
     538:	02820000 	addeq	r0, r2, #0
     53c:	00020000 	andeq	r0, r2, r0
     540:	00000877 	andeq	r0, r0, r7, ror r8
     544:	00000000 	andeq	r0, r0, r0
     548:	02840000 	addeq	r0, r4, #0
     54c:	02860000 	addeq	r0, r6, #0
     550:	00020000 	andeq	r0, r2, r0
     554:	0286007d 	addeq	r0, r6, #125	; 0x7d
     558:	02880000 	addeq	r0, r8, #0
     55c:	00020000 	andeq	r0, r2, r0
     560:	0288087d 	addeq	r0, r8, #8192000	; 0x7d0000
     564:	02e20000 	rsceq	r0, r2, #0
     568:	00020000 	andeq	r0, r2, r0
     56c:	00000877 	andeq	r0, r0, r7, ror r8
     570:	00000000 	andeq	r0, r0, r0
     574:	02e40000 	rsceq	r0, r4, #0
     578:	02e60000 	rsceq	r0, r6, #0
     57c:	00020000 	andeq	r0, r2, r0
     580:	02e6007d 	rsceq	r0, r6, #125	; 0x7d
     584:	02e80000 	rsceq	r0, r8, #0
     588:	00020000 	andeq	r0, r2, r0
     58c:	02e8087d 	rsceq	r0, r8, #8192000	; 0x7d0000
     590:	03420000 	movteq	r0, #8192	; 0x2000
     594:	00020000 	andeq	r0, r2, r0
     598:	00000877 	andeq	r0, r0, r7, ror r8
     59c:	00000000 	andeq	r0, r0, r0
     5a0:	03440000 	movteq	r0, #16384	; 0x4000
     5a4:	03460000 	movteq	r0, #24576	; 0x6000
     5a8:	00020000 	andeq	r0, r2, r0
     5ac:	0346007d 	movteq	r0, #24701	; 0x607d
     5b0:	03480000 	movteq	r0, #32768	; 0x8000
     5b4:	00020000 	andeq	r0, r2, r0
     5b8:	0348087d 	movteq	r0, #34941	; 0x887d
     5bc:	03de0000 	bicseq	r0, lr, #0
     5c0:	00020000 	andeq	r0, r2, r0
     5c4:	00000877 	andeq	r0, r0, r7, ror r8
     5c8:	00000000 	andeq	r0, r0, r0
     5cc:	03e00000 	mvneq	r0, #0
     5d0:	03e20000 	mvneq	r0, #0
     5d4:	00020000 	andeq	r0, r2, r0
     5d8:	03e2007d 	mvneq	r0, #125	; 0x7d
     5dc:	03e40000 	mvneq	r0, #0
     5e0:	00020000 	andeq	r0, r2, r0
     5e4:	03e4087d 	mvneq	r0, #8192000	; 0x7d0000
     5e8:	03e60000 	mvneq	r0, #0
     5ec:	00020000 	andeq	r0, r2, r0
     5f0:	03e6187d 	mvneq	r1, #8192000	; 0x7d0000
     5f4:	04820000 	streq	r0, [r2], #0
     5f8:	00020000 	andeq	r0, r2, r0
     5fc:	00001877 	andeq	r1, r0, r7, ror r8
     600:	00000000 	andeq	r0, r0, r0
     604:	04840000 	streq	r0, [r4], #0
     608:	04860000 	streq	r0, [r6], #0
     60c:	00020000 	andeq	r0, r2, r0
     610:	0486007d 	streq	r0, [r6], #125	; 0x7d
     614:	04880000 	streq	r0, [r8], #0
     618:	00020000 	andeq	r0, r2, r0
     61c:	0488087d 	streq	r0, [r8], #2173	; 0x87d
     620:	048a0000 	streq	r0, [sl], #0
     624:	00020000 	andeq	r0, r2, r0
     628:	048a107d 	streq	r1, [sl], #125	; 0x7d
     62c:	05460000 	strbeq	r0, [r6, #-0]
     630:	00020000 	andeq	r0, r2, r0
     634:	00001077 	andeq	r1, r0, r7, ror r0
     638:	00000000 	andeq	r0, r0, r0
     63c:	05480000 	strbeq	r0, [r8, #-0]
     640:	054a0000 	strbeq	r0, [sl, #-0]
     644:	00020000 	andeq	r0, r2, r0
     648:	054a007d 	strbeq	r0, [sl, #-125]	; 0x7d
     64c:	054c0000 	strbeq	r0, [ip, #-0]
     650:	00020000 	andeq	r0, r2, r0
     654:	054c047d 	strbeq	r0, [ip, #-1149]	; 0x47d
     658:	054e0000 	strbeq	r0, [lr, #-0]
     65c:	00020000 	andeq	r0, r2, r0
     660:	054e107d 	strbeq	r1, [lr, #-125]	; 0x7d
     664:	056c0000 	strbeq	r0, [ip, #-0]!
     668:	00020000 	andeq	r0, r2, r0
     66c:	00001077 	andeq	r1, r0, r7, ror r0
	...
     678:	00020000 	andeq	r0, r2, r0
     67c:	00020000 	andeq	r0, r2, r0
     680:	0002007d 	andeq	r0, r2, sp, ror r0
     684:	00040000 	andeq	r0, r4, r0
     688:	00020000 	andeq	r0, r2, r0
     68c:	0004107d 	andeq	r1, r4, sp, ror r0
     690:	00060000 	andeq	r0, r6, r0
     694:	00020000 	andeq	r0, r2, r0
     698:	0006187d 	andeq	r1, r6, sp, ror r8
     69c:	00080000 	andeq	r0, r8, r0
     6a0:	00020000 	andeq	r0, r2, r0
     6a4:	0008307d 	andeq	r3, r8, sp, ror r0
     6a8:	01cc0000 	biceq	r0, ip, r0
     6ac:	00020000 	andeq	r0, r2, r0
     6b0:	00003077 	andeq	r3, r0, r7, ror r0
     6b4:	00000000 	andeq	r0, r0, r0
     6b8:	01cc0000 	biceq	r0, ip, r0
     6bc:	01ce0000 	biceq	r0, lr, r0
     6c0:	00020000 	andeq	r0, r2, r0
     6c4:	01ce007d 	biceq	r0, lr, sp, ror r0
     6c8:	01d00000 	bicseq	r0, r0, r0
     6cc:	00020000 	andeq	r0, r2, r0
     6d0:	01d0107d 	bicseq	r1, r0, sp, ror r0
     6d4:	01d20000 	bicseq	r0, r2, r0
     6d8:	00020000 	andeq	r0, r2, r0
     6dc:	01d2147d 	bicseq	r1, r2, sp, ror r4
     6e0:	01d40000 	bicseq	r0, r4, r0
     6e4:	00020000 	andeq	r0, r2, r0
     6e8:	01d4207d 	bicseq	r2, r4, sp, ror r0
     6ec:	027c0000 	rsbseq	r0, ip, #0
     6f0:	00020000 	andeq	r0, r2, r0
     6f4:	00002077 	andeq	r2, r0, r7, ror r0
     6f8:	00000000 	andeq	r0, r0, r0
     6fc:	027c0000 	rsbseq	r0, ip, #0
     700:	027e0000 	rsbseq	r0, lr, #0
     704:	00020000 	andeq	r0, r2, r0
     708:	027e007d 	rsbseq	r0, lr, #125	; 0x7d
     70c:	02800000 	addeq	r0, r0, #0
     710:	00020000 	andeq	r0, r2, r0
     714:	0280047d 	addeq	r0, r0, #2097152000	; 0x7d000000
     718:	02820000 	addeq	r0, r2, #0
     71c:	00020000 	andeq	r0, r2, r0
     720:	0282107d 	addeq	r1, r2, #125	; 0x7d
     724:	02d00000 	sbcseq	r0, r0, #0
     728:	00020000 	andeq	r0, r2, r0
     72c:	00001077 	andeq	r1, r0, r7, ror r0
     730:	00000000 	andeq	r0, r0, r0
     734:	02d00000 	sbcseq	r0, r0, #0
     738:	02d20000 	sbcseq	r0, r2, #0
     73c:	00020000 	andeq	r0, r2, r0
     740:	02d2007d 	sbcseq	r0, r2, #125	; 0x7d
     744:	02d40000 	sbcseq	r0, r4, #0
     748:	00020000 	andeq	r0, r2, r0
     74c:	02d4047d 	sbcseq	r0, r4, #2097152000	; 0x7d000000
     750:	02d60000 	sbcseq	r0, r6, #0
     754:	00020000 	andeq	r0, r2, r0
     758:	02d6107d 	sbcseq	r1, r6, #125	; 0x7d
     75c:	032e0000 	teqeq	lr, #0
     760:	00020000 	andeq	r0, r2, r0
     764:	00001077 	andeq	r1, r0, r7, ror r0
     768:	00000000 	andeq	r0, r0, r0
     76c:	03300000 	teqeq	r0, #0
     770:	03320000 	teqeq	r2, #0
     774:	00020000 	andeq	r0, r2, r0
     778:	0332007d 	teqeq	r2, #125	; 0x7d
     77c:	03340000 	teqeq	r4, #0
     780:	00020000 	andeq	r0, r2, r0
     784:	0334047d 	teqeq	r4, #2097152000	; 0x7d000000
     788:	03360000 	teqeq	r6, #0
     78c:	00020000 	andeq	r0, r2, r0
     790:	0336107d 	teqeq	r6, #125	; 0x7d
     794:	03560000 	cmpeq	r6, #0
     798:	00020000 	andeq	r0, r2, r0
     79c:	00001077 	andeq	r1, r0, r7, ror r0
     7a0:	00000000 	andeq	r0, r0, r0
     7a4:	03580000 	cmpeq	r8, #0
     7a8:	035a0000 	cmpeq	sl, #0
     7ac:	00020000 	andeq	r0, r2, r0
     7b0:	035a007d 	cmpeq	sl, #125	; 0x7d
     7b4:	035c0000 	cmpeq	ip, #0
     7b8:	00020000 	andeq	r0, r2, r0
     7bc:	035c047d 	cmpeq	ip, #2097152000	; 0x7d000000
     7c0:	035e0000 	cmpeq	lr, #0
     7c4:	00020000 	andeq	r0, r2, r0
     7c8:	035e107d 	cmpeq	lr, #125	; 0x7d
     7cc:	03940000 	orrseq	r0, r4, #0
     7d0:	00020000 	andeq	r0, r2, r0
     7d4:	00001077 	andeq	r1, r0, r7, ror r0
     7d8:	00000000 	andeq	r0, r0, r0
     7dc:	03940000 	orrseq	r0, r4, #0
     7e0:	03960000 	orrseq	r0, r6, #0
     7e4:	00020000 	andeq	r0, r2, r0
     7e8:	0396007d 	orrseq	r0, r6, #125	; 0x7d
     7ec:	03980000 	orrseq	r0, r8, #0
     7f0:	00020000 	andeq	r0, r2, r0
     7f4:	0398107d 	orrseq	r1, r8, #125	; 0x7d
     7f8:	039a0000 	orrseq	r0, sl, #0
     7fc:	00020000 	andeq	r0, r2, r0
extern GPIO_InitTypeDef OV_PTA_init;

extern char ready_send_flag;

int main (void)
{
     800:	039a187d 	orrseq	r1, sl, #8192000	; 0x7d0000
     804:	039c0000 	orrseq	r0, ip, #0

    Ov7725_Init ();
     808:	00020000 	andeq	r0, r2, r0
    Ov7725_Delay();
     80c:	039c207d 	orrseq	r2, ip, #125	; 0x7d

    //Ov7725_Dma_Init();
    Ov7725_Gpio_Init ();
     810:	03f20000 	mvnseq	r0, #0
    dma_portx2buff_init (DMA_CH0, (void *)(&GPIOB_PDIR), (void *)img,PORTA_DMAREQ ,DMA_BYTE1, PHOTO_SIZE / 8, DADDR_KEEPON);
     814:	00020000 	andeq	r0, r2, r0
     818:	00002077 	andeq	r2, r0, r7, ror r0
     81c:	00000000 	andeq	r0, r0, r0
     820:	03f40000 	mvnseq	r0, #0
     824:	03f60000 	mvnseq	r0, #0
     828:	00020000 	andeq	r0, r2, r0
     82c:	03f6007d 	mvnseq	r0, #125	; 0x7d
     830:	03f80000 	mvnseq	r0, #0
     834:	00020000 	andeq	r0, r2, r0
     838:	03f8107d 	mvnseq	r1, #125	; 0x7d
     83c:	03fa0000 	mvnseq	r0, #0
    //装载DMA中断
    DMA_ISR[DMA_CH0] = Ov7725_eagle_dma;
     840:	00020000 	andeq	r0, r2, r0
     844:	03fa187d 	mvnseq	r1, #8192000	; 0x7d0000
     848:	03fc0000 	mvnseq	r0, #0
     84c:	00020000 	andeq	r0, r2, r0
     850:	03fc207d 	mvnseq	r2, #125	; 0x7d
    //关闭DMA通道
    DMA_DIS(DMA_CH0);
     854:	04520000 	ldrbeq	r0, [r2], #-0
     858:	00020000 	andeq	r0, r2, r0
     85c:	00002077 	andeq	r2, r0, r7, ror r0
     860:	00000000 	andeq	r0, r0, r0
     864:	04540000 	ldrbeq	r0, [r4], #-0
     868:	04560000 	ldrbeq	r0, [r6], #-0
    //关GPIO中断
    disable_irq(INT_PORTA - 16);
     86c:	00020000 	andeq	r0, r2, r0
     870:	0456007d 	ldrbeq	r0, [r6], #-125	; 0x7d
    //清DMA中断置为标志
    DMA_IRQ_CLEAN(DMA_CH0);
     874:	04580000 	ldrbeq	r0, [r8], #-0
     878:	00020000 	andeq	r0, r2, r0
     87c:	0458047d 	ldrbeq	r0, [r8], #-1149	; 0x47d
     880:	045a0000 	ldrbeq	r0, [sl], #-0
     884:	00020000 	andeq	r0, r2, r0
     888:	045a187d 	ldrbeq	r1, [sl], #-2173	; 0x87d
    //使能DMA中断
    DMA_IRQ_EN (DMA_CH0);
     88c:	07420000 	strbeq	r0, [r2, -r0]
     890:	00020000 	andeq	r0, r2, r0
    //开启GPIO中断
    LPLD_GPIO_EnableIrq(OV_PTA_init);
     894:	00001877 	andeq	r1, r0, r7, ror r8
     898:	00000000 	andeq	r0, r0, r0
     89c:	07440000 	strbeq	r0, [r4, -r0]
     8a0:	07460000 	strbeq	r0, [r6, -r0]
     8a4:	00020000 	andeq	r0, r2, r0
    {
        //获取图像
        //Ov7725_eagle_get_img ();
        //解压图像
        //Ov7725_img_extract (Pix_Data, img, PHOTO_SIZE/8);
        if(ready_send_flag)
     8a8:	0746007d 	smlsldxeq	r0, r6, sp, r0
     8ac:	07480000 	strbeq	r0, [r8, -r0]
     8b0:	00020000 	andeq	r0, r2, r0
     8b4:	0748047d 	smlsldxeq	r0, r8, sp, r4
        {
            //发送图片到上位机
            //get_midline(Pix_Data, 60, 80);
            Ov7725_sendimg (Pix_Data, PHOTO_SIZE);
     8b8:	074a0000 	strbeq	r0, [sl, -r0]
     8bc:	00020000 	andeq	r0, r2, r0
     8c0:	074a187d 	smlsldxeq	r1, sl, sp, r8
     8c4:	08c40000 	stmiaeq	r4, {}^	; <UNPREDICTABLE>
            ready_send_flag = 0;
     8c8:	00020000 	andeq	r0, r2, r0
     8cc:	00001877 	andeq	r1, r0, r7, ror r8
     8d0:	00000000 	andeq	r0, r0, r0
        }
    }
     8d4:	08c40000 	stmiaeq	r4, {}^	; <UNPREDICTABLE>
 * \param  void
 *
 * \return void
 */
void Default_Handler(void)
{
     8d8:	08c60000 	stmiaeq	r6, {}^	; <UNPREDICTABLE>
     8dc:	00020000 	andeq	r0, r2, r0
#define VECTORNUM       (*(volatile char *) (0xE000ED04))
  //while (1);
  char vtr = VECTORNUM;
     8e0:	08c6007d 	stmiaeq	r6, {r0, r2, r3, r4, r5, r6}^
     8e4:	08c80000 	stmiaeq	r8, {}^	; <UNPREDICTABLE>
     8e8:	00020000 	andeq	r0, r2, r0
  printf ("\n ******************\n");
     8ec:	08c8087d 	stmiaeq	r8, {r0, r2, r3, r4, r5, r6, fp}^
     8f0:	08d60000 	ldmeq	r6, {}^	; <UNPREDICTABLE>
     8f4:	00020000 	andeq	r0, r2, r0
  printf ("Default Handler Error\n");
     8f8:	00000877 	andeq	r0, r0, r7, ror r8
     8fc:	00000000 	andeq	r0, r0, r0
     900:	08d80000 	ldmeq	r8, {}^	; <UNPREDICTABLE>
  printf ("On vector %d **** Interrupt\n", vtr);
     904:	08da0000 	ldmeq	sl, {}^	; <UNPREDICTABLE>
     908:	00020000 	andeq	r0, r2, r0
     90c:	08da007d 	ldmeq	sl, {r0, r2, r3, r4, r5, r6}^
     910:	08dc0000 	ldmeq	ip, {}^	; <UNPREDICTABLE>
 * \param  void
 *
 * \return void
 */
void Reset_Handler(void)
{
     914:	00020000 	andeq	r0, r2, r0
     918:	08dc087d 	ldmeq	ip, {r0, r2, r3, r4, r5, r6, fp}^
  unsigned char *source;
  unsigned char *destination;

  /* watchdog disable */
  *((volatile unsigned short *)0x4005200E) = 0xC520;
     91c:	08ea0000 	stmiaeq	sl!, {}^	; <UNPREDICTABLE>
     920:	00020000 	andeq	r0, r2, r0
     924:	00000877 	andeq	r0, r0, r7, ror r8
	...
  *((volatile unsigned short *)0x4005200E) = 0xD928;
     930:	00020000 	andeq	r0, r2, r0
     934:	00020000 	andeq	r0, r2, r0
  *((volatile unsigned short *)0x40052000) = 0x01D2;
     938:	0002007d 	andeq	r0, r2, sp, ror r0
     93c:	00040000 	andeq	r0, r4, r0
     940:	00020000 	andeq	r0, r2, r0

  /* copy data values from ROM to RAM */
  source = (unsigned char *)&_etext;
     944:	0004107d 	andeq	r1, r4, sp, ror r0
     948:	00060000 	andeq	r0, r6, r0
     94c:	00020000 	andeq	r0, r2, r0
  destination = (unsigned char *)&_sdata;
     950:	0006147d 	andeq	r1, r6, sp, ror r4
     954:	00080000 	andeq	r0, r8, r0
  while (destination < (unsigned char*)&_edata) {
     958:	00030000 	andeq	r0, r3, r0
    *(destination++) = *(source++);
     95c:	0800c07d 	stmdaeq	r0, {r0, r2, r3, r4, r5, r6, lr, pc}
     960:	bc000000 	stclt	0, cr0, [r0], {-0}
     964:	03000004 	movweq	r0, #4
     968:	00c07700 	sbceq	r7, r0, r0, lsl #14
	...
  *((volatile unsigned short *)0x40052000) = 0x01D2;

  /* copy data values from ROM to RAM */
  source = (unsigned char *)&_etext;
  destination = (unsigned char *)&_sdata;
  while (destination < (unsigned char*)&_edata) {
     974:	000004bc 			; <UNDEFINED> instruction: 0x000004bc
     978:	000004be 			; <UNDEFINED> instruction: 0x000004be
     97c:	007d0002 	rsbseq	r0, sp, r2
    *(destination++) = *(source++);
  }

  /* clear bss section */
  source = (unsigned char *)&_sbss;
     980:	000004be 			; <UNDEFINED> instruction: 0x000004be
     984:	000004c0 	andeq	r0, r0, r0, asr #9
     988:	107d0002 	rsbsne	r0, sp, r2
  destination = (unsigned char *)&_ebss;
     98c:	000004c0 	andeq	r0, r0, r0, asr #9
     990:	000004c2 	andeq	r0, r0, r2, asr #9
  while (source < destination ) {
     994:	187d0002 	ldmdane	sp!, {r1}^
    *source++ = 0;
     998:	000004c2 	andeq	r0, r0, r2, asr #9
     99c:	000004e2 	andeq	r0, r0, r2, ror #9
     9a0:	18770002 	ldmdane	r7!, {r1}^
	...
  }

  /* clear bss section */
  source = (unsigned char *)&_sbss;
  destination = (unsigned char *)&_ebss;
  while (source < destination ) {
     9ac:	000004e4 	andeq	r0, r0, r4, ror #9
    *source++ = 0;
  }
 //进入系统初始化函数
  SystemInit();
     9b0:	000004e6 	andeq	r0, r0, r6, ror #9
 //进入用户函数
  main();
     9b4:	007d0002 	rsbseq	r0, sp, r2
 * \param  void
 *
 * \return void
 */
void SystemInit(void)
{
     9b8:	000004e6 	andeq	r0, r0, r6, ror #9
  //使能所有IO口时钟
  SIM_SCGC5 |= (SIM_SCGC5_PORTA_MASK | SIM_SCGC5_PORTB_MASK
     9bc:	000004e8 	andeq	r0, r0, r8, ror #9
     9c0:	107d0002 	rsbsne	r0, sp, r2
     9c4:	000004e8 	andeq	r0, r0, r8, ror #9
     9c8:	000004ea 	andeq	r0, r0, sl, ror #9
     9cc:	187d0002 	ldmdane	sp!, {r1}^
     9d0:	000004ea 	andeq	r0, r0, sl, ror #9
     9d4:	0000050a 	andeq	r0, r0, sl, lsl #10
     9d8:	18770002 	ldmdane	r7!, {r1}^
	...
              | SIM_SCGC5_PORTC_MASK | SIM_SCGC5_PORTD_MASK
              | SIM_SCGC5_PORTE_MASK);
  //初始化各部分时钟：系统内核主频、总线时钟、FlexBus时钟、Flash时钟
  LPLD_PLL_Setup(CORE_CLK_MHZ);
     9e4:	0000050c 	andeq	r0, r0, ip, lsl #10
     9e8:	0000050e 	andeq	r0, r0, lr, lsl #10
  
  //更新内核主频
  SystemCoreClockUpdate();
     9ec:	007d0002 	rsbseq	r0, sp, r2
  
  //获取各部分时钟
  g_core_clock = SystemCoreClock;
     9f0:	0000050e 	andeq	r0, r0, lr, lsl #10
     9f4:	00000510 	andeq	r0, r0, r0, lsl r5
     9f8:	107d0002 	rsbsne	r0, sp, r2
     9fc:	00000510 	andeq	r0, r0, r0, lsl r5
     a00:	00000512 	andeq	r0, r0, r2, lsl r5
  g_bus_clock = g_core_clock / ((uint32_t)((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV2_MASK) >> SIM_CLKDIV1_OUTDIV2_SHIFT)+ 1u);
     a04:	147d0002 	ldrbtne	r0, [sp], #-2
     a08:	00000512 	andeq	r0, r0, r2, lsl r5
     a0c:	00000560 	andeq	r0, r0, r0, ror #10
     a10:	14770002 	ldrbtne	r0, [r7], #-2
	...
     a1c:	00000560 	andeq	r0, r0, r0, ror #10
     a20:	00000562 	andeq	r0, r0, r2, ror #10
     a24:	007d0002 	rsbseq	r0, sp, r2
     a28:	00000562 	andeq	r0, r0, r2, ror #10
     a2c:	00000564 	andeq	r0, r0, r4, ror #10
     a30:	087d0002 	ldmdaeq	sp!, {r1}^
     a34:	00000564 	andeq	r0, r0, r4, ror #10
     a38:	0000058a 	andeq	r0, r0, sl, lsl #11
  g_flexbus_clock =  g_core_clock / ((uint32_t)((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV3_MASK) >> SIM_CLKDIV1_OUTDIV3_SHIFT)+ 1u);
     a3c:	08770002 	ldmdaeq	r7!, {r1}^
	...
     a48:	0000058c 	andeq	r0, r0, ip, lsl #11
     a4c:	0000058e 	andeq	r0, r0, lr, lsl #11
     a50:	007d0002 	rsbseq	r0, sp, r2
     a54:	0000058e 	andeq	r0, r0, lr, lsl #11
     a58:	00000590 	muleq	r0, r0, r5
     a5c:	087d0002 	ldmdaeq	sp!, {r1}^
     a60:	00000590 	muleq	r0, r0, r5
     a64:	000005b6 			; <UNDEFINED> instruction: 0x000005b6
     a68:	08770002 	ldmdaeq	r7!, {r1}^
	...
  g_flash_clock =  g_core_clock / ((uint32_t)((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV4_MASK) >> SIM_CLKDIV1_OUTDIV4_SHIFT)+ 1u);
     a74:	000005b8 			; <UNDEFINED> instruction: 0x000005b8
     a78:	000005ba 			; <UNDEFINED> instruction: 0x000005ba
     a7c:	007d0002 	rsbseq	r0, sp, r2
     a80:	000005ba 			; <UNDEFINED> instruction: 0x000005ba
     a84:	000005bc 			; <UNDEFINED> instruction: 0x000005bc
     a88:	087d0002 	ldmdaeq	sp!, {r1}^
     a8c:	000005bc 			; <UNDEFINED> instruction: 0x000005bc
     a90:	000005e2 	andeq	r0, r0, r2, ror #11
     a94:	08770002 	ldmdaeq	r7!, {r1}^
	...
     aa0:	000005e4 	andeq	r0, r0, r4, ror #11
     aa4:	000005e6 	andeq	r0, r0, r6, ror #11
 
    //初始化系统终端
  systemTerm ();
     aa8:	007d0002 	rsbseq	r0, sp, r2
 *
 * @brief  更新全局变量SystemCoreClock的值，以便获取最新的系统内核频率。
 *         
 */
void SystemCoreClockUpdate (void) 
{
     aac:	000005e6 	andeq	r0, r0, r6, ror #11
     ab0:	000005e8 	andeq	r0, r0, r8, ror #11
    uint32_t temp;
    temp =  CPU_XTAL_CLK_HZ *((uint32_t)(MCG_C6 & MCG_C6_VDIV_MASK) + 16u );
     ab4:	087d0002 	ldmdaeq	sp!, {r1}^
     ab8:	000005e8 	andeq	r0, r0, r8, ror #11
     abc:	0000060e 	andeq	r0, r0, lr, lsl #12
     ac0:	08770002 	ldmdaeq	r7!, {r1}^
	...
     acc:	00000610 	andeq	r0, r0, r0, lsl r6
     ad0:	00000612 	andeq	r0, r0, r2, lsl r6
     ad4:	007d0002 	rsbseq	r0, sp, r2
     ad8:	00000612 	andeq	r0, r0, r2, lsl r6
    temp = (uint32_t)(temp/((uint32_t)(MCG_C5 & MCG_C5_PRDIV_MASK) +1u ))/2;
     adc:	00000614 	andeq	r0, r0, r4, lsl r6
     ae0:	087d0002 	ldmdaeq	sp!, {r1}^
     ae4:	00000614 	andeq	r0, r0, r4, lsl r6
     ae8:	0000063a 	andeq	r0, r0, sl, lsr r6
     aec:	08770002 	ldmdaeq	r7!, {r1}^
	...
     af8:	0000063c 	andeq	r0, r0, ip, lsr r6
    SystemCoreClock = temp;
     afc:	0000063e 	andeq	r0, r0, lr, lsr r6
     b00:	007d0002 	rsbseq	r0, sp, r2
     b04:	0000063e 	andeq	r0, r0, lr, lsr r6
}
     b08:	00000640 	andeq	r0, r0, r0, asr #12
     b0c:	087d0002 	ldmdaeq	sp!, {r1}^
/*
 * 使能中断
 */

void enable_irq (int irq)
{
     b10:	00000640 	andeq	r0, r0, r0, asr #12
     b14:	00000666 	andeq	r0, r0, r6, ror #12
    int div;
    if (irq > 105)
     b18:	08770002 	ldmdaeq	r7!, {r1}^
	...
        irq = 105;
    div = irq / 32;
     b24:	00000668 	andeq	r0, r0, r8, ror #12
     b28:	0000066a 	andeq	r0, r0, sl, ror #12
     b2c:	007d0002 	rsbseq	r0, sp, r2
     b30:	0000066a 	andeq	r0, r0, sl, ror #12
    switch (div)
     b34:	0000066c 	andeq	r0, r0, ip, ror #12
     b38:	087d0002 	ldmdaeq	sp!, {r1}^
     b3c:	0000066c 	andeq	r0, r0, ip, ror #12
     b40:	00000692 	muleq	r0, r2, r6
     b44:	08770002 	ldmdaeq	r7!, {r1}^
	...
     b50:	00000694 	muleq	r0, r4, r6
    {
        case 0x0:
            NVICICPR0 |= 1 << (irq & 0x1F);
     b54:	00000696 	muleq	r0, r6, r6
     b58:	007d0002 	rsbseq	r0, sp, r2
     b5c:	00000696 	muleq	r0, r6, r6
     b60:	00000698 	muleq	r0, r8, r6
     b64:	087d0002 	ldmdaeq	sp!, {r1}^
     b68:	00000698 	muleq	r0, r8, r6
     b6c:	000006be 			; <UNDEFINED> instruction: 0x000006be
     b70:	08770002 	ldmdaeq	r7!, {r1}^
	...
            NVICISER0 |= 1 << (irq & 0x1F);
     b7c:	000006c0 	andeq	r0, r0, r0, asr #13
     b80:	000006c2 	andeq	r0, r0, r2, asr #13
     b84:	007d0002 	rsbseq	r0, sp, r2
     b88:	000006c2 	andeq	r0, r0, r2, asr #13
     b8c:	000006c4 	andeq	r0, r0, r4, asr #13
     b90:	087d0002 	ldmdaeq	sp!, {r1}^
     b94:	000006c4 	andeq	r0, r0, r4, asr #13
     b98:	000006ea 	andeq	r0, r0, sl, ror #13
     b9c:	08770002 	ldmdaeq	r7!, {r1}^
	...
            break;
        case 0x1:
            NVICICPR1 |= 1 << (irq & 0x1F);
     ba8:	000006ec 	andeq	r0, r0, ip, ror #13
     bac:	000006ee 	andeq	r0, r0, lr, ror #13
     bb0:	007d0002 	rsbseq	r0, sp, r2
     bb4:	000006ee 	andeq	r0, r0, lr, ror #13
     bb8:	000006f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     bbc:	087d0002 	ldmdaeq	sp!, {r1}^
     bc0:	000006f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     bc4:	00000716 	andeq	r0, r0, r6, lsl r7
     bc8:	08770002 	ldmdaeq	r7!, {r1}^
	...
            NVICISER1 |= 1 << (irq & 0x1F);
     bd4:	00000718 	andeq	r0, r0, r8, lsl r7
     bd8:	0000071a 	andeq	r0, r0, sl, lsl r7
     bdc:	007d0002 	rsbseq	r0, sp, r2
     be0:	0000071a 	andeq	r0, r0, sl, lsl r7
     be4:	0000071c 	andeq	r0, r0, ip, lsl r7
     be8:	087d0002 	ldmdaeq	sp!, {r1}^
     bec:	0000071c 	andeq	r0, r0, ip, lsl r7
            break;
        case 0x2:
            NVICICPR2 |= 1 << (irq & 0x1F);
     bf0:	00000742 	andeq	r0, r0, r2, asr #14
     bf4:	08770002 	ldmdaeq	r7!, {r1}^
	...
     c00:	00000744 	andeq	r0, r0, r4, asr #14
     c04:	00000746 	andeq	r0, r0, r6, asr #14
     c08:	007d0002 	rsbseq	r0, sp, r2
     c0c:	00000746 	andeq	r0, r0, r6, asr #14
     c10:	00000748 	andeq	r0, r0, r8, asr #14
     c14:	087d0002 	ldmdaeq	sp!, {r1}^
            NVICISER2 |= 1 << (irq & 0x1F);
     c18:	00000748 	andeq	r0, r0, r8, asr #14
     c1c:	0000076e 	andeq	r0, r0, lr, ror #14
     c20:	08770002 	ldmdaeq	r7!, {r1}^
	...
     c2c:	00000770 	andeq	r0, r0, r0, ror r7
     c30:	00000772 	andeq	r0, r0, r2, ror r7
     c34:	007d0002 	rsbseq	r0, sp, r2
     c38:	00000772 	andeq	r0, r0, r2, ror r7
            break;
     c3c:	00000774 	andeq	r0, r0, r4, ror r7
        case 0x3:
            NVICICPR3 |= 1 << (irq & 0x1F);
     c40:	087d0002 	ldmdaeq	sp!, {r1}^
     c44:	00000774 	andeq	r0, r0, r4, ror r7
     c48:	0000079a 	muleq	r0, sl, r7
     c4c:	08770002 	ldmdaeq	r7!, {r1}^
	...
     c58:	0000079c 	muleq	r0, ip, r7
     c5c:	0000079e 	muleq	r0, lr, r7
     c60:	007d0002 	rsbseq	r0, sp, r2
     c64:	0000079e 	muleq	r0, lr, r7
            NVICISER3 |= 1 << (irq & 0x1F);
     c68:	000007a0 	andeq	r0, r0, r0, lsr #15
     c6c:	087d0002 	ldmdaeq	sp!, {r1}^
     c70:	000007a0 	andeq	r0, r0, r0, lsr #15
     c74:	000007c6 	andeq	r0, r0, r6, asr #15
     c78:	08770002 	ldmdaeq	r7!, {r1}^
	...
     c84:	000007c8 	andeq	r0, r0, r8, asr #15
     c88:	000007ca 	andeq	r0, r0, sl, asr #15
            break;
    }
}
     c8c:	007d0002 	rsbseq	r0, sp, r2
     c90:	000007ca 	andeq	r0, r0, sl, asr #15
     c94:	000007cc 	andeq	r0, r0, ip, asr #15
/*
 * 关闭中断
 */

void disable_irq (int irq)
{
     c98:	087d0002 	ldmdaeq	sp!, {r1}^
     c9c:	000007cc 	andeq	r0, r0, ip, asr #15
    int div;
    if (irq > 105)
     ca0:	000007f2 	strdeq	r0, [r0], -r2
     ca4:	08770002 	ldmdaeq	r7!, {r1}^
	...
        irq = 105;
    div = irq / 32;
     cb0:	000007f4 	strdeq	r0, [r0], -r4
     cb4:	000007f6 	strdeq	r0, [r0], -r6
     cb8:	007d0002 	rsbseq	r0, sp, r2
    switch (div)
     cbc:	000007f6 	strdeq	r0, [r0], -r6
     cc0:	000007f8 	strdeq	r0, [r0], -r8
     cc4:	087d0002 	ldmdaeq	sp!, {r1}^
     cc8:	000007f8 	strdeq	r0, [r0], -r8
     ccc:	0000081e 	andeq	r0, r0, lr, lsl r8
     cd0:	08770002 	ldmdaeq	r7!, {r1}^
	...
    {
        case 0x0:
            NVICICPR0 |= 1 << (irq & 0x1F);
     ce0:	00000002 	andeq	r0, r0, r2
     ce4:	007d0002 	rsbseq	r0, sp, r2
     ce8:	00000002 	andeq	r0, r0, r2
     cec:	00000004 	andeq	r0, r0, r4
     cf0:	107d0002 	rsbsne	r0, sp, r2
     cf4:	00000004 	andeq	r0, r0, r4
     cf8:	00000006 	andeq	r0, r0, r6
     cfc:	187d0002 	ldmdane	sp!, {r1}^
            break;
     d00:	00000006 	andeq	r0, r0, r6
        case 0x1:
            NVICICPR1 |= 1 << (irq & 0x1F);
     d04:	00000008 	andeq	r0, r0, r8
     d08:	307d0002 	rsbscc	r0, sp, r2
     d0c:	00000008 	andeq	r0, r0, r8
     d10:	000001ee 	andeq	r0, r0, lr, ror #3
     d14:	20770002 	rsbscs	r0, r7, r2
	...
     d20:	000001f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     d24:	000001f2 	strdeq	r0, [r0], -r2
     d28:	007d0002 	rsbseq	r0, sp, r2
            break;
        case 0x2:
            NVICICPR2 |= 1 << (irq & 0x1F);
     d2c:	000001f2 	strdeq	r0, [r0], -r2
     d30:	000001f4 	strdeq	r0, [r0], -r4
     d34:	107d0002 	rsbsne	r0, sp, r2
     d38:	000001f4 	strdeq	r0, [r0], -r4
     d3c:	000001f6 	strdeq	r0, [r0], -r6
     d40:	187d0002 	ldmdane	sp!, {r1}^
     d44:	000001f6 	strdeq	r0, [r0], -r6
     d48:	000001f8 	strdeq	r0, [r0], -r8
     d4c:	287d0002 	ldmdacs	sp!, {r1}^
     d50:	000001f8 	strdeq	r0, [r0], -r8
            break;
     d54:	0000030c 	andeq	r0, r0, ip, lsl #6
        case 0x3:
            NVICICPR3 |= 1 << (irq & 0x1F);
     d58:	18770002 	ldmdane	r7!, {r1}^
	...
     d64:	0000030c 	andeq	r0, r0, ip, lsl #6
     d68:	0000030e 	andeq	r0, r0, lr, lsl #6
     d6c:	007d0002 	rsbseq	r0, sp, r2
     d70:	0000030e 	andeq	r0, r0, lr, lsl #6
     d74:	00000310 	andeq	r0, r0, r0, lsl r3
     d78:	087d0002 	ldmdaeq	sp!, {r1}^
     d7c:	00000310 	andeq	r0, r0, r0, lsl r3
            break;
    }
}
     d80:	00000312 	andeq	r0, r0, r2, lsl r3
     d84:	207d0002 	rsbscs	r0, sp, r2
     d88:	00000312 	andeq	r0, r0, r2, lsl r3
/*
 * 系统终端初始化函数
 */

 void systemTerm (void)
 {
     d8c:	000003b2 			; <UNDEFINED> instruction: 0x000003b2
     d90:	20770002 	rsbscs	r0, r7, r2
	...
     UART_InitTypeDef uart_init_struct;
     uart_init_struct.UART_Uartx = TERM_PORT;
     uart_init_struct.UART_BaudRate = TERM_BAUD;
     d9c:	000003b4 			; <UNDEFINED> instruction: 0x000003b4
     da0:	000003b6 			; <UNDEFINED> instruction: 0x000003b6
     uart_init_struct.UART_RxPin = TERM_RX;
     da4:	007d0002 	rsbseq	r0, sp, r2
     uart_init_struct.UART_TxPin = TERM_TX;
     da8:	000003b6 			; <UNDEFINED> instruction: 0x000003b6
     dac:	000003b8 			; <UNDEFINED> instruction: 0x000003b8
     uart_init_struct.UART_RxIntEnable = TERM_RX_IRQ;
     db0:	047d0002 	ldrbteq	r0, [sp], #-2
     uart_init_struct.UART_RxIsr = TERM_RX_FUN;
     db4:	000003b8 			; <UNDEFINED> instruction: 0x000003b8
     db8:	000003ba 			; <UNDEFINED> instruction: 0x000003ba

     LPLD_UART_Init (uart_init_struct);
     dbc:	207d0002 	rsbscs	r0, sp, r2
     dc0:	000003ba 			; <UNDEFINED> instruction: 0x000003ba
     dc4:	0000043c 	andeq	r0, r0, ip, lsr r4
#if (TERM_RX_IRQ == TRUE)
     LPLD_UART_EnableIrq (uart_init_struct);
#endif

 }
     dc8:	20770002 	rsbscs	r0, r7, r2
	...
//图像状态
volatile IMG_STATUS_e ov7725_eagle_img_flag = IMG_FINISH;

//ov7725初始化 
uint8 Ov7725_Init (void)
{
     dd4:	0000043c 	andeq	r0, r0, ip, lsr r4
    uint16 i = 0;
     dd8:	0000043e 	andeq	r0, r0, lr, lsr r4
    uint8 device_Id = 0;
     ddc:	007d0002 	rsbseq	r0, sp, r2
     de0:	0000043e 	andeq	r0, r0, lr, lsr r4
    uint8 reg_Buff[50] = {0};
     de4:	00000440 	andeq	r0, r0, r0, asr #8
     de8:	087d0002 	ldmdaeq	sp!, {r1}^
     dec:	00000440 	andeq	r0, r0, r0, asr #8
     df0:	00000442 	andeq	r0, r0, r2, asr #8
     df4:	107d0002 	rsbsne	r0, sp, r2
     df8:	00000442 	andeq	r0, r0, r2, asr #8
     dfc:	00000488 	andeq	r0, r0, r8, lsl #9
     e00:	10770002 	rsbsne	r0, r7, r2
	...
     e0c:	00000488 	andeq	r0, r0, r8, lsl #9
     e10:	0000048a 	andeq	r0, r0, sl, lsl #9
     e14:	007d0002 	rsbseq	r0, sp, r2
     e18:	0000048a 	andeq	r0, r0, sl, lsl #9
     e1c:	0000048c 	andeq	r0, r0, ip, lsl #9
     e20:	087d0002 	ldmdaeq	sp!, {r1}^
     e24:	0000048c 	andeq	r0, r0, ip, lsl #9
     e28:	0000048e 	andeq	r0, r0, lr, lsl #9
     e2c:	107d0002 	rsbsne	r0, sp, r2
     e30:	0000048e 	andeq	r0, r0, lr, lsl #9
     e34:	000005aa 	andeq	r0, r0, sl, lsr #11
     e38:	10770002 	rsbsne	r0, r7, r2
	...
     e44:	000005ac 	andeq	r0, r0, ip, lsr #11
     e48:	000005ae 	andeq	r0, r0, lr, lsr #11
     e4c:	007d0002 	rsbseq	r0, sp, r2
     e50:	000005ae 	andeq	r0, r0, lr, lsr #11
     e54:	000005b0 			; <UNDEFINED> instruction: 0x000005b0
     e58:	047d0002 	ldrbteq	r0, [sp], #-2
     e5c:	000005b0 			; <UNDEFINED> instruction: 0x000005b0
     e60:	000005b2 			; <UNDEFINED> instruction: 0x000005b2
     e64:	107d0002 	rsbsne	r0, sp, r2

    LPLD_SCCB_Init ();
     e68:	000005b2 			; <UNDEFINED> instruction: 0x000005b2
    
    Ov7725_Delay();
     e6c:	000005ce 	andeq	r0, r0, lr, asr #11

    while (!LPLD_SCCB_WriteReg (OV7725_COM7, 0x80))
     e70:	10770002 	rsbsne	r0, r7, r2
	...
    {
        if (i ++ >= 500)
     e7c:	000005d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     e80:	000005d2 	ldrdeq	r0, [r0], -r2
     e84:	007d0002 	rsbseq	r0, sp, r2
     e88:	000005d2 	ldrdeq	r0, [r0], -r2
     e8c:	000005d4 	ldrdeq	r0, [r0], -r4
            return 0;
     e90:	047d0002 	ldrbteq	r0, [sp], #-2

    LPLD_SCCB_Init ();
    
    Ov7725_Delay();

    while (!LPLD_SCCB_WriteReg (OV7725_COM7, 0x80))
     e94:	000005d4 	ldrdeq	r0, [r0], -r4
     e98:	000005d6 	ldrdeq	r0, [r0], -r6
     e9c:	107d0002 	rsbsne	r0, sp, r2
     ea0:	000005d6 	ldrdeq	r0, [r0], -r6
     ea4:	000005ee 	andeq	r0, r0, lr, ror #11
    {
        if (i ++ >= 500)
            return 0;
    }

    Ov7725_Delay();
     ea8:	10770002 	rsbsne	r0, r7, r2
	...
    
    while (0 == LPLD_SCCB_ReadReg (OV7725_VER, &device_Id, 1));
     eb4:	000005f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     eb8:	000005f2 	strdeq	r0, [r0], -r2
     ebc:	007d0002 	rsbseq	r0, sp, r2
     ec0:	000005f2 	strdeq	r0, [r0], -r2

    printf ("You get ID success, SENSOR ID is 0x%x", device_Id);
     ec4:	000005f4 	strdeq	r0, [r0], -r4
     ec8:	047d0002 	ldrbteq	r0, [sp], #-2
     ecc:	000005f4 	strdeq	r0, [r0], -r4
     ed0:	000005f6 	strdeq	r0, [r0], -r6
     ed4:	107d0002 	rsbsne	r0, sp, r2
    printf ("nconfig register Number is %d\n", ov7725_eagle_cfgnum);
     ed8:	000005f6 	strdeq	r0, [r0], -r6
     edc:	00000622 	andeq	r0, r0, r2, lsr #12
     ee0:	10770002 	rsbsne	r0, r7, r2
	...
     eec:	00000624 	andeq	r0, r0, r4, lsr #12

    //判断摄像头是否为ov7725
    if (device_Id == OV7725_ID)
     ef0:	00000626 	andeq	r0, r0, r6, lsr #12
     ef4:	007d0002 	rsbseq	r0, sp, r2
    {
        for (i = 0; i < ov7725_eagle_cfgnum; i++)
     ef8:	00000626 	andeq	r0, r0, r6, lsr #12
     efc:	00000628 	andeq	r0, r0, r8, lsr #12
        {
            if (0 == LPLD_SCCB_WriteReg(ov7725_eagle_reg[i].addr, ov7725_eagle_reg[i].val))
     f00:	047d0002 	ldrbteq	r0, [sp], #-2
     f04:	00000628 	andeq	r0, r0, r8, lsr #12
     f08:	0000062a 	andeq	r0, r0, sl, lsr #12
     f0c:	107d0002 	rsbsne	r0, sp, r2
     f10:	0000062a 	andeq	r0, r0, sl, lsr #12
     f14:	0000065e 	andeq	r0, r0, lr, asr r6
     f18:	10770002 	rsbsne	r0, r7, r2
	...
     f24:	00000660 	andeq	r0, r0, r0, ror #12
     f28:	00000662 	andeq	r0, r0, r2, ror #12
     f2c:	007d0002 	rsbseq	r0, sp, r2
            {
               printf ("error: writeReg error 0x%x\n", ov7725_eagle_reg[i].addr);
     f30:	00000662 	andeq	r0, r0, r2, ror #12
     f34:	00000664 	andeq	r0, r0, r4, ror #12
     f38:	047d0002 	ldrbteq	r0, [sp], #-2
     f3c:	00000664 	andeq	r0, r0, r4, ror #12
     f40:	00000666 	andeq	r0, r0, r6, ror #12
     f44:	107d0002 	rsbsne	r0, sp, r2
     f48:	00000666 	andeq	r0, r0, r6, ror #12
                return 0;
     f4c:	0000068a 	andeq	r0, r0, sl, lsl #13
            }
            if (LPLD_SCCB_ReadReg(ov7725_eagle_reg[i].addr, &reg_Buff[i], 1))
     f50:	10770002 	rsbsne	r0, r7, r2
	...
     f5c:	0000068c 	andeq	r0, r0, ip, lsl #13
     f60:	0000068e 	andeq	r0, r0, lr, lsl #13
     f64:	007d0002 	rsbseq	r0, sp, r2
     f68:	0000068e 	andeq	r0, r0, lr, lsl #13
     f6c:	00000690 	muleq	r0, r0, r6
     f70:	047d0002 	ldrbteq	r0, [sp], #-2
     f74:	00000690 	muleq	r0, r0, r6
            {
                printf ("writeRe 0x%x success: 0x%x\n", ov7725_eagle_reg[i].addr, reg_Buff[i]);
     f78:	00000692 	muleq	r0, r2, r6
     f7c:	107d0002 	rsbsne	r0, sp, r2
     f80:	00000692 	muleq	r0, r2, r6
     f84:	000006b2 			; <UNDEFINED> instruction: 0x000006b2
     f88:	10770002 	rsbsne	r0, r7, r2
	...
     f94:	000006b4 			; <UNDEFINED> instruction: 0x000006b4
     f98:	000006b6 			; <UNDEFINED> instruction: 0x000006b6
     f9c:	007d0002 	rsbseq	r0, sp, r2
     fa0:	000006b6 			; <UNDEFINED> instruction: 0x000006b6
    printf ("nconfig register Number is %d\n", ov7725_eagle_cfgnum);

    //判断摄像头是否为ov7725
    if (device_Id == OV7725_ID)
    {
        for (i = 0; i < ov7725_eagle_cfgnum; i++)
     fa4:	000006b8 			; <UNDEFINED> instruction: 0x000006b8
     fa8:	047d0002 	ldrbteq	r0, [sp], #-2
     fac:	000006b8 			; <UNDEFINED> instruction: 0x000006b8
     fb0:	000006ba 			; <UNDEFINED> instruction: 0x000006ba
     fb4:	107d0002 	rsbsne	r0, sp, r2
     fb8:	000006ba 			; <UNDEFINED> instruction: 0x000006ba
            }
        }
    }
    else
    {
        return 0;
     fbc:	000006ce 	andeq	r0, r0, lr, asr #13
     fc0:	10770002 	rsbsne	r0, r7, r2
	...
    }
    return 1;

}
     fcc:	000006d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>

//ov7725延时函数
void Ov7725_Delay(void)
{
     fd0:	000006d2 	ldrdeq	r0, [r0], -r2
     fd4:	007d0002 	rsbseq	r0, sp, r2
    uint16 i, n;
    for (i = 0; i < 3000; i++)
     fd8:	000006d2 	ldrdeq	r0, [r0], -r2
     fdc:	000006d4 	ldrdeq	r0, [r0], -r4
    {
        for (n = 0; n < 200; n++)
     fe0:	047d0002 	ldrbteq	r0, [sp], #-2
     fe4:	000006d4 	ldrdeq	r0, [r0], -r4
     fe8:	000006d6 	ldrdeq	r0, [r0], -r6
     fec:	107d0002 	rsbsne	r0, sp, r2
     ff0:	000006d6 	ldrdeq	r0, [r0], -r6
     ff4:	000006ea 	andeq	r0, r0, sl, ror #13

//ov7725延时函数
void Ov7725_Delay(void)
{
    uint16 i, n;
    for (i = 0; i < 3000; i++)
     ff8:	10770002 	rsbsne	r0, r7, r2
	...
    1004:	000006ec 	andeq	r0, r0, ip, ror #13
        for (n = 0; n < 200; n++)
        {
            asm("nop");
        }
    }
}
    1008:	000006ee 	andeq	r0, r0, lr, ror #13
    100c:	007d0002 	rsbseq	r0, sp, r2
    1010:	000006ee 	andeq	r0, r0, lr, ror #13

//DMA中断触发函数
void Ov7725_eagle_dma (void)
{
    1014:	000006f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    1018:	107d0002 	rsbsne	r0, sp, r2
    ov7725_eagle_img_flag = IMG_FINISH;
    101c:	000006f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    1020:	000006f2 	strdeq	r0, [r0], -r2
    1024:	187d0002 	ldmdane	sp!, {r1}^
    //关闭DMA通道
    DMA_DIS(DMA_CH0);
    1028:	000006f2 	strdeq	r0, [r0], -r2
    102c:	000006f4 	strdeq	r0, [r0], -r4
    1030:	207d0002 	rsbscs	r0, sp, r2
    1034:	000006f4 	strdeq	r0, [r0], -r4
    1038:	0000077e 	andeq	r0, r0, lr, ror r7
    103c:	20770002 	rsbscs	r0, r7, r2
	...
    //DMA0->INT |= 0x1u << 0;
    //enable_irq(INT_PORTA - 16);
    //图片进行解压
    Ov7725_img_extract(Pix_Data, img, PHOTO_SIZE/8);
    1048:	00000780 	andeq	r0, r0, r0, lsl #15
    104c:	00000782 	andeq	r0, r0, r2, lsl #15
    1050:	007d0002 	rsbseq	r0, sp, r2
    1054:	00000782 	andeq	r0, r0, r2, lsl #15
    //解压完成标志置位
    ready_send_flag = 1;
    1058:	00000784 	andeq	r0, r0, r4, lsl #15
    105c:	107d0002 	rsbsne	r0, sp, r2
    1060:	00000784 	andeq	r0, r0, r4, lsl #15
    1064:	00000786 	andeq	r0, r0, r6, lsl #15
    get_midline(Pix_Data, 60, 80);
    1068:	187d0002 	ldmdane	sp!, {r1}^
    106c:	00000786 	andeq	r0, r0, r6, lsl #15
    1070:	00000788 	andeq	r0, r0, r8, lsl #15
    1074:	207d0002 	rsbscs	r0, sp, r2
    1078:	00000788 	andeq	r0, r0, r8, lsl #15
         //重新装载DMA目标地址
        DMA_DADDR(DMA_CH0) = (uint32)img;
    107c:	00000812 	andeq	r0, r0, r2, lsl r8
    1080:	20770002 	rsbscs	r0, r7, r2
	...
    108c:	00000814 	andeq	r0, r0, r4, lsl r8
    1090:	00000816 	andeq	r0, r0, r6, lsl r8
   //Ov7725_sendimg(Pix_Data, PHOTO_SIZE);
    //clear PORTA isr set bit
    PORTA_ISFR = ~0;
    1094:	007d0002 	rsbseq	r0, sp, r2
    1098:	00000816 	andeq	r0, r0, r6, lsl r8
    109c:	00000818 	andeq	r0, r0, r8, lsl r8
    10a0:	087d0002 	ldmdaeq	sp!, {r1}^
    LPLD_GPIO_EnableIrq(OV_PTA_init);
    10a4:	00000818 	andeq	r0, r0, r8, lsl r8
    10a8:	0000081a 	andeq	r0, r0, sl, lsl r8
    10ac:	107d0002 	rsbsne	r0, sp, r2
    10b0:	0000081a 	andeq	r0, r0, sl, lsl r8
    10b4:	00000866 	andeq	r0, r0, r6, ror #16
    //DMA0->INT |= 0x1u << 0;
}
    10b8:	10770002 	rsbsne	r0, r7, r2
	...
//场中断开始判断函数
void Ov7725_eagle_vsync(void)
{
    //printf ("runing eagle_vsync\n");
    //判断场中断是否开始
    if (ov7725_eagle_img_flag == IMG_START)
    10c4:	00000868 	andeq	r0, r0, r8, ror #16
    10c8:	0000086a 	andeq	r0, r0, sl, ror #16
    10cc:	007d0002 	rsbseq	r0, sp, r2
    {
        ov7725_eagle_img_flag = IMG_GATHER;
    10d0:	0000086a 	andeq	r0, r0, sl, ror #16
    10d4:	0000086c 	andeq	r0, r0, ip, ror #16
    10d8:	087d0002 	ldmdaeq	sp!, {r1}^
    10dc:	0000086c 	andeq	r0, r0, ip, ror #16
        disable_irq (INT_PORTA - 16);
    10e0:	0000086e 	andeq	r0, r0, lr, ror #16
    10e4:	107d0002 	rsbsne	r0, sp, r2
        //LPLD_GPIO_DisableIrq(OV_PTA_init);
        //enable_irq (DMA_CH0 + INT_DMA0_DMA16 - 16);
        DMA_EN(DMA_CH0);
    10e8:	0000086e 	andeq	r0, r0, lr, ror #16
    10ec:	000008aa 	andeq	r0, r0, sl, lsr #17
    10f0:	10770002 	rsbsne	r0, r7, r2
	...
    10fc:	000008ac 	andeq	r0, r0, ip, lsr #17
        //LPLD_DMA_EnableIrq(OV_dma_init);
        //重新装载DMA目标地址
        DMA_DADDR(DMA_CH0) = (uint32)img;
    1100:	000008ae 	andeq	r0, r0, lr, lsr #17
    1104:	007d0002 	rsbseq	r0, sp, r2
    1108:	000008ae 	andeq	r0, r0, lr, lsr #17
    110c:	000008b0 			; <UNDEFINED> instruction: 0x000008b0
    1110:	107d0002 	rsbsne	r0, sp, r2
    1114:	000008b0 			; <UNDEFINED> instruction: 0x000008b0
    1118:	000008b2 			; <UNDEFINED> instruction: 0x000008b2
    }
    else
    {
        //disable_irq (INT_PORTA);
        //LPLD_GPIO_DisableIrq(OV_PTA_init);
        disable_irq (INT_PORTA - 16);
    111c:	147d0002 	ldrbtne	r0, [sp], #-2
    1120:	000008b2 			; <UNDEFINED> instruction: 0x000008b2
        ov7725_eagle_img_flag = IMG_FAIL;
    1124:	000008b4 			; <UNDEFINED> instruction: 0x000008b4
    1128:	387d0002 	ldmdacc	sp!, {r1}^
    112c:	000008b4 			; <UNDEFINED> instruction: 0x000008b4
    }
}
    1130:	00000a66 	andeq	r0, r0, r6, ror #20

//ov7725开始采集图像
void Ov7725_eagle_get_img(void)
{
    1134:	38770002 	ldmdacc	r7!, {r1}^
	...
    ov7725_eagle_img_flag = IMG_START;
    1140:	00000a68 	andeq	r0, r0, r8, ror #20
    1144:	00000a6a 	andeq	r0, r0, sl, ror #20
    //write 1 clear int 
    PORTA_ISFR = ~0;
    1148:	007d0002 	rsbseq	r0, sp, r2
    114c:	00000a6a 	andeq	r0, r0, sl, ror #20
    1150:	00000a6c 	andeq	r0, r0, ip, ror #20
    1154:	107d0002 	rsbsne	r0, sp, r2
    DMA_DADDR(DMA_CH0) = (uint32)img;
    1158:	00000a6c 	andeq	r0, r0, ip, ror #20
    115c:	00000a6e 	andeq	r0, r0, lr, ror #20
    1160:	147d0002 	ldrbtne	r0, [sp], #-2
    1164:	00000a6e 	andeq	r0, r0, lr, ror #20
    1168:	00000a70 	andeq	r0, r0, r0, ror sl
    116c:	287d0002 	ldmdacs	sp!, {r1}^
    1170:	00000a70 	andeq	r0, r0, r0, ror sl
    LPLD_GPIO_EnableIrq(OV_PTA_init);
    1174:	00000b74 	andeq	r0, r0, r4, ror fp
    1178:	28770002 	ldmdacs	r7!, {r1}^
	...
}
    1184:	00000b74 	andeq	r0, r0, r4, ror fp
 *  @param      srclen          二值化图像的占用空间大小
 *  @since      v5.0            img_extract(img, imgbuff,CAMERA_SIZE);
 *  Sample usage:   sendimg(imgbuff, CAMERA_W * CAMERA_H);                    //发送到上位机
 */
void Ov7725_img_extract(uint8 *dst, uint8 *src, uint32 srclen)
{
    1188:	00000b76 	andeq	r0, r0, r6, ror fp
    118c:	007d0002 	rsbseq	r0, sp, r2
    1190:	00000b76 	andeq	r0, r0, r6, ror fp
    uint8 colour[2] = {255, 0}; //0 和 1 分别对应的颜色
    1194:	00000b78 	andeq	r0, r0, r8, ror fp
    1198:	047d0002 	ldrbteq	r0, [sp], #-2
    119c:	00000b78 	andeq	r0, r0, r8, ror fp
    //注：野火的摄像头 1(or255)表示 白色，0表示 黑色
    uint8 tmpsrc;
    while(srclen --)
    11a0:	00000b7a 	andeq	r0, r0, sl, ror fp
    {
        tmpsrc = *src++;
    11a4:	107d0002 	rsbsne	r0, sp, r2
    11a8:	00000b7a 	andeq	r0, r0, sl, ror fp
    11ac:	000014ae 	andeq	r1, r0, lr, lsr #9
        *dst++ = colour[(tmpsrc >> 7) & 0x01];
    11b0:	10770002 	rsbsne	r0, r7, r2
	...
    11bc:	000014b0 			; <UNDEFINED> instruction: 0x000014b0
    11c0:	000014b2 			; <UNDEFINED> instruction: 0x000014b2
    11c4:	007d0002 	rsbseq	r0, sp, r2
    11c8:	000014b2 			; <UNDEFINED> instruction: 0x000014b2
    11cc:	000014b4 			; <UNDEFINED> instruction: 0x000014b4
    11d0:	047d0002 	ldrbteq	r0, [sp], #-2
        *dst++ = colour[(tmpsrc >> 6) & 0x01];
    11d4:	000014b4 			; <UNDEFINED> instruction: 0x000014b4
    11d8:	000014b6 			; <UNDEFINED> instruction: 0x000014b6
    11dc:	107d0002 	rsbsne	r0, sp, r2
    11e0:	000014b6 			; <UNDEFINED> instruction: 0x000014b6
    11e4:	00001b08 	andeq	r1, r0, r8, lsl #22
    11e8:	10770002 	rsbsne	r0, r7, r2
	...
        *dst++ = colour[(tmpsrc >> 5) & 0x01];
    11f4:	00001b08 	andeq	r1, r0, r8, lsl #22
    11f8:	00001b0a 	andeq	r1, r0, sl, lsl #22
    11fc:	007d0002 	rsbseq	r0, sp, r2
    1200:	00001b0a 	andeq	r1, r0, sl, lsl #22
    1204:	00001b0c 	andeq	r1, r0, ip, lsl #22
    1208:	107d0002 	rsbsne	r0, sp, r2
    120c:	00001b0c 	andeq	r1, r0, ip, lsl #22
    1210:	00001b0e 	andeq	r1, r0, lr, lsl #22
    1214:	147d0002 	ldrbtne	r0, [sp], #-2
        *dst++ = colour[(tmpsrc >> 4) & 0x01];
    1218:	00001b0e 	andeq	r1, r0, lr, lsl #22
    121c:	00001b10 	andeq	r1, r0, r0, lsl fp
    1220:	207d0002 	rsbscs	r0, sp, r2
    1224:	00001b10 	andeq	r1, r0, r0, lsl fp
    1228:	00001b78 	andeq	r1, r0, r8, ror fp
    122c:	20770002 	rsbscs	r0, r7, r2
	...
        *dst++ = colour[(tmpsrc >> 3) & 0x01];
    1238:	00001b78 	andeq	r1, r0, r8, ror fp
    123c:	00001b7a 	andeq	r1, r0, sl, ror fp
    1240:	007d0002 	rsbseq	r0, sp, r2
    1244:	00001b7a 	andeq	r1, r0, sl, ror fp
    1248:	00001b7c 	andeq	r1, r0, ip, ror fp
    124c:	107d0002 	rsbsne	r0, sp, r2
    1250:	00001b7c 	andeq	r1, r0, ip, ror fp
    1254:	00001b7e 	andeq	r1, r0, lr, ror fp
    1258:	147d0002 	ldrbtne	r0, [sp], #-2
        *dst++ = colour[(tmpsrc >> 2) & 0x01];
    125c:	00001b7e 	andeq	r1, r0, lr, ror fp
    1260:	00001b94 	muleq	r0, r4, fp
    1264:	14770002 	ldrbtne	r0, [r7], #-2
	...
    1270:	00001b94 	muleq	r0, r4, fp
    1274:	00001b96 	muleq	r0, r6, fp
    1278:	007d0002 	rsbseq	r0, sp, r2
        *dst++ = colour[(tmpsrc >> 1) & 0x01];
    127c:	00001b96 	muleq	r0, r6, fp
    1280:	00001b98 	muleq	r0, r8, fp
    1284:	087d0002 	ldmdaeq	sp!, {r1}^
    1288:	00001b98 	muleq	r0, r8, fp
    128c:	00001ba6 	andeq	r1, r0, r6, lsr #23
    1290:	08770002 	ldmdaeq	r7!, {r1}^
	...
    129c:	00001ba8 	andeq	r1, r0, r8, lsr #23
        *dst++ = colour[(tmpsrc >> 0) & 0x01];
    12a0:	00001baa 	andeq	r1, r0, sl, lsr #23
    12a4:	007d0002 	rsbseq	r0, sp, r2
    12a8:	00001baa 	andeq	r1, r0, sl, lsr #23
    12ac:	00001bac 	andeq	r1, r0, ip, lsr #23
    12b0:	087d0002 	ldmdaeq	sp!, {r1}^
    12b4:	00001bac 	andeq	r1, r0, ip, lsr #23
    12b8:	00001bba 			; <UNDEFINED> instruction: 0x00001bba
void Ov7725_img_extract(uint8 *dst, uint8 *src, uint32 srclen)
{
    uint8 colour[2] = {255, 0}; //0 和 1 分别对应的颜色
    //注：野火的摄像头 1(or255)表示 白色，0表示 黑色
    uint8 tmpsrc;
    while(srclen --)
    12bc:	08770002 	ldmdaeq	r7!, {r1}^
	...
    12c8:	00001bbc 			; <UNDEFINED> instruction: 0x00001bbc
    12cc:	00001bbe 			; <UNDEFINED> instruction: 0x00001bbe
    12d0:	007d0002 	rsbseq	r0, sp, r2
        *dst++ = colour[(tmpsrc >> 3) & 0x01];
        *dst++ = colour[(tmpsrc >> 2) & 0x01];
        *dst++ = colour[(tmpsrc >> 1) & 0x01];
        *dst++ = colour[(tmpsrc >> 0) & 0x01];
    }
}
    12d4:	00001bbe 			; <UNDEFINED> instruction: 0x00001bbe
    12d8:	00001bc0 	andeq	r1, r0, r0, asr #23
    12dc:	087d0002 	ldmdaeq	sp!, {r1}^
 *  @note       不同的上位机，不同的命令，这里使用 eSmartCameraCar软件，
                如果使用其他上位机，则需要修改代码。
 *  Sample usage:   sendimg(imgbuff, CAMERA_W * CAMERA_H);                    //发送到上位机
 */
void Ov7725_sendimg(uint8 *imgaddr, uint32 imgsize)
{
    12e0:	00001bc0 	andeq	r1, r0, r0, asr #23
    12e4:	00001bce 	andeq	r1, r0, lr, asr #23
    12e8:	08770002 	ldmdaeq	r7!, {r1}^
	...
    uint8 cmd[4] = {0, 255, 1, 0 };    //yy_摄像头串口调试 使用的命令
    12f8:	00000002 	andeq	r0, r0, r2
    
    LPLD_UART_PutCharArr(TERM_PORT, (char *)cmd, sizeof(cmd));
    12fc:	007d0002 	rsbseq	r0, sp, r2
    1300:	00000002 	andeq	r0, r0, r2
    1304:	00000004 	andeq	r0, r0, r4
    1308:	107d0002 	rsbsne	r0, sp, r2
    130c:	00000004 	andeq	r0, r0, r4
    LPLD_UART_PutCharArr(TERM_PORT, (char *)imgaddr, imgsize);
    1310:	00000006 	andeq	r0, r0, r6
    1314:	147d0002 	ldrbtne	r0, [sp], #-2
    1318:	00000006 	andeq	r0, r0, r6
    131c:	00000008 	andeq	r0, r0, r8
    1320:	307d0002 	rsbscc	r0, sp, r2

    //uart_putbuff(FIRE_PORT, cmd, sizeof(cmd));    //先发送命令

    //uart_putbuff(FIRE_PORT, imgaddr, imgsize); //再发送图像
}
    1324:	00000008 	andeq	r0, r0, r8
    1328:	00000156 	andeq	r0, r0, r6, asr r1

//OV7725GPIO口初始化
void Ov7725_Gpio_Init(void)
{
    132c:	30770002 	rsbscc	r0, r7, r2
	...
    //OV数据口初始化 B0～B7
    OV_PTB_init.GPIO_PTx = PTB;
    1338:	00000158 	andeq	r0, r0, r8, asr r1
    133c:	0000015a 	andeq	r0, r0, sl, asr r1
    1340:	007d0002 	rsbseq	r0, sp, r2
    OV_PTB_init.GPIO_Dir = DIR_INPUT;
    1344:	0000015a 	andeq	r0, r0, sl, asr r1
    1348:	0000015c 	andeq	r0, r0, ip, asr r1
    134c:	107d0002 	rsbsne	r0, sp, r2
    1350:	0000015c 	andeq	r0, r0, ip, asr r1
    OV_PTB_init.GPIO_Pins = GPIO_Pin0_7;
    1354:	0000015e 	andeq	r0, r0, lr, asr r1
    1358:	187d0002 	ldmdane	sp!, {r1}^
    135c:	0000015e 	andeq	r0, r0, lr, asr r1
    //禁止中断和DMA请求 禁用PULL 输入源下拉
    OV_PTB_init.GPIO_PinControl = IRQC_DIS |
    1360:	00000160 	andeq	r0, r0, r0, ror #2
    1364:	207d0002 	rsbscs	r0, sp, r2
    1368:	00000160 	andeq	r0, r0, r0, ror #2
    136c:	0000024a 	andeq	r0, r0, sl, asr #4
                                  INPUT_PULL_DIS|
                                  INPUT_PULL_DOWN;
    LPLD_GPIO_Init (OV_PTB_init);
    1370:	20770002 	rsbscs	r0, r7, r2
	...
    137c:	0000024c 	andeq	r0, r0, ip, asr #4

    //OV场信号接口初始化 A29 
    OV_PTA_init.GPIO_PTx = PTA;
    1380:	0000024e 	andeq	r0, r0, lr, asr #4
    1384:	007d0002 	rsbseq	r0, sp, r2
    1388:	0000024e 	andeq	r0, r0, lr, asr #4
    138c:	00000250 	andeq	r0, r0, r0, asr r2
    1390:	107d0002 	rsbsne	r0, sp, r2
    OV_PTA_init.GPIO_Dir = DIR_INPUT;
    1394:	00000250 	andeq	r0, r0, r0, asr r2
    1398:	00000252 	andeq	r0, r0, r2, asr r2
    139c:	147d0002 	ldrbtne	r0, [sp], #-2
    OV_PTA_init.GPIO_Pins = GPIO_Pin29;
    13a0:	00000252 	andeq	r0, r0, r2, asr r2
    13a4:	00000254 	andeq	r0, r0, r4, asr r2
    13a8:	287d0002 	ldmdacs	sp!, {r1}^
    13ac:	00000254 	andeq	r0, r0, r4, asr r2
    //场中断IO设置，上升沿触发IR，输入上拉，使能滤波
    OV_PTA_init.GPIO_PinControl = IRQC_RI |
    13b0:	00000352 	andeq	r0, r0, r2, asr r3
    13b4:	28770002 	ldmdacs	r7!, {r1}^
	...
                                    INPUT_PULL_UP|
                                    INPUT_PF_EN;
    OV_PTA_init.GPIO_Isr = Ov7725_isr;
    13c0:	00000354 	andeq	r0, r0, r4, asr r3
    13c4:	00000356 	andeq	r0, r0, r6, asr r3
    13c8:	007d0002 	rsbseq	r0, sp, r2
    13cc:	00000356 	andeq	r0, r0, r6, asr r3
    13d0:	00000358 	andeq	r0, r0, r8, asr r3
    LPLD_GPIO_Init (OV_PTA_init);
    13d4:	047d0002 	ldrbteq	r0, [sp], #-2
    13d8:	00000358 	andeq	r0, r0, r8, asr r3
    13dc:	0000035a 	andeq	r0, r0, sl, asr r3
    13e0:	107d0002 	rsbsne	r0, sp, r2

    //OV PCLK信号接口初始化: PTA27-PCLK 
    OV_PTD_init.GPIO_PTx = PTA;
    13e4:	0000035a 	andeq	r0, r0, sl, asr r3
    13e8:	00000374 	andeq	r0, r0, r4, ror r3
    13ec:	10770002 	rsbsne	r0, r7, r2
	...
    OV_PTD_init.GPIO_Pins = GPIO_Pin27;
    13f8:	00000374 	andeq	r0, r0, r4, ror r3
    13fc:	00000376 	andeq	r0, r0, r6, ror r3
    1400:	007d0002 	rsbseq	r0, sp, r2
    OV_PTD_init.GPIO_Dir = DIR_INPUT;
    1404:	00000376 	andeq	r0, r0, r6, ror r3
    1408:	00000378 	andeq	r0, r0, r8, ror r3
    140c:	047d0002 	ldrbteq	r0, [sp], #-2
    1410:	00000378 	andeq	r0, r0, r8, ror r3
    //PCLK信号，下降沿触发DMA，输入上拉
    OV_PTD_init.GPIO_PinControl = IRQC_DMAFA | INPUT_PULL_UP;
    1414:	0000037a 	andeq	r0, r0, sl, ror r3
    1418:	107d0002 	rsbsne	r0, sp, r2
    141c:	0000037a 	andeq	r0, r0, sl, ror r3
    1420:	000003b0 			; <UNDEFINED> instruction: 0x000003b0
    LPLD_GPIO_Init (OV_PTD_init);
    1424:	10770002 	rsbsne	r0, r7, r2
	...
    1430:	000003b0 			; <UNDEFINED> instruction: 0x000003b0
    1434:	000003b2 			; <UNDEFINED> instruction: 0x000003b2

}
    1438:	007d0002 	rsbseq	r0, sp, r2
 
//OV7725 DMA初始化 
void Ov7725_Dma_Init (void)
{
    143c:	000003b2 			; <UNDEFINED> instruction: 0x000003b2
    1440:	000003b4 			; <UNDEFINED> instruction: 0x000003b4
    OV_dma_init.DMA_CHx = DMA_CH0;
    1444:	047d0002 	ldrbteq	r0, [sp], #-2
    1448:	000003b4 			; <UNDEFINED> instruction: 0x000003b4
    144c:	000003b6 			; <UNDEFINED> instruction: 0x000003b6
    OV_dma_init.DMA_Req = PORTA_DMAREQ;
    1450:	107d0002 	rsbsne	r0, sp, r2
    1454:	000003b6 			; <UNDEFINED> instruction: 0x000003b6
    1458:	000003d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    145c:	10770002 	rsbsne	r0, r7, r2
	...
    OV_dma_init.DMA_MajorLoopCnt = PHOTO_SIZE / 8;
    1468:	000003d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    OV_dma_init.DMA_MinorByteCnt = 1;
    146c:	000003d2 	ldrdeq	r0, [r0], -r2
    1470:	007d0002 	rsbseq	r0, sp, r2
    1474:	000003d2 	ldrdeq	r0, [r0], -r2
    1478:	000003d4 	ldrdeq	r0, [r0], -r4
    
    OV_dma_init.DMA_SourceAddr = (uint32)(&GPIOB_PDIR);
    147c:	047d0002 	ldrbteq	r0, [sp], #-2
    1480:	000003d4 	ldrdeq	r0, [r0], -r4
    1484:	000003d6 	ldrdeq	r0, [r0], -r6
    1488:	107d0002 	rsbsne	r0, sp, r2
    OV_dma_init.DMA_DestAddr = (uint32)img;
    148c:	000003d6 	ldrdeq	r0, [r0], -r6
    1490:	000003fa 	strdeq	r0, [r0], -sl
    1494:	10770002 	rsbsne	r0, r7, r2
	...
    OV_dma_init.DMA_DestAddrOffset = 1;
    14a0:	000003fc 	strdeq	r0, [r0], -ip
    14a4:	000003fe 	strdeq	r0, [r0], -lr
    14a8:	007d0002 	rsbseq	r0, sp, r2
    OV_dma_init.DMA_Isr = Ov7725_eagle_dma;
    14ac:	000003fe 	strdeq	r0, [r0], -lr
    14b0:	00000400 	andeq	r0, r0, r0, lsl #8
    14b4:	047d0002 	ldrbteq	r0, [sp], #-2
    14b8:	00000400 	andeq	r0, r0, r0, lsl #8
    14bc:	00000402 	andeq	r0, r0, r2, lsl #8
    LPLD_DMA_Init (OV_dma_init);
    14c0:	187d0002 	ldmdane	sp!, {r1}^
    14c4:	00000402 	andeq	r0, r0, r2, lsl #8
    14c8:	00000418 	andeq	r0, r0, r8, lsl r4
    14cc:	18770002 	ldmdane	r7!, {r1}^
	...
    14d8:	00000418 	andeq	r0, r0, r8, lsl r4
    14dc:	0000041a 	andeq	r0, r0, sl, lsl r4

    LPLD_DMA_DisableReq(DMA_CH0);
    14e0:	007d0002 	rsbseq	r0, sp, r2
    14e4:	0000041a 	andeq	r0, r0, sl, lsl r4
    14e8:	0000041c 	andeq	r0, r0, ip, lsl r4
    14ec:	047d0002 	ldrbteq	r0, [sp], #-2
    14f0:	0000041c 	andeq	r0, r0, ip, lsl r4
    14f4:	0000041e 	andeq	r0, r0, lr, lsl r4
    //disable_irq (INT_PORTA - 16);
    LPLD_GPIO_EnableIrq (OV_PTA_init);
    14f8:	107d0002 	rsbsne	r0, sp, r2
    14fc:	0000041e 	andeq	r0, r0, lr, lsl r4
    1500:	00000442 	andeq	r0, r0, r2, asr #8
    1504:	10770002 	rsbsne	r0, r7, r2
	...
    DMA0->INT |= 0x1u <<0;
    1510:	00000444 	andeq	r0, r0, r4, asr #8
    1514:	00000446 	andeq	r0, r0, r6, asr #8
    1518:	007d0002 	rsbseq	r0, sp, r2
    151c:	00000446 	andeq	r0, r0, r6, asr #8
    1520:	00000448 	andeq	r0, r0, r8, asr #8
    //允许DMA通道传输完成中断
    //enable_irq (DMA_CH0);
    LPLD_DMA_EnableIrq (OV_dma_init);
    1524:	087d0002 	ldmdaeq	sp!, {r1}^
    1528:	00000448 	andeq	r0, r0, r8, asr #8
    152c:	00000466 	andeq	r0, r0, r6, ror #8
    1530:	08770002 	ldmdaeq	r7!, {r1}^
	...
    153c:	00000468 	andeq	r0, r0, r8, ror #8
    1540:	0000046a 	andeq	r0, r0, sl, ror #8
    //使能通道x的DMA请求
    //LPLD_DMA_EnableReq(DMA_CH0);
}
    1544:	007d0002 	rsbseq	r0, sp, r2
    1548:	0000046a 	andeq	r0, r0, sl, ror #8

//ov7725中断
void Ov7725_isr (void)
{
    154c:	0000046c 	andeq	r0, r0, ip, ror #8
    1550:	087d0002 	ldmdaeq	sp!, {r1}^
    uint8 n = 0;
    1554:	0000046c 	andeq	r0, r0, ip, ror #8
    while (!PORTA_ISFR);
    1558:	0000048a 	andeq	r0, r0, sl, lsl #9
    155c:	08770002 	ldmdaeq	r7!, {r1}^
	...
    1568:	0000048c 	andeq	r0, r0, ip, lsl #9
    uint32 flag = (PORTA->ISFR);
    156c:	0000048e 	andeq	r0, r0, lr, lsl #9
    1570:	007d0002 	rsbseq	r0, sp, r2
    1574:	0000048e 	andeq	r0, r0, lr, lsl #9
    (PORTA -> ISFR) = ~0;
    1578:	00000490 	muleq	r0, r0, r4
    157c:	087d0002 	ldmdaeq	sp!, {r1}^
    1580:	00000490 	muleq	r0, r0, r4
    1584:	000004ae 	andeq	r0, r0, lr, lsr #9
   
    n = 29;
    1588:	08770002 	ldmdaeq	r7!, {r1}^
	...
    //printf ("flag = %x\n", flag);
    if (flag & (1<<n))
    1594:	000004b0 			; <UNDEFINED> instruction: 0x000004b0
    1598:	000004b2 			; <UNDEFINED> instruction: 0x000004b2
    159c:	007d0002 	rsbseq	r0, sp, r2
    15a0:	000004b2 			; <UNDEFINED> instruction: 0x000004b2
    {
        //场中断开始 
        //set 場中断
        ov7725_eagle_img_flag = IMG_START;
    15a4:	000004b4 			; <UNDEFINED> instruction: 0x000004b4
    15a8:	087d0002 	ldmdaeq	sp!, {r1}^
    15ac:	000004b4 			; <UNDEFINED> instruction: 0x000004b4
        //关闭PORTA中断
        disable_irq (INT_PORTA - 16);
    15b0:	000004d2 	ldrdeq	r0, [r0], -r2
    15b4:	08770002 	ldmdaeq	r7!, {r1}^
	...
        //LPLD_GPIO_DisableIrq(OV_PTA_init);
        //enable_irq (DMA_CH0 + INT_DMA0_DMA16 - 16);
        //重新装载DMA目标地址
        //DMA_DADDR(DMA_CH0) = (uint32)img;
        //开启DMA通道
        DMA_EN(DMA_CH0);
    15c0:	000004d4 	ldrdeq	r0, [r0], -r4
    15c4:	000004d6 	ldrdeq	r0, [r0], -r6
    15c8:	007d0002 	rsbseq	r0, sp, r2
    15cc:	000004d6 	ldrdeq	r0, [r0], -r6
        //LPLD_DMA_EnableIrq(OV_dma_init);
    }
}
    15d0:	000004d8 	ldrdeq	r0, [r0], -r8
    15d4:	087d0002 	ldmdaeq	sp!, {r1}^

//移植野火的函数
void dma_portx2buff_init(uint8 CHn, void *SADDR, void *DADDR, uint8 dma_req, DMA_BYTEn byten, uint32 count, uint32 cfg)
{
    15d8:	000004d8 	ldrdeq	r0, [r0], -r8
    15dc:	000004f6 	strdeq	r0, [r0], -r6
    15e0:	08770002 	ldmdaeq	r7!, {r1}^
	...
    uint8 BYTEs = (byten == DMA_BYTE1 ? 1 : (byten == DMA_BYTE2 ? 2 : (byten == DMA_BYTE4 ? 4 : 16)));
    15f0:	00000002 	andeq	r0, r0, r2
    15f4:	007d0002 	rsbseq	r0, sp, r2
    15f8:	00000002 	andeq	r0, r0, r2
    15fc:	00000004 	andeq	r0, r0, r4
    1600:	047d0002 	ldrbteq	r0, [sp], #-2
    1604:	00000004 	andeq	r0, r0, r4
    1608:	00000006 	andeq	r0, r0, r6
    160c:	287d0002 	ldmdacs	sp!, {r1}^
    1610:	00000006 	andeq	r0, r0, r6
    1614:	000001a0 	andeq	r0, r0, r0, lsr #3
    
    SIM_SCGC7 |= SIM_SCGC7_DMA_MASK;
    1618:	28770002 	ldmdacs	r7!, {r1}^
	...
    1624:	000001a0 	andeq	r0, r0, r0, lsr #3
    1628:	000001a2 	andeq	r0, r0, r2, lsr #3
    162c:	007d0002 	rsbseq	r0, sp, r2
    1630:	000001a2 	andeq	r0, r0, r2, lsr #3
    1634:	000001a4 	andeq	r0, r0, r4, lsr #3
    SIM_SCGC6 |= SIM_SCGC6_DMAMUX0_MASK;
    1638:	087d0002 	ldmdaeq	sp!, {r1}^
    163c:	000001a4 	andeq	r0, r0, r4, lsr #3
    1640:	00000206 	andeq	r0, r0, r6, lsl #4
    1644:	08770002 	ldmdaeq	r7!, {r1}^
	...
    1650:	00000208 	andeq	r0, r0, r8, lsl #4
    1654:	0000020a 	andeq	r0, r0, sl, lsl #4
    1658:	007d0002 	rsbseq	r0, sp, r2
    165c:	0000020a 	andeq	r0, r0, sl, lsl #4

    DMA_SADDR(CHn) = (uint32) SADDR;
    1660:	0000020c 	andeq	r0, r0, ip, lsl #4
    1664:	047d0002 	ldrbteq	r0, [sp], #-2
    1668:	0000020c 	andeq	r0, r0, ip, lsl #4
    166c:	0000022a 	andeq	r0, r0, sl, lsr #4
    1670:	04770002 	ldrbteq	r0, [r7], #-2
	...
    DMA_DADDR(CHn) = (uint32) DADDR;
    167c:	0000022c 	andeq	r0, r0, ip, lsr #4
    1680:	0000022e 	andeq	r0, r0, lr, lsr #4
    1684:	007d0002 	rsbseq	r0, sp, r2
    1688:	0000022e 	andeq	r0, r0, lr, lsr #4
    168c:	00000230 	andeq	r0, r0, r0, lsr r2
    1690:	087d0002 	ldmdaeq	sp!, {r1}^
    DMA_SOFF(CHn) = 0x00u;
    1694:	00000230 	andeq	r0, r0, r0, lsr r2
    1698:	00000240 	andeq	r0, r0, r0, asr #4
    169c:	08770002 	ldmdaeq	r7!, {r1}^
	...
    16a8:	00000240 	andeq	r0, r0, r0, asr #4
    16ac:	00000242 	andeq	r0, r0, r2, asr #4
    DMA_DOFF(CHn) = BYTEs;
    16b0:	007d0002 	rsbseq	r0, sp, r2
    16b4:	00000242 	andeq	r0, r0, r2, asr #4
    16b8:	00000244 	andeq	r0, r0, r4, asr #4
    16bc:	087d0002 	ldmdaeq	sp!, {r1}^
    16c0:	00000244 	andeq	r0, r0, r4, asr #4
    16c4:	00000254 	andeq	r0, r0, r4, asr r2
    16c8:	08770002 	ldmdaeq	r7!, {r1}^
	...
    DMA_ATTR(CHn) = (0
    16d4:	00000254 	andeq	r0, r0, r4, asr r2
                     |DMA_ATTR_SMOD(0x0)
                     |DMA_ATTR_SSIZE(byten)
    16d8:	00000256 	andeq	r0, r0, r6, asr r2
    16dc:	007d0002 	rsbseq	r0, sp, r2
    16e0:	00000256 	andeq	r0, r0, r6, asr r2

    DMA_SADDR(CHn) = (uint32) SADDR;
    DMA_DADDR(CHn) = (uint32) DADDR;
    DMA_SOFF(CHn) = 0x00u;
    DMA_DOFF(CHn) = BYTEs;
    DMA_ATTR(CHn) = (0
    16e4:	00000258 	andeq	r0, r0, r8, asr r2
    16e8:	047d0002 	ldrbteq	r0, [sp], #-2
    16ec:	00000258 	andeq	r0, r0, r8, asr r2
    16f0:	0000027a 	andeq	r0, r0, sl, ror r2
    16f4:	04770002 	ldrbteq	r0, [r7], #-2
	...
    1700:	0000027c 	andeq	r0, r0, ip, ror r2
                     |DMA_ATTR_SMOD(0x0)
                     |DMA_ATTR_SSIZE(byten)
                     |DMA_ATTR_DMOD(0x0)
                     |DMA_ATTR_DSIZE(byten)
                    );
    DMA_CITER_ELINKNO(CHn) = DMA_CITER_ELINKNO_CITER(count);
    1704:	0000027e 	andeq	r0, r0, lr, ror r2
    1708:	007d0002 	rsbseq	r0, sp, r2
    170c:	0000027e 	andeq	r0, r0, lr, ror r2
    1710:	00000280 	andeq	r0, r0, r0, lsl #5
    1714:	047d0002 	ldrbteq	r0, [sp], #-2
    1718:	00000280 	andeq	r0, r0, r0, lsl #5
    171c:	00000282 	andeq	r0, r0, r2, lsl #5
    1720:	107d0002 	rsbsne	r0, sp, r2
    1724:	00000282 	andeq	r0, r0, r2, lsl #5
    1728:	0000033c 	andeq	r0, r0, ip, lsr r3
    DMA_BITER_ELINKNO(CHn) = DMA_BITER_ELINKNO_BITER(count);
    172c:	10770002 	rsbsne	r0, r7, r2
	...
    1738:	0000033c 	andeq	r0, r0, ip, lsr r3
    173c:	0000033e 	andeq	r0, r0, lr, lsr r3
    1740:	007d0002 	rsbseq	r0, sp, r2
    1744:	0000033e 	andeq	r0, r0, lr, lsr r3
    1748:	00000340 	andeq	r0, r0, r0, asr #6
    174c:	087d0002 	ldmdaeq	sp!, {r1}^
    1750:	00000340 	andeq	r0, r0, r0, asr #6

    DMA_CR &= ~DMA_CR_EMLM_MASK;
    1754:	00000366 	andeq	r0, r0, r6, ror #6
    1758:	08770002 	ldmdaeq	r7!, {r1}^
	...
    1768:	00000002 	andeq	r0, r0, r2

    DMA_NBYTES_MLNO(CHn) = DMA_NBYTES_MLNO_NBYTES(BYTEs);
    176c:	007d0002 	rsbseq	r0, sp, r2
    1770:	00000002 	andeq	r0, r0, r2
    1774:	00000004 	andeq	r0, r0, r4
    1778:	087d0002 	ldmdaeq	sp!, {r1}^
    177c:	00000004 	andeq	r0, r0, r4
    1780:	00000006 	andeq	r0, r0, r6
    1784:	187d0002 	ldmdane	sp!, {r1}^

    DMA_SLAST(CHn) = 0;
    1788:	00000006 	andeq	r0, r0, r6
    178c:	000002c2 	andeq	r0, r0, r2, asr #5
    1790:	18770002 	ldmdane	r7!, {r1}^
	...
    179c:	000002c4 	andeq	r0, r0, r4, asr #5
    17a0:	000002c6 	andeq	r0, r0, r6, asr #5
    17a4:	007d0002 	rsbseq	r0, sp, r2
    DMA_DLAST_SGA(CHn) = (uint32)((cfg & DADDR_KEEPON) == 0 ? (-count) : 0);
    17a8:	000002c6 	andeq	r0, r0, r6, asr #5
    17ac:	000002c8 	andeq	r0, r0, r8, asr #5
    17b0:	047d0002 	ldrbteq	r0, [sp], #-2
    17b4:	000002c8 	andeq	r0, r0, r8, asr #5
    17b8:	000002ca 	andeq	r0, r0, sl, asr #5
    17bc:	207d0002 	rsbscs	r0, sp, r2
    17c0:	000002ca 	andeq	r0, r0, sl, asr #5
    17c4:	00000362 	andeq	r0, r0, r2, ror #6
    17c8:	20770002 	rsbscs	r0, r7, r2
	...
    DMA_CSR(CHn) = (0
    17d8:	00000002 	andeq	r0, r0, r2
    17dc:	007d0002 	rsbseq	r0, sp, r2
    17e0:	00000002 	andeq	r0, r0, r2
    17e4:	00000004 	andeq	r0, r0, r4
    17e8:	107d0002 	rsbsne	r0, sp, r2
    17ec:	00000004 	andeq	r0, r0, r4
    17f0:	00000006 	andeq	r0, r0, r6
                    |DMA_CSR_BWC(3)
                    |DMA_CSR_DREQ_MASK
                    |DMA_CSR_INTMAJOR_MASK
                   );

    DMAMUX_CHCFG_REG(DMAMUX0_BASE_PTR, CHn) = (0                
    17f4:	1c7d0002 	ldclne	0, cr0, [sp], #-8
    17f8:	00000006 	andeq	r0, r0, r6
    17fc:	00000008 	andeq	r0, r0, r8
    1800:	c07d0003 	rsbsgt	r0, sp, r3
    1804:	00000800 	andeq	r0, r0, r0, lsl #16
    1808:	00035600 	andeq	r5, r3, r0, lsl #12
    180c:	77000300 	strvc	r0, [r0, -r0, lsl #6]
    |DMAMUX_CHCFG_ENBL_MASK
    |DMAMUX_CHCFG_SOURCE(dma_req));
    DMA_DIS(CHn);
    1810:	000000c0 	andeq	r0, r0, r0, asr #1
    1814:	00000000 	andeq	r0, r0, r0
    1818:	03580000 	cmpeq	r8, #0
    181c:	035a0000 	cmpeq	sl, #0
    1820:	00020000 	andeq	r0, r2, r0
    1824:	035a007d 	cmpeq	sl, #125	; 0x7d
    1828:	035c0000 	cmpeq	ip, #0
    182c:	00020000 	andeq	r0, r2, r0
    1830:	035c087d 	cmpeq	ip, #8192000	; 0x7d0000
    DMA_IRQ_CLEAN(CHn);
    1834:	03d80000 	bicseq	r0, r8, #0
    1838:	00020000 	andeq	r0, r2, r0
    183c:	00000877 	andeq	r0, r0, r7, ror r8
    1840:	00000000 	andeq	r0, r0, r0
    1844:	03d80000 	bicseq	r0, r8, #0
    1848:	03da0000 	bicseq	r0, sl, #0
    184c:	00020000 	andeq	r0, r2, r0
    1850:	03da007d 	bicseq	r0, sl, #125	; 0x7d
}
    1854:	03dc0000 	bicseq	r0, ip, #0
    1858:	00020000 	andeq	r0, r2, r0


//提取中线
void get_midline(uint8 *img, uint8 h, uint8 w)
{
    185c:	03dc0c7d 	bicseq	r0, ip, #32000	; 0x7d00
    1860:	03de0000 	bicseq	r0, lr, #0
    1864:	00020000 	andeq	r0, r2, r0
    1868:	03de307d 	bicseq	r3, lr, #125	; 0x7d
    int16 p = 0, i = 0, line_mid = 39;
    186c:	05360000 	ldreq	r0, [r6, #-0]!
    1870:	00020000 	andeq	r0, r2, r0
    1874:	00003077 	andeq	r3, r0, r7, ror r0
    1878:	00000000 	andeq	r0, r0, r0
    187c:	05380000 	ldreq	r0, [r8, #-0]!
    int8 side_left = 0, side_right = 79;
    1880:	053a0000 	ldreq	r0, [sl, #-0]!
    1884:	00020000 	andeq	r0, r2, r0
    1888:	053a007d 	ldreq	r0, [sl, #-125]!	; 0x7d

    if (img[(h-1)*w + line_mid] == 0xff)
    188c:	053c0000 	ldreq	r0, [ip, #-0]!
    1890:	00020000 	andeq	r0, r2, r0
    1894:	053c087d 	ldreq	r0, [ip, #-2173]!	; 0x87d
    1898:	053e0000 	ldreq	r0, [lr, #-0]!
    189c:	00020000 	andeq	r0, r2, r0
    18a0:	053e287d 	ldreq	r2, [lr, #-2173]!	; 0x87d
    18a4:	06480000 	strbeq	r0, [r8], -r0
    {
        for (i = h - 1; i >= 0; i --)
    18a8:	00020000 	andeq	r0, r2, r0
    18ac:	00002877 	andeq	r2, r0, r7, ror r8
    18b0:	00000000 	andeq	r0, r0, r0
    18b4:	06480000 	strbeq	r0, [r8], -r0
        {
            for (p = line_mid - 1; p > 0; p --)
    18b8:	064a0000 	strbeq	r0, [sl], -r0
    18bc:	00020000 	andeq	r0, r2, r0
    18c0:	064a007d 			; <UNDEFINED> instruction: 0x064a007d
            {
                if (img[i * w + p] == 0)
    18c4:	064c0000 	strbeq	r0, [ip], -r0
    18c8:	00020000 	andeq	r0, r2, r0
    18cc:	064c087d 			; <UNDEFINED> instruction: 0x064c087d
    18d0:	07260000 	streq	r0, [r6, -r0]!
    18d4:	00020000 	andeq	r0, r2, r0
    18d8:	00000877 	andeq	r0, r0, r7, ror r8
	...
                    if ((img[i * w + p - 1] == 0) 
    18e4:	00020000 	andeq	r0, r2, r0
    18e8:	00020000 	andeq	r0, r2, r0
    18ec:	0002007d 	andeq	r0, r2, sp, ror r0
    18f0:	00040000 	andeq	r0, r4, r0
    18f4:	00020000 	andeq	r0, r2, r0
    18f8:	0004107d 	andeq	r1, r4, sp, ror r0
                            && (line_mid-p-1>= 0))
    18fc:	00060000 	andeq	r0, r6, r0
    1900:	00020000 	andeq	r0, r2, r0
    1904:	0006147d 	andeq	r1, r6, sp, ror r4
    1908:	00080000 	andeq	r0, r8, r0
                    {
                        side_left = p;
    190c:	00020000 	andeq	r0, r2, r0
                        p = p - 2;
    1910:	0008287d 	andeq	r2, r8, sp, ror r8
    1914:	016e0000 	cmneq	lr, r0
    1918:	00020000 	andeq	r0, r2, r0
                        for (; p >= 0; p --)
                            img[i * w + p] = 0;
    191c:	00002877 	andeq	r2, r0, r7, ror r8
    1920:	00000000 	andeq	r0, r0, r0
    1924:	01700000 	cmneq	r0, r0
    1928:	01720000 	cmneq	r2, r0
    192c:	00020000 	andeq	r0, r2, r0
    1930:	0172007d 	cmneq	r2, sp, ror r0
    1934:	01740000 	cmneq	r4, r0
                    if ((img[i * w + p - 1] == 0) 
                            && (line_mid-p-1>= 0))
                    {
                        side_left = p;
                        p = p - 2;
                        for (; p >= 0; p --)
    1938:	00020000 	andeq	r0, r2, r0
    193c:	0174107d 	cmneq	r4, sp, ror r0
    1940:	01760000 	cmneq	r6, r0
    1944:	00020000 	andeq	r0, r2, r0

    if (img[(h-1)*w + line_mid] == 0xff)
    {
        for (i = h - 1; i >= 0; i --)
        {
            for (p = line_mid - 1; p > 0; p --)
    1948:	0176187d 	cmneq	r6, sp, ror r8
    194c:	01780000 	cmneq	r8, r0
    1950:	00020000 	andeq	r0, r2, r0
    1954:	0178207d 	cmneq	r8, sp, ror r0
                        p = p - 2;
                        for (; p >= 0; p --)
                            img[i * w + p] = 0;
                    }
            }
            for (p = line_mid + 1; p < w -1; p ++)
    1958:	01b80000 			; <UNDEFINED> instruction: 0x01b80000
    195c:	00020000 	andeq	r0, r2, r0
    1960:	00002077 	andeq	r2, r0, r7, ror r0
            {
                if (img[i * w + p] == 0)
    1964:	00000000 	andeq	r0, r0, r0
    1968:	01b80000 			; <UNDEFINED> instruction: 0x01b80000
    196c:	01ba0000 			; <UNDEFINED> instruction: 0x01ba0000
    1970:	00020000 	andeq	r0, r2, r0
    1974:	01ba007d 			; <UNDEFINED> instruction: 0x01ba007d
    1978:	01bc0000 			; <UNDEFINED> instruction: 0x01bc0000
                {
                    if ((img[i * w + p + 1] == 0)&&(p+1<w))
    197c:	00020000 	andeq	r0, r2, r0
    1980:	01bc107d 			; <UNDEFINED> instruction: 0x01bc107d
    1984:	01be0000 			; <UNDEFINED> instruction: 0x01be0000
    1988:	00020000 	andeq	r0, r2, r0
    198c:	01be187d 			; <UNDEFINED> instruction: 0x01be187d
    1990:	01c00000 	biceq	r0, r0, r0
    1994:	00020000 	andeq	r0, r2, r0
    1998:	01c0207d 	biceq	r2, r0, sp, ror r0
    199c:	01e60000 	mvneq	r0, r0
    19a0:	00020000 	andeq	r0, r2, r0
    19a4:	00002077 	andeq	r2, r0, r7, ror r0
                    {
                        side_right = p;
    19a8:	00000000 	andeq	r0, r0, r0
                        p = p + 2;
    19ac:	01e80000 	mvneq	r0, r0
    19b0:	01ea0000 	mvneq	r0, r0
    19b4:	00020000 	andeq	r0, r2, r0
                        for (; p < w; p ++)
                            img[i * w + p] = 0;
    19b8:	01ea007d 	mvneq	r0, sp, ror r0
    19bc:	01ec0000 	mvneq	r0, r0
    19c0:	00020000 	andeq	r0, r2, r0
    19c4:	01ec107d 	mvneq	r1, sp, ror r0
    19c8:	01ee0000 	mvneq	r0, r0
    19cc:	00020000 	andeq	r0, r2, r0
    19d0:	01ee187d 	mvneq	r1, sp, ror r8
                {
                    if ((img[i * w + p + 1] == 0)&&(p+1<w))
                    {
                        side_right = p;
                        p = p + 2;
                        for (; p < w; p ++)
    19d4:	01f00000 	mvnseq	r0, r0
    19d8:	00020000 	andeq	r0, r2, r0
    19dc:	01f0207d 	mvnseq	r2, sp, ror r0
    19e0:	02160000 	andseq	r0, r6, #0
                        p = p - 2;
                        for (; p >= 0; p --)
                            img[i * w + p] = 0;
                    }
            }
            for (p = line_mid + 1; p < w -1; p ++)
    19e4:	00020000 	andeq	r0, r2, r0
    19e8:	00002077 	andeq	r2, r0, r7, ror r0
    19ec:	00000000 	andeq	r0, r0, r0
    19f0:	02180000 	andseq	r0, r8, #0
    19f4:	021a0000 	andseq	r0, sl, #0
    19f8:	00020000 	andeq	r0, r2, r0
                        for (; p < w; p ++)
                            img[i * w + p] = 0;
                    }
                }
            }
            line_mid = (side_left + side_right) / 2;
    19fc:	021a007d 	andseq	r0, sl, #125	; 0x7d
    1a00:	021c0000 	andseq	r0, ip, #0
    1a04:	00020000 	andeq	r0, r2, r0
    1a08:	021c047d 	andseq	r0, ip, #2097152000	; 0x7d000000
    1a0c:	021e0000 	andseq	r0, lr, #0
            img[i * w + line_mid] = 0;
    1a10:	00020000 	andeq	r0, r2, r0
    1a14:	021e107d 	andseq	r1, lr, #125	; 0x7d
    1a18:	03300000 	teqeq	r0, #0
    1a1c:	00020000 	andeq	r0, r2, r0
    1a20:	00001077 	andeq	r1, r0, r7, ror r0
    1a24:	00000000 	andeq	r0, r0, r0
    1a28:	03300000 	teqeq	r0, #0
    int16 p = 0, i = 0, line_mid = 39;
    int8 side_left = 0, side_right = 79;

    if (img[(h-1)*w + line_mid] == 0xff)
    {
        for (i = h - 1; i >= 0; i --)
    1a2c:	03320000 	teqeq	r2, #0
    1a30:	00020000 	andeq	r0, r2, r0
    1a34:	0332007d 	teqeq	r2, #125	; 0x7d
    1a38:	03340000 	teqeq	r4, #0
            }
            line_mid = (side_left + side_right) / 2;
            img[i * w + line_mid] = 0;
        }
    }
}
    1a3c:	00020000 	andeq	r0, r2, r0
    1a40:	0334047d 	teqeq	r4, #2097152000	; 0x7d000000
    1a44:	03360000 	teqeq	r6, #0
  ptb.GPIO_PinControl = NULL;
  LPLD_GPIO_Init(ptb);
}*/

void LPLD_SCCB_Init(void)
{
    1a48:	00020000 	andeq	r0, r2, r0
    1a4c:	0336187d 	teqeq	r6, #8192000	; 0x7d0000
  GPIO_InitTypeDef ptb;
  /********û޸ֵ ʼ***********/
  ptb.GPIO_PTx = PTA;
    1a50:	04160000 	ldreq	r0, [r6], #-0
    1a54:	00020000 	andeq	r0, r2, r0
  ptb.GPIO_Pins = GPIO_Pin25 | GPIO_Pin26;
    1a58:	00001877 	andeq	r1, r0, r7, ror r8
    1a5c:	00000000 	andeq	r0, r0, r0
  /********û޸ֵ ***********/
  ptb.GPIO_Dir = DIR_OUTPUT;
    1a60:	04180000 	ldreq	r0, [r8], #-0
  ptb.GPIO_Output = OUTPUT_H;
    1a64:	041a0000 	ldreq	r0, [sl], #-0
    1a68:	00020000 	andeq	r0, r2, r0
  ptb.GPIO_PinControl = INPUT_PULL_UP;
    1a6c:	041a007d 	ldreq	r0, [sl], #-125	; 0x7d
  LPLD_GPIO_Init(ptb);
    1a70:	041c0000 	ldreq	r0, [ip], #-0
    1a74:	00020000 	andeq	r0, r2, r0
    1a78:	041c047d 	ldreq	r0, [ip], #-1149	; 0x47d
    1a7c:	041e0000 	ldreq	r0, [lr], #-0
}
    1a80:	00020000 	andeq	r0, r2, r0
    1a84:	041e107d 	ldreq	r1, [lr], #-125	; 0x7d
 * :
 *    1-ɹ
 *    0-ʧ
 */
uint8 LPLD_SCCB_WriteReg(uint16 reg_addr , uint8 data)
{		
    1a88:	048c0000 	streq	r0, [ip], #0
    1a8c:	00020000 	andeq	r0, r2, r0
    1a90:	00001077 	andeq	r1, r0, r7, ror r0
    1a94:	00000000 	andeq	r0, r0, r0
  if(!LPLD_SCCB_Start())
    1a98:	048c0000 	streq	r0, [ip], #0
    1a9c:	048e0000 	streq	r0, [lr], #0
  {
    return 0;
    1aa0:	00020000 	andeq	r0, r2, r0
    1aa4:	048e007d 	streq	r0, [lr], #125	; 0x7d
  }
  LPLD_SCCB_SendByte(SCCB_DEV_ADR ); 
    1aa8:	04900000 	ldreq	r0, [r0], #0
    1aac:	00020000 	andeq	r0, r2, r0
  if(!LPLD_SCCB_WaitAck())
    1ab0:	0490087d 	ldreq	r0, [r0], #2173	; 0x87d
    1ab4:	04ba0000 	ldrteq	r0, [sl], #0
  {
    LPLD_SCCB_Stop(); 
    1ab8:	00020000 	andeq	r0, r2, r0
    return 0;
    1abc:	00000877 	andeq	r0, r0, r7, ror r8
    1ac0:	00000000 	andeq	r0, r0, r0
  }
  LPLD_SCCB_SendByte((uint8)(reg_addr & 0x00FF));   
    1ac4:	04bc0000 	ldrteq	r0, [ip], #0
    1ac8:	04be0000 	ldrteq	r0, [lr], #0
  LPLD_SCCB_WaitAck();	
    1acc:	00020000 	andeq	r0, r2, r0
  LPLD_SCCB_SendByte(data);
    1ad0:	04be007d 	ldrteq	r0, [lr], #125	; 0x7d
    1ad4:	04c00000 	strbeq	r0, [r0], #0
  LPLD_SCCB_WaitAck();   
    1ad8:	00020000 	andeq	r0, r2, r0
  LPLD_SCCB_Stop(); 
    1adc:	04c0087d 	strbeq	r0, [r0], #2173	; 0x87d
  return 1;
    1ae0:	04ea0000 	strbteq	r0, [sl], #0
}									 
    1ae4:	00020000 	andeq	r0, r2, r0
    1ae8:	00000877 	andeq	r0, r0, r7, ror r8
    1aec:	00000000 	andeq	r0, r0, r0
 * :
 *    1-ɹ
 *    0-ʧ
 */          
uint8 LPLD_SCCB_ReadReg(uint8 reg_addr, uint8* data, uint16 length)
{	
    1af0:	04ec0000 	strbteq	r0, [ip], #0
    1af4:	04ee0000 	strbteq	r0, [lr], #0
    1af8:	00020000 	andeq	r0, r2, r0
    1afc:	04ee007d 	strbteq	r0, [lr], #125	; 0x7d
  if(!LPLD_SCCB_Start())
    1b00:	04f00000 	ldrbteq	r0, [r0], #0
    1b04:	00020000 	andeq	r0, r2, r0
    1b08:	04f0087d 	ldrbteq	r0, [r0], #2173	; 0x87d
  {
    return 0;
    1b0c:	051a0000 	ldreq	r0, [sl, #-0]
  }
  LPLD_SCCB_SendByte( SCCB_DEV_ADR ); 
    1b10:	00020000 	andeq	r0, r2, r0
    1b14:	00000877 	andeq	r0, r0, r7, ror r8
  if( !LPLD_SCCB_WaitAck() )
    1b18:	00000000 	andeq	r0, r0, r0
    1b1c:	051c0000 	ldreq	r0, [ip, #-0]
    1b20:	051e0000 	ldreq	r0, [lr, #-0]
  {
    LPLD_SCCB_Stop(); 
    1b24:	00020000 	andeq	r0, r2, r0
    return 0;
    1b28:	051e007d 	ldreq	r0, [lr, #-125]	; 0x7d
  }
  LPLD_SCCB_SendByte( reg_addr ); 
    1b2c:	05200000 	streq	r0, [r0, #-0]!
    1b30:	00020000 	andeq	r0, r2, r0
  LPLD_SCCB_WaitAck();	
    1b34:	0520087d 	streq	r0, [r0, #-2173]!	; 0x87d
  LPLD_SCCB_Stop(); 
    1b38:	054a0000 	strbeq	r0, [sl, #-0]
  
  if(!LPLD_SCCB_Start())
    1b3c:	00020000 	andeq	r0, r2, r0
    1b40:	00000877 	andeq	r0, r0, r7, ror r8
	...
  {
    return 0;
  }
  LPLD_SCCB_SendByte( SCCB_DEV_ADR + 1 );
    1b4c:	00020000 	andeq	r0, r2, r0
    1b50:	00020000 	andeq	r0, r2, r0
  
  if(!LPLD_SCCB_WaitAck())
    1b54:	0002007d 	andeq	r0, r2, sp, ror r0
    1b58:	00040000 	andeq	r0, r4, r0
    1b5c:	00020000 	andeq	r0, r2, r0
  {
    LPLD_SCCB_Stop(); 
    1b60:	0004107d 	andeq	r1, r4, sp, ror r0
    return 0;
    1b64:	00060000 	andeq	r0, r6, r0
  }
  while(length)
  {
    *data = LPLD_SCCB_ReceiveByte();
    1b68:	00020000 	andeq	r0, r2, r0
    1b6c:	0006147d 	andeq	r1, r6, sp, ror r4
    1b70:	00080000 	andeq	r0, r8, r0
    if(length == 1)
    1b74:	00030000 	andeq	r0, r3, r0
    1b78:	0800d07d 	stmdaeq	r0, {r0, r2, r3, r4, r5, r6, ip, lr, pc}
    {
      LPLD_SCCB_NoAck();
    1b7c:	aa000000 	bge	1b84 <LPLD_SCCB_ReadReg+0x94>
    }
    else
    {
      LPLD_SCCB_Ack(); 
    1b80:	03000007 	movweq	r0, #7
    }
    data++;
    1b84:	00d07700 	sbcseq	r7, r0, r0, lsl #14
	...
    length--;
    1b90:	000007ac 	andeq	r0, r0, ip, lsr #15
  if(!LPLD_SCCB_WaitAck())
  {
    LPLD_SCCB_Stop(); 
    return 0;
  }
  while(length)
    1b94:	000007ae 	andeq	r0, r0, lr, lsr #15
    1b98:	007d0002 	rsbseq	r0, sp, r2
      LPLD_SCCB_Ack(); 
    }
    data++;
    length--;
  }
  LPLD_SCCB_Stop();
    1b9c:	000007ae 	andeq	r0, r0, lr, lsr #15
  return 1;
    1ba0:	000007b0 			; <UNDEFINED> instruction: 0x000007b0
}
    1ba4:	107d0002 	rsbsne	r0, sp, r2
    1ba8:	000007b0 			; <UNDEFINED> instruction: 0x000007b0
/*
 * LPLD_SCCB_Start
 * SCCBʼźţڲ
 */
uint8 LPLD_SCCB_Start(void)
{
    1bac:	000007b2 			; <UNDEFINED> instruction: 0x000007b2
  SCCB_SDA_O=1;//ߵƽ
    1bb0:	187d0002 	ldmdane	sp!, {r1}^
    1bb4:	000007b2 			; <UNDEFINED> instruction: 0x000007b2
    1bb8:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
    1bbc:	207d0002 	rsbscs	r0, sp, r2
  SCCB_SCL=1;   //ʱߵƽ 
    1bc0:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
    1bc4:	000008a6 	andeq	r0, r0, r6, lsr #17
    1bc8:	20770002 	rsbscs	r0, r7, r2
	...
  SCCB_DELAY();
  
  SCCB_SDA_IN();//Ϊ
    1bd4:	000008a8 	andeq	r0, r0, r8, lsr #17
    1bd8:	000008aa 	andeq	r0, r0, sl, lsr #17
    1bdc:	007d0002 	rsbseq	r0, sp, r2
    1be0:	000008aa 	andeq	r0, r0, sl, lsr #17
  if(!SCCB_SDA_I)
    1be4:	000008ac 	andeq	r0, r0, ip, lsr #17
    1be8:	107d0002 	rsbsne	r0, sp, r2
    1bec:	000008ac 	andeq	r0, r0, ip, lsr #17
  {
    SCCB_SDA_OUT();	
    1bf0:	000008ae 	andeq	r0, r0, lr, lsr #17
    1bf4:	187d0002 	ldmdane	sp!, {r1}^
    1bf8:	000008ae 	andeq	r0, r0, lr, lsr #17
    1bfc:	000008b0 			; <UNDEFINED> instruction: 0x000008b0
    return 0;
    1c00:	207d0002 	rsbscs	r0, sp, r2
  }
  SCCB_SDA_OUT();//Ϊ;	
    1c04:	000008b0 			; <UNDEFINED> instruction: 0x000008b0
    1c08:	0000091e 	andeq	r0, r0, lr, lsl r9
    1c0c:	20770002 	rsbscs	r0, r7, r2
	...
  SCCB_SDA_O=0; //͵ƽ
    1c18:	00000920 	andeq	r0, r0, r0, lsr #18
    1c1c:	00000922 	andeq	r0, r0, r2, lsr #18
  
  SCCB_DELAY();
    1c20:	007d0002 	rsbseq	r0, sp, r2
    1c24:	00000922 	andeq	r0, r0, r2, lsr #18
  
  SCCB_SDA_IN();//Ϊ
    1c28:	00000924 	andeq	r0, r0, r4, lsr #18
    1c2c:	107d0002 	rsbsne	r0, sp, r2
    1c30:	00000924 	andeq	r0, r0, r4, lsr #18
    1c34:	00000926 	andeq	r0, r0, r6, lsr #18
  if(SCCB_SDA_I) 
    1c38:	187d0002 	ldmdane	sp!, {r1}^
    1c3c:	00000926 	andeq	r0, r0, r6, lsr #18
    1c40:	00000928 	andeq	r0, r0, r8, lsr #18
  {
    SCCB_SDA_OUT();
    1c44:	207d0002 	rsbscs	r0, sp, r2
    1c48:	00000928 	andeq	r0, r0, r8, lsr #18
    1c4c:	00000996 	muleq	r0, r6, r9
    1c50:	20770002 	rsbscs	r0, r7, r2
	...
    return 0;
  }
  SCCB_SDA_OUT();//Ϊ
    1c5c:	00000998 	muleq	r0, r8, r9
    1c60:	0000099a 	muleq	r0, sl, r9
    1c64:	007d0002 	rsbseq	r0, sp, r2
  SCCB_SDA_O=0;//͵ƽ
    1c68:	0000099a 	muleq	r0, sl, r9
    1c6c:	0000099c 	muleq	r0, ip, r9
    1c70:	047d0002 	ldrbteq	r0, [sp], #-2
  return 1;
    1c74:	0000099c 	muleq	r0, ip, r9
}
    1c78:	0000099e 	muleq	r0, lr, r9
/*
 * LPLD_SCCB_Stop
 * SCCBֹͣźţڲ
 */
static void LPLD_SCCB_Stop(void)
{
    1c7c:	187d0002 	ldmdane	sp!, {r1}^
  SCCB_SCL=0;
    1c80:	0000099e 	muleq	r0, lr, r9
    1c84:	00000a04 	andeq	r0, r0, r4, lsl #20
    1c88:	18770002 	ldmdane	r7!, {r1}^
	...
  SCCB_SDA_O=0;
    1c94:	00000a04 	andeq	r0, r0, r4, lsl #20
    1c98:	00000a06 	andeq	r0, r0, r6, lsl #20
  SCCB_DELAY();
    1c9c:	007d0002 	rsbseq	r0, sp, r2
    1ca0:	00000a06 	andeq	r0, r0, r6, lsl #20
  
  SCCB_SCL=1;
    1ca4:	00000a08 	andeq	r0, r0, r8, lsl #20
    1ca8:	047d0002 	ldrbteq	r0, [sp], #-2
    1cac:	00000a08 	andeq	r0, r0, r8, lsl #20
    1cb0:	00000a0a 	andeq	r0, r0, sl, lsl #20
  SCCB_SDA_O=1;
    1cb4:	187d0002 	ldmdane	sp!, {r1}^
    1cb8:	00000a0a 	andeq	r0, r0, sl, lsl #20
    1cbc:	00000a3a 	andeq	r0, r0, sl, lsr sl
  SCCB_DELAY();
    1cc0:	18770002 	ldmdane	r7!, {r1}^
	...
/*
 * LPLD_SCCB_Stop
 * SCCBӦźţڲ
 */
static void LPLD_SCCB_Ack(void)
{	
    1ccc:	00000a3c 	andeq	r0, r0, ip, lsr sl
  SCCB_SCL=0;
    1cd0:	00000a3e 	andeq	r0, r0, lr, lsr sl
    1cd4:	007d0002 	rsbseq	r0, sp, r2
    1cd8:	00000a3e 	andeq	r0, r0, lr, lsr sl
    1cdc:	00000a40 	andeq	r0, r0, r0, asr #20
  SCCB_DELAY();
    1ce0:	047d0002 	ldrbteq	r0, [sp], #-2
    1ce4:	00000a40 	andeq	r0, r0, r0, asr #20
  
  SCCB_SDA_O=0;
    1ce8:	00000a42 	andeq	r0, r0, r2, asr #20
    1cec:	107d0002 	rsbsne	r0, sp, r2
    1cf0:	00000a42 	andeq	r0, r0, r2, asr #20
  SCCB_DELAY();
    1cf4:	00000a84 	andeq	r0, r0, r4, lsl #21
    1cf8:	10770002 	rsbsne	r0, r7, r2
	...
  
  SCCB_SCL=1;
    1d04:	00000a84 	andeq	r0, r0, r4, lsl #21
    1d08:	00000a86 	andeq	r0, r0, r6, lsl #21
  SCCB_DELAY();
    1d0c:	007d0002 	rsbseq	r0, sp, r2
    1d10:	00000a86 	andeq	r0, r0, r6, lsl #21
  
  SCCB_SCL=0;
    1d14:	00000a88 	andeq	r0, r0, r8, lsl #21
    1d18:	087d0002 	ldmdaeq	sp!, {r1}^
    1d1c:	00000a88 	andeq	r0, r0, r8, lsl #21
  SCCB_DELAY();
    1d20:	00000bd4 	ldrdeq	r0, [r0], -r4
    1d24:	08770002 	ldmdaeq	r7!, {r1}^
	...
 * LPLD_SCCB_NoAck
 * SCCBӦźţڲ
 */
static void LPLD_SCCB_NoAck(void)
{	
  SCCB_SCL=0;
    1d30:	00000bd4 	ldrdeq	r0, [r0], -r4
    1d34:	00000bd6 	ldrdeq	r0, [r0], -r6
    1d38:	007d0002 	rsbseq	r0, sp, r2
    1d3c:	00000bd6 	ldrdeq	r0, [r0], -r6
  SCCB_DELAY();
    1d40:	00000bd8 	ldrdeq	r0, [r0], -r8
    1d44:	087d0002 	ldmdaeq	sp!, {r1}^
  SCCB_SDA_O=1;
    1d48:	00000bd8 	ldrdeq	r0, [r0], -r8
    1d4c:	00000d24 	andeq	r0, r0, r4, lsr #26
    1d50:	08770002 	ldmdaeq	r7!, {r1}^
	...
  SCCB_DELAY();
  SCCB_SCL=1;
    1d5c:	00000d24 	andeq	r0, r0, r4, lsr #26
    1d60:	00000d26 	andeq	r0, r0, r6, lsr #26
    1d64:	007d0002 	rsbseq	r0, sp, r2
    1d68:	00000d26 	andeq	r0, r0, r6, lsr #26
  SCCB_DELAY();
    1d6c:	00000d28 	andeq	r0, r0, r8, lsr #26
    1d70:	087d0002 	ldmdaeq	sp!, {r1}^
  SCCB_SCL=0;
    1d74:	00000d28 	andeq	r0, r0, r8, lsr #26
    1d78:	00000e74 	andeq	r0, r0, r4, ror lr
    1d7c:	08770002 	ldmdaeq	r7!, {r1}^
	...
/*
 * LPLD_SCCB_WaitAck
 * SCCBȴӦźţڲ
 */
static uint8 LPLD_SCCB_WaitAck(void) 	
{
    1d8c:	00000002 	andeq	r0, r0, r2
  SCCB_SCL=0;//ʱߵ͵ƽ
    1d90:	007d0002 	rsbseq	r0, sp, r2
    1d94:	00000002 	andeq	r0, r0, r2
    1d98:	00000004 	andeq	r0, r0, r4
    1d9c:	107d0002 	rsbsne	r0, sp, r2
  SCCB_DELAY(); 
    1da0:	00000004 	andeq	r0, r0, r4
    1da4:	00000006 	andeq	r0, r0, r6
  
 SCCB_SDA_IN();//Ϊ**
    1da8:	187d0002 	ldmdane	sp!, {r1}^
    1dac:	00000006 	andeq	r0, r0, r6
    1db0:	00000008 	andeq	r0, r0, r8
  SCCB_DELAY();
    1db4:	387d0002 	ldmdacc	sp!, {r1}^
    1db8:	00000008 	andeq	r0, r0, r8
  
  SCCB_SCL=1;//ʱ߸ߵƽ
    1dbc:	000004da 	ldrdeq	r0, [r0], -sl
    1dc0:	38770002 	ldmdacc	r7!, {r1}^
	...
  
  SCCB_DELAY();
    1dcc:	000004dc 	ldrdeq	r0, [r0], -ip
    1dd0:	000004de 	ldrdeq	r0, [r0], -lr
  
  if(SCCB_SDA_I)
    1dd4:	007d0002 	rsbseq	r0, sp, r2
    1dd8:	000004de 	ldrdeq	r0, [r0], -lr
    1ddc:	000004e0 	andeq	r0, r0, r0, ror #9
  {
    SCCB_SDA_OUT();
    1de0:	047d0002 	ldrbteq	r0, [sp], #-2
    1de4:	000004e0 	andeq	r0, r0, r0, ror #9
    1de8:	000004e2 	andeq	r0, r0, r2, ror #9
    1dec:	107d0002 	rsbsne	r0, sp, r2
    SCCB_SCL=0;
    1df0:	000004e2 	andeq	r0, r0, r2, ror #9
    1df4:	0000050a 	andeq	r0, r0, sl, lsl #10
    1df8:	10770002 	rsbsne	r0, r7, r2
	...
    return 0;
  }
  SCCB_SDA_OUT();//Ϊ
    1e04:	0000050c 	andeq	r0, r0, ip, lsl #10
    1e08:	0000050e 	andeq	r0, r0, lr, lsl #10
    1e0c:	007d0002 	rsbseq	r0, sp, r2
  SCCB_SCL=0; //ʱߵ͵ƽ
    1e10:	0000050e 	andeq	r0, r0, lr, lsl #10
    1e14:	00000510 	andeq	r0, r0, r0, lsl r5
    1e18:	047d0002 	ldrbteq	r0, [sp], #-2
    1e1c:	00000510 	andeq	r0, r0, r0, lsl r5
  return 1;
    1e20:	00000512 	andeq	r0, r0, r2, lsl r5
}
    1e24:	107d0002 	rsbsne	r0, sp, r2
/*
 * LPLD_SCCB_SendByte
 * SCCBݣڲ
 */
static void LPLD_SCCB_SendByte(uint8 data) 
{
    1e28:	00000512 	andeq	r0, r0, r2, lsl r5
    1e2c:	0000052a 	andeq	r0, r0, sl, lsr #10
    1e30:	10770002 	rsbsne	r0, r7, r2
	...
  uint8 i=8;
  while(i--)
  {
    SCCB_SCL=0;
    1e3c:	0000052c 	andeq	r0, r0, ip, lsr #10
    1e40:	0000052e 	andeq	r0, r0, lr, lsr #10
    1e44:	007d0002 	rsbseq	r0, sp, r2
    SCCB_DELAY();
    1e48:	0000052e 	andeq	r0, r0, lr, lsr #10
    1e4c:	00000530 	andeq	r0, r0, r0, lsr r5
    if(data&0x80)
    1e50:	047d0002 	ldrbteq	r0, [sp], #-2
    1e54:	00000530 	andeq	r0, r0, r0, lsr r5
    {
      SCCB_SDA_O=1; 
    1e58:	00000532 	andeq	r0, r0, r2, lsr r5
    1e5c:	107d0002 	rsbsne	r0, sp, r2
    1e60:	00000532 	andeq	r0, r0, r2, lsr r5
    1e64:	00000558 	andeq	r0, r0, r8, asr r5
    }
    else 
    {
      SCCB_SDA_O=0;   
    1e68:	10770002 	rsbsne	r0, r7, r2
	...
    1e74:	00000558 	andeq	r0, r0, r8, asr r5
    }
    data<<=1;
    1e78:	0000055a 	andeq	r0, r0, sl, asr r5
    1e7c:	007d0002 	rsbseq	r0, sp, r2
    SCCB_DELAY();
    1e80:	0000055a 	andeq	r0, r0, sl, asr r5
    1e84:	0000055c 	andeq	r0, r0, ip, asr r5
    SCCB_SCL=1;
    1e88:	087d0002 	ldmdaeq	sp!, {r1}^
    1e8c:	0000055c 	andeq	r0, r0, ip, asr r5
    1e90:	0000055e 	andeq	r0, r0, lr, asr r5
    SCCB_DELAY();
    1e94:	187d0002 	ldmdane	sp!, {r1}^
    1e98:	0000055e 	andeq	r0, r0, lr, asr r5
 * SCCBݣڲ
 */
static void LPLD_SCCB_SendByte(uint8 data) 
{
  uint8 i=8;
  while(i--)
    1e9c:	0000059e 	muleq	r0, lr, r5
    1ea0:	18770002 	ldmdane	r7!, {r1}^
	...
    1eac:	000005a0 	andeq	r0, r0, r0, lsr #11
    1eb0:	000005a2 	andeq	r0, r0, r2, lsr #11
    data<<=1;
    SCCB_DELAY();
    SCCB_SCL=1;
    SCCB_DELAY();
  }
  SCCB_SCL=0;
    1eb4:	007d0002 	rsbseq	r0, sp, r2
    1eb8:	000005a2 	andeq	r0, r0, r2, lsr #11
    1ebc:	000005a4 	andeq	r0, r0, r4, lsr #11
    1ec0:	107d0002 	rsbsne	r0, sp, r2
}
    1ec4:	000005a4 	andeq	r0, r0, r4, lsr #11
    1ec8:	000005a6 	andeq	r0, r0, r6, lsr #11
/*
 * LPLD_SCCB_SendByte
 * SCCBݣڲ
 */
static uint8 LPLD_SCCB_ReceiveByte(void)  
{ 
    1ecc:	187d0002 	ldmdane	sp!, {r1}^
    1ed0:	000005a6 	andeq	r0, r0, r6, lsr #11
  uint8 i=8;
    1ed4:	00000646 	andeq	r0, r0, r6, asr #12
  uint8 ReceiveByte=0;
    1ed8:	18770002 	ldmdane	r7!, {r1}^
	...
  
  SCCB_SDA_O=1;	
    1ee4:	00000648 	andeq	r0, r0, r8, asr #12
    1ee8:	0000064a 	andeq	r0, r0, sl, asr #12
  SCCB_DELAY();
    1eec:	007d0002 	rsbseq	r0, sp, r2
    1ef0:	0000064a 	andeq	r0, r0, sl, asr #12
  
  SCCB_SDA_IN();	
    1ef4:	0000064c 	andeq	r0, r0, ip, asr #12
    1ef8:	107d0002 	rsbsne	r0, sp, r2
    1efc:	0000064c 	andeq	r0, r0, ip, asr #12
    1f00:	0000064e 	andeq	r0, r0, lr, asr #12
  
  while(i--)
  {
    ReceiveByte<<=1;      
    1f04:	187d0002 	ldmdane	sp!, {r1}^
    1f08:	0000064e 	andeq	r0, r0, lr, asr #12
    SCCB_SCL=0;
    1f0c:	000006ee 	andeq	r0, r0, lr, ror #13
    1f10:	18770002 	ldmdane	r7!, {r1}^
	...
    SCCB_DELAY();
    1f1c:	000006f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    1f20:	000006f2 	strdeq	r0, [r0], -r2
    
    SCCB_SCL=1;
    1f24:	007d0002 	rsbseq	r0, sp, r2
    1f28:	000006f2 	strdeq	r0, [r0], -r2
    1f2c:	000006f4 	strdeq	r0, [r0], -r4
    SCCB_DELAY();	
    1f30:	087d0002 	ldmdaeq	sp!, {r1}^
    1f34:	000006f4 	strdeq	r0, [r0], -r4
    
    if(SCCB_SDA_I)
    1f38:	0000075e 	andeq	r0, r0, lr, asr r7
    1f3c:	08770002 	ldmdaeq	r7!, {r1}^
	...
    {
      ReceiveByte|=0x01;
    1f48:	00000760 	andeq	r0, r0, r0, ror #14
    1f4c:	00000762 	andeq	r0, r0, r2, ror #14
  SCCB_SDA_O=1;	
  SCCB_DELAY();
  
  SCCB_SDA_IN();	
  
  while(i--)
    1f50:	007d0002 	rsbseq	r0, sp, r2
    1f54:	00000762 	andeq	r0, r0, r2, ror #14
    1f58:	00000764 	andeq	r0, r0, r4, ror #14
    1f5c:	087d0002 	ldmdaeq	sp!, {r1}^
    1f60:	00000764 	andeq	r0, r0, r4, ror #14
    1f64:	000007ce 	andeq	r0, r0, lr, asr #15
    {
      ReceiveByte|=0x01;
    }
    
  }
  SCCB_SDA_OUT();
    1f68:	08770002 	ldmdaeq	r7!, {r1}^
	...
  SCCB_SCL=0;
    1f74:	000007d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    1f78:	000007d2 	ldrdeq	r0, [r0], -r2
    1f7c:	007d0002 	rsbseq	r0, sp, r2
    1f80:	000007d2 	ldrdeq	r0, [r0], -r2
  
  return ReceiveByte;
}
    1f84:	000007d4 	ldrdeq	r0, [r0], -r4
    1f88:	087d0002 	ldmdaeq	sp!, {r1}^
    1f8c:	000007d4 	ldrdeq	r0, [r0], -r4
/*
 * LPLD_SCCB_SendByte
 * SCCBʱڲ
 */
static void LPLD_SCCB_Delay(uint16 i)
{	
    1f90:	0000083e 	andeq	r0, r0, lr, lsr r8
    1f94:	08770002 	ldmdaeq	r7!, {r1}^
	...
  while(i) 
    i--; 
    1fa0:	00000840 	andeq	r0, r0, r0, asr #16
 * LPLD_SCCB_SendByte
 * SCCBʱڲ
 */
static void LPLD_SCCB_Delay(uint16 i)
{	
  while(i) 
    1fa4:	00000842 	andeq	r0, r0, r2, asr #16
    1fa8:	007d0002 	rsbseq	r0, sp, r2
    i--; 
}
    1fac:	00000842 	andeq	r0, r0, r2, asr #16
    1fb0:	00000844 	andeq	r0, r0, r4, asr #16
 * 输出:
 *    0--配置错误
 *    1--配置成功
 */
uint8 LPLD_ADC_Init(ADC_InitTypeDef adc_init_structure)
{
    1fb4:	087d0002 	ldmdaeq	sp!, {r1}^
    1fb8:	00000844 	andeq	r0, r0, r4, asr #16
    1fbc:	000008ae 	andeq	r0, r0, lr, lsr #17
    1fc0:	08770002 	ldmdaeq	r7!, {r1}^
	...
  uint8 i;
  ADC_MemMapPtr adcx = adc_init_structure.ADC_Adcx;
  uint8 diff = adc_init_structure.ADC_DiffMode;
    1fcc:	000008b0 			; <UNDEFINED> instruction: 0x000008b0
  uint8 mode = adc_init_structure.ADC_BitMode;
    1fd0:	000008b2 			; <UNDEFINED> instruction: 0x000008b2
  uint8 time = adc_init_structure.ADC_SampleTimeCfg;
    1fd4:	007d0002 	rsbseq	r0, sp, r2
    1fd8:	000008b2 			; <UNDEFINED> instruction: 0x000008b2
  uint8 ltime = adc_init_structure.ADC_LongSampleTimeSel;
    1fdc:	000008b4 			; <UNDEFINED> instruction: 0x000008b4
  uint8 avg = adc_init_structure.ADC_HwAvgSel;
    1fe0:	087d0002 	ldmdaeq	sp!, {r1}^
    1fe4:	000008b4 			; <UNDEFINED> instruction: 0x000008b4
  uint8 muxab = adc_init_structure.ADC_MuxSel;
    1fe8:	0000091e 	andeq	r0, r0, lr, lsl r9
  uint8 pga = adc_init_structure.ADC_PgaGain;
    1fec:	08770002 	ldmdaeq	r7!, {r1}^
	...
  uint8 hwtrg = adc_init_structure.ADC_HwTrgCfg;
  ADC_ISR_CALLBACK isr_func = adc_init_structure.ADC_Isr;
    1ff8:	00000920 	andeq	r0, r0, r0, lsr #18
 
  //配置ADC时钟 //这里貌似只配置了两个还要另行配置其他的几个
  if(adcx == ADC0)
    1ffc:	00000922 	andeq	r0, r0, r2, lsr #18
    2000:	007d0002 	rsbseq	r0, sp, r2
    2004:	00000922 	andeq	r0, r0, r2, lsr #18
    2008:	00000924 	andeq	r0, r0, r4, lsr #18
  {
    i=0;
    200c:	087d0002 	ldmdaeq	sp!, {r1}^
    SIM_SCGC6 |= SIM_SCGC6_ADC0_MASK;   // 开启ADC0时钟
    2010:	00000924 	andeq	r0, r0, r4, lsr #18
    2014:	0000098e 	andeq	r0, r0, lr, lsl #19
    2018:	08770002 	ldmdaeq	r7!, {r1}^
	...
    2028:	00000002 	andeq	r0, r0, r2
    202c:	007d0002 	rsbseq	r0, sp, r2
    2030:	00000002 	andeq	r0, r0, r2
    2034:	00000004 	andeq	r0, r0, r4
    2038:	087d0002 	ldmdaeq	sp!, {r1}^
  }
  else if(adcx == ADC1)
    203c:	00000004 	andeq	r0, r0, r4
    2040:	00000016 	andeq	r0, r0, r6, lsl r0
    2044:	08770002 	ldmdaeq	r7!, {r1}^
	...
  {
    i=1;
    SIM_SCGC3 |= SIM_SCGC3_ADC1_MASK;   // 开启ADC1时钟
    2050:	00000018 	andeq	r0, r0, r8, lsl r0
    2054:	0000001a 	andeq	r0, r0, sl, lsl r0
    2058:	007d0002 	rsbseq	r0, sp, r2
    205c:	0000001a 	andeq	r0, r0, sl, lsl r0
    2060:	0000001c 	andeq	r0, r0, ip, lsl r0
    2064:	087d0002 	ldmdaeq	sp!, {r1}^
    2068:	0000001c 	andeq	r0, r0, ip, lsl r0
    206c:	0000001e 	andeq	r0, r0, lr, lsl r0
    2070:	107d0002 	rsbsne	r0, sp, r2
    2074:	0000001e 	andeq	r0, r0, lr, lsl r0
  }
  else 
  {
    return 0;
    2078:	0000003c 	andeq	r0, r0, ip, lsr r0
    207c:	10770002 	rsbsne	r0, r7, r2
	...
  }

  if(adc_init_structure.ADC_CalEnable == TRUE)
    LPLD_ADC_Cal(adcx);  //进行ADC校准
    2088:	0000003c 	andeq	r0, r0, ip, lsr r0
  
  //设置ADCCFG1寄存器
  adcx->CFG1  &=   (~ADC_CFG1_ADLPC_MASK);         // 重新为正常使用进行配置
    208c:	0000003e 	andeq	r0, r0, lr, lsr r0
    2090:	007d0002 	rsbseq	r0, sp, r2
    2094:	0000003e 	andeq	r0, r0, lr, lsr r0
  adcx->CFG1  |=    ADC_CFG1_ADIV(ADIV_1)          // ADC输入时钟分频为 1
    2098:	00000040 	andeq	r0, r0, r0, asr #32
                  | (time)                           // 设置长短时间采样模式
                  | ADC_CFG1_ADICLK(ADICLK_BUS_2)  // ADC输入时钟源为 BusClk
    209c:	087d0002 	ldmdaeq	sp!, {r1}^
    20a0:	00000040 	andeq	r0, r0, r0, asr #32
    20a4:	00000052 	andeq	r0, r0, r2, asr r0
                  | ADC_CFG1_MODE(mode);           //设置ADC转换精度
    20a8:	08770002 	ldmdaeq	r7!, {r1}^
	...

  //设置ADCCFG2寄存器
  adcx->CFG2 &=  (~ADC_CFG2_ADACKEN_MASK);   //禁用异步时钟输出
    20b8:	00000002 	andeq	r0, r0, r2
    20bc:	007d0002 	rsbseq	r0, sp, r2
    20c0:	00000002 	andeq	r0, r0, r2
  adcx->CFG2 |=    (muxab)                      // ADC复用选择
    20c4:	00000004 	andeq	r0, r0, r4
                 | (ADC_CFG2_ADHSC_MASK)        // 高速转换
                 | ADC_CFG2_ADLSTS(ltime);    // 长采样时间时钟周期选择
    20c8:	087d0002 	ldmdaeq	sp!, {r1}^
    20cc:	00000004 	andeq	r0, r0, r4
    20d0:	00000006 	andeq	r0, r0, r6
    20d4:	187d0002 	ldmdane	sp!, {r1}^
    20d8:	00000006 	andeq	r0, r0, r6
                  | ADC_CFG1_ADICLK(ADICLK_BUS_2)  // ADC输入时钟源为 BusClk
                  | ADC_CFG1_MODE(mode);           //设置ADC转换精度

  //设置ADCCFG2寄存器
  adcx->CFG2 &=  (~ADC_CFG2_ADACKEN_MASK);   //禁用异步时钟输出
  adcx->CFG2 |=    (muxab)                      // ADC复用选择
    20dc:	00000058 	andeq	r0, r0, r8, asr r0
                 | (ADC_CFG2_ADHSC_MASK)        // 高速转换
                 | ADC_CFG2_ADLSTS(ltime);    // 长采样时间时钟周期选择
                                              // 总采样周期见K60技术文档 page:840
  //用于设定阈值
  adcx->CV1  = 0x1234u ; 
    20e0:	18770002 	ldmdane	r7!, {r1}^
	...
  adcx->CV2  = 0x5678u ;
    20ec:	00000058 	andeq	r0, r0, r8, asr r0
 
  adcx->SC2  &= ((~ADC_SC2_ACFE_MASK)     //关闭比较功能 
    20f0:	0000005a 	andeq	r0, r0, sl, asr r0
    20f4:	007d0002 	rsbseq	r0, sp, r2
    20f8:	0000005a 	andeq	r0, r0, sl, asr r0
                 & (~ADC_SC2_DMAEN_MASK)); //关闭DMA
  adcx->SC2  |=  (hwtrg & ADC_SC2_ADTRG_MASK) //设置触发方式
    20fc:	0000005c 	andeq	r0, r0, ip, asr r0
    2100:	047d0002 	ldrbteq	r0, [sp], #-2
    2104:	0000005c 	andeq	r0, r0, ip, asr r0
    2108:	0000005e 	andeq	r0, r0, lr, asr r0
    210c:	387d0002 	ldmdacc	sp!, {r1}^
                 |  ADC_SC2_ACREN_MASK          //使能范围比较
                 |  ADC_SC2_ACFGT_MASK          //使能大于比较功能
                 |  ADC_SC2_REFSEL(REFSEL_EXT); //选择外部参考源VREFH和VREFL
  
  if(adc_init_structure.ADC_DmaEnable == TRUE) 
    2110:	0000005e 	andeq	r0, r0, lr, asr r0
    2114:	00000176 	andeq	r0, r0, r6, ror r1
    adcx->SC2  |= ADC_SC2_DMAEN_MASK;           //使能DMA
    2118:	38770002 	ldmdacc	r7!, {r1}^
	...

  adcx->SC3  &=  (~ADC_SC3_CAL_MASK)          //关闭校准
    2124:	00000178 	andeq	r0, r0, r8, ror r1
    2128:	0000017a 	andeq	r0, r0, sl, ror r1
    212c:	007d0002 	rsbseq	r0, sp, r2
                 & (~ADC_SC3_ADCO_MASK);         //选择一次转换
  adcx->SC3  |=  avg;                        //硬件平均
    2130:	0000017a 	andeq	r0, r0, sl, ror r1
    2134:	0000017c 	andeq	r0, r0, ip, ror r1
    2138:	087d0002 	ldmdaeq	sp!, {r1}^
  
  adcx->PGA  = pga<<ADC_PGA_PGAG_SHIFT; 
    213c:	0000017c 	andeq	r0, r0, ip, ror r1
    2140:	0000017e 	andeq	r0, r0, lr, ror r1
    2144:	207d0002 	rsbscs	r0, sp, r2
  
  //校准完毕后再重新初始化ADC寄存器
  //adcx->SC1[0] = ADC_SC1_ADCH(AD31);    //复位SC1
  adcx->SC1[hwtrg & 0x01] = diff;         //设置单端、差分输入
    2148:	0000017e 	andeq	r0, r0, lr, ror r1
    214c:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
    2150:	20770002 	rsbscs	r0, r7, r2
	...
  
  if(isr_func!= NULL)
  {
    ADC_ISR[i] = isr_func;
    215c:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
    2160:	000001b2 			; <UNDEFINED> instruction: 0x000001b2
    2164:	007d0002 	rsbseq	r0, sp, r2
    2168:	000001b2 			; <UNDEFINED> instruction: 0x000001b2
  }
  
  return 1;
    216c:	000001b4 			; <UNDEFINED> instruction: 0x000001b4
}
    2170:	087d0002 	ldmdaeq	sp!, {r1}^
    2174:	000001b4 			; <UNDEFINED> instruction: 0x000001b4
    2178:	000001b6 			; <UNDEFINED> instruction: 0x000001b6
    217c:	207d0002 	rsbscs	r0, sp, r2
 * 输出:
 *    0--配置错误
 *    1--配置成功
 */
uint8 LPLD_ADC_Deinit(ADC_InitTypeDef adc_init_structure)
{
    2180:	000001b6 			; <UNDEFINED> instruction: 0x000001b6
    2184:	000001e8 	andeq	r0, r0, r8, ror #3
    2188:	20770002 	rsbscs	r0, r7, r2
	...
  ADC_MemMapPtr adcx = adc_init_structure.ADC_Adcx;
  uint8 hwtrg = adc_init_structure.ADC_HwTrgCfg;
    2194:	000001e8 	andeq	r0, r0, r8, ror #3
  
  adcx->SC1[hwtrg & 0x01] = ADC_SC1_ADCH(AD31);    //复位SC1
    2198:	000001ea 	andeq	r0, r0, sl, ror #3
    219c:	007d0002 	rsbseq	r0, sp, r2
    21a0:	000001ea 	andeq	r0, r0, sl, ror #3
    21a4:	000001ec 	andeq	r0, r0, ip, ror #3
  
  //配置ADC时钟
  if(adcx == ADC0)
    21a8:	087d0002 	ldmdaeq	sp!, {r1}^
    21ac:	000001ec 	andeq	r0, r0, ip, ror #3
    21b0:	000001ee 	andeq	r0, r0, lr, ror #3
    21b4:	f87d0003 			; <UNDEFINED> instruction: 0xf87d0003
  {
    SIM_SCGC6 &= ~(SIM_SCGC6_ADC0_MASK);   // 关闭ADC0时钟
    21b8:	0001ee00 	andeq	lr, r1, r0, lsl #28
    21bc:	0008c200 	andeq	ip, r8, r0, lsl #4
    21c0:	77000300 	strvc	r0, [r0, -r0, lsl #6]
    21c4:	000000f8 	strdeq	r0, [r0], -r8
    21c8:	00000000 	andeq	r0, r0, r0
    21cc:	08c40000 	stmiaeq	r4, {}^	; <UNPREDICTABLE>
    21d0:	08c60000 	stmiaeq	r6, {}^	; <UNPREDICTABLE>
    21d4:	00020000 	andeq	r0, r2, r0
    21d8:	08c6007d 	stmiaeq	r6, {r0, r2, r3, r4, r5, r6}^
    21dc:	08c80000 	stmiaeq	r8, {}^	; <UNPREDICTABLE>
  }
  else if(adcx == ADC1)
    21e0:	00020000 	andeq	r0, r2, r0
    21e4:	08c8107d 	stmiaeq	r8, {r0, r2, r3, r4, r5, r6, ip}^
    21e8:	08ca0000 	stmiaeq	sl, {}^	; <UNPREDICTABLE>
    21ec:	00020000 	andeq	r0, r2, r0
  {
    SIM_SCGC3 &= ~(SIM_SCGC3_ADC1_MASK);   // 关闭ADC1时钟
    21f0:	08ca187d 	stmiaeq	sl, {r0, r2, r3, r4, r5, r6, fp, ip}^
    21f4:	08cc0000 	stmiaeq	ip, {}^	; <UNPREDICTABLE>
    21f8:	00020000 	andeq	r0, r2, r0
    21fc:	08cc307d 	stmiaeq	ip, {r0, r2, r3, r4, r5, r6, ip, sp}^
    2200:	09040000 	stmdbeq	r4, {}	; <UNPREDICTABLE>
    2204:	00020000 	andeq	r0, r2, r0
    2208:	00003077 	andeq	r3, r0, r7, ror r0
    220c:	00000000 	andeq	r0, r0, r0
    2210:	09040000 	stmdbeq	r4, {}	; <UNPREDICTABLE>
    2214:	09060000 	stmdbeq	r6, {}	; <UNPREDICTABLE>
  }
  else 
  {
    return 0;
    2218:	00020000 	andeq	r0, r2, r0
    221c:	0906007d 	stmdbeq	r6, {r0, r2, r3, r4, r5, r6}
  }
  
  return 1;
    2220:	09080000 	stmdbeq	r8, {}	; <UNPREDICTABLE>
}
    2224:	00020000 	andeq	r0, r2, r0
    2228:	09080c7d 	stmdbeq	r8, {r0, r2, r3, r4, r5, r6, sl, fp}
    222c:	090a0000 	stmdbeq	sl, {}	; <UNPREDICTABLE>
 * 输出:
 *    AD通道转换值(右对齐)，若为差分转换结果，则为二进制补码格式(需强制转换为int16)
 *
 */
uint16 LPLD_ADC_Get(ADC_MemMapPtr adcx, AdcChnEnum_Type chn)
{
    2230:	00020000 	andeq	r0, r2, r0
    2234:	090a147d 	stmdbeq	sl, {r0, r2, r3, r4, r5, r6, sl, ip}
    2238:	090c0000 	stmdbeq	ip, {}	; <UNPREDICTABLE>
  adcx->SC1[0] &= ~(ADC_SC1_AIEN_MASK);
    223c:	00020000 	andeq	r0, r2, r0
    2240:	090c387d 	stmdbeq	ip, {r0, r2, r3, r4, r5, r6, fp, ip, sp}
    2244:	09540000 	ldmdbeq	r4, {}^	; <UNPREDICTABLE>
  adcx->SC1[0] &= ~(ADC_SC1_ADCH_MASK);
    2248:	00020000 	andeq	r0, r2, r0
    224c:	00003877 	andeq	r3, r0, r7, ror r8
    2250:	00000000 	andeq	r0, r0, r0
	...

Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:
   0:	0000001c 	andeq	r0, r0, ip, lsl r0
   4:	00000002 	andeq	r0, r0, r2
   8:	00040000 	andeq	r0, r4, r0
   c:	00000000 	andeq	r0, r0, r0
  10:	00000800 	andeq	r0, r0, r0, lsl #16
  14:	000000d6 	ldrdeq	r0, [r0], -r6
	...
  20:	0000001c 	andeq	r0, r0, ip, lsl r0
  24:	0a850002 	beq	fe140034 <__StackLimit+0xde140034>
  28:	00040000 	andeq	r0, r4, r0
  2c:	00000000 	andeq	r0, r0, r0
  30:	000008d8 	ldrdeq	r0, [r0], -r8
  34:	000000e0 	andeq	r0, r0, r0, ror #1
	...
  40:	0000001c 	andeq	r0, r0, ip, lsl r0
  44:	0be90002 	bleq	ffa40054 <__StackLimit+0xdfa40054>
  48:	00040000 	andeq	r0, r4, r0
  4c:	00000000 	andeq	r0, r0, r0
  50:	000009b8 			; <UNDEFINED> instruction: 0x000009b8
  54:	00000418 	andeq	r0, r0, r8, lsl r4
	...
  60:	0000001c 	andeq	r0, r0, ip, lsl r0
  64:	19100002 	ldmdbne	r0, {r1}
  68:	00040000 	andeq	r0, r4, r0
  6c:	00000000 	andeq	r0, r0, r0
  70:	00000dd0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
  74:	00000c76 	andeq	r0, r0, r6, ror ip
	...
  80:	0000001c 	andeq	r0, r0, ip, lsl r0
  84:	30410002 	subcc	r0, r1, r2
  88:	00040000 	andeq	r0, r4, r0
  8c:	00000000 	andeq	r0, r0, r0
  90:	00001a48 	andeq	r1, r0, r8, asr #20
  94:	0000056c 	andeq	r0, r0, ip, ror #10
	...
  a0:	0000001c 	andeq	r0, r0, ip, lsl r0
  a4:	34e00002 	strbtcc	r0, [r0], #2
  a8:	00040000 	andeq	r0, r4, r0
  ac:	00000000 	andeq	r0, r0, r0
  b0:	00001fb4 			; <UNDEFINED> instruction: 0x00001fb4
  b4:	000008ea 	andeq	r0, r0, sl, ror #17
	...
  c0:	0000001c 	andeq	r0, r0, ip, lsl r0
  c4:	42740002 	rsbsmi	r0, r4, #2
  c8:	00040000 	andeq	r0, r4, r0
  cc:	00000000 	andeq	r0, r0, r0
  d0:	000028a0 	andeq	r2, r0, r0, lsr #17
  d4:	0000081e 	andeq	r0, r0, lr, lsl r8
	...
  e0:	0000001c 	andeq	r0, r0, ip, lsl r0
  e4:	51b70002 			; <UNDEFINED> instruction: 0x51b70002
  e8:	00040000 	andeq	r0, r4, r0
  ec:	00000000 	andeq	r0, r0, r0
  f0:	000030c0 	andeq	r3, r0, r0, asr #1
  f4:	00001bce 	andeq	r1, r0, lr, asr #23
	...
 100:	0000001c 	andeq	r0, r0, ip, lsl r0
 104:	623c0002 	eorsvs	r0, ip, #2
 108:	00040000 	andeq	r0, r4, r0
 10c:	00000000 	andeq	r0, r0, r0
 110:	00004c90 	muleq	r0, r0, ip
 114:	000004f6 	strdeq	r0, [r0], -r6
	...
 120:	0000001c 	andeq	r0, r0, ip, lsl r0
 124:	68000002 	stmdavs	r0, {r1}
 128:	00040000 	andeq	r0, r4, r0
 12c:	00000000 	andeq	r0, r0, r0
 130:	00005188 	andeq	r5, r0, r8, lsl #3
 134:	00000366 	andeq	r0, r0, r6, ror #6
	...
 140:	0000001c 	andeq	r0, r0, ip, lsl r0
 144:	712b0002 	teqvc	fp, r2
 148:	00040000 	andeq	r0, r4, r0
 14c:	00000000 	andeq	r0, r0, r0
 150:	000054f0 	strdeq	r5, [r0], -r0
 154:	00000362 	andeq	r0, r0, r2, ror #6
	...
 160:	0000001c 	andeq	r0, r0, ip, lsl r0
 164:	77fe0002 	ldrbvc	r0, [lr, r2]!
 168:	00040000 	andeq	r0, r4, r0
 16c:	00000000 	andeq	r0, r0, r0
 170:	00005854 	andeq	r5, r0, r4, asr r8
 174:	00000726 	andeq	r0, r0, r6, lsr #14
	...
 180:	0000001c 	andeq	r0, r0, ip, lsl r0
 184:	853b0002 	ldrhi	r0, [fp, #-2]!
 188:	00040000 	andeq	r0, r4, r0
 18c:	00000000 	andeq	r0, r0, r0
 190:	00005f7c 	andeq	r5, r0, ip, ror pc
 194:	0000054a 	andeq	r0, r0, sl, asr #10
	...
 1a0:	0000001c 	andeq	r0, r0, ip, lsl r0
 1a4:	8b7a0002 	blhi	1e801b4 <__etext+0x1e7750c>
 1a8:	00040000 	andeq	r0, r4, r0
 1ac:	00000000 	andeq	r0, r0, r0
 1b0:	000064c8 	andeq	r6, r0, r8, asr #9
 1b4:	00000e74 	andeq	r0, r0, r4, ror lr
	...
 1c0:	0000001c 	andeq	r0, r0, ip, lsl r0
 1c4:	9c4e0002 	mcrrls	0, 0, r0, lr, cr2
 1c8:	00040000 	andeq	r0, r4, r0
 1cc:	00000000 	andeq	r0, r0, r0
 1d0:	0000733c 	andeq	r7, r0, ip, lsr r3
 1d4:	0000098e 	andeq	r0, r0, lr, lsl #19
	...
 1e0:	0000001c 	andeq	r0, r0, ip, lsl r0
 1e4:	ac740002 	ldclge	0, cr0, [r4], #-8
 1e8:	00040000 	andeq	r0, r4, r0
 1ec:	00000000 	andeq	r0, r0, r0
 1f0:	00007ccc 	andeq	r7, r0, ip, asr #25
 1f4:	00000052 	andeq	r0, r0, r2, asr r0
	...
 200:	0000001c 	andeq	r0, r0, ip, lsl r0
 204:	b0910002 	addslt	r0, r1, r2
 208:	00040000 	andeq	r0, r4, r0
 20c:	00000000 	andeq	r0, r0, r0
 210:	00007d20 	andeq	r7, r0, r0, lsr #26
 214:	00000954 	andeq	r0, r0, r4, asr r9
	...

Disassembly of section .debug_line:

00000000 <.debug_line>:
       0:	00000144 	andeq	r0, r0, r4, asr #2
       4:	011b0002 	tsteq	fp, r2
       8:	01020000 	mrseq	r0, (UNDEF: 2)
       c:	000d0efb 	strdeq	r0, [sp], -fp
      10:	01010101 	tsteq	r1, r1, lsl #2
      14:	01000000 	mrseq	r0, (UNDEF: 0)
      18:	2f010000 	svccs	0x00010000
      1c:	656d6f68 	strbvs	r6, [sp, #-3944]!	; 0xf68
      20:	6b6f6d2f 	blvs	1bdb4e4 <__etext+0x1bd283c>
      24:	732f7265 	teqvc	pc, #1342177286	; 0x50000006
      28:	7472616d 	ldrbtvc	r6, [r2], #-365	; 0x16d
      2c:	7261635f 	rsbvc	r6, r1, #2080374785	; 0x7c000001
      30:	6372732f 	cmnvs	r2, #-1140850688	; 0xbc000000
      34:	6363672f 	cmnvs	r3, #12320768	; 0xbc0000
      38:	6d72612d 	ldfvse	f6, [r2, #-180]!	; 0xffffff4c
      3c:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
      40:	61652d65 	cmnvs	r5, r5, ror #26
      44:	342d6962 	strtcc	r6, [sp], #-2402	; 0x962
      48:	322d375f 	eorcc	r3, sp, #24903680	; 0x17c0000
      4c:	71333130 	teqvc	r3, r0, lsr r1
      50:	69622f33 	stmdbvs	r2!, {r0, r1, r4, r5, r8, r9, sl, fp, sp}^
      54:	2e2e2f6e 	cdpcs	15, 2, cr2, cr14, cr14, {3}
      58:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
      5c:	6363672f 	cmnvs	r3, #12320768	; 0xbc0000
      60:	6d72612f 	ldfvse	f6, [r2, #-188]!	; 0xffffff44
      64:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
      68:	61652d65 	cmnvs	r5, r5, ror #26
      6c:	342f6962 	strtcc	r6, [pc], #-2402	; 74 <__vector_table+0x74>
      70:	342e372e 	strtcc	r3, [lr], #-1838	; 0x72e
      74:	2f2e2e2f 	svccs	0x002e2e2f
      78:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
      7c:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
      80:	6d72612f 	ldfvse	f6, [r2, #-188]!	; 0xffffff44
      84:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
      88:	61652d65 	cmnvs	r5, r5, ror #26
      8c:	692f6962 	stmdbvs	pc!, {r1, r5, r6, r8, fp, sp, lr}	; <UNPREDICTABLE>
      90:	756c636e 	strbvc	r6, [ip, #-878]!	; 0x36e
      94:	2e006564 	cfsh32cs	mvfx6, mvfx0, #52
      98:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
      9c:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
      a0:	7570632f 	ldrbvc	r6, [r0, #-815]!	; 0x32f
      a4:	6165682f 	cmnvs	r5, pc, lsr #16
      a8:	73726564 	cmnvc	r2, #419430400	; 0x19000000
      ac:	2f2e2e00 	svccs	0x002e2e00
      b0:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; 0 <__vector_table>
      b4:	632f6269 	teqvs	pc, #-1879048186	; 0x90000006
      b8:	6f6d6d6f 	svcvs	0x006d6d6f
      bc:	2e2e006e 	cdpcs	0, 2, cr0, cr14, cr14, {3}
      c0:	2f2e2e2f 	svccs	0x002e2e2f
      c4:	2f62696c 	svccs	0x0062696c
      c8:	00007768 	andeq	r7, r0, r8, ror #14
      cc:	6e69616d 	powvsez	f6, f1, #5.0
      d0:	0000632e 	andeq	r6, r0, lr, lsr #6
      d4:	74730000 	ldrbtvc	r0, [r3], #-0
      d8:	746e6964 	strbtvc	r6, [lr], #-2404	; 0x964
      dc:	0100682e 	tsteq	r0, lr, lsr #16
      e0:	4b4d0000 	blmi	13400e8 <__etext+0x1337440>
      e4:	31463036 	cmpcc	r6, r6, lsr r0
      e8:	00682e35 	rsbeq	r2, r8, r5, lsr lr
      ec:	63000002 	movwvs	r0, #2
      f0:	6f6d6d6f 	svcvs	0x006d6d6f
      f4:	00682e6e 	rsbeq	r2, r8, lr, ror #28
      f8:	68000003 	stmdavs	r0, {r0, r1}
      fc:	70675f77 	rsbvc	r5, r7, r7, ror pc
     100:	682e6f69 	stmdavs	lr!, {r0, r3, r5, r6, r8, r9, sl, fp, sp, lr}
     104:	00000400 	andeq	r0, r0, r0, lsl #8
     108:	645f7768 	ldrbvs	r7, [pc], #-1896	; 110 <__vector_table+0x110>
     10c:	682e616d 	stmdavs	lr!, {r0, r2, r3, r5, r6, r8, sp, lr}
     110:	00000400 	andeq	r0, r0, r0, lsl #8
     114:	5f766564 	svcpl	0x00766564
     118:	3737766f 	ldrcc	r7, [r7, -pc, ror #12]!
     11c:	682e3532 	stmdavs	lr!, {r1, r4, r5, r8, sl, ip, sp}
     120:	00000400 	andeq	r0, r0, r0, lsl #8
     124:	02050000 	andeq	r0, r5, #0
     128:	00000800 	andeq	r0, r0, r0, lsl #16
     12c:	3e011003 	cdpcc	0, 0, cr1, cr1, cr3, {0}
     130:	082f312f 	stmdaeq	pc!, {r0, r1, r2, r3, r5, r8, ip, sp}	; <UNPREDICTABLE>
     134:	4cbc9268 	lfmmi	f1, 1, [ip], #416	; 0x1a0
     138:	0e034cbc 	mcreq	12, 0, r4, cr3, cr12, {5}
     13c:	2079039e 			; <UNDEFINED> instruction: 0x2079039e
     140:	02768378 	rsbseq	r8, r6, #-536870911	; 0xe0000001
     144:	01010001 	tsteq	r1, r1
     148:	00000070 	andeq	r0, r0, r0, ror r0
     14c:	00320002 	eorseq	r0, r2, r2
     150:	01020000 	mrseq	r0, (UNDEF: 2)
     154:	000d0efb 	strdeq	r0, [sp], -fp
     158:	01010101 	tsteq	r1, r1, lsl #2
     15c:	01000000 	mrseq	r0, (UNDEF: 0)
     160:	2e010000 	cdpcs	0, 0, cr0, cr1, cr0, {0}
     164:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
     168:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
     16c:	7570632f 	ldrbvc	r6, [r0, #-815]!	; 0x32f
     170:	74730000 	ldrbtvc	r0, [r3], #-0
     174:	75747261 	ldrbvc	r7, [r4, #-609]!	; 0x261
     178:	366b5f70 	uqsub16cc	r5, fp, r0
     17c:	00632e30 	rsbeq	r2, r3, r0, lsr lr
     180:	00000001 	andeq	r0, r0, r1
     184:	d8020500 	stmdale	r2, {r8, sl}
     188:	03000008 	movweq	r0, #8
     18c:	3f010397 	svccc	0x00010397
     190:	00676767 	rsbeq	r6, r7, r7, ror #14
     194:	83010402 	movwhi	r0, #5122	; 0x1402
     198:	41200b03 	teqmi	r0, r3, lsl #22
     19c:	59777575 	ldmdbpl	r7!, {r0, r2, r4, r5, r6, r8, sl, ip, sp, lr}^
     1a0:	02002159 	andeq	r2, r0, #1073741846	; 0x40000016
     1a4:	79b90104 	ldmibvc	r9!, {r2, r8}
     1a8:	00215959 	eoreq	r5, r1, r9, asr r9
     1ac:	81010402 	tsthi	r1, r2, lsl #8
     1b0:	0200304e 	andeq	r3, r0, #78	; 0x4e
     1b4:	02300104 	eorseq	r0, r0, #1
     1b8:	01010001 	tsteq	r1, r1
     1bc:	0000018f 	andeq	r0, r0, pc, lsl #3
     1c0:	01300002 	teqeq	r0, r2
     1c4:	01020000 	mrseq	r0, (UNDEF: 2)
     1c8:	000d0efb 	strdeq	r0, [sp], -fp
     1cc:	01010101 	tsteq	r1, r1, lsl #2
     1d0:	01000000 	mrseq	r0, (UNDEF: 0)
     1d4:	2e010000 	cdpcs	0, 0, cr0, cr1, cr0, {0}
     1d8:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
     1dc:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
     1e0:	7570632f 	ldrbvc	r6, [r0, #-815]!	; 0x32f
     1e4:	6f682f00 	svcvs	0x00682f00
     1e8:	6d2f656d 	cfstr32vs	mvfx6, [pc, #-436]!	; 3c <__vector_table+0x3c>
     1ec:	72656b6f 	rsbvc	r6, r5, #113664	; 0x1bc00
     1f0:	616d732f 	cmnvs	sp, pc, lsr #6
     1f4:	635f7472 	cmpvs	pc, #1912602624	; 0x72000000
     1f8:	732f7261 	teqvc	pc, #268435462	; 0x10000006
     1fc:	672f6372 			; <UNDEFINED> instruction: 0x672f6372
     200:	612d6363 	teqvs	sp, r3, ror #6
     204:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
     208:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
     20c:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
     210:	375f342d 	ldrbcc	r3, [pc, -sp, lsr #8]
     214:	3130322d 	teqcc	r0, sp, lsr #4
     218:	2f337133 	svccs	0x00337133
     21c:	2f6e6962 	svccs	0x006e6962
     220:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; 170 <__vector_table+0x170>
     224:	672f6269 	strvs	r6, [pc, -r9, ror #4]!
     228:	612f6363 	teqvs	pc, r3, ror #6
     22c:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
     230:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
     234:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
     238:	372e342f 	strcc	r3, [lr, -pc, lsr #8]!
     23c:	2e2f342e 	cdpcs	4, 2, cr3, cr15, cr14, {1}
     240:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
     244:	2f2e2e2f 	svccs	0x002e2e2f
     248:	612f2e2e 	teqvs	pc, lr, lsr #28
     24c:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
     250:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
     254:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
     258:	636e692f 	cmnvs	lr, #770048	; 0xbc000
     25c:	6564756c 	strbvs	r7, [r4, #-1388]!	; 0x56c
     260:	2f2e2e00 	svccs	0x002e2e00
     264:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; 1b4 <__vector_table+0x1b4>
     268:	632f6269 	teqvs	pc, #-1879048186	; 0x90000006
     26c:	682f7570 	stmdavs	pc!, {r4, r5, r6, r8, sl, ip, sp, lr}	; <UNPREDICTABLE>
     270:	65646165 	strbvs	r6, [r4, #-357]!	; 0x165
     274:	2e007372 	mcrcs	3, 0, r7, cr0, cr2, {3}
     278:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
     27c:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
     280:	6d6f632f 	stclvs	3, cr6, [pc, #-188]!	; 1cc <__vector_table+0x1cc>
     284:	006e6f6d 	rsbeq	r6, lr, sp, ror #30
     288:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
     28c:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
     290:	77682f62 	strbvc	r2, [r8, -r2, ror #30]!
     294:	79730000 	ldmdbvc	r3!, {}^	; <UNPREDICTABLE>
     298:	6d657473 	cfstrdvs	mvd7, [r5, #-460]!	; 0xfffffe34
     29c:	30366b5f 	eorscc	r6, r6, pc, asr fp
     2a0:	0100632e 	tsteq	r0, lr, lsr #6
     2a4:	74730000 	ldrbtvc	r0, [r3], #-0
     2a8:	746e6964 	strbtvc	r6, [lr], #-2404	; 0x964
     2ac:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
     2b0:	4b4d0000 	blmi	13402b8 <__etext+0x1337610>
     2b4:	31463036 	cmpcc	r6, r6, lsr r0
     2b8:	00682e35 	rsbeq	r2, r8, r5, lsr lr
     2bc:	63000003 	movwvs	r0, #3
     2c0:	6f6d6d6f 	svcvs	0x006d6d6f
     2c4:	00682e6e 	rsbeq	r2, r8, lr, ror #28
     2c8:	4d000004 	stcmi	0, cr0, [r0, #-16]
     2cc:	445f534f 	ldrbmi	r5, [pc], #-847	; 2d4 <__vector_table+0x2d4>
     2d0:	65766972 	ldrbvs	r6, [r6, #-2418]!	; 0x972
     2d4:	682e7372 	stmdavs	lr!, {r1, r4, r5, r6, r8, r9, ip, sp, lr}
     2d8:	00000500 	andeq	r0, r0, r0, lsl #10
     2dc:	6d5f7768 	ldclvs	7, cr7, [pc, #-416]	; 144 <__vector_table+0x144>
     2e0:	682e6763 	stmdavs	lr!, {r0, r1, r5, r6, r8, r9, sl, sp, lr}
     2e4:	00000500 	andeq	r0, r0, r0, lsl #10
     2e8:	755f7768 	ldrbvc	r7, [pc, #-1896]	; fffffb88 <__StackLimit+0xdffffb88>
     2ec:	2e747261 	cdpcs	2, 7, cr7, cr4, cr1, {3}
     2f0:	00050068 	andeq	r0, r5, r8, rrx
     2f4:	05000000 	streq	r0, [r0, #-0]
     2f8:	0009b802 	andeq	fp, r9, r2, lsl #16
     2fc:	01290300 	teqeq	r9, r0, lsl #6
     300:	4d400830 	stclmi	8, cr0, [r0, #-192]	; 0xffffff40
     304:	9f089f31 	svcls	0x00089f31
     308:	a1089f08 	tstge	r8, r8, lsl #30
     30c:	200c032f 	andcs	r0, ip, pc, lsr #6
     310:	f33d083e 	vceq.i<illegal width 64>	d0, d13, d30
     314:	3d4c5f67 	stclcc	15, cr5, [ip, #-412]	; 0xfffffe64
     318:	08f5833d 	ldmeq	r5!, {r0, r2, r3, r4, r5, r8, r9, pc}^
     31c:	2221083d 	eorcs	r0, r1, #3997696	; 0x3d0000
     320:	21083d08 	tstcs	r8, r8, lsl #26
     324:	083d0822 	ldmdaeq	sp!, {r1, r5, fp}
     328:	3d082221 	sfmcc	f2, 4, [r8, #-132]	; 0xffffff7c
     32c:	6d222108 	stfvss	f2, [r2, #-32]!	; 0xffffffe0
     330:	833d3d4c 	teqhi	sp, #4864	; 0x1300
     334:	223d08d9 	eorscs	r0, sp, #14221312	; 0xd90000
     338:	08223d08 	stmdaeq	r2!, {r3, r8, sl, fp, ip, sp}
     33c:	3d08223d 	sfmcc	f2, 4, [r8, #-244]	; 0xffffff0c
     340:	593e6d22 	ldmdbpl	lr!, {r1, r5, r8, sl, fp, sp, lr}
     344:	3d3d3d3d 	ldccc	13, cr3, [sp, #-244]!	; 0xffffff0c
     348:	0402793e 	streq	r7, [r2], #-2366	; 0x93e
     34c:	ff010100 			; <UNDEFINED> instruction: 0xff010100
     350:	02000002 	andeq	r0, r0, #2
     354:	00012100 	andeq	r2, r1, r0, lsl #2
     358:	fb010200 	blx	40b62 <__etext+0x37eba>
     35c:	01000d0e 	tsteq	r0, lr, lsl #26
     360:	00010101 	andeq	r0, r1, r1, lsl #2
     364:	00010000 	andeq	r0, r1, r0
     368:	2e2e0100 	sufcse	f0, f6, f0
     36c:	2f2e2e2f 	svccs	0x002e2e2f
     370:	2f62696c 	svccs	0x0062696c
     374:	2f007768 	svccs	0x00007768
     378:	656d6f68 	strbvs	r6, [sp, #-3944]!	; 0xf68
     37c:	6b6f6d2f 	blvs	1bdb840 <__etext+0x1bd2b98>
     380:	732f7265 	teqvc	pc, #1342177286	; 0x50000006
     384:	7472616d 	ldrbtvc	r6, [r2], #-365	; 0x16d
     388:	7261635f 	rsbvc	r6, r1, #2080374785	; 0x7c000001
     38c:	6372732f 	cmnvs	r2, #-1140850688	; 0xbc000000
     390:	6363672f 	cmnvs	r3, #12320768	; 0xbc0000
     394:	6d72612d 	ldfvse	f6, [r2, #-180]!	; 0xffffff4c
     398:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
     39c:	61652d65 	cmnvs	r5, r5, ror #26
     3a0:	342d6962 	strtcc	r6, [sp], #-2402	; 0x962
     3a4:	322d375f 	eorcc	r3, sp, #24903680	; 0x17c0000
     3a8:	71333130 	teqvc	r3, r0, lsr r1
     3ac:	69622f33 	stmdbvs	r2!, {r0, r1, r4, r5, r8, r9, sl, fp, sp}^
     3b0:	2e2e2f6e 	cdpcs	15, 2, cr2, cr14, cr14, {3}
     3b4:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
     3b8:	6363672f 	cmnvs	r3, #12320768	; 0xbc0000
     3bc:	6d72612f 	ldfvse	f6, [r2, #-188]!	; 0xffffff44
     3c0:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
     3c4:	61652d65 	cmnvs	r5, r5, ror #26
     3c8:	342f6962 	strtcc	r6, [pc], #-2402	; 3d0 <__vector_table+0x3d0>
     3cc:	342e372e 	strtcc	r3, [lr], #-1838	; 0x72e
     3d0:	2f2e2e2f 	svccs	0x002e2e2f
     3d4:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
     3d8:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
     3dc:	6d72612f 	ldfvse	f6, [r2, #-188]!	; 0xffffff44
     3e0:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
     3e4:	61652d65 	cmnvs	r5, r5, ror #26
     3e8:	692f6962 	stmdbvs	pc!, {r1, r5, r6, r8, fp, sp, lr}	; <UNPREDICTABLE>
     3ec:	756c636e 	strbvc	r6, [ip, #-878]!	; 0x36e
     3f0:	2e006564 	cfsh32cs	mvfx6, mvfx0, #52
     3f4:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
     3f8:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
     3fc:	7570632f 	ldrbvc	r6, [r0, #-815]!	; 0x32f
     400:	6165682f 	cmnvs	r5, pc, lsr #16
     404:	73726564 	cmnvc	r2, #419430400	; 0x19000000
     408:	2f2e2e00 	svccs	0x002e2e00
     40c:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; 35c <__vector_table+0x35c>
     410:	632f6269 	teqvs	pc, #-1879048186	; 0x90000006
     414:	6f6d6d6f 	svcvs	0x006d6d6f
     418:	6400006e 	strvs	r0, [r0], #-110	; 0x6e
     41c:	6f5f7665 	svcvs	0x005f7665
     420:	32373776 	eorscc	r3, r7, #30932992	; 0x1d80000
     424:	00632e35 	rsbeq	r2, r3, r5, lsr lr
     428:	73000001 	movwvc	r0, #1
     42c:	6e696474 	mcrvs	4, 3, r6, cr9, cr4, {3}
     430:	00682e74 	rsbeq	r2, r8, r4, ror lr
     434:	4d000002 	stcmi	0, cr0, [r0, #-8]
     438:	4630364b 	ldrtmi	r3, [r0], -fp, asr #12
     43c:	682e3531 	stmdavs	lr!, {r0, r4, r5, r8, sl, ip, sp}
     440:	00000300 	andeq	r0, r0, r0, lsl #6
     444:	6d6d6f63 	stclvs	15, cr6, [sp, #-396]!	; 0xfffffe74
     448:	682e6e6f 	stmdavs	lr!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}
     44c:	00000400 	andeq	r0, r0, r0, lsl #8
     450:	675f7768 	ldrbvs	r7, [pc, -r8, ror #14]
     454:	2e6f6970 	mcrcs	9, 3, r6, cr15, cr0, {3}
     458:	00010068 	andeq	r0, r1, r8, rrx
     45c:	5f776800 	svcpl	0x00776800
     460:	2e616d64 	cdpcs	13, 6, cr6, cr1, cr4, {3}
     464:	00010068 	andeq	r0, r1, r8, rrx
     468:	76656400 	strbtvc	r6, [r5], -r0, lsl #8
     46c:	37766f5f 			; <UNDEFINED> instruction: 0x37766f5f
     470:	2e353237 	mrccs	2, 1, r3, cr5, cr7, {1}
     474:	00010068 	andeq	r0, r1, r8, rrx
     478:	05000000 	streq	r0, [r0, #-0]
     47c:	000dd002 	andeq	sp, sp, r2
     480:	00ea0300 	rsceq	r0, sl, r0, lsl #6
     484:	4b3d3d01 	blmi	f4f890 <__etext+0xf46be8>
     488:	30144202 	andscc	r4, r4, r2, lsl #4
     48c:	00d72230 	sbcseq	r2, r7, r0, lsr r2
     490:	39010402 	stmdbcc	r1, {r1, sl}
     494:	02003096 	andeq	r3, r0, #150	; 0x96
     498:	20060104 	andcs	r0, r6, r4, lsl #2
     49c:	bd91bc06 	ldclt	12, cr11, [r1, #24]
     4a0:	76084c4c 	strvc	r4, [r8], -ip, asr #24
     4a4:	30083ed7 	ldrdcc	r3, [r8], -r7
     4a8:	58087703 	stmdapl	r8, {r0, r1, r8, r9, sl, ip, sp, lr}
     4ac:	01040200 	mrseq	r0, R12_usr
     4b0:	06824a06 	streq	r4, [r2], r6, lsl #20
     4b4:	3e200f03 	cdpcc	15, 2, cr0, cr0, cr3, {0}
     4b8:	4c3e5c30 	ldcmi	12, cr5, [lr], #-192	; 0xffffff40
     4bc:	02040200 	andeq	r0, r4, #0
     4c0:	0402004c 	streq	r0, [r2], #-76	; 0x4c
     4c4:	02001e02 	andeq	r1, r0, #32
     4c8:	4a060104 	bmi	1808e0 <__etext+0x177c38>
     4cc:	02003a06 	andeq	r3, r0, #24576	; 0x6000
     4d0:	4a060104 	bmi	1808e8 <__etext+0x177c40>
     4d4:	3d6a5f06 	stclcc	15, cr5, [sl, #-24]!	; 0xffffffe8
     4d8:	75bcbe76 	ldrvc	fp, [ip, #3702]!	; 0xe76
     4dc:	9283cba0 	addls	ip, r3, #163840	; 0x28000
     4e0:	75843140 	strvc	r3, [r4, #320]	; 0x140
     4e4:	4bdcbd4d 	blmi	ff72fa20 <__StackLimit+0xdf72fa20>
     4e8:	763d3276 			; <UNDEFINED> instruction: 0x763d3276
     4ec:	0391c983 	orrseq	ip, r1, #2146304	; 0x20c000
     4f0:	69672e0b 	stmdbvs	r7!, {r0, r1, r3, r9, sl, fp, sp}^
     4f4:	13087522 	movwne	r7, #34082	; 0x8522
     4f8:	13081308 	movwne	r1, #33544	; 0x8308
     4fc:	13081308 	movwne	r1, #33544	; 0x8308
     500:	13081308 	movwne	r1, #33544	; 0x8308
     504:	01040200 	mrseq	r0, R12_usr
     508:	03d67603 	bicseq	r7, r6, #3145728	; 0x300000
     50c:	0c03c80c 	stceq	8, cr12, [r3], {12}
     510:	ad845966 	stcge	9, cr5, [r4, #408]	; 0x198
     514:	913e5c95 			; <UNDEFINED> instruction: 0x913e5c95
     518:	93777675 	cmnls	r7, #122683392	; 0x7500000
     51c:	93767591 	cmnls	r6, #608174080	; 0x24400000
     520:	75919391 	ldrvc	r9, [r1, #913]	; 0x391
     524:	40929176 	addsmi	r9, r2, r6, ror r1
     528:	7575753d 	ldrbvc	r7, [r5, #-1341]!	; 0x53d
     52c:	75919176 	ldrvc	r9, [r1, #374]	; 0x176
     530:	bc140891 	ldclt	8, cr0, [r4], {145}	; 0x91
     534:	1508bd91 	strne	fp, [r8, #-3473]	; 0xd91
     538:	003d3d4e 	eorseq	r3, sp, lr, asr #26
     53c:	06010402 	streq	r0, [r1], -r2, lsl #8
     540:	75830620 	strvc	r0, [r3, #1568]	; 0x620
     544:	76a23e84 	strtvc	r3, [r2], r4, lsl #29
     548:	834ebd50 	movthi	fp, #60752	; 0xed50
     54c:	01040200 	mrseq	r0, R12_usr
     550:	02004a06 	andeq	r4, r0, #24576	; 0x6000
     554:	004a0304 	subeq	r0, sl, r4, lsl #6
     558:	4a050402 	bmi	141568 <__etext+0x1388c0>
     55c:	06040200 	streq	r0, [r4], -r0, lsl #4
     560:	0402003c 	streq	r0, [r2], #-60	; 0x3c
     564:	02003c04 	andeq	r3, r0, #1024	; 0x400
     568:	003c0204 	eorseq	r0, ip, r4, lsl #4
     56c:	2e090402 	cdpcs	4, 0, cr0, cr9, cr2, {0}
     570:	09040200 	stmdbeq	r4, {r9}
     574:	02002206 	andeq	r2, r0, #1610612736	; 0x60000000
     578:	00f30904 	rscseq	r0, r3, r4, lsl #18
     57c:	08090402 	stmdaeq	r9, {r1, sl}
     580:	0402003e 	streq	r0, [r2], #-62	; 0x3e
     584:	0200bb09 	andeq	fp, r0, #9216	; 0x2400
     588:	00d70904 	sbcseq	r0, r7, r4, lsl #18
     58c:	c9090402 	stmdbgt	r9, {r1, sl}
     590:	09040200 	stmdbeq	r4, {r9}
     594:	040200e5 	streq	r0, [r2], #-229	; 0xe5
     598:	02005a09 	andeq	r5, r0, #36864	; 0x9000
     59c:	00640904 	rsbeq	r0, r4, r4, lsl #18
     5a0:	08090402 	stmdaeq	r9, {r1, sl}
     5a4:	04020018 	streq	r0, [r2], #-24
     5a8:	003d0809 	eorseq	r0, sp, r9, lsl #16
     5ac:	08090402 	stmdaeq	r9, {r1, sl}
     5b0:	0402003e 	streq	r0, [r2], #-62	; 0x3e
     5b4:	0200bc09 	andeq	fp, r0, #2304	; 0x900
     5b8:	00d80904 	sbcseq	r0, r8, r4, lsl #18
     5bc:	e5090402 	str	r0, [r9, #-1026]	; 0x402
     5c0:	01040200 	mrseq	r0, R12_usr
     5c4:	02009e06 	andeq	r9, r0, #96	; 0x60
     5c8:	004a0204 	subeq	r0, sl, r4, lsl #4
     5cc:	2e030402 	cdpcs	4, 0, cr0, cr3, cr2, {0}
     5d0:	03040200 	movweq	r0, #16896	; 0x4200
     5d4:	02008306 	andeq	r8, r0, #402653184	; 0x18000000
     5d8:	00ea0304 	rsceq	r0, sl, r4, lsl #6
     5dc:	cb030402 	blgt	c15ec <__etext+0xb8944>
     5e0:	03040200 	movweq	r0, #16896	; 0x4200
     5e4:	02002108 	andeq	r2, r0, #2
     5e8:	5df30304 	ldclpl	3, cr0, [r3, #16]!
     5ec:	e6689183 	strbt	r9, [r8], -r3, lsl #3
     5f0:	e5c96876 	strb	r6, [r9, #2166]	; 0x876
     5f4:	00592f92 			; <UNDEFINED> instruction: 0x00592f92
     5f8:	21020402 	tstcs	r2, r2, lsl #8
     5fc:	02040200 	andeq	r0, r4, #0
     600:	040200c7 	streq	r0, [r2], #-199	; 0xc7
     604:	064a0601 	strbeq	r0, [sl], -r1, lsl #12
     608:	004a7803 	subeq	r7, sl, r3, lsl #16
     60c:	06010402 	streq	r0, [r1], -r2, lsl #8
     610:	0c03064a 	stceq	6, cr0, [r3], {74}	; 0x4a
     614:	00ca684a 	sbceq	r6, sl, sl, asr #16
     618:	06010402 	streq	r0, [r1], -r2, lsl #8
     61c:	2f7606e4 	svccs	0x007606e4
     620:	04020059 	streq	r0, [r2], #-89	; 0x59
     624:	02002102 	andeq	r2, r0, #-2147483648	; 0x80000000
     628:	00c70204 	sbceq	r0, r7, r4, lsl #4
     62c:	06010402 	streq	r0, [r1], -r2, lsl #8
     630:	7803064a 	stmdavc	r3, {r1, r3, r6, r9, sl}
     634:	04020058 	streq	r0, [r2], #-88	; 0x58
     638:	064a0601 	strbeq	r0, [sl], -r1, lsl #12
     63c:	ad740d03 	ldclge	13, cr0, [r4, #-12]!
     640:	00c86403 	sbceq	r6, r8, r3, lsl #8
     644:	06010402 	streq	r0, [r1], -r2, lsl #8
     648:	1f03064a 	svcne	0x0003064a
     64c:	00050258 	andeq	r0, r5, r8, asr r2
     650:	01cc0101 	biceq	r0, ip, r1, lsl #2
     654:	00020000 	andeq	r0, r2, r0
     658:	00000103 	andeq	r0, r0, r3, lsl #2
     65c:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
     660:	0101000d 	tsteq	r1, sp
     664:	00000101 	andeq	r0, r0, r1, lsl #2
     668:	00000100 	andeq	r0, r0, r0, lsl #2
     66c:	2f2e2e01 	svccs	0x002e2e01
     670:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; 5c0 <__vector_table+0x5c0>
     674:	682f6269 	stmdavs	pc!, {r0, r3, r5, r6, r9, sp, lr}	; <UNPREDICTABLE>
     678:	2e2e0077 	mcrcs	0, 1, r0, cr14, cr7, {3}
     67c:	2f2e2e2f 	svccs	0x002e2e2f
     680:	2f62696c 	svccs	0x0062696c
     684:	2f757063 	svccs	0x00757063
     688:	64616568 	strbtvs	r6, [r1], #-1384	; 0x568
     68c:	00737265 	rsbseq	r7, r3, r5, ror #4
     690:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	; 5dc <__vector_table+0x5dc>
     694:	6f6d2f65 	svcvs	0x006d2f65
     698:	2f72656b 	svccs	0x0072656b
     69c:	72616d73 	rsbvc	r6, r1, #7360	; 0x1cc0
     6a0:	61635f74 	smcvs	13812	; 0x35f4
     6a4:	72732f72 	rsbsvc	r2, r3, #456	; 0x1c8
     6a8:	63672f63 	cmnvs	r7, #396	; 0x18c
     6ac:	72612d63 	rsbvc	r2, r1, #6336	; 0x18c0
     6b0:	6f6e2d6d 	svcvs	0x006e2d6d
     6b4:	652d656e 	strvs	r6, [sp, #-1390]!	; 0x56e
     6b8:	2d696261 	sfmcs	f6, 2, [r9, #-388]!	; 0xfffffe7c
     6bc:	2d375f34 	ldccs	15, cr5, [r7, #-208]!	; 0xffffff30
     6c0:	33313032 	teqcc	r1, #50	; 0x32
     6c4:	622f3371 	eorvs	r3, pc, #-1006632959	; 0xc4000001
     6c8:	2e2f6e69 	cdpcs	14, 2, cr6, cr15, cr9, {3}
     6cc:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
     6d0:	63672f62 	cmnvs	r7, #392	; 0x188
     6d4:	72612f63 	rsbvc	r2, r1, #396	; 0x18c
     6d8:	6f6e2d6d 	svcvs	0x006e2d6d
     6dc:	652d656e 	strvs	r6, [sp, #-1390]!	; 0x56e
     6e0:	2f696261 	svccs	0x00696261
     6e4:	2e372e34 	mrccs	14, 1, r2, cr7, cr4, {1}
     6e8:	2e2e2f34 	mcrcs	15, 1, r2, cr14, cr4, {1}
     6ec:	2f2e2e2f 	svccs	0x002e2e2f
     6f0:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
     6f4:	72612f2e 	rsbvc	r2, r1, #184	; 0xb8
     6f8:	6f6e2d6d 	svcvs	0x006e2d6d
     6fc:	652d656e 	strvs	r6, [sp, #-1390]!	; 0x56e
     700:	2f696261 	svccs	0x00696261
     704:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
     708:	00656475 	rsbeq	r6, r5, r5, ror r4
     70c:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
     710:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
     714:	6f632f62 	svcvs	0x00632f62
     718:	6e6f6d6d 	cdpvs	13, 6, cr6, cr15, cr13, {3}
     71c:	65640000 	strbvs	r0, [r4, #-0]!
     720:	63735f76 	cmnvs	r3, #472	; 0x1d8
     724:	632e6263 	teqvs	lr, #805306374	; 0x30000006
     728:	00000100 	andeq	r0, r0, r0, lsl #2
     72c:	30364b4d 	eorscc	r4, r6, sp, asr #22
     730:	2e353146 	rsfcssm	f3, f5, f6
     734:	00020068 	andeq	r0, r2, r8, rrx
     738:	64747300 	ldrbtvs	r7, [r4], #-768	; 0x300
     73c:	2e746e69 	cdpcs	14, 7, cr6, cr4, cr9, {3}
     740:	00030068 	andeq	r0, r3, r8, rrx
     744:	6d6f6300 	stclvs	3, cr6, [pc, #-0]	; 74c <__vector_table+0x74c>
     748:	2e6e6f6d 	cdpcs	15, 6, cr6, cr14, cr13, {3}
     74c:	00040068 	andeq	r0, r4, r8, rrx
     750:	5f776800 	svcpl	0x00776800
     754:	6f697067 	svcvs	0x00697067
     758:	0100682e 	tsteq	r0, lr, lsr #16
     75c:	00000000 	andeq	r0, r0, r0
     760:	1a480205 	bne	1200f7c <__etext+0x11f82d4>
     764:	31030000 	mrscc	r0, (UNDEF: 3)
     768:	3e593f01 	cdpcc	15, 5, cr3, cr9, cr1, {0}
     76c:	753d3d3d 	ldrvc	r3, [sp, #-3389]!	; 0xd3d
     770:	75580f03 	ldrbvc	r0, [r8, #-3843]	; 0xf03
     774:	5a4b3e5a 	bpl	12d00e4 <__etext+0x12c743c>
     778:	2f593e2f 	svccs	0x00593e2f
     77c:	2f2f2f4b 	svccs	0x002f2f4b
     780:	83661a03 	cmnhi	r6, #12288	; 0x3000
     784:	5a4b3e5a 	bpl	12d00f4 <__etext+0x12c744c>
     788:	2f4b3e2f 	svccs	0x004b3e2f
     78c:	4c3e5a30 	ldcmi	10, cr5, [lr], #-192	; 0xffffff40
     790:	67402f5a 	smlsldvs	r2, r0, sl, pc	; <UNPREDICTABLE>
     794:	4b30403e 	blmi	c10894 <__etext+0xc07bec>
     798:	01040200 	mrseq	r0, R12_usr
     79c:	034a7403 	movteq	r7, #41987	; 0xa403
     7a0:	2f2f3c0e 	svccs	0x002f3c0e
     7a4:	75752f5f 	ldrbvc	r2, [r5, #-3935]!	; 0xf5f
     7a8:	7576754c 	ldrbvc	r7, [r6, #-1356]!	; 0x54c
     7ac:	4c76753e 	cfldr64mi	mvdx7, [r6], #-248	; 0xffffff08
     7b0:	3e757675 	mrccc	6, 3, r7, cr5, cr5, {3}
     7b4:	352f7575 	strcc	r7, [pc, #-1397]!	; 247 <__vector_table+0x247>
     7b8:	4c75752f 	cfldr64mi	mvdx7, [r5], #-188	; 0xffffff44
     7bc:	354b7575 	strbcc	r7, [fp, #-1397]	; 0x575
     7c0:	754c752f 	strbvc	r7, [ip, #-1327]	; 0x52f
     7c4:	754c754c 	strbvc	r7, [ip, #-1356]	; 0x54c
     7c8:	752f354b 	strvc	r3, [pc, #-1355]!	; 285 <__vector_table+0x285>
     7cc:	754b754b 	strbvc	r7, [fp, #-1355]	; 0x54b
     7d0:	354b754b 	strbcc	r7, [fp, #-1355]	; 0x54b
     7d4:	754c752f 	strbvc	r7, [ip, #-1327]	; 0x52f
     7d8:	764c764c 	strbvc	r7, [ip], -ip, asr #12
     7dc:	753e7575 	ldrvc	r7, [lr, #-1397]!	; 0x575
     7e0:	59432f75 	stmdbpl	r3, {r0, r2, r4, r5, r6, r8, r9, sl, fp, sp}^
     7e4:	4b75223d 	blmi	1d490e0 <__etext+0x1d40438>
     7e8:	4b76864c 	blmi	1da2120 <__etext+0x1d99478>
     7ec:	0200754b 	andeq	r7, r0, #314572800	; 0x12c00000
     7f0:	71030104 	tstvc	r3, r4, lsl #2
     7f4:	ba11034a 	blt	441524 <__etext+0x43887c>
     7f8:	3d3d5f75 	ldccc	15, cr5, [sp, #-468]!	; 0xfffffe2c
     7fc:	764c753e 			; <UNDEFINED> instruction: 0x764c753e
extern GPIO_InitTypeDef OV_PTA_init;

extern char ready_send_flag;

int main (void)
{
     800:	4c754b22 	ldclmi	11, cr4, [r5], #-136	; 0xffffff78
     804:	00764c75 	rsbseq	r4, r6, r5, ror ip

    Ov7725_Init ();
     808:	03010402 	movweq	r0, #5122	; 0x1402
    Ov7725_Delay();
     80c:	0f034a75 	svceq	0x00034a75

    //Ov7725_Dma_Init();
    Ov7725_Gpio_Init ();
     810:	217675ba 	ldrhcs	r7, [r6, #-90]!	; 0xffffffa6
    dma_portx2buff_init (DMA_CH0, (void *)(&GPIOB_PDIR), (void *)img,PORTA_DMAREQ ,DMA_BYTE1, PHOTO_SIZE / 8, DADDR_KEEPON);
     814:	0021596d 	eoreq	r5, r1, sp, ror #18
     818:	49010402 	stmdbmi	r1, {r1, sl}
     81c:	0005023e 	andeq	r0, r5, lr, lsr r2
     820:	020c0101 	andeq	r0, ip, #1073741824	; 0x40000000
     824:	00020000 	andeq	r0, r2, r0
     828:	00000100 	andeq	r0, r0, r0, lsl #2
     82c:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
     830:	0101000d 	tsteq	r1, sp
     834:	00000101 	andeq	r0, r0, r1, lsl #2
     838:	00000100 	andeq	r0, r0, r0, lsl #2
     83c:	2f2e2e01 	svccs	0x002e2e01
    //装载DMA中断
    DMA_ISR[DMA_CH0] = Ov7725_eagle_dma;
     840:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; 790 <__vector_table+0x790>
     844:	682f6269 	stmdavs	pc!, {r0, r3, r5, r6, r9, sp, lr}	; <UNPREDICTABLE>
     848:	682f0077 	stmdavs	pc!, {r0, r1, r2, r4, r5, r6}	; <UNPREDICTABLE>
     84c:	2f656d6f 	svccs	0x00656d6f
     850:	656b6f6d 	strbvs	r6, [fp, #-3949]!	; 0xf6d
    //关闭DMA通道
    DMA_DIS(DMA_CH0);
     854:	6d732f72 	ldclvs	15, cr2, [r3, #-456]!	; 0xfffffe38
     858:	5f747261 	svcpl	0x00747261
     85c:	2f726163 	svccs	0x00726163
     860:	2f637273 	svccs	0x00637273
     864:	2d636367 	stclcs	3, cr6, [r3, #-412]!	; 0xfffffe64
     868:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
    //关GPIO中断
    disable_irq(INT_PORTA - 16);
     86c:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
     870:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
    //清DMA中断置为标志
    DMA_IRQ_CLEAN(DMA_CH0);
     874:	5f342d69 	svcpl	0x00342d69
     878:	30322d37 	eorscc	r2, r2, r7, lsr sp
     87c:	33713331 	cmncc	r1, #-1006632960	; 0xc4000000
     880:	6e69622f 	cdpvs	2, 6, cr6, cr9, cr15, {1}
     884:	2f2e2e2f 	svccs	0x002e2e2f
     888:	2f62696c 	svccs	0x0062696c
    //使能DMA中断
    DMA_IRQ_EN (DMA_CH0);
     88c:	2f636367 	svccs	0x00636367
     890:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
    //开启GPIO中断
    LPLD_GPIO_EnableIrq(OV_PTA_init);
     894:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
     898:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
     89c:	2e342f69 	cdpcs	15, 3, cr2, cr4, cr9, {3}
     8a0:	2f342e37 	svccs	0x00342e37
     8a4:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    {
        //获取图像
        //Ov7725_eagle_get_img ();
        //解压图像
        //Ov7725_img_extract (Pix_Data, img, PHOTO_SIZE/8);
        if(ready_send_flag)
     8a8:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
     8ac:	2f2e2e2f 	svccs	0x002e2e2f
     8b0:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
     8b4:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
        {
            //发送图片到上位机
            //get_midline(Pix_Data, 60, 80);
            Ov7725_sendimg (Pix_Data, PHOTO_SIZE);
     8b8:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
     8bc:	6e692f69 	cdpvs	15, 6, cr2, cr9, cr9, {3}
     8c0:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xc63
     8c4:	2e2e0065 	cdpcs	0, 2, cr0, cr14, cr5, {3}
            ready_send_flag = 0;
     8c8:	2f2e2e2f 	svccs	0x002e2e2f
     8cc:	2f62696c 	svccs	0x0062696c
     8d0:	2f757063 	svccs	0x00757063
        }
    }
     8d4:	64616568 	strbtvs	r6, [r1], #-1384	; 0x568
 * \param  void
 *
 * \return void
 */
void Default_Handler(void)
{
     8d8:	00737265 	rsbseq	r7, r3, r5, ror #4
     8dc:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
#define VECTORNUM       (*(volatile char *) (0xE000ED04))
  //while (1);
  char vtr = VECTORNUM;
     8e0:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
     8e4:	6f632f62 	svcvs	0x00632f62
     8e8:	6e6f6d6d 	cdpvs	13, 6, cr6, cr15, cr13, {3}
  printf ("\n ******************\n");
     8ec:	77680000 	strbvc	r0, [r8, -r0]!
     8f0:	6364615f 	cmnvs	r4, #-1073741801	; 0xc0000017
     8f4:	0100632e 	tsteq	r0, lr, lsr #6
  printf ("Default Handler Error\n");
     8f8:	74730000 	ldrbtvc	r0, [r3], #-0
     8fc:	746e6964 	strbtvc	r6, [lr], #-2404	; 0x964
     900:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
  printf ("On vector %d **** Interrupt\n", vtr);
     904:	4b4d0000 	blmi	134090c <__etext+0x1337c64>
     908:	31463036 	cmpcc	r6, r6, lsr r0
     90c:	00682e35 	rsbeq	r2, r8, r5, lsr lr
     910:	63000003 	movwvs	r0, #3
 * \param  void
 *
 * \return void
 */
void Reset_Handler(void)
{
     914:	6f6d6d6f 	svcvs	0x006d6d6f
     918:	00682e6e 	rsbeq	r2, r8, lr, ror #28
  unsigned char *source;
  unsigned char *destination;

  /* watchdog disable */
  *((volatile unsigned short *)0x4005200E) = 0xC520;
     91c:	68000004 	stmdavs	r0, {r2}
     920:	64615f77 	strbtvs	r5, [r1], #-3959	; 0xf77
     924:	00682e63 	rsbeq	r2, r8, r3, ror #28
  *((volatile unsigned short *)0x4005200E) = 0xD928;
     928:	00000001 	andeq	r0, r0, r1
     92c:	b4020500 	strlt	r0, [r2], #-1280	; 0x500
     930:	0300001f 	movweq	r0, #31
     934:	2f84011c 	svccs	0x0084011c
  *((volatile unsigned short *)0x40052000) = 0x01D2;
     938:	3d3d3d3d 	ldccc	13, cr3, [sp, #-244]!	; 0xffffff0c
     93c:	3d3d3d3d 	ldccc	13, cr3, [sp, #-244]!	; 0xffffff0c
     940:	083d7631 	ldmdaeq	sp!, {r0, r4, r5, r9, sl, ip, sp, lr}

  /* copy data values from ROM to RAM */
  source = (unsigned char *)&_etext;
     944:	083d764c 	ldmdaeq	sp!, {r2, r3, r6, r9, sl, ip, sp, lr}
     948:	3f4b3f4e 	svccc	0x004b3f4e
     94c:	63593067 	cmpvs	r9, #103	; 0x67
  destination = (unsigned char *)&_sdata;
     950:	8e306742 	cdphi	7, 3, cr6, cr0, cr2, {2}
     954:	684c4b41 	stmdavs	ip, {r0, r6, r8, r9, fp, lr}^
  while (destination < (unsigned char*)&_edata) {
     958:	68684ba3 	stmdavs	r8!, {r0, r1, r5, r7, r8, r9, fp, lr}^
    *(destination++) = *(source++);
     95c:	3e766a68 	vsubcc.f32	s13, s12, s17
     960:	0f032f85 	svceq	0x00032f85
     964:	302f8382 	eorcc	r8, pc, r2, lsl #7
     968:	4c087685 	stcmi	6, cr7, [r8], {133}	; 0x85
     96c:	3f4e0876 	svccc	0x004e0876
     970:	00c7032f 	sbceq	r0, r7, pc, lsr #6
  *((volatile unsigned short *)0x40052000) = 0x01D2;

  /* copy data values from ROM to RAM */
  source = (unsigned char *)&_etext;
  destination = (unsigned char *)&_sdata;
  while (destination < (unsigned char*)&_edata) {
     974:	67676774 			; <UNDEFINED> instruction: 0x67676774
     978:	04020083 	streq	r0, [r2], #-131	; 0x83
     97c:	06200601 	strteq	r0, [r0], -r1, lsl #12
    *(destination++) = *(source++);
  }

  /* clear bss section */
  source = (unsigned char *)&_sbss;
     980:	19033d67 	stmdbne	r3, {r0, r1, r2, r5, r6, r8, sl, fp, ip, sp}
     984:	a03e7566 	eorsge	r7, lr, r6, ror #10
     988:	1403bb9f 	strne	fp, [r3], #-2975	; 0xb9f
  destination = (unsigned char *)&_ebss;
     98c:	03756866 	cmneq	r5, #6684672	; 0x660000
     990:	674b7412 	smlaldvs	r7, fp, r2, r4
  while (source < destination ) {
     994:	2f3d673d 	svccs	0x003d673d
    *source++ = 0;
     998:	83661103 	cmnhi	r6, #-1073741824	; 0xc0000000
     99c:	75597530 	ldrbvc	r7, [r9, #-1328]	; 0x530
     9a0:	032f3d5a 	teqeq	pc, #5760	; 0x1680
     9a4:	30839010 	addcc	r9, r3, r0, lsl r0
  }

  /* clear bss section */
  source = (unsigned char *)&_sbss;
  destination = (unsigned char *)&_ebss;
  while (source < destination ) {
     9a8:	5a755975 	bpl	1d56f84 <__etext+0x1d4e2dc>
     9ac:	c9032f3e 	stmdbgt	r3, {r1, r2, r3, r4, r5, r8, r9, sl, fp, sp}
    *source++ = 0;
  }
 //进入系统初始化函数
  SystemInit();
     9b0:	76689000 	strbtvc	r9, [r8], -r0
 //进入用户函数
  main();
     9b4:	02843f3d 	addeq	r3, r4, #244	; 0xf4
 * \param  void
 *
 * \return void
 */
void SystemInit(void)
{
     9b8:	754b1a45 	strbvc	r1, [fp, #-2629]	; 0xa45
  //使能所有IO口时钟
  SIM_SCGC5 |= (SIM_SCGC5_PORTA_MASK | SIM_SCGC5_PORTB_MASK
     9bc:	23754b22 	cmncs	r5, #34816	; 0x8800
     9c0:	ad23ad4b 	stcge	13, cr10, [r3, #-300]!	; 0xfffffed4
     9c4:	ad23ad23 	stcge	13, cr10, [r3, #-140]!	; 0xffffff74
     9c8:	ad25ad23 	stcge	13, cr10, [r5, #-140]!	; 0xffffff74
     9cc:	3f2e0a03 	svccc	0x002e0a03
     9d0:	020b0384 	andeq	r0, fp, #268435458	; 0x10000002
     9d4:	af3d0146 	svcge	0x003d0146
     9d8:	ad23ad1f 	stcge	13, cr10, [r3, #-124]!	; 0xffffff84
     9dc:	ad23ad25 	stcge	13, cr10, [r3, #-148]!	; 0xffffff6c
     9e0:	0b039124 	bleq	e4e78 <__etext+0xdc1d0>
              | SIM_SCGC5_PORTC_MASK | SIM_SCGC5_PORTD_MASK
              | SIM_SCGC5_PORTE_MASK);
  //初始化各部分时钟：系统内核主频、总线时钟、FlexBus时钟、Flash时钟
  LPLD_PLL_Setup(CORE_CLK_MHZ);
     9e4:	9c03412e 	stflss	f4, [r3], {46}	; 0x2e
     9e8:	32323c7f 	eorscc	r3, r2, #32512	; 0x7f00
  
  //更新内核主频
  SystemCoreClockUpdate();
     9ec:	2e2b0333 	mcrcs	3, 1, r0, cr11, cr3, {1}
  
  //获取各部分时钟
  g_core_clock = SystemCoreClock;
     9f0:	2f202f03 	svccs	0x00202f03
     9f4:	03740f03 	cmneq	r4, #12
     9f8:	6a674a0a 	bvs	19d3228 <__etext+0x19ca580>
     9fc:	4c4b6a67 	mcrrmi	10, 6, r6, fp, cr7
     a00:	68674c67 	stmdavs	r7!, {r0, r1, r2, r5, r6, sl, fp, lr}^
  g_bus_clock = g_core_clock / ((uint32_t)((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV2_MASK) >> SIM_CLKDIV1_OUTDIV2_SHIFT)+ 1u);
     a04:	04020068 	streq	r0, [r2], #-104	; 0x68
     a08:	06200601 	strteq	r0, [r0], -r1, lsl #12
     a0c:	3d3f6868 	ldccc	8, cr6, [pc, #-416]!	; 874 <main+0x74>
     a10:	6767673d 			; <UNDEFINED> instruction: 0x6767673d
     a14:	684b6767 	stmdavs	fp, {r0, r1, r2, r5, r6, r8, r9, sl, sp, lr}^
     a18:	673d3d3f 			; <UNDEFINED> instruction: 0x673d3d3f
     a1c:	67676767 	strbvs	r6, [r7, -r7, ror #14]!
     a20:	683d684b 	ldmdavs	sp!, {r0, r1, r3, r6, fp, sp, lr}
     a24:	6609032f 	strvs	r0, [r9], -pc, lsr #6
     a28:	2f31672f 	svccs	0x0031672f
     a2c:	00010267 	andeq	r0, r1, r7, ror #4
     a30:	01f30101 	mvnseq	r0, r1, lsl #2
     a34:	00020000 	andeq	r0, r2, r0
     a38:	00000100 	andeq	r0, r0, r0, lsl #2
  g_flexbus_clock =  g_core_clock / ((uint32_t)((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV3_MASK) >> SIM_CLKDIV1_OUTDIV3_SHIFT)+ 1u);
     a3c:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
     a40:	0101000d 	tsteq	r1, sp
     a44:	00000101 	andeq	r0, r0, r1, lsl #2
     a48:	00000100 	andeq	r0, r0, r0, lsl #2
     a4c:	2f2e2e01 	svccs	0x002e2e01
     a50:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; 9a0 <Reset_Handler+0x8c>
     a54:	682f6269 	stmdavs	pc!, {r0, r3, r5, r6, r9, sp, lr}	; <UNPREDICTABLE>
     a58:	682f0077 	stmdavs	pc!, {r0, r1, r2, r4, r5, r6}	; <UNPREDICTABLE>
     a5c:	2f656d6f 	svccs	0x00656d6f
     a60:	656b6f6d 	strbvs	r6, [fp, #-3949]!	; 0xf6d
     a64:	6d732f72 	ldclvs	15, cr2, [r3, #-456]!	; 0xfffffe38
     a68:	5f747261 	svcpl	0x00747261
     a6c:	2f726163 	svccs	0x00726163
  g_flash_clock =  g_core_clock / ((uint32_t)((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV4_MASK) >> SIM_CLKDIV1_OUTDIV4_SHIFT)+ 1u);
     a70:	2f637273 	svccs	0x00637273
     a74:	2d636367 	stclcs	3, cr6, [r3, #-412]!	; 0xfffffe64
     a78:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
     a7c:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
     a80:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
     a84:	5f342d69 	svcpl	0x00342d69
     a88:	30322d37 	eorscc	r2, r2, r7, lsr sp
     a8c:	33713331 	cmncc	r1, #-1006632960	; 0xc4000000
     a90:	6e69622f 	cdpvs	2, 6, cr6, cr9, cr15, {1}
     a94:	2f2e2e2f 	svccs	0x002e2e2f
     a98:	2f62696c 	svccs	0x0062696c
     a9c:	2f636367 	svccs	0x00636367
     aa0:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
     aa4:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
 
    //初始化系统终端
  systemTerm ();
     aa8:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
 *
 * @brief  更新全局变量SystemCoreClock的值，以便获取最新的系统内核频率。
 *         
 */
void SystemCoreClockUpdate (void) 
{
     aac:	2e342f69 	cdpcs	15, 3, cr2, cr4, cr9, {3}
     ab0:	2f342e37 	svccs	0x00342e37
    uint32_t temp;
    temp =  CPU_XTAL_CLK_HZ *((uint32_t)(MCG_C6 & MCG_C6_VDIV_MASK) + 16u );
     ab4:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
     ab8:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
     abc:	2f2e2e2f 	svccs	0x002e2e2f
     ac0:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
     ac4:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
     ac8:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
     acc:	6e692f69 	cdpvs	15, 6, cr2, cr9, cr9, {3}
     ad0:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xc63
     ad4:	2e2e0065 	cdpcs	0, 2, cr0, cr14, cr5, {3}
     ad8:	2f2e2e2f 	svccs	0x002e2e2f
    temp = (uint32_t)(temp/((uint32_t)(MCG_C5 & MCG_C5_PRDIV_MASK) +1u ))/2;
     adc:	2f62696c 	svccs	0x0062696c
     ae0:	2f757063 	svccs	0x00757063
     ae4:	64616568 	strbtvs	r6, [r1], #-1384	; 0x568
     ae8:	00737265 	rsbseq	r7, r3, r5, ror #4
     aec:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
     af0:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
     af4:	6f632f62 	svcvs	0x00632f62
     af8:	6e6f6d6d 	cdpvs	13, 6, cr6, cr15, cr13, {3}
    SystemCoreClock = temp;
     afc:	77680000 	strbvc	r0, [r8, -r0]!
     b00:	616d645f 	cmnvs	sp, pc, asr r4
     b04:	0100632e 	tsteq	r0, lr, lsr #6
}
     b08:	74730000 	ldrbtvc	r0, [r3], #-0
     b0c:	746e6964 	strbtvc	r6, [lr], #-2404	; 0x964
/*
 * 使能中断
 */

void enable_irq (int irq)
{
     b10:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
     b14:	4b4d0000 	blmi	1340b1c <__etext+0x1337e74>
    int div;
    if (irq > 105)
     b18:	31463036 	cmpcc	r6, r6, lsr r0
     b1c:	00682e35 	rsbeq	r2, r8, r5, lsr lr
        irq = 105;
     b20:	63000003 	movwvs	r0, #3
    div = irq / 32;
     b24:	6f6d6d6f 	svcvs	0x006d6d6f
     b28:	00682e6e 	rsbeq	r2, r8, lr, ror #28
     b2c:	68000004 	stmdavs	r0, {r2}
     b30:	6d645f77 	stclvs	15, cr5, [r4, #-476]!	; 0xfffffe24
    switch (div)
     b34:	00682e61 	rsbeq	r2, r8, r1, ror #28
     b38:	00000001 	andeq	r0, r0, r1
     b3c:	a0020500 	andge	r0, r2, r0, lsl #10
     b40:	03000028 	movweq	r0, #40	; 0x28
     b44:	4b830129 	blmi	fe0c0ff0 <__StackLimit+0xde0c0ff0>
     b48:	2f2f4b4b 	svccs	0x002f4b4b
     b4c:	2f3d3d2f 	svccs	0x003d3d2f
     b50:	2f3d3d2f 	svccs	0x003d3d2f
    {
        case 0x0:
            NVICICPR0 |= 1 << (irq & 0x1F);
     b54:	4b3c0b03 	blmi	f03768 <__etext+0xefaac0>
     b58:	4b3d4b3d 	blmi	f53854 <__etext+0xf4abac>
     b5c:	003d3d3d 	eorseq	r3, sp, sp, lsr sp
     b60:	06010402 	streq	r0, [r1], -r2, lsl #8
     b64:	3d3d063c 	ldccc	6, cr0, [sp, #-240]!	; 0xffffff10
     b68:	02003d3d 	andeq	r3, r0, #3904	; 0xf40
     b6c:	3c060104 	stfccs	f0, [r6], {4}
     b70:	f33e3d06 	vabd.f<illegal width 64>	d3, d14, d6
     b74:	31083f08 	tstcc	r8, r8, lsl #30
     b78:	32084cbc 	andcc	r4, r8, #48128	; 0xbc00
            NVICISER0 |= 1 << (irq & 0x1F);
     b7c:	caca2508 	bgt	ff289fa4 <__StackLimit+0xdf289fa4>
     b80:	e6e73e08 	strbt	r3, [r7], r8, lsl #28
     b84:	ebe608e6 	bl	ff982f24 <__StackLimit+0xdf982f24>
     b88:	43083e08 	movwmi	r3, #36360	; 0x8e08
     b8c:	0200f5e8 	andeq	pc, r0, #973078528	; 0x3a000000
     b90:	003d0104 	eorseq	r0, sp, r4, lsl #2
     b94:	2d010402 	cfstrscs	mvf0, [r1, #-8]
     b98:	92e50832 	rscls	r0, r5, #3276800	; 0x320000
     b9c:	01040200 	mrseq	r0, R12_usr
            break;
     ba0:	0402003d 	streq	r0, [r2], #-61	; 0x3d
        case 0x1:
            NVICICPR1 |= 1 << (irq & 0x1F);
     ba4:	08322d01 	ldmdaeq	r2!, {r0, r8, sl, fp, sp}
     ba8:	083e93e5 	ldmdaeq	lr!, {r0, r2, r5, r6, r7, r8, r9, ip, pc}
     bac:	08e808f6 	stmiaeq	r8!, {r1, r2, r4, r5, r6, r7, fp}^
     bb0:	0f032f22 	svceq	0x00032f22
     bb4:	2f4b7574 	svccs	0x004b7574
     bb8:	75740f03 	ldrbvc	r0, [r4, #-3843]!	; 0xf03
     bbc:	0e032f4b 	cdpeq	15, 0, cr2, cr3, cr11, {2}
     bc0:	d7087574 	smlsdxle	r8, r4, r5, r7
     bc4:	2e090352 	mcrcs	3, 0, r0, cr9, cr2, {2}
     bc8:	0331bf68 	teqeq	r1, #416	; 0x1a0
            NVICISER1 |= 1 << (irq & 0x1F);
     bcc:	bf682e09 	svclt	0x00682e09
     bd0:	2e090331 	mcrcs	3, 0, r0, cr9, cr1, {1}
     bd4:	0331bf68 	teqeq	r1, #416	; 0x1a0
     bd8:	bf682e09 	svclt	0x00682e09
     bdc:	2e090331 	mcrcs	3, 0, r0, cr9, cr1, {1}
     be0:	0331bf68 	teqeq	r1, #416	; 0x1a0
     be4:	bf682e09 	svclt	0x00682e09
     be8:	2e090331 	mcrcs	3, 0, r0, cr9, cr1, {1}
     bec:	0331bf68 	teqeq	r1, #416	; 0x1a0
            break;
        case 0x2:
            NVICICPR2 |= 1 << (irq & 0x1F);
     bf0:	bf682e09 	svclt	0x00682e09
     bf4:	2e090331 	mcrcs	3, 0, r0, cr9, cr1, {1}
     bf8:	0331bf68 	teqeq	r1, #416	; 0x1a0
     bfc:	bf682e09 	svclt	0x00682e09
     c00:	2e090331 	mcrcs	3, 0, r0, cr9, cr1, {1}
     c04:	0331bf68 	teqeq	r1, #416	; 0x1a0
     c08:	bf682e09 	svclt	0x00682e09
     c0c:	2e090331 	mcrcs	3, 0, r0, cr9, cr1, {1}
     c10:	0331bf68 	teqeq	r1, #416	; 0x1a0
     c14:	bf682e09 	svclt	0x00682e09
            NVICISER2 |= 1 << (irq & 0x1F);
     c18:	2e090331 	mcrcs	3, 0, r0, cr9, cr1, {1}
     c1c:	0331bf68 	teqeq	r1, #416	; 0x1a0
     c20:	bf682e09 	svclt	0x00682e09
     c24:	01000102 	tsteq	r0, r2, lsl #2
     c28:	0003ab01 	andeq	sl, r3, r1, lsl #22
     c2c:	1d000200 	sfmne	f0, 4, [r0, #-0]
     c30:	02000001 	andeq	r0, r0, #1
     c34:	0d0efb01 	vstreq	d15, [lr, #-4]
     c38:	01010100 	mrseq	r0, (UNDEF: 17)
            break;
     c3c:	00000001 	andeq	r0, r0, r1
        case 0x3:
            NVICICPR3 |= 1 << (irq & 0x1F);
     c40:	01000001 	tsteq	r0, r1
     c44:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
     c48:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
     c4c:	77682f62 	strbvc	r2, [r8, -r2, ror #30]!
     c50:	6f682f00 	svcvs	0x00682f00
     c54:	6d2f656d 	cfstr32vs	mvfx6, [pc, #-436]!	; aa8 <SystemInit+0xf0>
     c58:	72656b6f 	rsbvc	r6, r5, #113664	; 0x1bc00
     c5c:	616d732f 	cmnvs	sp, pc, lsr #6
     c60:	635f7472 	cmpvs	pc, #1912602624	; 0x72000000
     c64:	732f7261 	teqvc	pc, #268435462	; 0x10000006
            NVICISER3 |= 1 << (irq & 0x1F);
     c68:	672f6372 			; <UNDEFINED> instruction: 0x672f6372
     c6c:	612d6363 	teqvs	sp, r3, ror #6
     c70:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
     c74:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
     c78:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
     c7c:	375f342d 	ldrbcc	r3, [pc, -sp, lsr #8]
     c80:	3130322d 	teqcc	r0, sp, lsr #4
     c84:	2f337133 	svccs	0x00337133
     c88:	2f6e6962 	svccs	0x006e6962
            break;
    }
}
     c8c:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; bdc <enable_irq+0xcc>
     c90:	672f6269 	strvs	r6, [pc, -r9, ror #4]!
     c94:	612f6363 	teqvs	pc, r3, ror #6
/*
 * 关闭中断
 */

void disable_irq (int irq)
{
     c98:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
     c9c:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
    int div;
    if (irq > 105)
     ca0:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
     ca4:	372e342f 	strcc	r3, [lr, -pc, lsr #8]!
        irq = 105;
     ca8:	2e2f342e 	cdpcs	4, 2, cr3, cr15, cr14, {1}
    div = irq / 32;
     cac:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
     cb0:	2f2e2e2f 	svccs	0x002e2e2f
     cb4:	612f2e2e 	teqvs	pc, lr, lsr #28
     cb8:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    switch (div)
     cbc:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
     cc0:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
     cc4:	636e692f 	cmnvs	lr, #770048	; 0xbc000
     cc8:	6564756c 	strbvs	r7, [r4, #-1388]!	; 0x56c
     ccc:	2f2e2e00 	svccs	0x002e2e00
     cd0:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; c20 <enable_irq+0x110>
     cd4:	632f6269 	teqvs	pc, #-1879048186	; 0x90000006
    {
        case 0x0:
            NVICICPR0 |= 1 << (irq & 0x1F);
     cd8:	682f7570 	stmdavs	pc!, {r4, r5, r6, r8, sl, ip, sp, lr}	; <UNPREDICTABLE>
     cdc:	65646165 	strbvs	r6, [r4, #-357]!	; 0x165
     ce0:	2e007372 	mcrcs	3, 0, r7, cr0, cr2, {3}
     ce4:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
     ce8:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
     cec:	6d6f632f 	stclvs	3, cr6, [pc, #-188]!	; c38 <enable_irq+0x128>
     cf0:	006e6f6d 	rsbeq	r6, lr, sp, ror #30
     cf4:	5f776800 	svcpl	0x00776800
     cf8:	2e6d7466 	cdpcs	4, 6, cr7, cr13, cr6, {3}
     cfc:	00010063 	andeq	r0, r1, r3, rrx
            break;
     d00:	64747300 	ldrbtvs	r7, [r4], #-768	; 0x300
        case 0x1:
            NVICICPR1 |= 1 << (irq & 0x1F);
     d04:	2e746e69 	cdpcs	14, 7, cr6, cr4, cr9, {3}
     d08:	00020068 	andeq	r0, r2, r8, rrx
     d0c:	364b4d00 	strbcc	r4, [fp], -r0, lsl #26
     d10:	35314630 	ldrcc	r4, [r1, #-1584]!	; 0x630
     d14:	0300682e 	movweq	r6, #2094	; 0x82e
     d18:	6f630000 	svcvs	0x00630000
     d1c:	6e6f6d6d 	cdpvs	13, 6, cr6, cr15, cr13, {3}
     d20:	0400682e 	streq	r6, [r0], #-2094	; 0x82e
     d24:	4f4d0000 	svcmi	0x004d0000
     d28:	72445f53 	subvc	r5, r4, #332	; 0x14c
            break;
        case 0x2:
            NVICICPR2 |= 1 << (irq & 0x1F);
     d2c:	72657669 	rsbvc	r7, r5, #110100480	; 0x6900000
     d30:	00682e73 	rsbeq	r2, r8, r3, ror lr
     d34:	68000001 	stmdavs	r0, {r0}
     d38:	74665f77 	strbtvc	r5, [r6], #-3959	; 0xf77
     d3c:	00682e6d 	rsbeq	r2, r8, sp, ror #28
     d40:	68000001 	stmdavs	r0, {r0}
     d44:	636d5f77 	cmnvs	sp, #476	; 0x1dc
     d48:	00682e67 	rsbeq	r2, r8, r7, ror #28
     d4c:	00000001 	andeq	r0, r0, r1
     d50:	c0020500 	andgt	r0, r2, r0, lsl #10
            break;
     d54:	03000030 	movweq	r0, #48	; 0x30
        case 0x3:
            NVICICPR3 |= 1 << (irq & 0x1F);
     d58:	76860130 			; <UNDEFINED> instruction: 0x76860130
     d5c:	764c083d 			; <UNDEFINED> instruction: 0x764c083d
     d60:	764c083d 			; <UNDEFINED> instruction: 0x764c083d
     d64:	764c083d 			; <UNDEFINED> instruction: 0x764c083d
     d68:	3f4e083d 	svccc	0x004e083d
     d6c:	e65ae65a 			; <UNDEFINED> instruction: 0xe65ae65a
     d70:	d95ae65a 	ldmdble	sl, {r1, r3, r4, r6, r9, sl, sp, lr, pc}^
     d74:	4c833e3f 	stcmi	14, cr3, [r3], {63}	; 0x3f
     d78:	0f03216b 	svceq	0x0003216b
     d7c:	08768390 	ldmdaeq	r6!, {r4, r7, r8, r9, pc}^
            break;
    }
}
     d80:	4c08764c 	stcmi	6, cr7, [r8], {76}	; 0x4c
     d84:	764c0876 			; <UNDEFINED> instruction: 0x764c0876
     d88:	c93f4e08 	ldmdbgt	pc!, {r3, r9, sl, fp, lr}	; <UNPREDICTABLE>
/*
 * 系统终端初始化函数
 */

 void systemTerm (void)
 {
     d8c:	86662f03 	strbthi	r2, [r6], -r3, lsl #30
     d90:	3f9f4059 	svccc	0x009f4059
     UART_InitTypeDef uart_init_struct;
     uart_init_struct.UART_Uartx = TERM_PORT;
     d94:	e93d6a4c 	ldmdb	sp!, {r2, r3, r6, r9, fp, sp, lr}
     d98:	032f92a0 	teqeq	pc, #10
     uart_init_struct.UART_BaudRate = TERM_BAUD;
     d9c:	5978661c 	ldmdbpl	r8!, {r2, r3, r4, r9, sl, sp, lr}^
     da0:	3d6abc41 	stclcc	12, cr11, [sl, #-260]!	; 0xfffffefc
     uart_init_struct.UART_RxPin = TERM_RX;
     da4:	032f92e7 	teqeq	pc, #1879048206	; 0x7000000e
     uart_init_struct.UART_TxPin = TERM_TX;
     da8:	5967661a 	stmdbpl	r7!, {r1, r3, r4, r9, sl, sp, lr}^
     dac:	032fa09f 	teqeq	pc, #159	; 0x9f
     uart_init_struct.UART_RxIntEnable = TERM_RX_IRQ;
     db0:	9f755830 	svcls	0x00755830
     uart_init_struct.UART_RxIsr = TERM_RX_FUN;
     db4:	2208a03e 	andcs	sl, r8, #62	; 0x3e
     db8:	22082108 	andcs	r2, r8, #2

     LPLD_UART_Init (uart_init_struct);
     dbc:	22082108 	andcs	r2, r8, #2
     dc0:	032f2208 	teqeq	pc, #-2147483648	; 0x80000000
     dc4:	754b6611 	strbvc	r6, [fp, #-1553]	; 0x611
#if (TERM_RX_IRQ == TRUE)
     LPLD_UART_EnableIrq (uart_init_struct);
#endif

 }
     dc8:	4b741103 	blmi	1d051dc <__etext+0x1cfc534>
     dcc:	661a0367 	ldrvs	r0, [sl], -r7, ror #6
//图像状态
volatile IMG_STATUS_e ov7725_eagle_img_flag = IMG_FINISH;

//ov7725初始化 
uint8 Ov7725_Init (void)
{
     dd0:	1a03c967 	bne	f3374 <__etext+0xea6cc>
     dd4:	21086774 	tstcs	r8, r4, ror r7
    uint16 i = 0;
     dd8:	67661a03 	strbvs	r1, [r6, -r3, lsl #20]!
    uint8 device_Id = 0;
     ddc:	74110391 	ldrvc	r0, [r1], #-913	; 0x391
     de0:	1103914b 	tstne	r3, fp, asr #2
    uint8 reg_Buff[50] = {0};
     de4:	033d4b74 	teqeq	sp, #118784	; 0x1d000
     de8:	4b4b7411 	blmi	12dde34 <__etext+0x12d518c>
     dec:	84661003 	strbthi	r1, [r6], #-3
     df0:	754b7530 	strbvc	r7, [fp, #-1328]	; 0x530
     df4:	754b754b 	strbvc	r7, [fp, #-1355]	; 0x54b
     df8:	2f683e4c 	svccs	0x00683e4c
     dfc:	84901003 	ldrhi	r1, [r0], #3
     e00:	754b7530 	strbvc	r7, [fp, #-1328]	; 0x530
     e04:	754b754b 	strbvc	r7, [fp, #-1355]	; 0x54b
     e08:	2f683e4c 	svccs	0x00683e4c
     e0c:	83901a03 	orrshi	r1, r0, #12288	; 0x3000
     e10:	3e9f3d9f 	mrccc	13, 4, r3, cr15, cr15, {4}
     e14:	6610032f 	ldrvs	r0, [r0], -pc, lsr #6
     e18:	833d834b 	teqhi	sp, #738197505	; 0x2c000001
     e1c:	866d2f3e 	uqasxhi	r2, sp, lr
     e20:	3d3d2f2f 	ldccc	15, cr2, [sp, #-188]!	; 0xffffff44
     e24:	683e3d33 	ldmdavs	lr!, {r0, r1, r4, r5, r8, sl, fp, ip, sp}
     e28:	01040200 	mrseq	r0, R12_usr
     e2c:	3e064a06 	vmlacc.f32	s8, s12, s12
     e30:	bc2f3dbc 	stclt	13, cr3, [pc], #-752	; b48 <enable_irq+0x38>
     e34:	3dbc2f3d 	ldccc	15, cr2, [ip, #244]!	; 0xf4
     e38:	2f3dbc2f 	svccs	0x003dbc2f
     e3c:	bc2f3dbc 	stclt	13, cr3, [pc], #-752	; b54 <enable_irq+0x44>
     e40:	3dbc2f3d 	ldccc	15, cr2, [ip, #244]!	; 0xf4
     e44:	033da02f 	teqeq	sp, #47	; 0x2f
     e48:	4f3f3c0b 	svcmi	0x003f3c0b
     e4c:	9f3e4c4b 	svcls	0x003e4c4b
     e50:	892f7641 	stmdbhi	pc!, {r0, r6, r9, sl, ip, sp, lr}	; <UNPREDICTABLE>
     e54:	332f3d84 	teqcc	pc, #8448	; 0x2100
     e58:	4c5a3d3d 	mrrcmi	13, 3, r3, sl, cr13
     e5c:	594b4b4b 	stmdbpl	fp, {r0, r1, r3, r6, r8, r9, fp, lr}^
     e60:	3e69a050 	mcrcc	0, 3, sl, cr9, cr0, {2}
     e64:	4b754b75 	blmi	1d53c40 <__etext+0x1d4af98>

    LPLD_SCCB_Init ();
     e68:	4c754b75 	ldclmi	11, cr4, [r5], #-468	; 0xfffffe2c
    
    Ov7725_Delay();
     e6c:	7b2f853d 	blvc	be2368 <__etext+0xbd96c0>

    while (!LPLD_SCCB_WriteReg (OV7725_COM7, 0x80))
     e70:	77088484 	strvc	r8, [r8, -r4, lsl #9]
    {
        if (i ++ >= 500)
     e74:	3d2adb3d 	fstmdbxcc	sl!, {d13-d42}	;@ Deprecated
     e78:	3d4d2dd9 	stclcc	13, cr2, [sp, #-868]	; 0xfffffc9c
     e7c:	d93d2adb 	ldmdble	sp!, {r0, r1, r3, r4, r6, r7, r9, fp, sp}
     e80:	db3d4d2d 	blle	f5433c <__etext+0xf4b694>
     e84:	1fd93d2a 	svcne	0x00d93d2a
     e88:	1cdb3d3f 	ldclne	13, cr3, [fp], {63}	; 0x3f
     e8c:	3f1fd93d 	svccc	0x001fd93d
            return 0;
     e90:	3d1cdb3d 	vldrcc	d13, [ip, #-244]	; 0xffffff0c

    LPLD_SCCB_Init ();
    
    Ov7725_Delay();

    while (!LPLD_SCCB_WriteReg (OV7725_COM7, 0x80))
     e94:	3d3f1fd9 	ldccc	15, cr1, [pc, #-868]!	; b38 <enable_irq+0x28>
     e98:	d93d1cdb 	ldmdble	sp!, {r0, r1, r3, r4, r6, r7, sl, fp, ip}
     e9c:	db3d3f1f 	blle	f50b20 <__etext+0xf47e78>
     ea0:	1fd93d1c 	svcne	0x00d93d1c
     ea4:	1cdb3d3f 	ldclne	13, cr3, [fp], {63}	; 0x3f
    {
        if (i ++ >= 500)
            return 0;
    }

    Ov7725_Delay();
     ea8:	3f2dd93d 	svccc	0x002dd93d
    
    while (0 == LPLD_SCCB_ReadReg (OV7725_VER, &device_Id, 1));
     eac:	a108843f 	tstge	r8, pc, lsr r4
     eb0:	7a03dd3d 	bvc	f83ac <__etext+0xef704>
     eb4:	1cdb3d20 	ldclne	13, cr3, [fp], {32}
     eb8:	3f1fd93d 	svccc	0x001fd93d
     ebc:	7a03dd3d 	bvc	f83b8 <__etext+0xef710>
     ec0:	1cdb3d20 	ldclne	13, cr3, [fp], {32}

    printf ("You get ID success, SENSOR ID is 0x%x", device_Id);
     ec4:	3f1fd93d 	svccc	0x001fd93d
     ec8:	7a03dd3d 	bvc	f83c4 <__etext+0xef71c>
     ecc:	1cbf3d20 	ldcne	13, cr3, [pc], #128	; f54 <Ov7725_Init+0x184>
     ed0:	3f2dd93d 	svccc	0x002dd93d
     ed4:	c93de53d 	ldmdbgt	sp!, {r0, r2, r3, r4, r5, r8, sl, sp, lr, pc}
    printf ("nconfig register Number is %d\n", ov7725_eagle_cfgnum);
     ed8:	3f3ee63d 	svccc	0x003ee63d
     edc:	3daf0884 	stccc	8, cr0, [pc, #528]!	; 10f4 <Ov7725_eagle_vsync+0x38>
     ee0:	d93d1cdb 	ldmdble	sp!, {r0, r1, r3, r4, r6, r7, sl, fp, ip}
     ee4:	db3d3f1f 	blle	f50b68 <__etext+0xf47ec0>
     ee8:	1fd93d1c 	svcne	0x00d93d1c
     eec:	1cdb3d3f 	ldclne	13, cr3, [fp], {63}	; 0x3f

    //判断摄像头是否为ov7725
    if (device_Id == OV7725_ID)
     ef0:	3f1fd93d 	svccc	0x001fd93d
     ef4:	3d1cdb3d 	vldrcc	d13, [ip, #-244]	; 0xffffff0c
    {
        for (i = 0; i < ov7725_eagle_cfgnum; i++)
     ef8:	3f3f2dd9 	svccc	0x003f2dd9
     efc:	3d770884 	ldclcc	8, cr0, [r7, #-528]!	; 0xfffffdf0
        {
            if (0 == LPLD_SCCB_WriteReg(ov7725_eagle_reg[i].addr, ov7725_eagle_reg[i].val))
     f00:	d93d1cdb 	ldmdble	sp!, {r0, r1, r3, r4, r6, r7, sl, fp, ip}
     f04:	db3d3f1f 	blle	f50b88 <__etext+0xf47ee0>
     f08:	1fd93d1c 	svcne	0x00d93d1c
     f0c:	1cdb3d3f 	ldclne	13, cr3, [fp], {63}	; 0x3f
     f10:	3f1fd93d 	svccc	0x001fd93d
     f14:	3d1cdb3d 	vldrcc	d13, [ip, #-244]	; 0xffffff0c
     f18:	3d3f1fd9 	ldccc	15, cr1, [pc, #-868]!	; bbc <enable_irq+0xac>
     f1c:	d93d1cdb 	ldmdble	sp!, {r0, r1, r3, r4, r6, r7, sl, fp, ip}
     f20:	db3d3f1f 	blle	f50ba4 <__etext+0xf47efc>
     f24:	1fd93d1c 	svcne	0x00d93d1c
     f28:	1cdb3d3f 	ldclne	13, cr3, [fp], {63}	; 0x3f
     f2c:	3f1fd93d 	svccc	0x001fd93d
            {
               printf ("error: writeReg error 0x%x\n", ov7725_eagle_reg[i].addr);
     f30:	3d1cdb3d 	vldrcc	d13, [ip, #-244]	; 0xffffff0c
     f34:	413f2dd9 			; <UNDEFINED> instruction: 0x413f2dd9
     f38:	687b2f3e 	ldmdavs	fp!, {r1, r2, r3, r4, r5, r8, r9, sl, fp, sp}^
     f3c:	9f770884 	svcls	0x00770884
     f40:	2275ad75 	rsbscs	sl, r5, #7488	; 0x1d40
     f44:	75ad759f 	strvc	r7, [sp, #1439]!	; 0x59f
     f48:	ad759f22 	ldclge	15, cr9, [r5, #-136]!	; 0xffffff78
                return 0;
     f4c:	759f2275 	ldrvc	r2, [pc, #629]	; 11c9 <Ov7725_img_extract+0x41>
            }
            if (LPLD_SCCB_ReadReg(ov7725_eagle_reg[i].addr, &reg_Buff[i], 1))
     f50:	9f2275ad 	svcls	0x002275ad
     f54:	2275ad75 	rsbscs	sl, r5, #7488	; 0x1d40
     f58:	75ad759f 	strvc	r7, [sp, #1439]!	; 0x59f
     f5c:	ad759f22 	ldclge	15, cr9, [r5, #-136]!	; 0xffffff78
     f60:	759f2275 	ldrvc	r2, [pc, #629]	; 11dd <Ov7725_img_extract+0x55>
     f64:	3f3075ad 	svccc	0x003075ad
     f68:	9faf0884 	svcls	0x00af0884
     f6c:	ad759f75 	ldclge	15, cr9, [r5, #-468]!	; 0xfffffe2c
     f70:	759f2275 	ldrvc	r2, [pc, #629]	; 11ed <Ov7725_img_extract+0x65>
     f74:	75ad759f 	strvc	r7, [sp, #1439]!	; 0x59f
            {
                printf ("writeRe 0x%x success: 0x%x\n", ov7725_eagle_reg[i].addr, reg_Buff[i]);
     f78:	9f759f22 	svcls	0x00759f22
     f7c:	2275ad75 	rsbscs	sl, r5, #7488	; 0x1d40
     f80:	759f759f 	ldrvc	r7, [pc, #1439]	; 1527 <Ov7725_Dma_Init+0xeb>
     f84:	3f3075ad 	svccc	0x003075ad
     f88:	9faf0884 	svcls	0x00af0884
     f8c:	2275ad75 	rsbscs	sl, r5, #7488	; 0x1d40
     f90:	759f759f 	ldrvc	r7, [pc, #1439]	; 1537 <Ov7725_Dma_Init+0xfb>
     f94:	9f759f22 	svcls	0x00759f22
     f98:	759f2275 	ldrvc	r2, [pc, #629]	; 1215 <Ov7725_img_extract+0x8d>
     f9c:	3f30759f 	svccc	0x0030759f
     fa0:	7f81037c 	svcvc	0x0081037c
    printf ("nconfig register Number is %d\n", ov7725_eagle_cfgnum);

    //判断摄像头是否为ov7725
    if (device_Id == OV7725_ID)
    {
        for (i = 0; i < ov7725_eagle_cfgnum; i++)
     fa4:	3434343c 	ldrtcc	r3, [r4], #-1084	; 0x43c
     fa8:	34343434 	ldrtcc	r3, [r4], #-1076	; 0x434
     fac:	362e1003 	strtcc	r1, [lr], -r3
     fb0:	0e033636 	mcreq	6, 0, r3, cr3, cr6, {1}
     fb4:	3434342e 	ldrtcc	r3, [r4], #-1070	; 0x42e
     fb8:	2f200f03 	svccs	0x00200f03
            }
        }
    }
    else
    {
        return 0;
     fbc:	303d836d 	eorscc	r8, sp, sp, ror #6
     fc0:	4c4b4b68 	mcrrmi	11, 6, r4, fp, cr8
    }
    return 1;
     fc4:	772f8483 	strvc	r8, [pc, -r3, lsl #9]!

}
     fc8:	36602f76 	uqsub16cc	r2, r0, r6
     fcc:	6b36316b 	blvs	d8d580 <__etext+0xd848d8>

//ov7725延时函数
void Ov7725_Delay(void)
{
     fd0:	026b3631 	rsbeq	r3, fp, #51380224	; 0x3100000
     fd4:	01010001 	tsteq	r1, r1
    uint16 i, n;
    for (i = 0; i < 3000; i++)
     fd8:	000001a1 	andeq	r0, r0, r1, lsr #3
     fdc:	01020002 	tsteq	r2, r2
    {
        for (n = 0; n < 200; n++)
     fe0:	01020000 	mrseq	r0, (UNDEF: 2)
     fe4:	000d0efb 	strdeq	r0, [sp], -fp
     fe8:	01010101 	tsteq	r1, r1, lsl #2
     fec:	01000000 	mrseq	r0, (UNDEF: 0)
     ff0:	2e010000 	cdpcs	0, 0, cr0, cr1, cr0, {0}
     ff4:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}

//ov7725延时函数
void Ov7725_Delay(void)
{
    uint16 i, n;
    for (i = 0; i < 3000; i++)
     ff8:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
     ffc:	0077682f 	rsbseq	r6, r7, pc, lsr #16
    1000:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	; f4c <Ov7725_Init+0x17c>
    1004:	6f6d2f65 	svcvs	0x006d2f65
        for (n = 0; n < 200; n++)
        {
            asm("nop");
        }
    }
}
    1008:	2f72656b 	svccs	0x0072656b
    100c:	72616d73 	rsbvc	r6, r1, #7360	; 0x1cc0
    1010:	61635f74 	smcvs	13812	; 0x35f4

//DMA中断触发函数
void Ov7725_eagle_dma (void)
{
    1014:	72732f72 	rsbsvc	r2, r3, #456	; 0x1c8
    1018:	63672f63 	cmnvs	r7, #396	; 0x18c
    ov7725_eagle_img_flag = IMG_FINISH;
    101c:	72612d63 	rsbvc	r2, r1, #6336	; 0x18c0
    1020:	6f6e2d6d 	svcvs	0x006e2d6d
    1024:	652d656e 	strvs	r6, [sp, #-1390]!	; 0x56e
    //关闭DMA通道
    DMA_DIS(DMA_CH0);
    1028:	2d696261 	sfmcs	f6, 2, [r9, #-388]!	; 0xfffffe7c
    102c:	2d375f34 	ldccs	15, cr5, [r7, #-208]!	; 0xffffff30
    1030:	33313032 	teqcc	r1, #50	; 0x32
    1034:	622f3371 	eorvs	r3, pc, #-1006632959	; 0xc4000001
    1038:	2e2f6e69 	cdpcs	14, 2, cr6, cr15, cr9, {3}
    103c:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
    //DMA0->INT |= 0x1u << 0;
    //enable_irq(INT_PORTA - 16);
    //图片进行解压
    Ov7725_img_extract(Pix_Data, img, PHOTO_SIZE/8);
    1040:	63672f62 	cmnvs	r7, #392	; 0x188
    1044:	72612f63 	rsbvc	r2, r1, #396	; 0x18c
    1048:	6f6e2d6d 	svcvs	0x006e2d6d
    104c:	652d656e 	strvs	r6, [sp, #-1390]!	; 0x56e
    1050:	2f696261 	svccs	0x00696261
    1054:	2e372e34 	mrccs	14, 1, r2, cr7, cr4, {1}
    //解压完成标志置位
    ready_send_flag = 1;
    1058:	2e2e2f34 	mcrcs	15, 1, r2, cr14, cr4, {1}
    105c:	2f2e2e2f 	svccs	0x002e2e2f
    1060:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    1064:	72612f2e 	rsbvc	r2, r1, #184	; 0xb8
    get_midline(Pix_Data, 60, 80);
    1068:	6f6e2d6d 	svcvs	0x006e2d6d
    106c:	652d656e 	strvs	r6, [sp, #-1390]!	; 0x56e
    1070:	2f696261 	svccs	0x00696261
    1074:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
    1078:	00656475 	rsbeq	r6, r5, r5, ror r4
         //重新装载DMA目标地址
        DMA_DADDR(DMA_CH0) = (uint32)img;
    107c:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    1080:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
    1084:	70632f62 	rsbvc	r2, r3, r2, ror #30
    1088:	65682f75 	strbvs	r2, [r8, #-3957]!	; 0xf75
    108c:	72656461 	rsbvc	r6, r5, #1627389952	; 0x61000000
    1090:	2e2e0073 	mcrcs	0, 1, r0, cr14, cr3, {3}
   //Ov7725_sendimg(Pix_Data, PHOTO_SIZE);
    //clear PORTA isr set bit
    PORTA_ISFR = ~0;
    1094:	2f2e2e2f 	svccs	0x002e2e2f
    1098:	2f62696c 	svccs	0x0062696c
    109c:	6d6d6f63 	stclvs	15, cr6, [sp, #-396]!	; 0xfffffe74
    10a0:	00006e6f 	andeq	r6, r0, pc, ror #28
    LPLD_GPIO_EnableIrq(OV_PTA_init);
    10a4:	675f7768 	ldrbvs	r7, [pc, -r8, ror #14]
    10a8:	2e6f6970 	mcrcs	9, 3, r6, cr15, cr0, {3}
    10ac:	00010063 	andeq	r0, r1, r3, rrx
    10b0:	64747300 	ldrbtvs	r7, [r4], #-768	; 0x300
    10b4:	2e746e69 	cdpcs	14, 7, cr6, cr4, cr9, {3}
    //DMA0->INT |= 0x1u << 0;
}
    10b8:	00020068 	andeq	r0, r2, r8, rrx

//场中断开始判断函数
void Ov7725_eagle_vsync(void)
{
    10bc:	364b4d00 	strbcc	r4, [fp], -r0, lsl #26
    //printf ("runing eagle_vsync\n");
    //判断场中断是否开始
    if (ov7725_eagle_img_flag == IMG_START)
    10c0:	35314630 	ldrcc	r4, [r1, #-1584]!	; 0x630
    10c4:	0300682e 	movweq	r6, #2094	; 0x82e
    10c8:	6f630000 	svcvs	0x00630000
    10cc:	6e6f6d6d 	cdpvs	13, 6, cr6, cr15, cr13, {3}
    {
        ov7725_eagle_img_flag = IMG_GATHER;
    10d0:	0400682e 	streq	r6, [r0], #-2094	; 0x82e
    10d4:	77680000 	strbvc	r0, [r8, -r0]!
    10d8:	6970675f 	ldmdbvs	r0!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, sp, lr}^
    10dc:	00682e6f 	rsbeq	r2, r8, pc, ror #28
        disable_irq (INT_PORTA - 16);
    10e0:	00000001 	andeq	r0, r0, r1
    10e4:	90020500 	andls	r0, r2, r0, lsl #10
        //LPLD_GPIO_DisableIrq(OV_PTA_init);
        //enable_irq (DMA_CH0 + INT_DMA0_DMA16 - 16);
        DMA_EN(DMA_CH0);
    10e8:	0300004c 	movweq	r0, #76	; 0x4c
    10ec:	1f870113 	svcne	0x00870113
    10f0:	3d2f2f3e 	stccc	15, cr2, [pc, #-248]!	; 1000 <Ov7725_Delay+0x30>
    10f4:	75677540 	strbvc	r7, [r7, #-1344]!	; 0x540
    10f8:	75677567 	strbvc	r7, [r7, #-1383]!	; 0x567
    10fc:	75677567 	strbvc	r7, [r7, #-1383]!	; 0x567
        //LPLD_DMA_EnableIrq(OV_dma_init);
        //重新装载DMA目标地址
        DMA_DADDR(DMA_CH0) = (uint32)img;
    1100:	673e3e68 	ldrvs	r3, [lr, -r8, ror #28]!
    1104:	8578763d 	ldrbhi	r7, [r8, #-1597]!	; 0x63d
    1108:	0055834c 	subseq	r8, r5, ip, asr #6
    110c:	06010402 	streq	r0, [r1], -r2, lsl #8
    1110:	3e42064a 	cdpcc	6, 4, cr0, cr2, cr10, {2}
    1114:	83821003 	orrhi	r1, r2, #3
    1118:	3d3d302f 	ldccc	0, cr3, [sp, #-188]!	; 0xffffff44
    }
    else
    {
        //disable_irq (INT_PORTA);
        //LPLD_GPIO_DisableIrq(OV_PTA_init);
        disable_irq (INT_PORTA - 16);
    111c:	765a6776 			; <UNDEFINED> instruction: 0x765a6776
    1120:	4b76764b 	blmi	1d9ea54 <__etext+0x1d95dac>
        ov7725_eagle_img_flag = IMG_FAIL;
    1124:	764b7676 			; <UNDEFINED> instruction: 0x764b7676
    1128:	3d774b76 	vldmdbcc	r7!, {d20-<overflow reg d78>}
    112c:	9010032f 	andsls	r0, r0, pc, lsr #6
    }
}
    1130:	75303084 	ldrvc	r3, [r0, #-132]!	; 0x84

//ov7725开始采集图像
void Ov7725_eagle_get_img(void)
{
    1134:	75677567 	strbvc	r7, [r7, #-1383]!	; 0x567
    1138:	75677567 	strbvc	r7, [r7, #-1383]!	; 0x567
    ov7725_eagle_img_flag = IMG_START;
    113c:	3e687567 	cdpcc	5, 6, cr7, cr8, cr7, {3}
    1140:	009b834c 	addseq	r8, fp, ip, asr #6
    1144:	06010402 	streq	r0, [r1], -r2, lsl #8
    //write 1 clear int 
    PORTA_ISFR = ~0;
    1148:	2f41064a 	svccs	0x0041064a
    114c:	59820903 	stmibpl	r2, {r0, r1, r8, fp}
    1150:	08835b67 	stmeq	r3, {r0, r1, r2, r5, r6, r8, r9, fp, ip, lr}
    1154:	58090313 	stmdapl	r9, {r0, r1, r4, r8, r9}
    DMA_DADDR(DMA_CH0) = (uint32)img;
    1158:	675b6759 			; <UNDEFINED> instruction: 0x675b6759
    115c:	3d4c6e9f 	stclcc	14, cr6, [ip, #-636]	; 0xfffffd84
    1160:	91676921 	cmnls	r7, r1, lsr #18
    1164:	83672f7a 	cmnhi	r7, #488	; 0x1e8
    1168:	83672f30 	cmnhi	r7, #192	; 0xc0
    116c:	83672f30 	cmnhi	r7, #192	; 0xc0
    1170:	83672f31 	cmnhi	r7, #196	; 0xc4
    LPLD_GPIO_EnableIrq(OV_PTA_init);
    1174:	83672f31 	cmnhi	r7, #196	; 0xc4
    1178:	01000102 	tsteq	r0, r2, lsl #2
    117c:	00018101 	andeq	r8, r1, r1, lsl #2
    1180:	04000200 	streq	r0, [r0], #-512	; 0x200
}
    1184:	02000001 	andeq	r0, r0, #1
 *  @param      srclen          二值化图像的占用空间大小
 *  @since      v5.0            img_extract(img, imgbuff,CAMERA_SIZE);
 *  Sample usage:   sendimg(imgbuff, CAMERA_W * CAMERA_H);                    //发送到上位机
 */
void Ov7725_img_extract(uint8 *dst, uint8 *src, uint32 srclen)
{
    1188:	0d0efb01 	vstreq	d15, [lr, #-4]
    118c:	01010100 	mrseq	r0, (UNDEF: 17)
    1190:	00000001 	andeq	r0, r0, r1
    uint8 colour[2] = {255, 0}; //0 和 1 分别对应的颜色
    1194:	01000001 	tsteq	r0, r1
    1198:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    119c:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
    //注：野火的摄像头 1(or255)表示 白色，0表示 黑色
    uint8 tmpsrc;
    while(srclen --)
    11a0:	77682f62 	strbvc	r2, [r8, -r2, ror #30]!
    {
        tmpsrc = *src++;
    11a4:	6f682f00 	svcvs	0x00682f00
    11a8:	6d2f656d 	cfstr32vs	mvfx6, [pc, #-436]!	; ffc <Ov7725_Delay+0x2c>
    11ac:	72656b6f 	rsbvc	r6, r5, #113664	; 0x1bc00
        *dst++ = colour[(tmpsrc >> 7) & 0x01];
    11b0:	616d732f 	cmnvs	sp, pc, lsr #6
    11b4:	635f7472 	cmpvs	pc, #1912602624	; 0x72000000
    11b8:	732f7261 	teqvc	pc, #268435462	; 0x10000006
    11bc:	672f6372 			; <UNDEFINED> instruction: 0x672f6372
    11c0:	612d6363 	teqvs	sp, r3, ror #6
    11c4:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    11c8:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
    11cc:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    11d0:	375f342d 	ldrbcc	r3, [pc, -sp, lsr #8]
        *dst++ = colour[(tmpsrc >> 6) & 0x01];
    11d4:	3130322d 	teqcc	r0, sp, lsr #4
    11d8:	2f337133 	svccs	0x00337133
    11dc:	2f6e6962 	svccs	0x006e6962
    11e0:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; 1130 <Ov7725_eagle_vsync+0x74>
    11e4:	672f6269 	strvs	r6, [pc, -r9, ror #4]!
    11e8:	612f6363 	teqvs	pc, r3, ror #6
    11ec:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    11f0:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
        *dst++ = colour[(tmpsrc >> 5) & 0x01];
    11f4:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    11f8:	372e342f 	strcc	r3, [lr, -pc, lsr #8]!
    11fc:	2e2f342e 	cdpcs	4, 2, cr3, cr15, cr14, {1}
    1200:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    1204:	2f2e2e2f 	svccs	0x002e2e2f
    1208:	612f2e2e 	teqvs	pc, lr, lsr #28
    120c:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    1210:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
    1214:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
        *dst++ = colour[(tmpsrc >> 4) & 0x01];
    1218:	636e692f 	cmnvs	lr, #770048	; 0xbc000
    121c:	6564756c 	strbvs	r7, [r4, #-1388]!	; 0x56c
    1220:	2f2e2e00 	svccs	0x002e2e00
    1224:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; 1174 <Ov7725_eagle_get_img+0x40>
    1228:	632f6269 	teqvs	pc, #-1879048186	; 0x90000006
    122c:	682f7570 	stmdavs	pc!, {r4, r5, r6, r8, sl, ip, sp, lr}	; <UNPREDICTABLE>
    1230:	65646165 	strbvs	r6, [r4, #-357]!	; 0x165
    1234:	2e007372 	mcrcs	3, 0, r7, cr0, cr2, {3}
        *dst++ = colour[(tmpsrc >> 3) & 0x01];
    1238:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    123c:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
    1240:	6d6f632f 	stclvs	3, cr6, [pc, #-188]!	; 118c <Ov7725_img_extract+0x4>
    1244:	006e6f6d 	rsbeq	r6, lr, sp, ror #30
    1248:	5f776800 	svcpl	0x00776800
    124c:	6d74706c 	ldclvs	0, cr7, [r4, #-432]!	; 0xfffffe50
    1250:	00632e72 	rsbeq	r2, r3, r2, ror lr
    1254:	73000001 	movwvc	r0, #1
    1258:	6e696474 	mcrvs	4, 3, r6, cr9, cr4, {3}
        *dst++ = colour[(tmpsrc >> 2) & 0x01];
    125c:	00682e74 	rsbeq	r2, r8, r4, ror lr
    1260:	4d000002 	stcmi	0, cr0, [r0, #-8]
    1264:	4630364b 	ldrtmi	r3, [r0], -fp, asr #12
    1268:	682e3531 	stmdavs	lr!, {r0, r4, r5, r8, sl, ip, sp}
    126c:	00000300 	andeq	r0, r0, r0, lsl #6
    1270:	6d6d6f63 	stclvs	15, cr6, [sp, #-396]!	; 0xfffffe74
    1274:	682e6e6f 	stmdavs	lr!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}
    1278:	00000400 	andeq	r0, r0, r0, lsl #8
        *dst++ = colour[(tmpsrc >> 1) & 0x01];
    127c:	6c5f7768 	mrrcvs	7, 6, r7, pc, cr8	; <UNPREDICTABLE>
    1280:	726d7470 	rsbvc	r7, sp, #1879048192	; 0x70000000
    1284:	0100682e 	tsteq	r0, lr, lsr #16
    1288:	00000000 	andeq	r0, r0, r0
    128c:	51880205 	orrpl	r0, r8, r5, lsl #4
    1290:	27030000 	strcs	r0, [r3, -r0]
    1294:	2f2f7501 	svccs	0x002f7501
    1298:	3d3d322f 	lfmcc	f3, 4, [sp, #-188]!	; 0xffffff44
    129c:	08d83e3d 	ldmeq	r8, {r0, r2, r3, r4, r5, r9, sl, fp, ip, sp}^
        *dst++ = colour[(tmpsrc >> 0) & 0x01];
    12a0:	7675753f 			; <UNDEFINED> instruction: 0x7675753f
    12a4:	3f876844 	svccc	0x00876844
    12a8:	793e843e 	ldmdbvc	lr!, {r1, r2, r3, r4, r5, sl, pc}
    12ac:	bdbb9f78 	ldclt	15, cr9, [fp, #480]!	; 0x1e0
    12b0:	01040200 	mrseq	r0, R12_usr
    12b4:	3e063c06 	cdpcc	12, 0, cr3, cr6, cr6, {0}
    12b8:	2fbbbd67 	svccs	0x00bbbd67
void Ov7725_img_extract(uint8 *dst, uint8 *src, uint32 srclen)
{
    uint8 colour[2] = {255, 0}; //0 和 1 分别对应的颜色
    //注：野火的摄像头 1(or255)表示 白色，0表示 黑色
    uint8 tmpsrc;
    while(srclen --)
    12bc:	30660e03 	rsbcc	r0, r6, r3, lsl #28
    12c0:	4d767676 	ldclmi	6, cr7, [r6, #-472]!	; 0xfffffe28
    12c4:	032f3e08 	teqeq	pc, #128	; 0x80
    12c8:	bb2f3c0c 	bllt	bd0300 <__etext+0xbc7658>
    12cc:	2f4a0e03 	svccs	0x004a0e03
    12d0:	0f032f4b 	svceq	0x00032f4b
        *dst++ = colour[(tmpsrc >> 3) & 0x01];
        *dst++ = colour[(tmpsrc >> 2) & 0x01];
        *dst++ = colour[(tmpsrc >> 1) & 0x01];
        *dst++ = colour[(tmpsrc >> 0) & 0x01];
    }
}
    12d4:	2f4b2f2e 	svccs	0x004b2f2e
    12d8:	2f2e0c03 	svccs	0x002e0c03
    12dc:	0e036775 	mcreq	7, 0, r6, cr3, cr5, {3}
 *  @note       不同的上位机，不同的命令，这里使用 eSmartCameraCar软件，
                如果使用其他上位机，则需要修改代码。
 *  Sample usage:   sendimg(imgbuff, CAMERA_W * CAMERA_H);                    //发送到上位机
 */
void Ov7725_sendimg(uint8 *imgaddr, uint32 imgsize)
{
    12e0:	d83f5958 	ldmdale	pc!, {r3, r4, r6, r8, fp, ip, lr}	; <UNPREDICTABLE>
    12e4:	77693f08 	strbvc	r3, [r9, -r8, lsl #30]!
    12e8:	040200bd 	streq	r0, [r2], #-189	; 0xbd
    uint8 cmd[4] = {0, 255, 1, 0 };    //yy_摄像头串口调试 使用的命令
    12ec:	06200601 	strteq	r0, [r0], -r1, lsl #12
    12f0:	c86d0393 	stmdagt	sp!, {r0, r1, r4, r7, r8, r9}^
    12f4:	03201503 	teqeq	r0, #12582912	; 0xc00000
    12f8:	bb2f5809 	bllt	bd7324 <__etext+0xbce67c>
    
    LPLD_UART_PutCharArr(TERM_PORT, (char *)cmd, sizeof(cmd));
    12fc:	00010267 	andeq	r0, r1, r7, ror #4
    1300:	018a0101 	orreq	r0, sl, r1, lsl #2
    1304:	00020000 	andeq	r0, r2, r0
    1308:	00000100 	andeq	r0, r0, r0, lsl #2
    130c:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
    LPLD_UART_PutCharArr(TERM_PORT, (char *)imgaddr, imgsize);
    1310:	0101000d 	tsteq	r1, sp
    1314:	00000101 	andeq	r0, r0, r1, lsl #2
    1318:	00000100 	andeq	r0, r0, r0, lsl #2
    131c:	2f2e2e01 	svccs	0x002e2e01
    1320:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; 1270 <Ov7725_img_extract+0xe8>

    //uart_putbuff(FIRE_PORT, cmd, sizeof(cmd));    //先发送命令

    //uart_putbuff(FIRE_PORT, imgaddr, imgsize); //再发送图像
}
    1324:	682f6269 	stmdavs	pc!, {r0, r3, r5, r6, r9, sp, lr}	; <UNPREDICTABLE>
    1328:	682f0077 	stmdavs	pc!, {r0, r1, r2, r4, r5, r6}	; <UNPREDICTABLE>

//OV7725GPIO口初始化
void Ov7725_Gpio_Init(void)
{
    132c:	2f656d6f 	svccs	0x00656d6f
    1330:	656b6f6d 	strbvs	r6, [fp, #-3949]!	; 0xf6d
    //OV数据口初始化 B0～B7
    OV_PTB_init.GPIO_PTx = PTB;
    1334:	6d732f72 	ldclvs	15, cr2, [r3, #-456]!	; 0xfffffe38
    1338:	5f747261 	svcpl	0x00747261
    133c:	2f726163 	svccs	0x00726163
    1340:	2f637273 	svccs	0x00637273
    OV_PTB_init.GPIO_Dir = DIR_INPUT;
    1344:	2d636367 	stclcs	3, cr6, [r3, #-412]!	; 0xfffffe64
    1348:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
    134c:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
    1350:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
    OV_PTB_init.GPIO_Pins = GPIO_Pin0_7;
    1354:	5f342d69 	svcpl	0x00342d69
    1358:	30322d37 	eorscc	r2, r2, r7, lsr sp
    135c:	33713331 	cmncc	r1, #-1006632960	; 0xc4000000
    //禁止中断和DMA请求 禁用PULL 输入源下拉
    OV_PTB_init.GPIO_PinControl = IRQC_DIS |
    1360:	6e69622f 	cdpvs	2, 6, cr6, cr9, cr15, {1}
    1364:	2f2e2e2f 	svccs	0x002e2e2f
    1368:	2f62696c 	svccs	0x0062696c
    136c:	2f636367 	svccs	0x00636367
                                  INPUT_PULL_DIS|
                                  INPUT_PULL_DOWN;
    LPLD_GPIO_Init (OV_PTB_init);
    1370:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
    1374:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
    1378:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
    137c:	2e342f69 	cdpcs	15, 3, cr2, cr4, cr9, {3}

    //OV场信号接口初始化 A29 
    OV_PTA_init.GPIO_PTx = PTA;
    1380:	2f342e37 	svccs	0x00342e37
    1384:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    1388:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    138c:	2f2e2e2f 	svccs	0x002e2e2f
    1390:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
    OV_PTA_init.GPIO_Dir = DIR_INPUT;
    1394:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
    1398:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
    139c:	6e692f69 	cdpvs	15, 6, cr2, cr9, cr9, {3}
    OV_PTA_init.GPIO_Pins = GPIO_Pin29;
    13a0:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xc63
    13a4:	2e2e0065 	cdpcs	0, 2, cr0, cr14, cr5, {3}
    13a8:	2f2e2e2f 	svccs	0x002e2e2f
    13ac:	2f62696c 	svccs	0x0062696c
    //场中断IO设置，上升沿触发IR，输入上拉，使能滤波
    OV_PTA_init.GPIO_PinControl = IRQC_RI |
    13b0:	2f757063 	svccs	0x00757063
    13b4:	64616568 	strbtvs	r6, [r1], #-1384	; 0x568
    13b8:	00737265 	rsbseq	r7, r3, r5, ror #4
    13bc:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
                                    INPUT_PULL_UP|
                                    INPUT_PF_EN;
    OV_PTA_init.GPIO_Isr = Ov7725_isr;
    13c0:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
    13c4:	6f632f62 	svcvs	0x00632f62
    13c8:	6e6f6d6d 	cdpvs	13, 6, cr6, cr15, cr13, {3}
    13cc:	77680000 	strbvc	r0, [r8, -r0]!
    13d0:	67636d5f 			; <UNDEFINED> instruction: 0x67636d5f
    LPLD_GPIO_Init (OV_PTA_init);
    13d4:	0100632e 	tsteq	r0, lr, lsr #6
    13d8:	74730000 	ldrbtvc	r0, [r3], #-0
    13dc:	746e6964 	strbtvc	r6, [lr], #-2404	; 0x964
    13e0:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000

    //OV PCLK信号接口初始化: PTA27-PCLK 
    OV_PTD_init.GPIO_PTx = PTA;
    13e4:	4b4d0000 	blmi	13413ec <__etext+0x1338744>
    13e8:	31463036 	cmpcc	r6, r6, lsr r0
    13ec:	00682e35 	rsbeq	r2, r8, r5, lsr lr
    13f0:	63000003 	movwvs	r0, #3
    13f4:	6f6d6d6f 	svcvs	0x006d6d6f
    OV_PTD_init.GPIO_Pins = GPIO_Pin27;
    13f8:	00682e6e 	rsbeq	r2, r8, lr, ror #28
    13fc:	68000004 	stmdavs	r0, {r2}
    1400:	636d5f77 	cmnvs	sp, #476	; 0x1dc
    OV_PTD_init.GPIO_Dir = DIR_INPUT;
    1404:	00682e67 	rsbeq	r2, r8, r7, ror #28
    1408:	00000001 	andeq	r0, r0, r1
    140c:	f0020500 			; <UNDEFINED> instruction: 0xf0020500
    1410:	03000054 	movweq	r0, #84	; 0x54
    //PCLK信号，下降沿触发DMA，输入上拉
    OV_PTD_init.GPIO_PinControl = IRQC_DMAFA | INPUT_PULL_UP;
    1414:	3d5d011c 	ldfcce	f0, [sp, #-112]	; 0xffffff90
    1418:	0b033d3d 	bleq	d0914 <__etext+0xc7c6c>
    141c:	1508593c 	strne	r5, [r8, #-2364]	; 0x93c
    1420:	3d223d3d 	stccc	13, cr3, [r2, #-244]!	; 0xffffff0c
    LPLD_GPIO_Init (OV_PTD_init);
    1424:	3d3d223d 	lfmcc	f2, 4, [sp, #-244]!	; 0xffffff0c
    1428:	223d3d22 	eorscs	r3, sp, #2176	; 0x880
    142c:	3d223d3d 	stccc	13, cr3, [r2, #-244]!	; 0xffffff0c
    1430:	3068223d 	rsbcc	r2, r8, sp, lsr r2
    1434:	4c844cf4 	stcmi	12, cr4, [r4], {244}	; 0xf4

}
    1438:	4c844cf4 	stcmi	12, cr4, [r4], {244}	; 0xf4
 
//OV7725 DMA初始化 
void Ov7725_Dma_Init (void)
{
    143c:	50844cf4 	strdpl	r4, [r4], r4	; <UNPREDICTABLE>
    1440:	4208d9d8 	andmi	sp, r8, #3538944	; 0x360000
    OV_dma_init.DMA_CHx = DMA_CH0;
    1444:	04020076 	streq	r0, [r2], #-118	; 0x76
    1448:	06200601 	strteq	r0, [r0], -r1, lsl #12
    144c:	040200a0 	streq	r0, [r2], #-160	; 0xa0
    OV_dma_init.DMA_Req = PORTA_DMAREQ;
    1450:	06200601 	strteq	r0, [r0], -r1, lsl #12
    1454:	6a7793c0 	bvs	1de635c <__etext+0x1ddd6b4>
    1458:	040200bc 	streq	r0, [r2], #-188	; 0xbc
    145c:	06200601 	strteq	r0, [r0], -r1, lsl #12
    OV_dma_init.DMA_MajorLoopCnt = PHOTO_SIZE / 8;
    1460:	040200a0 	streq	r0, [r2], #-160	; 0xa0
    1464:	06200601 	strteq	r0, [r0], -r1, lsl #12
    1468:	0200d9a4 	andeq	sp, r0, #2686976	; 0x290000
    OV_dma_init.DMA_MinorByteCnt = 1;
    146c:	20060104 	andcs	r0, r6, r4, lsl #2
    1470:	0321be06 	teqeq	r1, #96	; 0x60
    1474:	69786610 	ldmdbvs	r8!, {r4, r9, sl, sp, lr}^
    1478:	5cb9c9bf 	ldcpl	9, cr12, [r9], #764	; 0x2fc
    
    OV_dma_init.DMA_SourceAddr = (uint32)(&GPIOB_PDIR);
    147c:	02040200 	andeq	r0, r4, #0
    1480:	02004a06 	andeq	r4, r0, #24576	; 0x6000
    1484:	064a0104 	strbeq	r0, [sl], -r4, lsl #2
    1488:	0221684d 	eoreq	r6, r1, #5046272	; 0x4d0000
    OV_dma_init.DMA_DestAddr = (uint32)img;
    148c:	01010005 	tsteq	r1, r5
    1490:	000001d1 	ldrdeq	r0, [r0], -r1
    1494:	010c0002 	tsteq	ip, r2
    1498:	01020000 	mrseq	r0, (UNDEF: 2)
    149c:	000d0efb 	strdeq	r0, [sp], -fp
    OV_dma_init.DMA_DestAddrOffset = 1;
    14a0:	01010101 	tsteq	r1, r1, lsl #2
    14a4:	01000000 	mrseq	r0, (UNDEF: 0)
    14a8:	2e010000 	cdpcs	0, 0, cr0, cr1, cr0, {0}
    OV_dma_init.DMA_Isr = Ov7725_eagle_dma;
    14ac:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    14b0:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
    14b4:	0077682f 	rsbseq	r6, r7, pc, lsr #16
    14b8:	6d6f682f 	stclvs	8, cr6, [pc, #-188]!	; 1404 <Ov7725_Gpio_Init+0xd8>
    14bc:	6f6d2f65 	svcvs	0x006d2f65
    LPLD_DMA_Init (OV_dma_init);
    14c0:	2f72656b 	svccs	0x0072656b
    14c4:	72616d73 	rsbvc	r6, r1, #7360	; 0x1cc0
    14c8:	61635f74 	smcvs	13812	; 0x35f4
    14cc:	72732f72 	rsbsvc	r2, r3, #456	; 0x1c8
    14d0:	63672f63 	cmnvs	r7, #396	; 0x18c
    14d4:	72612d63 	rsbvc	r2, r1, #6336	; 0x18c0
    14d8:	6f6e2d6d 	svcvs	0x006e2d6d
    14dc:	652d656e 	strvs	r6, [sp, #-1390]!	; 0x56e

    LPLD_DMA_DisableReq(DMA_CH0);
    14e0:	2d696261 	sfmcs	f6, 2, [r9, #-388]!	; 0xfffffe7c
    14e4:	2d375f34 	ldccs	15, cr5, [r7, #-208]!	; 0xffffff30
    14e8:	33313032 	teqcc	r1, #50	; 0x32
    14ec:	622f3371 	eorvs	r3, pc, #-1006632959	; 0xc4000001
    14f0:	2e2f6e69 	cdpcs	14, 2, cr6, cr15, cr9, {3}
    14f4:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
    //disable_irq (INT_PORTA - 16);
    LPLD_GPIO_EnableIrq (OV_PTA_init);
    14f8:	63672f62 	cmnvs	r7, #392	; 0x188
    14fc:	72612f63 	rsbvc	r2, r1, #396	; 0x18c
    1500:	6f6e2d6d 	svcvs	0x006e2d6d
    1504:	652d656e 	strvs	r6, [sp, #-1390]!	; 0x56e
    1508:	2f696261 	svccs	0x00696261
    DMA0->INT |= 0x1u <<0;
    150c:	2e372e34 	mrccs	14, 1, r2, cr7, cr4, {1}
    1510:	2e2e2f34 	mcrcs	15, 1, r2, cr14, cr4, {1}
    1514:	2f2e2e2f 	svccs	0x002e2e2f
    1518:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    151c:	72612f2e 	rsbvc	r2, r1, #184	; 0xb8
    1520:	6f6e2d6d 	svcvs	0x006e2d6d
    //允许DMA通道传输完成中断
    //enable_irq (DMA_CH0);
    LPLD_DMA_EnableIrq (OV_dma_init);
    1524:	652d656e 	strvs	r6, [sp, #-1390]!	; 0x56e
    1528:	2f696261 	svccs	0x00696261
    152c:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
    1530:	00656475 	rsbeq	r6, r5, r5, ror r4
    1534:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    1538:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
    153c:	70632f62 	rsbvc	r2, r3, r2, ror #30
    1540:	65682f75 	strbvs	r2, [r8, #-3957]!	; 0xf75
    //使能通道x的DMA请求
    //LPLD_DMA_EnableReq(DMA_CH0);
}
    1544:	72656461 	rsbvc	r6, r5, #1627389952	; 0x61000000
    1548:	2e2e0073 	mcrcs	0, 1, r0, cr14, cr3, {3}

//ov7725中断
void Ov7725_isr (void)
{
    154c:	2f2e2e2f 	svccs	0x002e2e2f
    1550:	2f62696c 	svccs	0x0062696c
    uint8 n = 0;
    1554:	6d6d6f63 	stclvs	15, cr6, [sp, #-396]!	; 0xfffffe74
    while (!PORTA_ISFR);
    1558:	00006e6f 	andeq	r6, r0, pc, ror #28
    155c:	705f7768 	subsvc	r7, pc, r8, ror #14
    1560:	632e6264 	teqvs	lr, #1073741830	; 0x40000006
    1564:	00000100 	andeq	r0, r0, r0, lsl #2
    1568:	69647473 	stmdbvs	r4!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
    uint32 flag = (PORTA->ISFR);
    156c:	682e746e 	stmdavs	lr!, {r1, r2, r3, r5, r6, sl, ip, sp, lr}
    1570:	00000200 	andeq	r0, r0, r0, lsl #4
    1574:	30364b4d 	eorscc	r4, r6, sp, asr #22
    (PORTA -> ISFR) = ~0;
    1578:	2e353146 	rsfcssm	f3, f5, f6
    157c:	00030068 	andeq	r0, r3, r8, rrx
    1580:	6d6f6300 	stclvs	3, cr6, [pc, #-0]	; 1588 <Ov7725_isr+0x3c>
    1584:	2e6e6f6d 	cdpcs	15, 6, cr6, cr14, cr13, {3}
   
    n = 29;
    1588:	00040068 	andeq	r0, r4, r8, rrx
    158c:	5f776800 	svcpl	0x00776800
    //printf ("flag = %x\n", flag);
    if (flag & (1<<n))
    1590:	2e626470 	mcrcs	4, 3, r6, cr2, cr0, {3}
    1594:	00010068 	andeq	r0, r1, r8, rrx
    1598:	5f776800 	svcpl	0x00776800
    159c:	2e67636d 	cdpcs	3, 6, cr6, cr7, cr13, {3}
    15a0:	00010068 	andeq	r0, r1, r8, rrx
    {
        //场中断开始 
        //set 場中断
        ov7725_eagle_img_flag = IMG_START;
    15a4:	05000000 	streq	r0, [r0, #-0]
    15a8:	00585402 	subseq	r5, r8, r2, lsl #8
    15ac:	012d0300 	teqeq	sp, r0, lsl #6
        //关闭PORTA中断
        disable_irq (INT_PORTA - 16);
    15b0:	59732283 	ldmdbpl	r3!, {r0, r1, r7, r9, sp}^
    15b4:	7322311e 	teqvc	r2, #-2147483641	; 0x80000007
        //LPLD_GPIO_DisableIrq(OV_PTA_init);
        //enable_irq (DMA_CH0 + INT_DMA0_DMA16 - 16);
        //重新装载DMA目标地址
        //DMA_DADDR(DMA_CH0) = (uint32)img;
        //开启DMA通道
        DMA_EN(DMA_CH0);
    15b8:	3d311e59 	ldccc	14, cr1, [r1, #-356]!	; 0xfffffe9c
    15bc:	d609033d 			; <UNDEFINED> instruction: 0xd609033d
    15c0:	01040200 	mrseq	r0, R12_usr
    15c4:	3d063c06 	stccc	12, cr3, [r6, #-24]	; 0xffffffe8
    15c8:	4c3c0d03 	ldcmi	13, cr0, [ip], #-12
    15cc:	082f4c2f 	stmdaeq	pc!, {r0, r1, r2, r3, r5, sl, fp, lr}	; <UNPREDICTABLE>
        //LPLD_DMA_EnableIrq(OV_dma_init);
    }
}
    15d0:	02005413 	andeq	r5, r0, #318767104	; 0x13000000
    15d4:	4a060104 	bmi	1819ec <__etext+0x178d44>

//移植野火的函数
void dma_portx2buff_init(uint8 CHn, void *SADDR, void *DADDR, uint8 dma_req, DMA_BYTEn byten, uint32 count, uint32 cfg)
{
    15d8:	5a224f06 	bpl	8951f8 <__etext+0x88c550>
    15dc:	3c73033d 	ldclcc	3, cr0, [r3], #-244	; 0xffffff0c
    15e0:	01040200 	mrseq	r0, R12_usr
    15e4:	03064a06 	movweq	r4, #27142	; 0x6a06
    uint8 BYTEs = (byten == DMA_BYTE1 ? 1 : (byten == DMA_BYTE2 ? 2 : (byten == DMA_BYTE4 ? 4 : 16)));
    15e8:	08264a0b 	stmdaeq	r6!, {r0, r1, r3, r9, fp, lr}
    15ec:	f3bb763f 	vqshlu.s32	d7, d31, #27
    15f0:	4bf5f4f4 	blmi	ffd7e9c8 <__StackLimit+0xdfd7e9c8>
    15f4:	ca4bbdca 	bgt	12f0d24 <__etext+0x12e807c>
    15f8:	4b683ebc 	blmi	1a110f0 <__etext+0x1a08448>
    15fc:	683ebdca 	ldmdavs	lr!, {r1, r3, r6, r7, r8, sl, fp, ip, sp, pc}
    1600:	4cbeca4b 	vldmiami	lr!, {s24-s98}
    1604:	bc2408d7 	stclt	8, cr0, [r4], #-860	; 0xfffffca4
    1608:	900d032f 	andls	r0, sp, pc, lsr #6
    160c:	83767530 	cmnhi	r6, #201326592	; 0xc000000
    1610:	3e087784 	cdpcc	7, 0, cr7, cr8, cr4, {4}
    1614:	201c034b 	andscs	r0, ip, fp, asr #6
    
    SIM_SCGC7 |= SIM_SCGC7_DMA_MASK;
    1618:	4b75d877 	blmi	1d777fc <__etext+0x1d6eb54>
    161c:	593e4c75 	ldmdbpl	lr!, {r0, r2, r4, r5, r6, sl, fp, lr}
    1620:	3e4c594b 	cdpcc	9, 4, cr5, cr12, cr11, {2}
    1624:	e508e6d7 	str	lr, [r8, #-1751]	; 0x6d7
    1628:	2fbca008 	svccs	0x00bca008
    162c:	77741503 	ldrbvc	r1, [r4, -r3, lsl #10]!
    1630:	754b75d8 	strbvc	r7, [fp, #-1496]	; 0x5d8
    1634:	e6d73e4c 	ldrb	r3, [r7], ip, asr #28
    SIM_SCGC6 |= SIM_SCGC6_DMAMUX0_MASK;
    1638:	4c083d08 	stcmi	13, cr3, [r8], {8}
    163c:	036e2fbc 	cmneq	lr, #752	; 0x2f0
    1640:	02002e09 	andeq	r2, r0, #144	; 0x90
    1644:	90060104 	andls	r0, r6, r4, lsl #2
    1648:	be689306 	cdplt	3, 6, cr9, cr8, cr6, {0}
    164c:	01040200 	mrseq	r0, R12_usr
    1650:	93069006 	movwls	r9, #24582	; 0x6006
    1654:	0200be67 	andeq	fp, r0, #1648	; 0x670
    1658:	90060104 	andls	r0, r6, r4, lsl #2
    165c:	c0679306 	rsbgt	r9, r7, r6, lsl #6

    DMA_SADDR(CHn) = (uint32) SADDR;
    1660:	01000102 	tsteq	r0, r2, lsl #2
    1664:	00018401 	andeq	r8, r1, r1, lsl #8
    1668:	0c000200 	sfmeq	f0, 4, [r0], {-0}
    166c:	02000001 	andeq	r0, r0, #1
    1670:	0d0efb01 	vstreq	d15, [lr, #-4]
    1674:	01010100 	mrseq	r0, (UNDEF: 17)
    DMA_DADDR(CHn) = (uint32) DADDR;
    1678:	00000001 	andeq	r0, r0, r1
    167c:	01000001 	tsteq	r0, r1
    1680:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    1684:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
    1688:	77682f62 	strbvc	r2, [r8, -r2, ror #30]!
    168c:	6f682f00 	svcvs	0x00682f00
    1690:	6d2f656d 	cfstr32vs	mvfx6, [pc, #-436]!	; 14e4 <Ov7725_Dma_Init+0xa8>
    DMA_SOFF(CHn) = 0x00u;
    1694:	72656b6f 	rsbvc	r6, r5, #113664	; 0x1bc00
    1698:	616d732f 	cmnvs	sp, pc, lsr #6
    169c:	635f7472 	cmpvs	pc, #1912602624	; 0x72000000
    16a0:	732f7261 	teqvc	pc, #268435462	; 0x10000006
    16a4:	672f6372 			; <UNDEFINED> instruction: 0x672f6372
    16a8:	612d6363 	teqvs	sp, r3, ror #6
    16ac:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    DMA_DOFF(CHn) = BYTEs;
    16b0:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
    16b4:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    16b8:	375f342d 	ldrbcc	r3, [pc, -sp, lsr #8]
    16bc:	3130322d 	teqcc	r0, sp, lsr #4
    16c0:	2f337133 	svccs	0x00337133
    16c4:	2f6e6962 	svccs	0x006e6962
    16c8:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; 1618 <dma_portx2buff_init+0x40>
    DMA_ATTR(CHn) = (0
    16cc:	672f6269 	strvs	r6, [pc, -r9, ror #4]!
    16d0:	612f6363 	teqvs	pc, r3, ror #6
    16d4:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
                     |DMA_ATTR_SMOD(0x0)
                     |DMA_ATTR_SSIZE(byten)
    16d8:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
    16dc:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    16e0:	372e342f 	strcc	r3, [lr, -pc, lsr #8]!

    DMA_SADDR(CHn) = (uint32) SADDR;
    DMA_DADDR(CHn) = (uint32) DADDR;
    DMA_SOFF(CHn) = 0x00u;
    DMA_DOFF(CHn) = BYTEs;
    DMA_ATTR(CHn) = (0
    16e4:	2e2f342e 	cdpcs	4, 2, cr3, cr15, cr14, {1}
    16e8:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    16ec:	2f2e2e2f 	svccs	0x002e2e2f
    16f0:	612f2e2e 	teqvs	pc, lr, lsr #28
    16f4:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    16f8:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
    16fc:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    1700:	636e692f 	cmnvs	lr, #770048	; 0xbc000
                     |DMA_ATTR_SMOD(0x0)
                     |DMA_ATTR_SSIZE(byten)
                     |DMA_ATTR_DMOD(0x0)
                     |DMA_ATTR_DSIZE(byten)
                    );
    DMA_CITER_ELINKNO(CHn) = DMA_CITER_ELINKNO_CITER(count);
    1704:	6564756c 	strbvs	r7, [r4, #-1388]!	; 0x56c
    1708:	2f2e2e00 	svccs	0x002e2e00
    170c:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; 165c <dma_portx2buff_init+0x84>
    1710:	632f6269 	teqvs	pc, #-1879048186	; 0x90000006
    1714:	682f7570 	stmdavs	pc!, {r4, r5, r6, r8, sl, ip, sp, lr}	; <UNPREDICTABLE>
    1718:	65646165 	strbvs	r6, [r4, #-357]!	; 0x165
    171c:	2e007372 	mcrcs	3, 0, r7, cr0, cr2, {3}
    1720:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    1724:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
    1728:	6d6f632f 	stclvs	3, cr6, [pc, #-188]!	; 1674 <dma_portx2buff_init+0x9c>
    DMA_BITER_ELINKNO(CHn) = DMA_BITER_ELINKNO_BITER(count);
    172c:	006e6f6d 	rsbeq	r6, lr, sp, ror #30
    1730:	5f776800 	svcpl	0x00776800
    1734:	2e746970 	mrccs	9, 3, r6, cr4, cr0, {3}
    1738:	00010063 	andeq	r0, r1, r3, rrx
    173c:	64747300 	ldrbtvs	r7, [r4], #-768	; 0x300
    1740:	2e746e69 	cdpcs	14, 7, cr6, cr4, cr9, {3}
    1744:	00020068 	andeq	r0, r2, r8, rrx
    1748:	364b4d00 	strbcc	r4, [fp], -r0, lsl #26
    174c:	35314630 	ldrcc	r4, [r1, #-1584]!	; 0x630
    1750:	0300682e 	movweq	r6, #2094	; 0x82e

    DMA_CR &= ~DMA_CR_EMLM_MASK;
    1754:	6f630000 	svcvs	0x00630000
    1758:	6e6f6d6d 	cdpvs	13, 6, cr6, cr15, cr13, {3}
    175c:	0400682e 	streq	r6, [r0], #-2094	; 0x82e
    1760:	77680000 	strbvc	r0, [r8, -r0]!
    1764:	7469705f 	strbtvc	r7, [r9], #-95	; 0x5f
    1768:	0100682e 	tsteq	r0, lr, lsr #16

    DMA_NBYTES_MLNO(CHn) = DMA_NBYTES_MLNO_NBYTES(BYTEs);
    176c:	77680000 	strbvc	r0, [r8, -r0]!
    1770:	67636d5f 			; <UNDEFINED> instruction: 0x67636d5f
    1774:	0100682e 	tsteq	r0, lr, lsr #16
    1778:	00000000 	andeq	r0, r0, r0
    177c:	5f7c0205 	svcpl	0x007c0205
    1780:	1b030000 	blne	c1788 <__etext+0xb8ae0>
    1784:	08f38401 	ldmeq	r3!, {r0, sl, pc}^

    DMA_SLAST(CHn) = 0;
    1788:	3156084b 	cmpcc	r6, fp, asr #16
    178c:	3d3d332f 	ldccc	3, cr3, [sp, #-188]!	; 0xffffff44
    1790:	3f083f3d 	svccc	0x00083f3d
    1794:	ce843d76 	mcrgt	13, 4, r3, cr4, cr6, {3}
    1798:	2f7608da 	svccs	0x007608da
    179c:	83820e03 	orrhi	r0, r2, #48	; 0x30
    17a0:	03c96933 	biceq	r6, r9, #835584	; 0xcc000
    17a4:	3383740f 	orrcc	r7, r3, #251658240	; 0xf000000
    DMA_DLAST_SGA(CHn) = (uint32)((cfg & DADDR_KEEPON) == 0 ? (-count) : 0);
    17a8:	820f0367 	andhi	r0, pc, #-1677721599	; 0x9c000001
    17ac:	86673383 	strbthi	r3, [r7], -r3, lsl #7
    17b0:	bc3e085a 	ldclt	8, cr0, [lr], #-360	; 0xfffffe98
    17b4:	08cb7608 	stmiaeq	fp, {r3, r9, sl, ip, sp, lr}^
    17b8:	cc760876 	ldclgt	8, cr0, [r6], #-472	; 0xfffffe28
    17bc:	e8d85a5b 	ldm	r8, {r0, r1, r3, r4, r6, r9, fp, ip, lr}^
    17c0:	75087608 	strvc	r7, [r8, #-1544]	; 0x608
    17c4:	f34c4c3e 			; <UNDEFINED> instruction: 0xf34c4c3e
    17c8:	77085978 	smlsdxvc	r8, r8, r9, r5
    17cc:	09037508 	stmdbeq	r3, {r3, r8, sl, ip, sp, lr}
    17d0:	2e090358 	mcrcs	3, 0, r0, cr9, cr8, {2}
    17d4:	0330db68 	teqeq	r0, #106496	; 0x1a000
    DMA_CSR(CHn) = (0
    17d8:	db682e09 	blle	1a0d004 <__etext+0x1a0435c>
    17dc:	2e090330 	mcrcs	3, 0, r0, cr9, cr0, {1}
    17e0:	0330db68 	teqeq	r0, #106496	; 0x1a000
    17e4:	d7682e09 	strble	r2, [r8, -r9, lsl #28]!
    17e8:	01000102 	tsteq	r0, r2, lsl #2
    17ec:	0002b101 	andeq	fp, r2, r1, lsl #2
    17f0:	11000200 	mrsne	r0, R8_usr
                    |DMA_CSR_BWC(3)
                    |DMA_CSR_DREQ_MASK
                    |DMA_CSR_INTMAJOR_MASK
                   );

    DMAMUX_CHCFG_REG(DMAMUX0_BASE_PTR, CHn) = (0                
    17f4:	02000001 	andeq	r0, r0, #1
    17f8:	0d0efb01 	vstreq	d15, [lr, #-4]
    17fc:	01010100 	mrseq	r0, (UNDEF: 17)
    1800:	00000001 	andeq	r0, r0, r1
    1804:	01000001 	tsteq	r0, r1
    1808:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    180c:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
    |DMAMUX_CHCFG_ENBL_MASK
    |DMAMUX_CHCFG_SOURCE(dma_req));
    DMA_DIS(CHn);
    1810:	77682f62 	strbvc	r2, [r8, -r2, ror #30]!
    1814:	6f682f00 	svcvs	0x00682f00
    1818:	6d2f656d 	cfstr32vs	mvfx6, [pc, #-436]!	; 166c <dma_portx2buff_init+0x94>
    181c:	72656b6f 	rsbvc	r6, r5, #113664	; 0x1bc00
    1820:	616d732f 	cmnvs	sp, pc, lsr #6
    1824:	635f7472 	cmpvs	pc, #1912602624	; 0x72000000
    1828:	732f7261 	teqvc	pc, #268435462	; 0x10000006
    182c:	672f6372 			; <UNDEFINED> instruction: 0x672f6372
    1830:	612d6363 	teqvs	sp, r3, ror #6
    DMA_IRQ_CLEAN(CHn);
    1834:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    1838:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
    183c:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    1840:	375f342d 	ldrbcc	r3, [pc, -sp, lsr #8]
    1844:	3130322d 	teqcc	r0, sp, lsr #4
    1848:	2f337133 	svccs	0x00337133
    184c:	2f6e6962 	svccs	0x006e6962
    1850:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; 17a0 <dma_portx2buff_init+0x1c8>
}
    1854:	672f6269 	strvs	r6, [pc, -r9, ror #4]!
    1858:	612f6363 	teqvs	pc, r3, ror #6


//提取中线
void get_midline(uint8 *img, uint8 h, uint8 w)
{
    185c:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    1860:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
    1864:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    1868:	372e342f 	strcc	r3, [lr, -pc, lsr #8]!
    int16 p = 0, i = 0, line_mid = 39;
    186c:	2e2f342e 	cdpcs	4, 2, cr3, cr15, cr14, {1}
    1870:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    1874:	2f2e2e2f 	svccs	0x002e2e2f
    1878:	612f2e2e 	teqvs	pc, lr, lsr #28
    187c:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    int8 side_left = 0, side_right = 79;
    1880:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
    1884:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    1888:	636e692f 	cmnvs	lr, #770048	; 0xbc000

    if (img[(h-1)*w + line_mid] == 0xff)
    188c:	6564756c 	strbvs	r7, [r4, #-1388]!	; 0x56c
    1890:	2f2e2e00 	svccs	0x002e2e00
    1894:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; 17e4 <dma_portx2buff_init+0x20c>
    1898:	632f6269 	teqvs	pc, #-1879048186	; 0x90000006
    189c:	682f7570 	stmdavs	pc!, {r4, r5, r6, r8, sl, ip, sp, lr}	; <UNPREDICTABLE>
    18a0:	65646165 	strbvs	r6, [r4, #-357]!	; 0x165
    18a4:	2e007372 	mcrcs	3, 0, r7, cr0, cr2, {3}
    {
        for (i = h - 1; i >= 0; i --)
    18a8:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    18ac:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
    18b0:	6d6f632f 	stclvs	3, cr6, [pc, #-188]!	; 17fc <dma_portx2buff_init+0x224>
    18b4:	006e6f6d 	rsbeq	r6, lr, sp, ror #30
        {
            for (p = line_mid - 1; p > 0; p --)
    18b8:	5f776800 	svcpl	0x00776800
    18bc:	2e697073 	mcrcs	0, 3, r7, cr9, cr3, {3}
    18c0:	00010063 	andeq	r0, r1, r3, rrx
            {
                if (img[i * w + p] == 0)
    18c4:	64747300 	ldrbtvs	r7, [r4], #-768	; 0x300
    18c8:	2e746e69 	cdpcs	14, 7, cr6, cr4, cr9, {3}
    18cc:	00020068 	andeq	r0, r2, r8, rrx
    18d0:	364b4d00 	strbcc	r4, [fp], -r0, lsl #26
    18d4:	35314630 	ldrcc	r4, [r1, #-1584]!	; 0x630
    18d8:	0300682e 	movweq	r6, #2094	; 0x82e
                    if ((img[i * w + p - 1] == 0) 
    18dc:	6f630000 	svcvs	0x00630000
    18e0:	6e6f6d6d 	cdpvs	13, 6, cr6, cr15, cr13, {3}
    18e4:	0400682e 	streq	r6, [r0], #-2094	; 0x82e
    18e8:	4f4d0000 	svcmi	0x004d0000
    18ec:	72445f53 	subvc	r5, r4, #332	; 0x14c
    18f0:	72657669 	rsbvc	r7, r5, #110100480	; 0x6900000
    18f4:	00682e73 	rsbeq	r2, r8, r3, ror lr
    18f8:	68000001 	stmdavs	r0, {r0}
                            && (line_mid-p-1>= 0))
    18fc:	70735f77 	rsbsvc	r5, r3, r7, ror pc
    1900:	00682e69 	rsbeq	r2, r8, r9, ror #28
    1904:	00000001 	andeq	r0, r0, r1
    1908:	c8020500 	stmdagt	r2, {r8, sl}
                    {
                        side_left = p;
    190c:	03000064 	movweq	r0, #100	; 0x64
                        p = p - 2;
    1910:	2f83012c 	svccs	0x0083012c
    1914:	4c4b4b4b 	mcrrmi	11, 4, r4, fp, cr11
    1918:	4b4b4b4b 	blmi	12d464c <__etext+0x12cb9a4>
                        for (; p >= 0; p --)
                            img[i * w + p] = 0;
    191c:	4c4b4b4b 	mcrrmi	11, 4, r4, fp, cr11
    1920:	4b4b4b4b 	blmi	12d4654 <__etext+0x12cb9ac>
    1924:	4b4b4b4b 	blmi	12d4658 <__etext+0x12cb9b0>
    1928:	2f2f2f3e 	svccs	0x002f2f3e
    192c:	00302f2f 	eorseq	r2, r0, pc, lsr #30
    1930:	06010402 	streq	r0, [r1], -r2, lsl #8
    1934:	3f4b064a 	svccc	0x004b064a
                    if ((img[i * w + p - 1] == 0) 
                            && (line_mid-p-1>= 0))
                    {
                        side_left = p;
                        p = p - 2;
                        for (; p >= 0; p --)
    1938:	773f0876 			; <UNDEFINED> instruction: 0x773f0876
    193c:	c5037676 	strgt	r7, [r3, #-1654]	; 0x676
    1940:	08843c00 	stmeq	r4, {sl, fp, ip, sp}
    1944:	4c844c3e 	stcmi	12, cr4, [r4], {62}	; 0x3e

    if (img[(h-1)*w + line_mid] == 0xff)
    {
        for (i = h - 1; i >= 0; i --)
        {
            for (p = line_mid - 1; p > 0; p --)
    1948:	4c844c77 	stcmi	12, cr4, [r4], {119}	; 0x77
    194c:	4c784c77 	ldclmi	12, cr4, [r8], #-476	; 0xfffffe24
    1950:	4c844c78 	stcmi	12, cr4, [r4], {120}	; 0x78
    1954:	4c844c77 	stcmi	12, cr4, [r4], {119}	; 0x77
                        p = p - 2;
                        for (; p >= 0; p --)
                            img[i * w + p] = 0;
                    }
            }
            for (p = line_mid + 1; p < w -1; p ++)
    1958:	5a844c77 	bpl	fe114b3c <__StackLimit+0xde114b3c>
    195c:	3e087685 	cfmadd32cc	mvax4, mvfx7, mvfx8, mvfx5
    1960:	774c844c 	strbvc	r8, [ip, -ip, asr #8]
            {
                if (img[i * w + p] == 0)
    1964:	844c784c 	strbhi	r7, [ip], #-2124	; 0x84c
    1968:	844c774c 	strbhi	r7, [ip], #-1868	; 0x74c
    196c:	844c774c 	strbhi	r7, [ip], #-1868	; 0x74c
    1970:	9667784c 	strbtls	r7, [r7], -ip, asr #16
    1974:	67226769 	strvs	r6, [r2, -r9, ror #14]!
    1978:	784c4022 	stmdavc	ip, {r1, r5, lr}^
                {
                    if ((img[i * w + p + 1] == 0)&&(p+1<w))
    197c:	69784c69 	ldmdbvs	r8!, {r0, r3, r5, r6, sl, fp, lr}^
    1980:	4c69784c 	stclmi	8, cr7, [r9], #-304	; 0xfffffed0
    1984:	774c6877 	smlsldxvc	r6, ip, r7, r8
    1988:	69784c68 	ldmdbvs	r8!, {r3, r5, r6, sl, fp, lr}^
    198c:	4c69784c 	stclmi	8, cr7, [r9], #-304	; 0xfffffed0
    1990:	784c6978 	stmdavc	ip, {r3, r4, r5, r6, r8, fp, sp, lr}^
    1994:	6a784c69 	bvs	1e14b40 <__etext+0x1e0be98>
    1998:	4b674b76 	blmi	19d4778 <__etext+0x19cbad0>
    199c:	4b674b67 	blmi	19d4740 <__etext+0x19cba98>
    19a0:	04020067 	streq	r0, [r2], #-103	; 0x67
    19a4:	064a0601 	strbeq	r0, [sl], -r1, lsl #12
                    {
                        side_right = p;
    19a8:	0200674b 	andeq	r6, r0, #19660800	; 0x12c0000
                        p = p + 2;
    19ac:	58060104 	stmdapl	r6, {r2, r8}
    19b0:	76765906 	ldrbtvc	r5, [r6], -r6, lsl #18
    19b4:	674b674b 	strbvs	r6, [fp, -fp, asr #14]
                        for (; p < w; p ++)
                            img[i * w + p] = 0;
    19b8:	674b674b 	strbvs	r6, [fp, -fp, asr #14]
    19bc:	01040200 	mrseq	r0, R12_usr
    19c0:	4b064a06 	blmi	1941e0 <__etext+0x18b538>
    19c4:	04020067 	streq	r0, [r2], #-103	; 0x67
    19c8:	064a0601 	strbeq	r0, [sl], -r1, lsl #12
    19cc:	4b76764b 	blmi	1d9f300 <__etext+0x1d96658>
    19d0:	4b674b67 	blmi	19d4774 <__etext+0x19cbacc>
                {
                    if ((img[i * w + p + 1] == 0)&&(p+1<w))
                    {
                        side_right = p;
                        p = p + 2;
                        for (; p < w; p ++)
    19d4:	00674b67 	rsbeq	r4, r7, r7, ror #22
    19d8:	06010402 	streq	r0, [r1], -r2, lsl #8
    19dc:	674b064a 	strbvs	r0, [fp, -sl, asr #12]
    19e0:	01040200 	mrseq	r0, R12_usr
                        p = p - 2;
                        for (; p >= 0; p --)
                            img[i * w + p] = 0;
                    }
            }
            for (p = line_mid + 1; p < w -1; p ++)
    19e4:	4b064a06 	blmi	194204 <__etext+0x18b55c>
    19e8:	946c6869 	strbtls	r6, [ip], #-2153	; 0x869
    19ec:	6a676967 	bvs	19dbf90 <__etext+0x19d32e8>
    19f0:	68896867 	stmvs	r9, {r0, r1, r2, r5, r6, fp, sp, lr}
    19f4:	8210032f 	andshi	r0, r0, #-1140850688	; 0xbc000000
    19f8:	76672f83 	strbtvc	r2, [r7], -r3, lsl #31
                        for (; p < w; p ++)
                            img[i * w + p] = 0;
                    }
                }
            }
            line_mid = (side_left + side_right) / 2;
    19fc:	764c084b 	strbvc	r0, [ip], -fp, asr #16
    1a00:	764c084b 	strbvc	r0, [ip], -fp, asr #16
    1a04:	3d4d084b 	stclcc	8, cr0, [sp, #-300]	; 0xfffffed4
    1a08:	900f032f 	andls	r0, pc, pc, lsr #6
    1a0c:	5a762f83 	bpl	1d8d820 <__etext+0x1d84b78>
            img[i * w + line_mid] = 0;
    1a10:	5b765a76 	blpl	1d983f0 <__etext+0x1d8f748>
    1a14:	0f032f3e 	svceq	0x00032f3e
    1a18:	762f8390 			; <UNDEFINED> instruction: 0x762f8390
    1a1c:	765a765a 			; <UNDEFINED> instruction: 0x765a765a
    1a20:	032f3d5b 	teqeq	pc, #5824	; 0x16c0
    1a24:	2177901b 	cmncs	r7, fp, lsl r0
    1a28:	332b672f 	teqcc	fp, #12320768	; 0xbc0000
    int16 p = 0, i = 0, line_mid = 39;
    int8 side_left = 0, side_right = 79;

    if (img[(h-1)*w + line_mid] == 0xff)
    {
        for (i = h - 1; i >= 0; i --)
    1a2c:	01040200 	mrseq	r0, R12_usr
    1a30:	4b062006 	blmi	189a50 <__etext+0x180da8>
    1a34:	04020068 	streq	r0, [r2], #-104	; 0x68
    1a38:	06200601 	strteq	r0, [r0], -r1, lsl #12
            }
            line_mid = (side_left + side_right) / 2;
            img[i * w + line_mid] = 0;
        }
    }
}
    1a3c:	22673d67 	rsbcs	r3, r7, #6592	; 0x19c0
    1a40:	4d660f03 	stclmi	15, cr0, [r6, #-12]!
    1a44:	01040200 	mrseq	r0, R12_usr
  ptb.GPIO_PinControl = NULL;
  LPLD_GPIO_Init(ptb);
}*/

void LPLD_SCCB_Init(void)
{
    1a48:	67062006 	strvs	r2, [r6, -r6]
    1a4c:	0321683d 	teqeq	r1, #3997696	; 0x3d0000
  GPIO_InitTypeDef ptb;
  /********û޸ֵ ʼ***********/
  ptb.GPIO_PTx = PTA;
    1a50:	21767418 	cmncs	r6, r8, lsl r4
    1a54:	332b672f 	teqcc	fp, #12320768	; 0xbc0000
  ptb.GPIO_Pins = GPIO_Pin25 | GPIO_Pin26;
    1a58:	01040200 	mrseq	r0, R12_usr
    1a5c:	4b062006 	blmi	189a7c <__etext+0x180dd4>
  /********û޸ֵ ***********/
  ptb.GPIO_Dir = DIR_OUTPUT;
    1a60:	76355c67 	ldrtvc	r5, [r5], -r7, ror #24
  ptb.GPIO_Output = OUTPUT_H;
    1a64:	6792ca67 	ldrvs	ip, [r2, r7, ror #20]
    1a68:	ca6792ca 	bgt	19e6598 <__etext+0x19dd8f0>
  ptb.GPIO_PinControl = INPUT_PULL_UP;
    1a6c:	92ca6792 	sbcls	r6, sl, #38273024	; 0x2480000
  LPLD_GPIO_Init(ptb);
    1a70:	6792ca67 	ldrvs	ip, [r2, r7, ror #20]
    1a74:	763524bf 			; <UNDEFINED> instruction: 0x763524bf
    1a78:	6792ca67 	ldrvs	ip, [r2, r7, ror #20]
    1a7c:	ca6792ca 	bgt	19e65ac <__etext+0x19dd904>
}
    1a80:	92ca6792 	sbcls	r6, sl, #38273024	; 0x2480000
    1a84:	6792ca67 	ldrvs	ip, [r2, r7, ror #20]
 * :
 *    1-ɹ
 *    0-ʧ
 */
uint8 LPLD_SCCB_WriteReg(uint16 reg_addr , uint8 data)
{		
    1a88:	763524bf 			; <UNDEFINED> instruction: 0x763524bf
    1a8c:	6792ca67 	ldrvs	ip, [r2, r7, ror #20]
    1a90:	ca6792ca 	bgt	19e65c0 <__etext+0x19dd918>
    1a94:	92ca6792 	sbcls	r6, sl, #38273024	; 0x2480000
  if(!LPLD_SCCB_Start())
    1a98:	6792ca67 	ldrvs	ip, [r2, r7, ror #20]
    1a9c:	000102bf 			; <UNDEFINED> instruction: 0x000102bf
  {
    return 0;
    1aa0:	02630101 	rsbeq	r0, r3, #1073741824	; 0x40000000
    1aa4:	00020000 	andeq	r0, r2, r0
  }
  LPLD_SCCB_SendByte(SCCB_DEV_ADR ); 
    1aa8:	0000011f 	andeq	r0, r0, pc, lsl r1
    1aac:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
  if(!LPLD_SCCB_WaitAck())
    1ab0:	0101000d 	tsteq	r1, sp
    1ab4:	00000101 	andeq	r0, r0, r1, lsl #2
  {
    LPLD_SCCB_Stop(); 
    1ab8:	00000100 	andeq	r0, r0, r0, lsl #2
    return 0;
    1abc:	2f2e2e01 	svccs	0x002e2e01
    1ac0:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; 1a10 <get_midline+0x1b4>
  }
  LPLD_SCCB_SendByte((uint8)(reg_addr & 0x00FF));   
    1ac4:	682f6269 	stmdavs	pc!, {r0, r3, r5, r6, r9, sp, lr}	; <UNPREDICTABLE>
    1ac8:	682f0077 	stmdavs	pc!, {r0, r1, r2, r4, r5, r6}	; <UNPREDICTABLE>
  LPLD_SCCB_WaitAck();	
    1acc:	2f656d6f 	svccs	0x00656d6f
  LPLD_SCCB_SendByte(data);
    1ad0:	656b6f6d 	strbvs	r6, [fp, #-3949]!	; 0xf6d
    1ad4:	6d732f72 	ldclvs	15, cr2, [r3, #-456]!	; 0xfffffe38
  LPLD_SCCB_WaitAck();   
    1ad8:	5f747261 	svcpl	0x00747261
  LPLD_SCCB_Stop(); 
    1adc:	2f726163 	svccs	0x00726163
  return 1;
    1ae0:	2f637273 	svccs	0x00637273
}									 
    1ae4:	2d636367 	stclcs	3, cr6, [r3, #-412]!	; 0xfffffe64
    1ae8:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
    1aec:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
 * :
 *    1-ɹ
 *    0-ʧ
 */          
uint8 LPLD_SCCB_ReadReg(uint8 reg_addr, uint8* data, uint16 length)
{	
    1af0:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
    1af4:	5f342d69 	svcpl	0x00342d69
    1af8:	30322d37 	eorscc	r2, r2, r7, lsr sp
    1afc:	33713331 	cmncc	r1, #-1006632960	; 0xc4000000
  if(!LPLD_SCCB_Start())
    1b00:	6e69622f 	cdpvs	2, 6, cr6, cr9, cr15, {1}
    1b04:	2f2e2e2f 	svccs	0x002e2e2f
    1b08:	2f62696c 	svccs	0x0062696c
  {
    return 0;
    1b0c:	2f636367 	svccs	0x00636367
  }
  LPLD_SCCB_SendByte( SCCB_DEV_ADR ); 
    1b10:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
    1b14:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
  if( !LPLD_SCCB_WaitAck() )
    1b18:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
    1b1c:	2e342f69 	cdpcs	15, 3, cr2, cr4, cr9, {3}
    1b20:	2f342e37 	svccs	0x00342e37
  {
    LPLD_SCCB_Stop(); 
    1b24:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    return 0;
    1b28:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
  }
  LPLD_SCCB_SendByte( reg_addr ); 
    1b2c:	2f2e2e2f 	svccs	0x002e2e2f
    1b30:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
  LPLD_SCCB_WaitAck();	
    1b34:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
  LPLD_SCCB_Stop(); 
    1b38:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
  
  if(!LPLD_SCCB_Start())
    1b3c:	6e692f69 	cdpvs	15, 6, cr2, cr9, cr9, {3}
    1b40:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xc63
    1b44:	2e2e0065 	cdpcs	0, 2, cr0, cr14, cr5, {3}
  {
    return 0;
    1b48:	2f2e2e2f 	svccs	0x002e2e2f
  }
  LPLD_SCCB_SendByte( SCCB_DEV_ADR + 1 );
    1b4c:	2f62696c 	svccs	0x0062696c
    1b50:	2f757063 	svccs	0x00757063
  
  if(!LPLD_SCCB_WaitAck())
    1b54:	64616568 	strbtvs	r6, [r1], #-1384	; 0x568
    1b58:	00737265 	rsbseq	r7, r3, r5, ror #4
    1b5c:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
  {
    LPLD_SCCB_Stop(); 
    1b60:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
    return 0;
    1b64:	6f632f62 	svcvs	0x00632f62
  }
  while(length)
  {
    *data = LPLD_SCCB_ReceiveByte();
    1b68:	6e6f6d6d 	cdpvs	13, 6, cr6, cr15, cr13, {3}
    1b6c:	77680000 	strbvc	r0, [r8, -r0]!
    1b70:	7261755f 	rsbvc	r7, r1, #398458880	; 0x17c00000
    if(length == 1)
    1b74:	00632e74 	rsbeq	r2, r3, r4, ror lr
    1b78:	73000001 	movwvc	r0, #1
    {
      LPLD_SCCB_NoAck();
    1b7c:	6e696474 	mcrvs	4, 3, r6, cr9, cr4, {3}
    }
    else
    {
      LPLD_SCCB_Ack(); 
    1b80:	00682e74 	rsbeq	r2, r8, r4, ror lr
    }
    data++;
    1b84:	4d000002 	stcmi	0, cr0, [r0, #-8]
    1b88:	4630364b 	ldrtmi	r3, [r0], -fp, asr #12
    length--;
    1b8c:	682e3531 	stmdavs	lr!, {r0, r4, r5, r8, sl, ip, sp}
    1b90:	00000300 	andeq	r0, r0, r0, lsl #6
  if(!LPLD_SCCB_WaitAck())
  {
    LPLD_SCCB_Stop(); 
    return 0;
  }
  while(length)
    1b94:	6d6d6f63 	stclvs	15, cr6, [sp, #-396]!	; 0xfffffe74
    1b98:	682e6e6f 	stmdavs	lr!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}
      LPLD_SCCB_Ack(); 
    }
    data++;
    length--;
  }
  LPLD_SCCB_Stop();
    1b9c:	00000400 	andeq	r0, r0, r0, lsl #8
  return 1;
    1ba0:	5f534f4d 	svcpl	0x00534f4d
}
    1ba4:	76697244 	strbtvc	r7, [r9], -r4, asr #4
    1ba8:	2e737265 	cdpcs	2, 7, cr7, cr3, cr5, {3}
/*
 * LPLD_SCCB_Start
 * SCCBʼźţڲ
 */
uint8 LPLD_SCCB_Start(void)
{
    1bac:	00010068 	andeq	r0, r1, r8, rrx
  SCCB_SDA_O=1;//ߵƽ
    1bb0:	5f776800 	svcpl	0x00776800
    1bb4:	74726175 	ldrbtvc	r6, [r2], #-373	; 0x175
    1bb8:	0100682e 	tsteq	r0, lr, lsr #16
    1bbc:	77680000 	strbvc	r0, [r8, -r0]!
  SCCB_SCL=1;   //ʱߵƽ 
    1bc0:	67636d5f 			; <UNDEFINED> instruction: 0x67636d5f
    1bc4:	0100682e 	tsteq	r0, lr, lsr #16
    1bc8:	00000000 	andeq	r0, r0, r0
  SCCB_DELAY();
    1bcc:	733c0205 	teqvc	ip, #1342177280	; 0x50000000
    1bd0:	1d030000 	stcne	0, cr0, [r3, #-0]
  
  SCCB_SDA_IN();//Ϊ
    1bd4:	2f2f8601 	svccs	0x002f8601
    1bd8:	302f3d3d 	eorcc	r3, pc, sp, lsr sp	; <UNPREDICTABLE>
    1bdc:	3d76403e 	ldclcc	0, cr4, [r6, #-248]!	; 0xffffff08
    1be0:	3d3e0867 	ldccc	8, cr0, [lr, #-412]!	; 0xfffffe64
  if(!SCCB_SDA_I)
    1be4:	76843d83 	strvc	r3, [r4], r3, lsl #27
    1be8:	843d833d 	ldrthi	r8, [sp], #-829	; 0x33d
    1bec:	673d7686 	ldrvs	r7, [sp, -r6, lsl #13]!
  {
    SCCB_SDA_OUT();	
    1bf0:	843d3e08 	ldrthi	r3, [sp], #-3592	; 0xe08
    1bf4:	86843d76 			; <UNDEFINED> instruction: 0x86843d76
    1bf8:	083d7667 	ldmdaeq	sp!, {r0, r1, r2, r5, r6, r9, sl, ip, sp, lr}
    1bfc:	7686753e 			; <UNDEFINED> instruction: 0x7686753e
    return 0;
    1c00:	3d3e083d 	ldccc	8, cr0, [lr, #-244]!	; 0xffffff0c
  }
  SCCB_SDA_OUT();//Ϊ;	
    1c04:	76843d83 	strvc	r3, [r4], r3, lsl #27
    1c08:	843d833d 	ldrthi	r8, [sp], #-829	; 0x33d
    1c0c:	083d7686 	ldmdaeq	sp!, {r1, r2, r7, r9, sl, ip, sp, lr}
    1c10:	76843d3e 			; <UNDEFINED> instruction: 0x76843d3e
  SCCB_SDA_O=0; //͵ƽ
    1c14:	3d86843d 	cfstrscc	mvf8, [r6, #244]	; 0xf4
    1c18:	3d3e0859 	ldccc	8, cr0, [lr, #-356]!	; 0xfffffe9c
    1c1c:	843d7684 	ldrthi	r7, [sp], #-1668	; 0x684
  
  SCCB_DELAY();
    1c20:	774d857c 	smlsldxvc	r8, sp, ip, r5
    1c24:	083fd768 	ldmdaeq	pc!, {r3, r5, r6, r8, r9, sl, ip, lr, pc}	; <UNPREDICTABLE>
  
  SCCB_SDA_IN();//Ϊ
    1c28:	00936831 	addseq	r6, r3, r1, lsr r8
    1c2c:	06010402 	streq	r0, [r1], -r2, lsl #8
    1c30:	833e064a 	teqhi	lr, #77594624	; 0x4a00000
    1c34:	02008594 	andeq	r8, r0, #620756992	; 0x25000000
  if(SCCB_SDA_I) 
    1c38:	4a060104 	bmi	182050 <__etext+0x1793a8>
    1c3c:	94833e06 	strls	r3, [r3], #3590	; 0xe06
    1c40:	14038386 	strne	r8, [r3], #-902	; 0x386
  {
    SCCB_SDA_OUT();
    1c44:	02004c74 	andeq	r4, r0, #29696	; 0x7400
    1c48:	20060104 	andcs	r0, r6, r4, lsl #2
    1c4c:	03597706 	cmpeq	r9, #1572864	; 0x180000
    1c50:	594b7415 	stmdbpl	fp, {r0, r2, r4, sl, ip, sp, lr}^
    return 0;
    1c54:	68741603 	ldmdavs	r4!, {r0, r1, r9, sl, ip}^
  }
  SCCB_SDA_OUT();//Ϊ
    1c58:	01040200 	mrseq	r0, R12_usr
    1c5c:	77062006 	strvc	r2, [r6, -r6]
    1c60:	5817033d 	ldmdapl	r7, {r0, r2, r3, r4, r5, r8, r9}
    1c64:	02002267 	andeq	r2, r0, #1879048198	; 0x70000006
  SCCB_SDA_O=0;//͵ƽ
    1c68:	beb80104 	frdlte	f0, f0, f4
    1c6c:	75580f03 	ldrbvc	r0, [r8, #-3843]	; 0xf03
    1c70:	5a765a76 	bpl	1d98650 <__etext+0x1d8f9a8>
  return 1;
    1c74:	5a765a76 	bpl	1d98654 <__etext+0x1d8f9ac>
}
    1c78:	4c765a76 	ldclmi	10, cr5, [r6], #-472	; 0xfffffe28
/*
 * LPLD_SCCB_Stop
 * SCCBֹͣźţڲ
 */
static void LPLD_SCCB_Stop(void)
{
    1c7c:	76660f03 	strbtvc	r0, [r6], -r3, lsl #30
  SCCB_SCL=0;
    1c80:	59755975 	ldmdbpl	r5!, {r0, r2, r4, r5, r6, r8, fp, ip, lr}^
    1c84:	59755975 	ldmdbpl	r5!, {r0, r2, r4, r5, r6, r8, fp, ip, lr}^
    1c88:	4b755975 	blmi	1d58264 <__etext+0x1d4f5bc>
    1c8c:	0200316b 	andeq	r3, r0, #-1073741798	; 0xc000001a
  SCCB_SDA_O=0;
    1c90:	9e060104 	adflss	f0, f6, f4
    1c94:	0069a006 	rsbeq	sl, r9, r6
    1c98:	06010402 	streq	r0, [r1], -r2, lsl #8
  SCCB_DELAY();
    1c9c:	68a0069e 	stmiavs	r0!, {r1, r2, r3, r4, r7, r9, sl}
    1ca0:	02003132 	andeq	r3, r0, #-2147483636	; 0x8000000c
  
  SCCB_SCL=1;
    1ca4:	9e060104 	adflss	f0, f6, f4
    1ca8:	0069a006 	rsbeq	sl, r9, r6
    1cac:	06010402 	streq	r0, [r1], -r2, lsl #8
    1cb0:	68a0069e 	stmiavs	r0!, {r1, r2, r3, r4, r7, r9, sl}
  SCCB_SDA_O=1;
    1cb4:	02003032 	andeq	r3, r0, #50	; 0x32
    1cb8:	9e060104 	adflss	f0, f6, f4
    1cbc:	0069a006 	rsbeq	sl, r9, r6
  SCCB_DELAY();
    1cc0:	06010402 	streq	r0, [r1], -r2, lsl #8
    1cc4:	68a0069e 	stmiavs	r0!, {r1, r2, r3, r4, r7, r9, sl}
}
    1cc8:	02003032 	andeq	r3, r0, #50	; 0x32
/*
 * LPLD_SCCB_Stop
 * SCCBӦźţڲ
 */
static void LPLD_SCCB_Ack(void)
{	
    1ccc:	9e060104 	adflss	f0, f6, f4
  SCCB_SCL=0;
    1cd0:	0069a006 	rsbeq	sl, r9, r6
    1cd4:	06010402 	streq	r0, [r1], -r2, lsl #8
    1cd8:	68a0069e 	stmiavs	r0!, {r1, r2, r3, r4, r7, r9, sl}
    1cdc:	02003032 	andeq	r3, r0, #50	; 0x32
  SCCB_DELAY();
    1ce0:	9e060104 	adflss	f0, f6, f4
    1ce4:	0069a006 	rsbeq	sl, r9, r6
  
  SCCB_SDA_O=0;
    1ce8:	06010402 	streq	r0, [r1], -r2, lsl #8
    1cec:	68a0069e 	stmiavs	r0!, {r1, r2, r3, r4, r7, r9, sl}
    1cf0:	02003032 	andeq	r3, r0, #50	; 0x32
  SCCB_DELAY();
    1cf4:	9e060104 	adflss	f0, f6, f4
    1cf8:	0069a006 	rsbeq	sl, r9, r6
  
  SCCB_SCL=1;
    1cfc:	06010402 	streq	r0, [r1], -r2, lsl #8
    1d00:	68a0069e 	stmiavs	r0!, {r1, r2, r3, r4, r7, r9, sl}
    1d04:	01000102 	tsteq	r0, r2, lsl #2
    1d08:	0000f401 	andeq	pc, r0, r1, lsl #8
  SCCB_DELAY();
    1d0c:	d7000200 	strle	r0, [r0, -r0, lsl #4]
    1d10:	02000000 	andeq	r0, r0, #0
  
  SCCB_SCL=0;
    1d14:	0d0efb01 	vstreq	d15, [lr, #-4]
    1d18:	01010100 	mrseq	r0, (UNDEF: 17)
    1d1c:	00000001 	andeq	r0, r0, r1
  SCCB_DELAY();
    1d20:	01000001 	tsteq	r0, r1
    1d24:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
}
    1d28:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
/*
 * LPLD_SCCB_NoAck
 * SCCBӦźţڲ
 */
static void LPLD_SCCB_NoAck(void)
{	
    1d2c:	6f632f62 	svcvs	0x00632f62
  SCCB_SCL=0;
    1d30:	6e6f6d6d 	cdpvs	13, 6, cr6, cr15, cr13, {3}
    1d34:	2f2e2e00 	svccs	0x002e2e00
    1d38:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; 1c88 <LPLD_SCCB_Stop+0xc>
    1d3c:	632f6269 	teqvs	pc, #-1879048186	; 0x90000006
  SCCB_DELAY();
    1d40:	682f7570 	stmdavs	pc!, {r4, r5, r6, r8, sl, ip, sp, lr}	; <UNPREDICTABLE>
    1d44:	65646165 	strbvs	r6, [r4, #-357]!	; 0x165
  SCCB_SDA_O=1;
    1d48:	2f007372 	svccs	0x00007372
    1d4c:	656d6f68 	strbvs	r6, [sp, #-3944]!	; 0xf68
    1d50:	6b6f6d2f 	blvs	1bdd214 <__etext+0x1bd456c>
  SCCB_DELAY();
    1d54:	732f7265 	teqvc	pc, #1342177286	; 0x50000006
    1d58:	7472616d 	ldrbtvc	r6, [r2], #-365	; 0x16d
  SCCB_SCL=1;
    1d5c:	7261635f 	rsbvc	r6, r1, #2080374785	; 0x7c000001
    1d60:	6372732f 	cmnvs	r2, #-1140850688	; 0xbc000000
    1d64:	6363672f 	cmnvs	r3, #12320768	; 0xbc0000
    1d68:	6d72612d 	ldfvse	f6, [r2, #-180]!	; 0xffffff4c
  SCCB_DELAY();
    1d6c:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    1d70:	61652d65 	cmnvs	r5, r5, ror #26
  SCCB_SCL=0;
    1d74:	342d6962 	strtcc	r6, [sp], #-2402	; 0x962
    1d78:	322d375f 	eorcc	r3, sp, #24903680	; 0x17c0000
    1d7c:	71333130 	teqvc	r3, r0, lsr r1
  SCCB_DELAY();
    1d80:	69622f33 	stmdbvs	r2!, {r0, r1, r4, r5, r8, r9, sl, fp, sp}^
    1d84:	2e2e2f6e 	cdpcs	15, 2, cr2, cr14, cr14, {3}
}
    1d88:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
/*
 * LPLD_SCCB_WaitAck
 * SCCBȴӦźţڲ
 */
static uint8 LPLD_SCCB_WaitAck(void) 	
{
    1d8c:	6363672f 	cmnvs	r3, #12320768	; 0xbc0000
  SCCB_SCL=0;//ʱߵ͵ƽ
    1d90:	6d72612f 	ldfvse	f6, [r2, #-188]!	; 0xffffff44
    1d94:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    1d98:	61652d65 	cmnvs	r5, r5, ror #26
    1d9c:	342f6962 	strtcc	r6, [pc], #-2402	; 1da4 <LPLD_SCCB_WaitAck+0x18>
  SCCB_DELAY(); 
    1da0:	342e372e 	strtcc	r3, [lr], #-1838	; 0x72e
    1da4:	2f2e2e2f 	svccs	0x002e2e2f
  
 SCCB_SDA_IN();//Ϊ**
    1da8:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    1dac:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    1db0:	6d72612f 	ldfvse	f6, [r2, #-188]!	; 0xffffff44
  SCCB_DELAY();
    1db4:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    1db8:	61652d65 	cmnvs	r5, r5, ror #26
  
  SCCB_SCL=1;//ʱ߸ߵƽ
    1dbc:	692f6962 	stmdbvs	pc!, {r1, r5, r6, r8, fp, sp, lr}	; <UNPREDICTABLE>
    1dc0:	756c636e 	strbvc	r6, [ip, #-878]!	; 0x36e
    1dc4:	00006564 	andeq	r6, r0, r4, ror #10
    1dc8:	632e6f69 	teqvs	lr, #420	; 0x1a4
  
  SCCB_DELAY();
    1dcc:	00000100 	andeq	r0, r0, r0, lsl #2
    1dd0:	30364b4d 	eorscc	r4, r6, sp, asr #22
  
  if(SCCB_SDA_I)
    1dd4:	2e353146 	rsfcssm	f3, f5, f6
    1dd8:	00020068 	andeq	r0, r2, r8, rrx
    1ddc:	64747300 	ldrbtvs	r7, [r4], #-768	; 0x300
  {
    SCCB_SDA_OUT();
    1de0:	2e746e69 	cdpcs	14, 7, cr6, cr4, cr9, {3}
    1de4:	00030068 	andeq	r0, r3, r8, rrx
    1de8:	05000000 	streq	r0, [r0, #-0]
    1dec:	007ccc02 	rsbseq	ip, ip, r2, lsl #24
    SCCB_SCL=0;
    1df0:	011d0300 	tsteq	sp, r0, lsl #6
    1df4:	593f752f 	ldmdbpl	pc!, {r0, r1, r2, r3, r5, r8, sl, ip, sp, lr}	; <UNPREDICTABLE>
    1df8:	752f4d91 	strvc	r4, [pc, #-3473]!	; 106f <Ov7725_eagle_dma+0x5b>
    return 0;
    1dfc:	01000202 	tsteq	r0, r2, lsl #4
    1e00:	0002d801 	andeq	sp, r2, r1, lsl #16
  }
  SCCB_SDA_OUT();//Ϊ
    1e04:	3f000200 	svccc	0x00000200
    1e08:	02000001 	andeq	r0, r0, #1
    1e0c:	0d0efb01 	vstreq	d15, [lr, #-4]
  SCCB_SCL=0; //ʱߵ͵ƽ
    1e10:	01010100 	mrseq	r0, (UNDEF: 17)
    1e14:	00000001 	andeq	r0, r0, r1
    1e18:	01000001 	tsteq	r0, r1
    1e1c:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
  return 1;
    1e20:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
}
    1e24:	6f632f62 	svcvs	0x00632f62
/*
 * LPLD_SCCB_SendByte
 * SCCBݣڲ
 */
static void LPLD_SCCB_SendByte(uint8 data) 
{
    1e28:	6e6f6d6d 	cdpvs	13, 6, cr6, cr15, cr13, {3}
    1e2c:	6f682f00 	svcvs	0x00682f00
    1e30:	6d2f656d 	cfstr32vs	mvfx6, [pc, #-436]!	; 1c84 <LPLD_SCCB_Stop+0x8>
  uint8 i=8;
    1e34:	72656b6f 	rsbvc	r6, r5, #113664	; 0x1bc00
  while(i--)
    1e38:	616d732f 	cmnvs	sp, pc, lsr #6
  {
    SCCB_SCL=0;
    1e3c:	635f7472 	cmpvs	pc, #1912602624	; 0x72000000
    1e40:	732f7261 	teqvc	pc, #268435462	; 0x10000006
    1e44:	672f6372 			; <UNDEFINED> instruction: 0x672f6372
    SCCB_DELAY();
    1e48:	612d6363 	teqvs	sp, r3, ror #6
    1e4c:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    if(data&0x80)
    1e50:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
    1e54:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    {
      SCCB_SDA_O=1; 
    1e58:	375f342d 	ldrbcc	r3, [pc, -sp, lsr #8]
    1e5c:	3130322d 	teqcc	r0, sp, lsr #4
    1e60:	2f337133 	svccs	0x00337133
    1e64:	2f6e6962 	svccs	0x006e6962
    }
    else 
    {
      SCCB_SDA_O=0;   
    1e68:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; 1db8 <LPLD_SCCB_WaitAck+0x2c>
    1e6c:	672f6269 	strvs	r6, [pc, -r9, ror #4]!
    1e70:	612f6363 	teqvs	pc, r3, ror #6
    1e74:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    }
    data<<=1;
    1e78:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
    1e7c:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    SCCB_DELAY();
    1e80:	372e342f 	strcc	r3, [lr, -pc, lsr #8]!
    1e84:	692f342e 	stmdbvs	pc!, {r1, r2, r3, r5, sl, ip, sp}	; <UNPREDICTABLE>
    SCCB_SCL=1;
    1e88:	756c636e 	strbvc	r6, [ip, #-878]!	; 0x36e
    1e8c:	2f006564 	svccs	0x00006564
    1e90:	656d6f68 	strbvs	r6, [sp, #-3944]!	; 0xf68
    SCCB_DELAY();
    1e94:	6b6f6d2f 	blvs	1bdd358 <__etext+0x1bd46b0>
    1e98:	732f7265 	teqvc	pc, #1342177286	; 0x50000006
 * SCCBݣڲ
 */
static void LPLD_SCCB_SendByte(uint8 data) 
{
  uint8 i=8;
  while(i--)
    1e9c:	7472616d 	ldrbtvc	r6, [r2], #-365	; 0x16d
    1ea0:	7261635f 	rsbvc	r6, r1, #2080374785	; 0x7c000001
    1ea4:	6372732f 	cmnvs	r2, #-1140850688	; 0xbc000000
    1ea8:	6363672f 	cmnvs	r3, #12320768	; 0xbc0000
    1eac:	6d72612d 	ldfvse	f6, [r2, #-180]!	; 0xffffff4c
    1eb0:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    data<<=1;
    SCCB_DELAY();
    SCCB_SCL=1;
    SCCB_DELAY();
  }
  SCCB_SCL=0;
    1eb4:	61652d65 	cmnvs	r5, r5, ror #26
    1eb8:	342d6962 	strtcc	r6, [sp], #-2402	; 0x962
    1ebc:	322d375f 	eorcc	r3, sp, #24903680	; 0x17c0000
    1ec0:	71333130 	teqvc	r3, r0, lsr r1
}
    1ec4:	69622f33 	stmdbvs	r2!, {r0, r1, r4, r5, r8, r9, sl, fp, sp}^
    1ec8:	2e2e2f6e 	cdpcs	15, 2, cr2, cr14, cr14, {3}
/*
 * LPLD_SCCB_SendByte
 * SCCBݣڲ
 */
static uint8 LPLD_SCCB_ReceiveByte(void)  
{ 
    1ecc:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
    1ed0:	6363672f 	cmnvs	r3, #12320768	; 0xbc0000
  uint8 i=8;
    1ed4:	6d72612f 	ldfvse	f6, [r2, #-188]!	; 0xffffff44
  uint8 ReceiveByte=0;
    1ed8:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    1edc:	61652d65 	cmnvs	r5, r5, ror #26
  
  SCCB_SDA_O=1;	
    1ee0:	342f6962 	strtcc	r6, [pc], #-2402	; 1ee8 <LPLD_SCCB_ReceiveByte+0x1c>
    1ee4:	342e372e 	strtcc	r3, [lr], #-1838	; 0x72e
    1ee8:	2f2e2e2f 	svccs	0x002e2e2f
  SCCB_DELAY();
    1eec:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    1ef0:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
  
  SCCB_SDA_IN();	
    1ef4:	6d72612f 	ldfvse	f6, [r2, #-188]!	; 0xffffff44
    1ef8:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    1efc:	61652d65 	cmnvs	r5, r5, ror #26
    1f00:	692f6962 	stmdbvs	pc!, {r1, r5, r6, r8, fp, sp, lr}	; <UNPREDICTABLE>
  
  while(i--)
  {
    ReceiveByte<<=1;      
    1f04:	756c636e 	strbvc	r6, [ip, #-878]!	; 0x36e
    1f08:	00006564 	andeq	r6, r0, r4, ror #10
    SCCB_SCL=0;
    1f0c:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
    1f10:	632e6674 	teqvs	lr, #121634816	; 0x7400000
    1f14:	00000100 	andeq	r0, r0, r0, lsl #2
    1f18:	6d6d6f63 	stclvs	15, cr6, [sp, #-396]!	; 0xfffffe74
    SCCB_DELAY();
    1f1c:	682e6e6f 	stmdavs	lr!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}
    1f20:	00000100 	andeq	r0, r0, r0, lsl #2
    
    SCCB_SCL=1;
    1f24:	61647473 	smcvs	18243	; 0x4743
    1f28:	682e6772 	stmdavs	lr!, {r1, r4, r5, r6, r8, r9, sl, sp, lr}
    1f2c:	00000200 	andeq	r0, r0, r0, lsl #4
    SCCB_DELAY();	
    1f30:	69647473 	stmdbvs	r4!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
    1f34:	00682e6f 	rsbeq	r2, r8, pc, ror #28
    
    if(SCCB_SDA_I)
    1f38:	3c000003 	stccc	0, cr0, [r0], {3}
    1f3c:	6c697562 	cfstr64vs	mvdx7, [r9], #-392	; 0xfffffe78
    1f40:	6e692d74 	mcrvs	13, 3, r2, cr9, cr4, {3}
    1f44:	0000003e 	andeq	r0, r0, lr, lsr r0
    {
      ReceiveByte|=0x01;
    1f48:	05000000 	streq	r0, [r0, #-0]
    1f4c:	007d2002 	rsbseq	r2, sp, r2
  SCCB_SDA_O=1;	
  SCCB_DELAY();
  
  SCCB_SDA_IN();	
  
  while(i--)
    1f50:	00d50300 	sbcseq	r0, r5, r0, lsl #6
    1f54:	75776701 	ldrbvc	r6, [r7, #-1793]!	; 0x701
    1f58:	22675922 	rsbcs	r5, r7, #557056	; 0x88000
    1f5c:	7b4e6722 	blvc	139bbec <__etext+0x1392f44>
    1f60:	3e842f3d 	mcrcc	15, 4, r2, cr4, cr13, {1}
    1f64:	4b4b3e3d 	blmi	12d1860 <__etext+0x12c8bb8>
    {
      ReceiveByte|=0x01;
    }
    
  }
  SCCB_SDA_OUT();
    1f68:	3e755924 	cdpcc	9, 7, cr5, cr5, cr4, {1}
    1f6c:	832f4c5c 	teqhi	pc, #23552	; 0x5c00
    1f70:	01040200 	mrseq	r0, R12_usr
  SCCB_SCL=0;
    1f74:	064a7203 	strbeq	r7, [sl], -r3, lsl #4
    1f78:	1303063c 	movwne	r0, #13884	; 0x363c
    1f7c:	4b3e3d20 	blmi	f91404 <__etext+0xf8875c>
    1f80:	7559244b 	ldrbvc	r2, [r9, #-1099]	; 0x44b
  
  return ReceiveByte;
}
    1f84:	2f4c5c3e 	svccs	0x004c5c3e
    1f88:	04020083 	streq	r0, [r2], #-131	; 0x83
    1f8c:	4a720301 	bmi	1c82b98 <__etext+0x1c79ef0>
/*
 * LPLD_SCCB_SendByte
 * SCCBʱڲ
 */
static void LPLD_SCCB_Delay(uint16 i)
{	
    1f90:	213c1203 	teqcs	ip, r3, lsl #4
    1f94:	02007778 	andeq	r7, r0, #31457280	; 0x1e00000
    1f98:	003e0204 	eorseq	r0, lr, r4, lsl #4
  while(i) 
    i--; 
    1f9c:	64020402 	strvs	r0, [r2], #-1026	; 0x402
    1fa0:	01040200 	mrseq	r0, R12_usr
 * LPLD_SCCB_SendByte
 * SCCBʱڲ
 */
static void LPLD_SCCB_Delay(uint16 i)
{	
  while(i) 
    1fa4:	4e064a06 	vmlami.f32	s8, s12, s12
    1fa8:	0200774f 	andeq	r7, r0, #20709376	; 0x13c0000
    i--; 
}
    1fac:	003e0204 	eorseq	r0, lr, r4, lsl #4
    1fb0:	64020402 	strvs	r0, [r2], #-1026	; 0x402
 * 输出:
 *    0--配置错误
 *    1--配置成功
 */
uint8 LPLD_ADC_Init(ADC_InitTypeDef adc_init_structure)
{
    1fb4:	01040200 	mrseq	r0, R12_usr
    1fb8:	4e064a06 	vmlami.f32	s8, s12, s12
    1fbc:	660a034e 	strvs	r0, [sl], -lr, asr #6
    1fc0:	443c1503 	ldrtmi	r1, [ip], #-1283	; 0x503
  uint8 i;
  ADC_MemMapPtr adcx = adc_init_structure.ADC_Adcx;
    1fc4:	0f033e43 	svceq	0x00033e43
  uint8 diff = adc_init_structure.ADC_DiffMode;
    1fc8:	20750374 	rsbscs	r0, r5, r4, ror r3
    1fcc:	820a0383 	andhi	r0, sl, #201326594	; 0xc000002
  uint8 mode = adc_init_structure.ADC_BitMode;
    1fd0:	223d3d26 	eorscs	r3, sp, #2432	; 0x980
  uint8 time = adc_init_structure.ADC_SampleTimeCfg;
    1fd4:	4b153002 	blmi	54dfe4 <__etext+0x54533c>
    1fd8:	4b224b22 	blmi	894c68 <__etext+0x88bfc0>
  uint8 ltime = adc_init_structure.ADC_LongSampleTimeSel;
    1fdc:	4b224b22 	blmi	894c6c <__etext+0x88bfc4>
  uint8 avg = adc_init_structure.ADC_HwAvgSel;
    1fe0:	003d4b23 	eorseq	r4, sp, r3, lsr #22
    1fe4:	03010402 	movweq	r0, #5122	; 0x1402
  uint8 muxab = adc_init_structure.ADC_MuxSel;
    1fe8:	1e032069 	cdpne	0, 0, cr2, cr3, cr9, {3}
  uint8 pga = adc_init_structure.ADC_PgaGain;
    1fec:	223d3d3c 	eorscs	r3, sp, #3840	; 0xf00
    1ff0:	c9c80c03 	stmibgt	r8, {r0, r1, sl, fp}^
  uint8 hwtrg = adc_init_structure.ADC_HwTrgCfg;
    1ff4:	003d4b23 	eorseq	r4, sp, r3, lsr #22
  ADC_ISR_CALLBACK isr_func = adc_init_structure.ADC_Isr;
    1ff8:	03010402 	movweq	r0, #5122	; 0x1402
 
  //配置ADC时钟 //这里貌似只配置了两个还要另行配置其他的几个
  if(adcx == ADC0)
    1ffc:	1b03206c 	blne	ca1b4 <__etext+0xc150c>
    2000:	223d983c 	eorscs	r9, sp, #3932160	; 0x3c0000
    2004:	23ac1003 			; <UNDEFINED> instruction: 0x23ac1003
    2008:	02003d4b 	andeq	r3, r0, #4800	; 0x12c0
  {
    i=0;
    200c:	69030104 	stmdbvs	r3, {r2, r8}
    SIM_SCGC6 |= SIM_SCGC6_ADC0_MASK;   // 开启ADC0时钟
    2010:	063c0620 	ldrteq	r0, [ip], -r0, lsr #12
    2014:	03201e03 	teqeq	r0, #48	; 0x30
    2018:	0d034a0b 	vstreq	s8, [r3, #-44]	; 0xffffffd4
    201c:	76034bc8 	strvc	r4, [r3], -r8, asr #23
    2020:	03313120 	teqeq	r1, #8
    2024:	5302200a 	movwpl	r2, #8202	; 0x200a
    2028:	5ac96716 	bpl	ff25bc88 <__StackLimit+0xdf25bc88>
    202c:	5a5c3d3e 	bpl	171152c <__etext+0x1708884>
    2030:	3d5a5c3d 	ldclcc	12, cr5, [sl, #-244]	; 0xffffff0c
    2034:	5a41405c 	bpl	10521ac <__etext+0x1049504>
    2038:	833e753d 	teqhi	lr, #255852544	; 0xf400000
  }
  else if(adcx == ADC1)
    203c:	3d845a40 	vstrcc	s10, [r4, #256]	; 0x100
    2040:	02004275 	andeq	r4, r0, #1342177287	; 0x50000007
    2044:	4a060104 	bmi	18245c <__etext+0x1797b4>
  {
    i=1;
    2048:	24764c06 	ldrbtcs	r4, [r6], #-3078	; 0xc06
    204c:	3d5ac967 	ldclcc	9, cr12, [sl, #-412]	; 0xfffffe64
    SIM_SCGC3 |= SIM_SCGC3_ADC1_MASK;   // 开启ADC1时钟
    2050:	84835a5a 	strhi	r5, [r3], #2650	; 0xa5a
    2054:	5a40833e 	bpl	1022d54 <__etext+0x101a0ac>
    2058:	5a834c5a 	bpl	fe0d51c8 <__StackLimit+0xde0d51c8>
    205c:	00418383 	subeq	r8, r1, r3, lsl #7
    2060:	06010402 	streq	r0, [r1], -r2, lsl #8
    2064:	834c0666 	movthi	r0, #50790	; 0xc666
    2068:	67234c83 	strvs	r4, [r3, -r3, lsl #25]!
    206c:	c96722c9 	stmdbgt	r7!, {r0, r3, r6, r7, r9, sp}^
    2070:	22c96722 	sbccs	r6, r9, #8912896	; 0x880000
    2074:	5a5acb67 	bpl	16b4e18 <__etext+0x16ac170>
  }
  else 
  {
    return 0;
    2078:	2e0b0383 	cdpcs	3, 0, cr0, cr11, cr3, {4}
    207c:	5a207903 	bpl	820490 <__etext+0x8177e8>
  }

  if(adc_init_structure.ADC_CalEnable == TRUE)
    2080:	7fb00387 	svcvc	0x00b00387
    2084:	2e2d0320 	cdpcs	3, 2, cr0, cr13, cr0, {1}
    LPLD_ADC_Cal(adcx);  //进行ADC校准
    2088:	21202303 	teqcs	r0, r3, lsl #6
  
  //设置ADCCFG1寄存器
  adcx->CFG1  &=   (~ADC_CFG1_ADLPC_MASK);         // 重新为正常使用进行配置
    208c:	040200e3 	streq	r0, [r2], #-227	; 0xe3
    2090:	06200601 	strteq	r0, [r0], -r1, lsl #12
    2094:	23845a4d 	orrcs	r5, r4, #315392	; 0x4d000
  adcx->CFG1  |=    ADC_CFG1_ADIV(ADIV_1)          // ADC输入时钟分频为 1
    2098:	67227583 	strvs	r7, [r2, -r3, lsl #11]!
                  | (time)                           // 设置长短时间采样模式
                  | ADC_CFG1_ADICLK(ADICLK_BUS_2)  // ADC输入时钟源为 BusClk
    209c:	845a593e 	ldrbhi	r5, [sl], #-2366	; 0x93e
    20a0:	0200e321 	andeq	lr, r0, #-2080374784	; 0x84000000
    20a4:	20060104 	andcs	r0, r6, r4, lsl #2
                  | ADC_CFG1_MODE(mode);           //设置ADC转换精度
    20a8:	855a4c06 	ldrbhi	r4, [sl, #-3078]	; 0xc06
    20ac:	223d6722 	eorscs	r6, sp, #8912896	; 0x880000
    20b0:	20630375 	rsbcs	r0, r3, r5, ror r3
  if(adc_init_structure.ADC_CalEnable == TRUE)
    LPLD_ADC_Cal(adcx);  //进行ADC校准
  
  //设置ADCCFG1寄存器
  adcx->CFG1  &=   (~ADC_CFG1_ADLPC_MASK);         // 重新为正常使用进行配置
  adcx->CFG1  |=    ADC_CFG1_ADIV(ADIV_1)          // ADC输入时钟分频为 1
    20b4:	032e1603 	teqeq	lr, #3145728	; 0x300000
                  | (time)                           // 设置长短时间采样模式
                  | ADC_CFG1_ADICLK(ADICLK_BUS_2)  // ADC输入时钟源为 BusClk
                  | ADC_CFG1_MODE(mode);           //设置ADC转换精度

  //设置ADCCFG2寄存器
  adcx->CFG2 &=  (~ADC_CFG2_ADACKEN_MASK);   //禁用异步时钟输出
    20b8:	00207da9 	eoreq	r7, r0, r9, lsr #27
    20bc:	06010402 	streq	r0, [r1], -r2, lsl #8
    20c0:	e103064a 	tst	r3, sl, asr #12
  adcx->CFG2 |=    (muxab)                      // ADC复用选择
    20c4:	6a218202 	bvs	8628d4 <__etext+0x859c2c>
                 | (ADC_CFG2_ADHSC_MASK)        // 高速转换
                 | ADC_CFG2_ADLSTS(ltime);    // 长采样时间时钟周期选择
    20c8:	3d5c3d50 	ldclcc	13, cr3, [ip, #-320]	; 0xfffffec0
    20cc:	5a862187 	bpl	fe18a6f0 <__StackLimit+0xde18a6f0>
    20d0:	2f3d3e42 	svccs	0x003d3e42
    20d4:	214d833d 	cmpcs	sp, sp, lsr r3
    20d8:	01000802 	tsteq	r0, r2, lsl #16
                  | ADC_CFG1_ADICLK(ADICLK_BUS_2)  // ADC输入时钟源为 BusClk
                  | ADC_CFG1_MODE(mode);           //设置ADC转换精度

  //设置ADCCFG2寄存器
  adcx->CFG2 &=  (~ADC_CFG2_ADACKEN_MASK);   //禁用异步时钟输出
  adcx->CFG2 |=    (muxab)                      // ADC复用选择
    20dc:	Address 0x000020dc is out of bounds.


Disassembly of section .debug_str:

00000000 <.debug_str>:
       0:	5f544e49 	svcpl	0x00544e49
       4:	64726148 	ldrbtvs	r6, [r2], #-328	; 0x148
       8:	7561465f 	strbvc	r4, [r1, #-1631]!	; 0x65f
       c:	7200746c 	andvc	r7, r0, #1811939328	; 0x6c000000
      10:	79646165 	stmdbvc	r4!, {r0, r2, r5, r6, r8, sp, lr}^
      14:	6e65735f 	mcrvs	3, 3, r7, cr5, cr15, {2}
      18:	6c665f64 	stclvs	15, cr5, [r6], #-400	; 0xfffffe70
      1c:	4e006761 	cdpmi	7, 0, cr6, cr0, cr1, {3}
      20:	45545942 	ldrbmi	r5, [r4, #-2370]	; 0x942
      24:	4c4d5f53 	mcrrmi	15, 5, r5, sp, cr3
      28:	4e46464f 	cdpmi	6, 4, cr4, cr6, cr15, {2}
      2c:	4e49004f 	cdpmi	0, 4, cr0, cr9, cr15, {2}
      30:	49505f54 	ldmdbmi	r0, {r2, r4, r6, r8, r9, sl, fp, ip, lr}^
      34:	43003154 	movwmi	r3, #340	; 0x154
      38:	52455449 	subpl	r5, r5, #1224736768	; 0x49000000
      3c:	494c455f 	stmdbmi	ip, {r0, r1, r2, r3, r4, r6, r8, sl, lr}^
      40:	4f4e4b4e 	svcmi	0x004e4b4e
      44:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
      48:	5449505f 	strbpl	r5, [r9], #-95	; 0x5f
      4c:	4e490033 	mcrmi	0, 2, r0, cr9, cr3, {1}
      50:	434d5f54 	movtmi	r5, #57172	; 0xdf54
      54:	4e490047 	cdpmi	0, 4, cr0, cr9, cr7, {2}
      58:	4e455f54 	mcrmi	15, 2, r5, cr5, cr4, {2}
      5c:	525f5445 	subspl	r5, pc, #1157627904	; 0x45000000
      60:	69656365 	stmdbvs	r5!, {r0, r2, r5, r6, r8, r9, sp, lr}^
      64:	50006576 	andpl	r6, r0, r6, ror r5
      68:	00524f54 	subseq	r4, r2, r4, asr pc
      6c:	5f544e49 	svcpl	0x00544e49
      70:	314e4143 	cmpcc	lr, r3, asr #2
      74:	65524f5f 	ldrbvs	r4, [r2, #-3935]	; 0xf5f
      78:	654d5f64 	strbvs	r5, [sp, #-3940]	; 0xf64
      7c:	67617373 			; <UNDEFINED> instruction: 0x67617373
      80:	75625f65 	strbvc	r5, [r2, #-3941]!	; 0xf65
      84:	72656666 	rsbvc	r6, r5, #106954752	; 0x6600000
      88:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
      8c:	4e41435f 	mcrmi	3, 2, r4, cr1, cr15, {2}
      90:	524f5f30 	subpl	r5, pc, #192	; 0xc0
      94:	4d5f6465 	cfldrdmi	mvd6, [pc, #-404]	; ffffff08 <__StackLimit+0xdfffff08>
      98:	61737365 	cmnvs	r3, r5, ror #6
      9c:	625f6567 	subsvs	r6, pc, #432013312	; 0x19c00000
      a0:	65666675 	strbvs	r6, [r6, #-1653]!	; 0x675
      a4:	4e490072 	mcrmi	0, 2, r0, cr9, cr2, {3}
      a8:	44535f54 	ldrbmi	r5, [r3], #-3924	; 0xf54
      ac:	44004348 	strmi	r4, [r0], #-840	; 0x348
      b0:	0046464f 	subeq	r4, r6, pc, asr #12
      b4:	5f544e49 	svcpl	0x00544e49
      b8:	65736552 	ldrbvs	r6, [r3, #-1362]!	; 0x552
      bc:	64657672 	strbtvs	r7, [r5], #-1650	; 0x672
      c0:	00323031 	eorseq	r3, r2, r1, lsr r0
      c4:	5f544e49 	svcpl	0x00544e49
      c8:	5f6d654d 	svcpl	0x006d654d
      cc:	616e614d 	cmnvs	lr, sp, asr #2
      d0:	465f6567 	ldrbmi	r6, [pc], -r7, ror #10
      d4:	746c7561 	strbtvc	r7, [ip], #-1377	; 0x561
      d8:	45455300 	strbmi	r5, [r5, #-768]	; 0x300
      dc:	4e490049 	cdpmi	0, 4, cr0, cr9, cr9, {2}
      e0:	4e455f54 	mcrmi	15, 2, r5, cr5, cr4, {2}
      e4:	545f5445 	ldrbpl	r5, [pc], #-1093	; ec <__vector_table+0xec>
      e8:	736e6172 	cmnvc	lr, #-2147483620	; 0x8000001c
      ec:	0074696d 	rsbseq	r6, r4, sp, ror #18
      f0:	50484344 	subpl	r4, r8, r4, asr #6
      f4:	00344952 	eorseq	r4, r4, r2, asr r9
      f8:	5f544e49 	svcpl	0x00544e49
      fc:	65736552 	ldrbvs	r6, [r3, #-1362]!	; 0x552
     100:	64657672 	strbtvs	r7, [r5], #-1650	; 0x672
     104:	00333131 	eorseq	r3, r3, r1, lsr r1
     108:	5f544e49 	svcpl	0x00544e49
     10c:	30414d44 	subcc	r4, r1, r4, asr #26
     110:	414d445f 	cmpmi	sp, pc, asr r4
     114:	49003631 	stmdbmi	r0, {r0, r4, r5, r9, sl, ip, sp}
     118:	525f544e 	subspl	r5, pc, #1308622848	; 0x4e000000
     11c:	5f646165 	svcpl	0x00646165
     120:	6c6c6f43 	stclvs	15, cr6, [ip], #-268	; 0xfffffef4
     124:	6f697369 	svcvs	0x00697369
     128:	4e49006e 	cdpmi	0, 4, cr0, cr9, cr14, {3}
     12c:	4f505f54 	svcmi	0x00505f54
     130:	00425452 	subeq	r5, r2, r2, asr r4
     134:	524f4350 	subpl	r4, pc, #1073741825	; 0x40000001
     138:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     13c:	414d445f 	cmpmi	sp, pc, asr r4
     140:	4d445f39 	stclmi	15, cr5, [r4, #-228]	; 0xffffff1c
     144:	00353241 	eorseq	r3, r5, r1, asr #4
     148:	5f544e49 	svcpl	0x00544e49
     14c:	32414d44 	subcc	r4, r1, #4352	; 0x1100
     150:	414d445f 	cmpmi	sp, pc, asr r4
     154:	47003831 	smladxmi	r0, r1, r8, r3
     158:	5f4f4950 	svcpl	0x004f4950
     15c:	4d6d654d 	cfstr64mi	mvdx6, [sp, #-308]!	; 0xfffffecc
     160:	74507061 	ldrbvc	r7, [r0], #-97	; 0x61
     164:	4e490072 	mcrmi	0, 2, r0, cr9, cr2, {3}
     168:	41435f54 	cmpmi	r3, r4, asr pc
     16c:	425f304e 	subsmi	r3, pc, #78	; 0x4e
     170:	4f5f7375 	svcmi	0x005f7375
     174:	50006666 	andpl	r6, r0, r6, ror #12
     178:	00524944 	subseq	r4, r2, r4, asr #18
     17c:	50484344 	subpl	r4, r8, r4, asr #6
     180:	36314952 			; <UNDEFINED> instruction: 0x36314952
     184:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     188:	5332495f 	teqpl	r2, #1556480	; 0x17c000
     18c:	78545f31 	ldmdavc	r4, {r0, r4, r5, r8, r9, sl, fp, ip, lr}^
     190:	6e6f6c00 	cdpvs	12, 6, cr6, cr15, cr0, {0}
     194:	6f6c2067 	svcvs	0x006c2067
     198:	6920676e 	stmdbvs	r0!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}
     19c:	4900746e 	stmdbmi	r0, {r1, r2, r3, r5, r6, sl, ip, sp, lr}
     1a0:	455f544e 	ldrbmi	r5, [pc, #-1102]	; fffffd5a <__StackLimit+0xdffffd5a>
     1a4:	5f54454e 	svcpl	0x0054454e
     1a8:	6f727245 	svcvs	0x00727245
     1ac:	4e490072 	mcrmi	0, 2, r0, cr9, cr2, {3}
     1b0:	41435f54 	cmpmi	r3, r4, asr pc
     1b4:	455f314e 	ldrbmi	r3, [pc, #-334]	; 6e <__vector_table+0x6e>
     1b8:	726f7272 	rsbvc	r7, pc, #536870919	; 0x20000007
     1bc:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     1c0:	7375425f 	cmnvc	r5, #-268435451	; 0xf0000005
     1c4:	7561465f 	strbvc	r4, [r1, #-1631]!	; 0x65f
     1c8:	4900746c 	stmdbmi	r0, {r2, r3, r5, r6, sl, ip, sp, lr}
     1cc:	435f544e 	cmpmi	pc, #1308622848	; 0x4e000000
     1d0:	5f314e41 	svcpl	0x00314e41
     1d4:	575f7852 			; <UNDEFINED> instruction: 0x575f7852
     1d8:	696e7261 	stmdbvs	lr!, {r0, r5, r6, r9, ip, sp, lr}^
     1dc:	6c00676e 	stcvs	7, cr6, [r0], {110}	; 0x6e
     1e0:	20676e6f 	rsbcs	r6, r7, pc, ror #28
     1e4:	676e6f6c 	strbvs	r6, [lr, -ip, ror #30]!
     1e8:	736e7520 	cmnvc	lr, #134217728	; 0x8000000
     1ec:	656e6769 	strbvs	r6, [lr, #-1897]!	; 0x769
     1f0:	6e692064 	cdpvs	0, 6, cr2, cr9, cr4, {3}
     1f4:	4e490074 	mcrmi	0, 2, r0, cr9, cr4, {3}
     1f8:	41435f54 	cmpmi	r3, r4, asr pc
     1fc:	545f314e 	ldrbpl	r3, [pc], #-334	; 204 <__vector_table+0x204>
     200:	61575f78 	cmpvs	r7, r8, ror pc
     204:	6e696e72 	mcrvs	14, 3, r6, cr9, cr2, {3}
     208:	4e490067 	cdpmi	0, 4, cr0, cr9, cr7, {3}
     20c:	4d4e5f54 	stclmi	15, cr5, [lr, #-336]	; 0xfffffeb0
     210:	4e490049 	cdpmi	0, 4, cr0, cr9, cr9, {2}
     214:	434d5f54 	movtmi	r5, #57172	; 0xdf54
     218:	4e49004d 	cdpmi	0, 4, cr0, cr9, cr13, {2}
     21c:	4d435f54 	stclmi	15, cr5, [r3, #-336]	; 0xfffffeb0
     220:	4e490054 	mcrmi	0, 2, r0, cr9, cr4, {2}
     224:	53555f54 	cmppl	r5, #336	; 0x150
     228:	49003042 	stmdbmi	r0, {r1, r6, ip, sp}
     22c:	415f544e 	cmpmi	pc, lr, asr #8
     230:	00314344 	eorseq	r4, r1, r4, asr #6
     234:	20554e47 	subscs	r4, r5, r7, asr #28
     238:	2e342043 	cdpcs	0, 3, cr2, cr4, cr3, {2}
     23c:	20342e37 	eorscs	r2, r4, r7, lsr lr
     240:	33313032 	teqcc	r1, #50	; 0x32
     244:	33313930 	teqcc	r1, #786432	; 0xc0000
     248:	65722820 	ldrbvs	r2, [r2, #-2080]!	; 0x820
     24c:	7361656c 	cmnvc	r1, #452984832	; 0x1b000000
     250:	5b202965 	blpl	80a7ec <__etext+0x801b44>
     254:	2f4d5241 	svccs	0x004d5241
     258:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xd65
     25c:	64656464 	strbtvs	r6, [r5], #-1124	; 0x464
     260:	375f342d 	ldrbcc	r3, [pc, -sp, lsr #8]
     264:	6172622d 	cmnvs	r2, sp, lsr #4
     268:	2068636e 	rsbcs	r6, r8, lr, ror #6
     26c:	69766572 	ldmdbvs	r6!, {r1, r4, r5, r6, r8, sl, sp, lr}^
     270:	6e6f6973 	mcrvs	9, 3, r6, cr15, cr3, {3}
     274:	32303220 	eorscc	r3, r0, #2
     278:	5d313036 	ldcpl	0, cr3, [r1, #-216]!	; 0xffffff28
     27c:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     280:	7365525f 	cmnvc	r5, #-268435451	; 0xf0000005
     284:	65767265 	ldrbvs	r7, [r6, #-613]!	; 0x265
     288:	49003764 	stmdbmi	r0, {r2, r5, r6, r8, r9, sl, ip, sp}
     28c:	525f544e 	subspl	r5, pc, #1308622848	; 0x4e000000
     290:	72657365 	rsbvc	r7, r5, #-1811939327	; 0x94000001
     294:	38646576 	stmdacc	r4!, {r1, r2, r4, r5, r6, r8, sl, sp, lr}^
     298:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     29c:	7365525f 	cmnvc	r5, #-268435451	; 0xf0000005
     2a0:	65767265 	ldrbvs	r7, [r6, #-613]!	; 0x265
     2a4:	49003964 	stmdbmi	r0, {r2, r5, r6, r8, fp, ip, sp}
     2a8:	525f544e 	subspl	r5, pc, #1308622848	; 0x4e000000
     2ac:	72657365 	rsbvc	r7, r5, #-1811939327	; 0x94000001
     2b0:	31646576 	smccc	18006	; 0x4656
     2b4:	49003631 	stmdbmi	r0, {r0, r4, r5, r9, sl, ip, sp}
     2b8:	435f544e 	cmpmi	pc, #1308622848	; 0x4e000000
     2bc:	5f304e41 	svcpl	0x00304e41
     2c0:	656b6157 	strbvs	r6, [fp, #-343]!	; 0x157
     2c4:	0070555f 	rsbseq	r5, r0, pc, asr r5
     2c8:	454e4443 	strbmi	r4, [lr, #-1091]	; 0x443
     2cc:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     2d0:	4d54465f 	ldclmi	6, cr4, [r4, #-380]	; 0xfffffe84
     2d4:	4e490030 	mcrmi	0, 2, r0, cr9, cr0, {1}
     2d8:	54465f54 	strbpl	r5, [r6], #-3924	; 0xf54
     2dc:	4900314d 	stmdbmi	r0, {r0, r2, r3, r6, r8, ip, sp}
     2e0:	465f544e 	ldrbmi	r5, [pc], -lr, asr #8
     2e4:	00324d54 	eorseq	r4, r2, r4, asr sp
     2e8:	5f544e49 	svcpl	0x00544e49
     2ec:	334d5446 	movtcc	r5, #54342	; 0xd446
     2f0:	4f535000 	svcmi	0x00535000
     2f4:	50470052 	subpl	r0, r7, r2, asr r0
     2f8:	505f4f49 	subspl	r4, pc, r9, asr #30
     2fc:	6f436e69 	svcvs	0x00436e69
     300:	6f72746e 	svcvs	0x0072746e
     304:	4e49006c 	cdpmi	0, 4, cr0, cr9, cr12, {3}
     308:	504c5f54 	subpl	r5, ip, r4, asr pc
     30c:	656d6954 	strbvs	r6, [sp, #-2388]!	; 0x954
     310:	45520072 	ldrbmi	r0, [r2, #-114]	; 0x72
     314:	56524553 			; <UNDEFINED> instruction: 0x56524553
     318:	305f4445 	subscc	r4, pc, r5, asr #8
     31c:	53455200 	movtpl	r5, #20992	; 0x5200
     320:	45565245 	ldrbmi	r5, [r6, #-581]	; 0x245
     324:	00315f44 	eorseq	r5, r1, r4, asr #30
     328:	746e6975 	strbtvc	r6, [lr], #-2421	; 0x975
     32c:	745f3631 	ldrbvc	r3, [pc], #-1585	; 334 <__vector_table+0x334>
     330:	53455200 	movtpl	r5, #20992	; 0x5200
     334:	45565245 	ldrbmi	r5, [r6, #-581]	; 0x245
     338:	00335f44 	eorseq	r5, r3, r4, asr #30
     33c:	45534552 	ldrbmi	r4, [r3, #-1362]	; 0x552
     340:	44455652 	strbmi	r5, [r5], #-1618	; 0x652
     344:	5200345f 	andpl	r3, r0, #1593835520	; 0x5f000000
     348:	52455345 	subpl	r5, r5, #335544321	; 0x14000001
     34c:	5f444556 	svcpl	0x00444556
     350:	45520035 	ldrbmi	r0, [r2, #-53]	; 0x35
     354:	56524553 			; <UNDEFINED> instruction: 0x56524553
     358:	365f4445 	ldrbcc	r4, [pc], -r5, asr #8
     35c:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     360:	6d61545f 	cfstrdvs	mvd5, [r1, #-380]!	; 0xfffffe84
     364:	00726570 	rsbseq	r6, r2, r0, ror r5
     368:	5f544e49 	svcpl	0x00544e49
     36c:	30533249 	subscc	r3, r3, r9, asr #4
     370:	0078545f 	rsbseq	r5, r8, pc, asr r4
     374:	44444153 	strbmi	r4, [r4], #-339	; 0x153
     378:	4e490052 	mcrmi	0, 2, r0, cr9, cr2, {2}
     37c:	4d445f54 	stclmi	15, cr5, [r4, #-336]	; 0xfffffeb0
     380:	445f3441 	ldrbmi	r3, [pc], #-1089	; 388 <__vector_table+0x388>
     384:	3032414d 	eorscc	r4, r2, sp, asr #2
     388:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     38c:	4354525f 	cmpmi	r4, #-268435451	; 0xf0000005
     390:	6365535f 	cmnvs	r5, #2080374785	; 0x7c000001
     394:	73646e6f 	cmnvc	r4, #1776	; 0x6f0
     398:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     39c:	4e41435f 	mcrmi	3, 2, r4, cr1, cr15, {2}
     3a0:	75425f31 	strbvc	r5, [r2, #-3889]	; 0xf31
     3a4:	664f5f73 			; <UNDEFINED> instruction: 0x664f5f73
     3a8:	53530066 	cmppl	r3, #102	; 0x66
     3ac:	49005452 	stmdbmi	r0, {r1, r4, r6, sl, ip, lr}
     3b0:	445f544e 	ldrbmi	r5, [pc], #-1102	; 3b8 <__vector_table+0x3b8>
     3b4:	3531414d 	ldrcc	r4, [r1, #-333]!	; 0x14d
     3b8:	414d445f 	cmpmi	sp, pc, asr r4
     3bc:	49003133 	stmdbmi	r0, {r0, r1, r4, r5, r8, ip, sp}
     3c0:	445f544e 	ldrbmi	r5, [pc], #-1102	; 3c8 <__vector_table+0x3c8>
     3c4:	3031414d 	eorscc	r4, r1, sp, asr #2
     3c8:	414d445f 	cmpmi	sp, pc, asr r4
     3cc:	49003632 	stmdbmi	r0, {r1, r4, r5, r9, sl, ip, sp}
     3d0:	445f544e 	ldrbmi	r5, [pc], #-1102	; 3d8 <__vector_table+0x3d8>
     3d4:	5f36414d 	svcpl	0x0036414d
     3d8:	32414d44 	subcc	r4, r1, #4352	; 0x1100
     3dc:	4e490032 	mcrmi	0, 2, r0, cr9, cr2, {1}
     3e0:	79535f54 	ldmdbvc	r3, {r2, r4, r6, r8, r9, sl, fp, ip, lr}^
     3e4:	63695473 	cmnvs	r9, #1929379840	; 0x73000000
     3e8:	4e49006b 	cdpmi	0, 4, cr0, cr9, cr11, {3}
     3ec:	53545f54 	cmppl	r4, #336	; 0x150
     3f0:	49003049 	stmdbmi	r0, {r0, r3, r6, ip, sp}
     3f4:	465f544e 	ldrbmi	r5, [pc], -lr, asr #8
     3f8:	00454654 	subeq	r4, r5, r4, asr r6
     3fc:	50484344 	subpl	r4, r8, r4, asr #6
     400:	00364952 	eorseq	r4, r6, r2, asr r9
     404:	5f544e49 	svcpl	0x00544e49
     408:	30434441 	subcc	r4, r3, r1, asr #8
     40c:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     410:	414d445f 	cmpmi	sp, pc, asr r4
     414:	445f3231 	ldrbmi	r3, [pc], #-561	; 41c <__vector_table+0x41c>
     418:	3832414d 	ldmdacc	r2!, {r0, r2, r3, r6, r8, lr}
     41c:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     420:	4344415f 	movtmi	r4, #16735	; 0x415f
     424:	4e490032 	mcrmi	0, 2, r0, cr9, cr2, {1}
     428:	44415f54 	strbmi	r5, [r1], #-3924	; 0xf54
     42c:	49003343 	stmdbmi	r0, {r0, r1, r6, r8, r9, ip, sp}
     430:	445f544e 	ldrbmi	r5, [pc], #-1102	; 438 <__vector_table+0x438>
     434:	5f38414d 	svcpl	0x0038414d
     438:	32414d44 	subcc	r4, r1, #4352	; 0x1100
     43c:	4e490034 	mcrmi	0, 2, r0, cr9, cr4, {1}
     440:	41435f54 	cmpmi	r3, r4, asr pc
     444:	575f314e 	ldrbpl	r3, [pc, -lr, asr #2]
     448:	5f656b61 	svcpl	0x00656b61
     44c:	41007055 	qaddmi	r7, r5, r0
     450:	00525454 	subseq	r5, r2, r4, asr r4
     454:	5f544e49 	svcpl	0x00544e49
     458:	54524155 	ldrbpl	r4, [r2], #-341	; 0x155
     45c:	52455f30 	subpl	r5, r5, #192	; 0xc0
     460:	4e490052 	mcrmi	0, 2, r0, cr9, cr2, {2}
     464:	54525f54 	ldrbpl	r5, [r2], #-3924	; 0xf54
     468:	4e490043 	cdpmi	0, 4, cr0, cr9, cr3, {2}
     46c:	41555f54 	cmpmi	r5, r4, asr pc
     470:	5f315452 	svcpl	0x00315452
     474:	545f5852 	ldrbpl	r5, [pc], #-2130	; 47c <__vector_table+0x47c>
     478:	4e490058 	mcrmi	0, 2, r0, cr9, cr8, {2}
     47c:	49505f54 	ldmdbmi	r0, {r2, r4, r6, r8, r9, sl, fp, ip, lr}^
     480:	75003054 	strvc	r3, [r0, #-84]	; 0x54
     484:	38746e69 	ldmdacc	r4!, {r0, r3, r5, r6, r9, sl, fp, sp, lr}^
     488:	48434400 	stmdami	r3, {sl, lr}^
     48c:	32495250 	subcc	r5, r9, #5
     490:	68730032 	ldmdavs	r3!, {r1, r4, r5}^
     494:	2074726f 	rsbscs	r7, r4, pc, ror #4
     498:	69736e75 	ldmdbvs	r3!, {r0, r2, r4, r5, r6, r9, sl, fp, sp, lr}^
     49c:	64656e67 	strbtvs	r6, [r5], #-3687	; 0xe67
     4a0:	746e6920 	strbtvc	r6, [lr], #-2336	; 0x920
     4a4:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     4a8:	5241555f 	subpl	r5, r1, #398458880	; 0x17c00000
     4ac:	525f3354 	subspl	r3, pc, #1342177281	; 0x50000001
     4b0:	58545f58 	ldmdapl	r4, {r3, r4, r6, r8, r9, sl, fp, ip, lr}^
     4b4:	48434400 	stmdami	r3, {sl, lr}^
     4b8:	31495250 	cmpcc	r9, r0, asr r2
     4bc:	4f530038 	svcmi	0x00530038
     4c0:	49004646 	stmdbmi	r0, {r1, r2, r6, r9, sl, lr}
     4c4:	555f544e 	ldrbpl	r5, [pc, #-1102]	; 7e <__vector_table+0x7e>
     4c8:	35545241 	ldrbcc	r5, [r4, #-577]	; 0x241
     4cc:	5f58525f 	svcpl	0x0058525f
     4d0:	49005854 	stmdbmi	r0, {r2, r4, r6, fp, ip, lr}
     4d4:	4c5f544e 	cfldrdmi	mvd5, [pc], {78}	; 0x4e
     4d8:	4900574c 	stmdbmi	r0, {r2, r3, r6, r8, r9, sl, ip, lr}
     4dc:	525f544e 	subspl	r5, pc, #1308622848	; 0x4e000000
     4e0:	72657365 	rsbvc	r7, r5, #-1811939327	; 0x94000001
     4e4:	35646576 	strbcc	r6, [r4, #-1398]!	; 0x576
     4e8:	4e490039 	mcrmi	0, 2, r0, cr9, cr9, {1}
     4ec:	41445f54 	cmpmi	r4, r4, asr pc
     4f0:	44003143 	strmi	r3, [r0], #-323	; 0x143
     4f4:	425f414d 	subsmi	r4, pc, #1073741843	; 0x40000013
     4f8:	31455459 	cmpcc	r5, r9, asr r4
     4fc:	414d4400 	cmpmi	sp, r0, lsl #8
     500:	5459425f 	ldrbpl	r4, [r9], #-607	; 0x25f
     504:	44003245 	strmi	r3, [r0], #-581	; 0x245
     508:	425f414d 	subsmi	r4, pc, #1073741843	; 0x40000013
     50c:	34455459 	strbcc	r5, [r5], #-1113	; 0x459
     510:	414d4400 	cmpmi	sp, r0, lsl #8
     514:	6d654d5f 	stclvs	13, cr4, [r5, #-380]!	; 0xfffffe84
     518:	5070614d 	rsbspl	r6, r0, sp, asr #2
     51c:	49007274 	stmdbmi	r0, {r2, r4, r5, r6, r9, ip, sp, lr}
     520:	445f544e 	ldrbmi	r5, [pc], #-1102	; 528 <__vector_table+0x528>
     524:	3431414d 	ldrtcc	r4, [r1], #-333	; 0x14d
     528:	414d445f 	cmpmi	sp, pc, asr r4
     52c:	50003033 	andpl	r3, r0, r3, lsr r0
     530:	00524444 	subseq	r4, r2, r4, asr #8
     534:	4f495047 	svcmi	0x00495047
     538:	7269445f 	rsbvc	r4, r9, #1593835520	; 0x5f000000
     53c:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     540:	5241555f 	subpl	r5, r1, #398458880	; 0x17c00000
     544:	455f3554 	ldrbmi	r3, [pc, #-1364]	; fffffff8 <__StackLimit+0xdffffff8>
     548:	49005252 	stmdbmi	r0, {r1, r4, r6, r9, ip, lr}
     54c:	505f544e 	subspl	r5, pc, lr, asr #8
     550:	61646e65 	cmnvs	r4, r5, ror #28
     554:	53656c62 	cmnpl	r5, #25088	; 0x6200
     558:	65527672 	ldrbvs	r7, [r2, #-1650]	; 0x672
     55c:	41440071 	hvcmi	16385	; 0x4001
     560:	5f524444 	svcpl	0x00524444
     564:	5045454b 	subpl	r4, r5, fp, asr #10
     568:	44004e4f 	strmi	r4, [r0], #-3663	; 0xe4f
     56c:	52504843 	subspl	r4, r0, #4390912	; 0x430000
     570:	00303249 	eorseq	r3, r0, r9, asr #4
     574:	657a6973 	ldrbvs	r6, [sl, #-2419]!	; 0x973
     578:	65707974 	ldrbvs	r7, [r0, #-2420]!	; 0x974
     57c:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     580:	5241555f 	subpl	r5, r1, #398458880	; 0x17c00000
     584:	455f3254 	ldrbmi	r3, [pc, #-596]	; 338 <__vector_table+0x338>
     588:	49005252 	stmdbmi	r0, {r1, r4, r6, r9, ip, lr}
     58c:	435f544e 	cmpmi	pc, #1308622848	; 0x4e000000
     590:	5f304e41 	svcpl	0x00304e41
     594:	6f727245 	svcvs	0x00727245
     598:	4e490072 	mcrmi	0, 2, r0, cr9, cr2, {3}
     59c:	65445f54 	strbvs	r5, [r4, #-3924]	; 0xf54
     5a0:	4d677562 	cfstr64mi	mvdx7, [r7, #-392]!	; 0xfffffe78
     5a4:	74696e6f 	strbtvc	r6, [r9], #-3695	; 0xe6f
     5a8:	4400726f 	strmi	r7, [r0], #-623	; 0x26f
     5ac:	52504843 	subspl	r4, r0, #4390912	; 0x430000
     5b0:	00333249 	eorseq	r3, r3, r9, asr #4
     5b4:	53414c44 	movtpl	r4, #7236	; 0x1c44
     5b8:	47535f54 			; <UNDEFINED> instruction: 0x47535f54
     5bc:	616d0041 	cmnvs	sp, r1, asr #32
     5c0:	49006e69 	stmdbmi	r0, {r0, r3, r5, r6, r9, sl, fp, sp, lr}
     5c4:	4e5f544e 	cdpmi	4, 5, cr5, cr15, cr14, {2}
     5c8:	4f004346 	svcmi	0x00004346
     5cc:	54505f56 	ldrbpl	r5, [r0], #-3926	; 0xf56
     5d0:	6e695f41 	cdpvs	15, 6, cr5, cr9, cr1, {2}
     5d4:	49007469 	stmdbmi	r0, {r0, r3, r5, r6, sl, ip, sp, lr}
     5d8:	445f544e 	ldrbmi	r5, [pc], #-1102	; 5e0 <__vector_table+0x5e0>
     5dc:	00304341 	eorseq	r4, r0, r1, asr #6
     5e0:	5f544e49 	svcpl	0x00544e49
     5e4:	5f44564c 	svcpl	0x0044564c
     5e8:	0057564c 	subseq	r5, r7, ip, asr #12
     5ec:	5f544e49 	svcpl	0x00544e49
     5f0:	30424450 	subcc	r4, r2, r0, asr r4
     5f4:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     5f8:	524f505f 	subpl	r5, pc, #95	; 0x5f
     5fc:	47004154 	smlsdmi	r0, r4, r1, r4
     600:	5f4f4950 	svcpl	0x004f4950
     604:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
     608:	65707954 	ldrbvs	r7, [r0, #-2388]!	; 0x954
     60c:	00666544 	rsbeq	r6, r6, r4, asr #10
     610:	5f544e49 	svcpl	0x00544e49
     614:	54524f50 	ldrbpl	r4, [r2], #-3920	; 0xf50
     618:	50470043 	subpl	r0, r7, r3, asr #32
     61c:	495f4f49 	ldmdbmi	pc, {r0, r3, r6, r8, r9, sl, fp, lr}^	; <UNPREDICTABLE>
     620:	435f5253 	cmpmi	pc, #805306373	; 0x30000005
     624:	424c4c41 	submi	r4, ip, #16640	; 0x4100
     628:	004b4341 	subeq	r4, fp, r1, asr #6
     62c:	5f544e49 	svcpl	0x00544e49
     630:	54524f50 	ldrbpl	r4, [r2], #-3920	; 0xf50
     634:	4e490045 	cdpmi	0, 4, cr0, cr9, cr5, {2}
     638:	4f505f54 	svcmi	0x00505f54
     63c:	00465452 	subeq	r5, r6, r2, asr r4
     640:	4f495047 	svcmi	0x00495047
     644:	7854505f 	ldmdavc	r4, {r0, r1, r2, r3, r4, r6, ip, lr}^
     648:	52454300 	subpl	r4, r5, #0
     64c:	45430051 	strbmi	r0, [r3, #-81]	; 0x51
     650:	49005252 	stmdbmi	r0, {r1, r4, r6, r9, ip, lr}
     654:	525f544e 	subspl	r5, pc, #1308622848	; 0x4e000000
     658:	5300474e 	movwpl	r4, #1870	; 0x74e
     65c:	5453414c 	ldrbpl	r4, [r3], #-332	; 0x14c
     660:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     664:	4957535f 	ldmdbmi	r7, {r0, r1, r2, r3, r4, r6, r8, r9, ip, lr}^
     668:	6f6c6600 	svcvs	0x006c6600
     66c:	49007461 	stmdbmi	r0, {r0, r5, r6, sl, ip, sp, lr}
     670:	435f544e 	cmpmi	pc, #1308622848	; 0x4e000000
     674:	0031504d 	eorseq	r5, r1, sp, asr #32
     678:	5f544e49 	svcpl	0x00544e49
     67c:	32504d43 	subscc	r4, r0, #4288	; 0x10c0
     680:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     684:	4253555f 	subsmi	r5, r3, #398458880	; 0x17c00000
     688:	49005348 	stmdbmi	r0, {r3, r6, r8, r9, ip, lr}
     68c:	445f544e 	ldrbmi	r5, [pc], #-1102	; 694 <__vector_table+0x694>
     690:	5f31414d 	svcpl	0x0031414d
     694:	31414d44 	cmpcc	r1, r4, asr #26
     698:	4e490037 	mcrmi	0, 2, r0, cr9, cr7, {1}
     69c:	6e495f54 	mcrvs	15, 2, r5, cr9, cr4, {2}
     6a0:	61697469 	cmnvs	r9, r9, ror #8
     6a4:	72505f6c 	subsvc	r5, r0, #432	; 0x1b0
     6a8:	6172676f 	cmnvs	r2, pc, ror #14
     6ac:	6f435f6d 	svcvs	0x00435f6d
     6b0:	65746e75 	ldrbvs	r6, [r4, #-3701]!	; 0xe75
     6b4:	49430072 	stmdbmi	r3, {r1, r4, r5, r6}^
     6b8:	4400544e 	strmi	r5, [r0], #-1102	; 0x44e
     6bc:	52504843 	subspl	r4, r0, #4390912	; 0x430000
     6c0:	00303149 	eorseq	r3, r0, r9, asr #2
     6c4:	50484344 	subpl	r4, r8, r4, asr #6
     6c8:	31314952 	teqcc	r1, r2, asr r9
     6cc:	48434400 	stmdami	r3, {sl, lr}^
     6d0:	31495250 	cmpcc	r9, r0, asr r2
     6d4:	43440032 	movtmi	r0, #16434	; 0x4032
     6d8:	49525048 	ldmdbmi	r2, {r3, r6, ip, lr}^
     6dc:	44003331 	strmi	r3, [r0], #-817	; 0x331
     6e0:	52504843 	subspl	r4, r0, #4390912	; 0x430000
     6e4:	00343149 	eorseq	r3, r4, r9, asr #2
     6e8:	50484344 	subpl	r4, r8, r4, asr #6
     6ec:	35314952 	ldrcc	r4, [r1, #-2386]!	; 0x952
     6f0:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     6f4:	414d445f 	cmpmi	sp, pc, asr r4
     6f8:	4d445f33 	stclmi	15, cr5, [r4, #-204]	; 0xffffff34
     6fc:	00393141 	eorseq	r3, r9, r1, asr #2
     700:	50484344 	subpl	r4, r8, r4, asr #6
     704:	37314952 			; <UNDEFINED> instruction: 0x37314952
     708:	736e7500 	cmnvc	lr, #0
     70c:	656e6769 	strbvs	r6, [lr, #-1897]!	; 0x769
     710:	68632064 	stmdavs	r3!, {r2, r5, r6, sp}^
     714:	44007261 	strmi	r7, [r0], #-609	; 0x261
     718:	52504843 	subspl	r4, r0, #4390912	; 0x430000
     71c:	00393149 	eorseq	r3, r9, r9, asr #2
     720:	5f414d44 	svcpl	0x00414d44
     724:	5f525349 	svcpl	0x00525349
     728:	4c4c4143 	stfmie	f4, [ip], {67}	; 0x43
     72c:	4b434142 	blmi	10d0c3c <__etext+0x10c7f94>
     730:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     734:	524f505f 	subpl	r5, pc, #95	; 0x5f
     738:	73004454 	movwvc	r4, #1108	; 0x454
     73c:	74726f68 	ldrbtvc	r6, [r2], #-3944	; 0xf68
     740:	746e6920 	strbtvc	r6, [lr], #-2336	; 0x920
     744:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     748:	5241555f 	subpl	r5, r1, #398458880	; 0x17c00000
     74c:	4c5f3054 	mrrcmi	0, 5, r3, pc, cr4	; <UNPREDICTABLE>
     750:	49004e4f 	stmdbmi	r0, {r0, r1, r2, r3, r6, r9, sl, fp, lr}
     754:	555f544e 	ldrbpl	r5, [pc, #-1102]	; 30e <__vector_table+0x30e>
     758:	43444253 	movtmi	r4, #16979	; 0x4253
     75c:	4e490044 	cdpmi	0, 4, cr0, cr9, cr4, {2}
     760:	32495f54 	subcc	r5, r9, #336	; 0x150
     764:	50003043 	andpl	r3, r0, r3, asr #32
     768:	445f7869 	ldrbmi	r7, [pc], #-2153	; 770 <__vector_table+0x770>
     76c:	00617461 	rsbeq	r7, r1, r1, ror #8
     770:	45544943 	ldrbmi	r4, [r4, #-2371]	; 0x943
     774:	4c455f52 	mcrrmi	15, 5, r5, r5, cr2
     778:	594b4e49 	stmdbpl	fp, {r0, r3, r6, r9, sl, fp, lr}^
     77c:	49005345 	stmdbmi	r0, {r0, r2, r6, r8, r9, ip, lr}
     780:	535f544e 	cmppl	pc, #1308622848	; 0x4e000000
     784:	00314950 	eorseq	r4, r1, r0, asr r9
     788:	6e69616d 	powvsez	f6, f1, #5.0
     78c:	4e00632e 	cdpmi	3, 0, cr6, cr0, cr14, {1}
     790:	45545942 	ldrbmi	r5, [r4, #-2370]	; 0x942
     794:	4c4d5f53 	mcrrmi	15, 5, r5, sp, cr3
     798:	75004f4e 	strvc	r4, [r0, #-3918]	; 0xf4e
     79c:	33746e69 	cmncc	r4, #1680	; 0x690
     7a0:	00745f32 	rsbseq	r5, r4, r2, lsr pc
     7a4:	44444144 	strbmi	r4, [r4], #-324	; 0x144
     7a8:	45525f52 	ldrbmi	r5, [r2, #-3922]	; 0xf52
     7ac:	45564f43 	ldrbmi	r4, [r6, #-3907]	; 0xf43
     7b0:	424e0052 	submi	r0, lr, #82	; 0x52
     7b4:	53455459 	movtpl	r5, #21593	; 0x5459
     7b8:	4f4c4d5f 	svcmi	0x004c4d5f
     7bc:	45594646 	ldrbmi	r4, [r9, #-1606]	; 0x646
     7c0:	43440053 	movtmi	r0, #16467	; 0x4053
     7c4:	49525048 	ldmdbmi	r2, {r3, r6, ip, lr}^
     7c8:	49003132 	stmdbmi	r0, {r1, r4, r5, r8, ip, sp}
     7cc:	505f544e 	subspl	r5, pc, lr, asr #8
     7d0:	00325449 	eorseq	r5, r2, r9, asr #8
     7d4:	45544942 	ldrbmi	r4, [r4, #-2370]	; 0x942
     7d8:	4c455f52 	mcrrmi	15, 5, r5, r5, cr2
     7dc:	4e4b4e49 	cdpmi	14, 4, cr4, cr11, cr9, {2}
     7e0:	4344004f 	movtmi	r0, #16463	; 0x404f
     7e4:	49525048 	ldmdbmi	r2, {r3, r6, ip, lr}^
     7e8:	44003432 	strmi	r3, [r0], #-1074	; 0x432
     7ec:	52504843 	subspl	r4, r0, #4390912	; 0x430000
     7f0:	00353249 	eorseq	r3, r5, r9, asr #4
     7f4:	50484344 	subpl	r4, r8, r4, asr #6
     7f8:	36324952 			; <UNDEFINED> instruction: 0x36324952
     7fc:	48434400 	stmdami	r3, {sl, lr}^
extern GPIO_InitTypeDef OV_PTA_init;

extern char ready_send_flag;

int main (void)
{
     800:	32495250 	subcc	r5, r9, #5
     804:	43440037 	movtmi	r0, #16439	; 0x4037

    Ov7725_Init ();
     808:	49525048 	ldmdbmi	r2, {r3, r6, ip, lr}^
    Ov7725_Delay();
     80c:	44003832 	strmi	r3, [r0], #-2098	; 0x832

    //Ov7725_Dma_Init();
    Ov7725_Gpio_Init ();
     810:	52504843 	subspl	r4, r0, #4390912	; 0x430000
    dma_portx2buff_init (DMA_CH0, (void *)(&GPIOB_PDIR), (void *)img,PORTA_DMAREQ ,DMA_BYTE1, PHOTO_SIZE / 8, DADDR_KEEPON);
     814:	00393249 	eorseq	r3, r9, r9, asr #4
     818:	5f544e49 	svcpl	0x00544e49
     81c:	35414d44 	strbcc	r4, [r1, #-3396]	; 0xd44
     820:	414d445f 	cmpmi	sp, pc, asr r4
     824:	2f003132 	svccs	0x00003132
     828:	656d6f68 	strbvs	r6, [sp, #-3944]!	; 0xf68
     82c:	6b6f6d2f 	blvs	1bdbcf0 <__etext+0x1bd3048>
     830:	652f7265 	strvs	r7, [pc, #-613]!	; 5d3 <__vector_table+0x5d3>
     834:	6465626d 	strbtvs	r6, [r5], #-621	; 0x26d
     838:	61656c5f 	cmnvs	r5, pc, asr ip
     83c:	702f6e72 	eorvc	r6, pc, r2, ror lr	; <UNPREDICTABLE>
    //装载DMA中断
    DMA_ISR[DMA_CH0] = Ov7725_eagle_dma;
     840:	656a6f72 	strbvs	r6, [sl, #-3954]!	; 0xf72
     844:	732f7463 	teqvc	pc, #1660944384	; 0x63000000
     848:	7472616d 	ldrbtvc	r6, [r2], #-365	; 0x16d
     84c:	7261635f 	rsbvc	r6, r1, #2080374785	; 0x7c000001
     850:	6f72702f 	svcvs	0x0072702f
    //关闭DMA通道
    DMA_DIS(DMA_CH0);
     854:	7463656a 	strbtvc	r6, [r3], #-1386	; 0x56a
     858:	2d30312f 	ldfcss	f3, [r0, #-188]!	; 0xffffff44
     85c:	3737766f 	ldrcc	r7, [r7, -pc, ror #12]!
     860:	49003532 	stmdbmi	r0, {r1, r4, r5, r8, sl, ip, sp}
     864:	435f544e 	cmpmi	pc, #1308622848	; 0x4e000000
     868:	5f304e41 	svcpl	0x00304e41
    //关GPIO中断
    disable_irq(INT_PORTA - 16);
     86c:	575f7852 			; <UNDEFINED> instruction: 0x575f7852
     870:	696e7261 	stmdbvs	lr!, {r0, r5, r6, r9, ip, sp, lr}^
    //清DMA中断置为标志
    DMA_IRQ_CLEAN(DMA_CH0);
     874:	4900676e 	stmdbmi	r0, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}
     878:	435f544e 	cmpmi	pc, #1308622848	; 0x4e000000
     87c:	5f304e41 	svcpl	0x00304e41
     880:	575f7854 			; <UNDEFINED> instruction: 0x575f7854
     884:	696e7261 	stmdbvs	lr!, {r0, r5, r6, r9, ip, sp, lr}^
     888:	5300676e 	movwpl	r6, #1902	; 0x76e
    //使能DMA中断
    DMA_IRQ_EN (DMA_CH0);
     88c:	00515245 	subseq	r5, r1, r5, asr #4
     890:	5f544e49 	svcpl	0x00544e49
    //开启GPIO中断
    LPLD_GPIO_EnableIrq(OV_PTA_init);
     894:	00524444 	subseq	r4, r2, r4, asr #8
     898:	5f544e49 	svcpl	0x00544e49
     89c:	31414d44 	cmpcc	r1, r4, asr #26
     8a0:	4d445f31 	stclmi	15, cr5, [r4, #-196]	; 0xffffff3c
     8a4:	00373241 	eorseq	r3, r7, r1, asr #4
    {
        //获取图像
        //Ov7725_eagle_get_img ();
        //解压图像
        //Ov7725_img_extract (Pix_Data, img, PHOTO_SIZE/8);
        if(ready_send_flag)
     8a8:	50484344 	subpl	r4, r8, r4, asr #6
     8ac:	00394952 	eorseq	r4, r9, r2, asr r9
     8b0:	5f544e49 	svcpl	0x00544e49
     8b4:	37414d44 	strbcc	r4, [r1, -r4, asr #26]
        {
            //发送图片到上位机
            //get_midline(Pix_Data, 60, 80);
            Ov7725_sendimg (Pix_Data, PHOTO_SIZE);
     8b8:	414d445f 	cmpmi	sp, pc, asr r4
     8bc:	49003332 	stmdbmi	r0, {r1, r4, r5, r8, r9, ip, sp}
     8c0:	555f544e 	ldrbpl	r5, [pc, #-1102]	; 47a <__vector_table+0x47a>
     8c4:	65676173 	strbvs	r6, [r7, #-371]!	; 0x173
            ready_send_flag = 0;
     8c8:	7561465f 	strbvc	r4, [r1, #-1631]!	; 0x65f
     8cc:	4900746c 	stmdbmi	r0, {r2, r3, r5, r6, sl, ip, sp, lr}
     8d0:	445f544e 	ldrbmi	r5, [pc], #-1102	; 8d8 <CAN0_Bus_Off_IRQHandler>
        }
    }
     8d4:	455f414d 	ldrbmi	r4, [pc, #-333]	; 78f <__vector_table+0x78f>
 * \param  void
 *
 * \return void
 */
void Default_Handler(void)
{
     8d8:	726f7272 	rsbvc	r7, pc, #536870919	; 0x20000007
     8dc:	44414400 	strbmi	r4, [r1], #-1024	; 0x400
#define VECTORNUM       (*(volatile char *) (0xE000ED04))
  //while (1);
  char vtr = VECTORNUM;
     8e0:	43005244 	movwmi	r5, #580	; 0x244
     8e4:	00494545 	subeq	r4, r9, r5, asr #10
     8e8:	5f544e49 	svcpl	0x00544e49
  printf ("\n ******************\n");
     8ec:	31414d44 	cmpcc	r1, r4, asr #26
     8f0:	4d445f33 	stclmi	15, cr5, [r4, #-204]	; 0xffffff34
     8f4:	00393241 	eorseq	r3, r9, r1, asr #4
  printf ("Default Handler Error\n");
     8f8:	4f495047 	svcmi	0x00495047
     8fc:	6d654d5f 	stclvs	13, cr4, [r5, #-380]!	; 0xfffffe84
     900:	0070614d 	rsbseq	r6, r0, sp, asr #2
  printf ("On vector %d **** Interrupt\n", vtr);
     904:	5f544e49 	svcpl	0x00544e49
     908:	54454e45 	strbpl	r4, [r5], #-3653	; 0xe45
     90c:	3835315f 	ldmdacc	r5!, {r0, r1, r2, r3, r4, r6, r8, ip, sp}
     910:	69545f38 	ldmdbvs	r4, {r3, r4, r5, r8, r9, sl, fp, ip, lr}^
 * \param  void
 *
 * \return void
 */
void Reset_Handler(void)
{
     914:	0072656d 	rsbseq	r6, r2, sp, ror #10
     918:	5f544e49 	svcpl	0x00544e49
  unsigned char *source;
  unsigned char *destination;

  /* watchdog disable */
  *((volatile unsigned short *)0x4005200E) = 0xC520;
     91c:	54524155 	ldrbpl	r4, [r2], #-341	; 0x155
     920:	58525f30 	ldmdapl	r2, {r4, r5, r8, r9, sl, fp, ip, lr}^
     924:	0058545f 	subseq	r5, r8, pc, asr r4
  *((volatile unsigned short *)0x4005200E) = 0xD928;
     928:	50484344 	subpl	r4, r8, r4, asr #6
     92c:	00304952 	eorseq	r4, r0, r2, asr r9
     930:	50484344 	subpl	r4, r8, r4, asr #6
     934:	00314952 	eorseq	r4, r1, r2, asr r9
  *((volatile unsigned short *)0x40052000) = 0x01D2;
     938:	50484344 	subpl	r4, r8, r4, asr #6
     93c:	00324952 	eorseq	r4, r2, r2, asr r9
     940:	50484344 	subpl	r4, r8, r4, asr #6

  /* copy data values from ROM to RAM */
  source = (unsigned char *)&_etext;
     944:	00334952 	eorseq	r4, r3, r2, asr r9
     948:	5f414d44 	svcpl	0x00414d44
     94c:	4d6d654d 	cfstr64mi	mvdx6, [sp, #-308]!	; 0xfffffecc
  destination = (unsigned char *)&_sdata;
     950:	44007061 	strmi	r7, [r0], #-97	; 0x61
     954:	52504843 	subspl	r4, r0, #4390912	; 0x430000
  while (destination < (unsigned char*)&_edata) {
     958:	42003549 	andmi	r3, r0, #306184192	; 0x12400000
    *(destination++) = *(source++);
     95c:	52455449 	subpl	r5, r5, #1224736768	; 0x49000000
     960:	494c455f 	stmdbmi	ip, {r0, r1, r2, r3, r4, r6, r8, sl, lr}^
     964:	45594b4e 	ldrbmi	r4, [r9, #-2894]	; 0xb4e
     968:	43440053 	movtmi	r0, #16467	; 0x4053
     96c:	49525048 	ldmdbmi	r2, {r3, r6, ip, lr}^
     970:	43440037 	movtmi	r0, #16439	; 0x4037
  *((volatile unsigned short *)0x40052000) = 0x01D2;

  /* copy data values from ROM to RAM */
  source = (unsigned char *)&_etext;
  destination = (unsigned char *)&_sdata;
  while (destination < (unsigned char*)&_edata) {
     974:	49525048 	ldmdbmi	r2, {r3, r6, ip, lr}^
     978:	4e490038 	mcrmi	0, 2, r0, cr9, cr8, {1}
     97c:	41555f54 	cmpmi	r5, r4, asr pc
    *(destination++) = *(source++);
  }

  /* clear bss section */
  source = (unsigned char *)&_sbss;
     980:	5f345452 	svcpl	0x00345452
     984:	00525245 	subseq	r5, r2, r5, asr #4
     988:	5f544e49 	svcpl	0x00544e49
  destination = (unsigned char *)&_ebss;
     98c:	31533249 	cmpcc	r3, r9, asr #4
     990:	0078525f 	rsbseq	r5, r8, pc, asr r2
  while (source < destination ) {
     994:	5f544e49 	svcpl	0x00544e49
    *source++ = 0;
     998:	54524155 	ldrbpl	r4, [r2], #-341	; 0x155
     99c:	58525f32 	ldmdapl	r2, {r1, r4, r5, r8, r9, sl, fp, ip, lr}^
     9a0:	0058545f 	subseq	r5, r8, pc, asr r4
     9a4:	5f544e49 	svcpl	0x00544e49
  }

  /* clear bss section */
  source = (unsigned char *)&_sbss;
  destination = (unsigned char *)&_ebss;
  while (source < destination ) {
     9a8:	65736552 	ldrbvs	r6, [r3, #-1362]!	; 0x552
     9ac:	64657672 	strbtvs	r7, [r5], #-1650	; 0x672
    *source++ = 0;
  }
 //进入系统初始化函数
  SystemInit();
     9b0:	49003031 	stmdbmi	r0, {r0, r4, r5, ip, sp}
 //进入用户函数
  main();
     9b4:	435f544e 	cmpmi	pc, #1308622848	; 0x4e000000
 * \param  void
 *
 * \return void
 */
void SystemInit(void)
{
     9b8:	0030504d 	eorseq	r5, r0, sp, asr #32
  //使能所有IO口时钟
  SIM_SCGC5 |= (SIM_SCGC5_PORTA_MASK | SIM_SCGC5_PORTB_MASK
     9bc:	50484344 	subpl	r4, r8, r4, asr #6
     9c0:	30334952 	eorscc	r4, r3, r2, asr r9
     9c4:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     9c8:	7365525f 	cmnvc	r5, #-268435451	; 0xf0000005
     9cc:	65767265 	ldrbvs	r7, [r6, #-613]!	; 0x265
     9d0:	00333164 	eorseq	r3, r3, r4, ror #2
     9d4:	4f495047 	svcmi	0x00495047
     9d8:	7273495f 	rsbsvc	r4, r3, #1556480	; 0x17c000
     9dc:	6e697500 	cdpvs	5, 6, cr7, cr9, cr0, {0}
     9e0:	745f3874 	ldrbvc	r3, [pc], #-2164	; 9e8 <SystemInit+0x30>
              | SIM_SCGC5_PORTC_MASK | SIM_SCGC5_PORTD_MASK
              | SIM_SCGC5_PORTE_MASK);
  //初始化各部分时钟：系统内核主频、总线时钟、FlexBus时钟、Flash时钟
  LPLD_PLL_Setup(CORE_CLK_MHZ);
     9e4:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     9e8:	504d435f 	subpl	r4, sp, pc, asr r3
  
  //更新内核主频
  SystemCoreClockUpdate();
     9ec:	50470033 	subpl	r0, r7, r3, lsr r0
  
  //获取各部分时钟
  g_core_clock = SystemCoreClock;
     9f0:	505f4f49 	subspl	r4, pc, r9, asr #30
     9f4:	00736e69 	rsbseq	r6, r3, r9, ror #28
     9f8:	5f544e49 	svcpl	0x00544e49
     9fc:	54524155 	ldrbpl	r4, [r2], #-341	; 0x155
     a00:	58525f34 	ldmdapl	r2, {r2, r4, r5, r8, r9, sl, fp, ip, lr}^
  g_bus_clock = g_core_clock / ((uint32_t)((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV2_MASK) >> SIM_CLKDIV1_OUTDIV2_SHIFT)+ 1u);
     a04:	0058545f 	subseq	r5, r8, pc, asr r4
     a08:	50484344 	subpl	r4, r8, r4, asr #6
     a0c:	31334952 	teqcc	r3, r2, asr r9
     a10:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     a14:	4356535f 	cmpmi	r6, #2080374785	; 0x7c000001
     a18:	006c6c61 	rsbeq	r6, ip, r1, ror #24
     a1c:	524f4450 	subpl	r4, pc, #1342177280	; 0x50000000
     a20:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     a24:	5241555f 	subpl	r5, r1, #398458880	; 0x17c00000
     a28:	455f3354 	ldrbmi	r3, [pc, #-852]	; 6dc <__vector_table+0x6dc>
     a2c:	44005252 	strmi	r5, [r0], #-594	; 0x252
     a30:	495f414d 	ldmdbmi	pc, {r0, r2, r3, r6, r8, lr}^	; <UNPREDICTABLE>
     a34:	49005253 	stmdbmi	r0, {r0, r1, r4, r6, r9, ip, lr}
     a38:	575f544e 	ldrbpl	r5, [pc, -lr, asr #8]
  g_flexbus_clock =  g_core_clock / ((uint32_t)((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV3_MASK) >> SIM_CLKDIV1_OUTDIV3_SHIFT)+ 1u);
     a3c:	68637461 	stmdavs	r3!, {r0, r5, r6, sl, ip, sp, lr}^
     a40:	00676f64 	rsbeq	r6, r7, r4, ror #30
     a44:	5f544e49 	svcpl	0x00544e49
     a48:	65736552 	ldrbvs	r6, [r3, #-1362]!	; 0x552
     a4c:	64657672 	strbtvs	r7, [r5], #-1650	; 0x672
     a50:	49003539 	stmdbmi	r0, {r0, r3, r4, r5, r8, sl, ip, sp}
     a54:	495f544e 	ldmdbmi	pc, {r1, r2, r3, r6, sl, ip, lr}^	; <UNPREDICTABLE>
     a58:	00314332 	eorseq	r4, r1, r2, lsr r3
     a5c:	5f414d44 	svcpl	0x00414d44
     a60:	45545942 	ldrbmi	r5, [r4, #-2370]	; 0x942
     a64:	49003631 	stmdbmi	r0, {r0, r4, r5, r9, sl, ip, sp}
     a68:	535f544e 	cmppl	pc, #1308622848	; 0x4e000000
     a6c:	00304950 	eorseq	r4, r0, r0, asr r9
  g_flash_clock =  g_core_clock / ((uint32_t)((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV4_MASK) >> SIM_CLKDIV1_OUTDIV4_SHIFT)+ 1u);
     a70:	5f544e49 	svcpl	0x00544e49
     a74:	32495053 	subcc	r5, r9, #83	; 0x53
     a78:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
     a7c:	5241555f 	subpl	r5, r1, #398458880	; 0x17c00000
     a80:	455f3154 	ldrbmi	r3, [pc, #-340]	; 934 <Reset_Handler+0x20>
     a84:	64005252 	strvs	r5, [r0], #-594	; 0x252
     a88:	6c62756f 	cfstr64vs	mvdx7, [r2], #-444	; 0xfffffe44
     a8c:	4e490065 	cdpmi	0, 4, cr0, cr9, cr5, {3}
     a90:	32495f54 	subcc	r5, r9, #336	; 0x150
     a94:	525f3053 	subspl	r3, pc, #83	; 0x53
     a98:	45520078 	ldrbmi	r0, [r2, #-120]	; 0x78
     a9c:	56524553 			; <UNDEFINED> instruction: 0x56524553
     aa0:	325f4445 	subscc	r4, pc, #1157627904	; 0x45000000
     aa4:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
 
    //初始化系统终端
  systemTerm ();
     aa8:	696e495f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, lr}^
 *
 * @brief  更新全局变量SystemCoreClock的值，以便获取最新的系统内核频率。
 *         
 */
void SystemCoreClockUpdate (void) 
{
     aac:	6c616974 	stclvs	9, cr6, [r1], #-464	; 0xfffffe30
     ab0:	6174535f 	cmnvs	r4, pc, asr r3
    uint32_t temp;
    temp =  CPU_XTAL_CLK_HZ *((uint32_t)(MCG_C6 & MCG_C6_VDIV_MASK) + 16u );
     ab4:	505f6b63 	subspl	r6, pc, r3, ror #22
     ab8:	746e696f 	strbtvc	r6, [lr], #-2415	; 0x96f
     abc:	2e007265 	cdpcs	2, 0, cr7, cr0, cr5, {3}
     ac0:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
     ac4:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
     ac8:	7570632f 	ldrbvc	r6, [r0, #-815]!	; 0x32f
     acc:	6174732f 	cmnvs	r4, pc, lsr #6
     ad0:	70757472 	rsbsvc	r7, r5, r2, ror r4
     ad4:	30366b5f 	eorscc	r6, r6, pc, asr fp
     ad8:	5f00632e 	svcpl	0x0000632e
    temp = (uint32_t)(temp/((uint32_t)(MCG_C5 & MCG_C5_PRDIV_MASK) +1u ))/2;
     adc:	74616473 	strbtvc	r6, [r1], #-1139	; 0x473
     ae0:	65640061 	strbvs	r0, [r4, #-97]!	; 0x61
     ae4:	6e697473 	mcrvs	4, 3, r7, cr9, cr3, {3}
     ae8:	6f697461 	svcvs	0x00697461
     aec:	6552006e 	ldrbvs	r0, [r2, #-110]	; 0x6e
     af0:	5f746573 	svcpl	0x00746573
     af4:	646e6148 	strbtvs	r6, [lr], #-328	; 0x148
     af8:	0072656c 	rsbseq	r6, r2, ip, ror #10
    SystemCoreClock = temp;
     afc:	61666544 	cmnvs	r6, r4, asr #10
     b00:	5f746c75 	svcpl	0x00746c75
     b04:	646e6148 	strbtvs	r6, [lr], #-328	; 0x148
}
     b08:	0072656c 	rsbseq	r6, r2, ip, ror #10
     b0c:	6574655f 	ldrbvs	r6, [r4, #-1375]!	; 0x55f
/*
 * 使能中断
 */

void enable_irq (int irq)
{
     b10:	5f007478 	svcpl	0x00007478
     b14:	73736265 	cmnvc	r3, #1342177286	; 0x50000006
    int div;
    if (irq > 105)
     b18:	756f7300 	strbvc	r7, [pc, #-768]!	; 820 <main+0x20>
     b1c:	00656372 	rsbeq	r6, r5, r2, ror r3
        irq = 105;
     b20:	6164655f 	cmnvs	r4, pc, asr r5
    div = irq / 32;
     b24:	67006174 	smlsdxvs	r0, r4, r1, r6
     b28:	6e66705f 	mcrvs	0, 3, r7, cr6, cr15, {2}
     b2c:	74636556 	strbtvc	r6, [r3], #-1366	; 0x556
     b30:	0073726f 	rsbseq	r7, r3, pc, ror #4
    switch (div)
     b34:	7362735f 	cmnvc	r2, #2080374785	; 0x7c000001
     b38:	44530073 	ldrbmi	r0, [r3], #-115	; 0x73
     b3c:	53004854 	movwpl	r4, #2132	; 0x854
     b40:	004c5444 	subeq	r5, ip, r4, asr #8
     b44:	6c665f67 	stclvs	15, cr5, [r6], #-412	; 0xfffffe64
     b48:	5f687361 	svcpl	0x00687361
     b4c:	636f6c63 	cmnvs	pc, #25344	; 0x6300
     b50:	4657006b 	ldrbmi	r0, [r7], -fp, rrx
    {
        case 0x0:
            NVICICPR0 |= 1 << (irq & 0x1F);
     b54:	36313837 			; <UNDEFINED> instruction: 0x36313837
     b58:	73795300 	cmnvc	r9, #0
     b5c:	436d6574 	cmnmi	sp, #486539264	; 0x1d000000
     b60:	4365726f 	cmnmi	r5, #-268435450	; 0xf0000006
     b64:	6b636f6c 	blvs	18dc91c <__etext+0x18d3c74>
     b68:	61647055 	qdsubvs	r7, r5, r4
     b6c:	50006574 	andpl	r6, r0, r4, ror r5
     b70:	315f4c4c 	cmpcc	pc, ip, asr #24
     b74:	53003030 	movwpl	r3, #48	; 0x30
     b78:	4f464946 	svcmi	0x00464946
            NVICISER0 |= 1 << (irq & 0x1F);
     b7c:	41545000 	cmpmi	r4, r0
     b80:	50003931 	andpl	r3, r0, r1, lsr r9
     b84:	30324254 	eorscc	r4, r2, r4, asr r2
     b88:	42545000 	subsmi	r5, r4, #0
     b8c:	50003132 	andpl	r3, r0, r2, lsr r1
     b90:	32324254 	eorscc	r4, r2, #1073741829	; 0x40000005
     b94:	42545000 	subsmi	r5, r4, #0
     b98:	54003332 	strpl	r3, [r0], #-818	; 0x332
     b9c:	46494643 	strbmi	r4, [r9], -r3, asr #12
            break;
     ba0:	5441004f 	strbpl	r0, [r1], #-79	; 0x4f
        case 0x1:
            NVICICPR1 |= 1 << (irq & 0x1F);
     ba4:	00485643 	subeq	r5, r8, r3, asr #12
     ba8:	49465754 	stmdbmi	r6, {r2, r4, r6, r8, r9, sl, ip, lr}^
     bac:	41004f46 	tstmi	r0, r6, asr #30
     bb0:	4c564354 	mrrcmi	3, 5, r4, r6, cr4
     bb4:	49465000 	stmdbmi	r6, {ip, lr}^
     bb8:	67004f46 	strvs	r4, [r0, -r6, asr #30]
     bbc:	656c665f 	strbvs	r6, [ip, #-1631]!	; 0x65f
     bc0:	73756278 	cmnvc	r5, #-2147483641	; 0x80000007
     bc4:	6f6c635f 	svcvs	0x006c635f
     bc8:	55006b63 	strpl	r6, [r0, #-2915]	; 0xb63
            NVICISER1 |= 1 << (irq & 0x1F);
     bcc:	00484449 	subeq	r4, r8, r9, asr #8
     bd0:	4c444955 	mcrrmi	9, 5, r4, r4, cr5
     bd4:	374c5400 	strbcc	r5, [ip, -r0, lsl #8]
     bd8:	00363138 	eorseq	r3, r6, r8, lsr r1
     bdc:	31455450 	cmpcc	r5, r0, asr r4
     be0:	54500030 	ldrbpl	r0, [r0], #-48	; 0x30
     be4:	00313145 	eorseq	r3, r1, r5, asr #2
     be8:	38375445 	ldmdacc	r7!, {r0, r2, r6, sl, ip, lr}
     bec:	50003631 	andpl	r3, r0, r1, lsr r6
            break;
        case 0x2:
            NVICICPR2 |= 1 << (irq & 0x1F);
     bf0:	315f4c4c 	cmpcc	pc, ip, asr #24
     bf4:	67003032 	smladxvs	r0, r2, r0, r3
     bf8:	7375625f 	cmnvc	r5, #-268435451	; 0xf0000005
     bfc:	6f6c635f 	svcvs	0x006c635f
     c00:	55006b63 	strpl	r6, [r0, #-2915]	; 0xb63
     c04:	5f545241 	svcpl	0x00545241
     c08:	4d6d654d 	cfstr64mi	mvdx6, [sp, #-308]!	; 0xfffffecc
     c0c:	74507061 	ldrbvc	r7, [r0], #-97	; 0x61
     c10:	2e2e0072 	mcrcs	0, 1, r0, cr14, cr2, {3}
     c14:	2f2e2e2f 	svccs	0x002e2e2f
            NVICISER2 |= 1 << (irq & 0x1F);
     c18:	2f62696c 	svccs	0x0062696c
     c1c:	2f757063 	svccs	0x00757063
     c20:	74737973 	ldrbtvc	r7, [r3], #-2419	; 0x973
     c24:	6b5f6d65 	blvs	17dc1c0 <__etext+0x17d3518>
     c28:	632e3036 	teqvs	lr, #54	; 0x36
     c2c:	45534900 	ldrbmi	r4, [r3, #-2304]	; 0x900
     c30:	4e570052 	mrcmi	0, 2, r0, cr7, cr2, {2}
     c34:	36313837 			; <UNDEFINED> instruction: 0x36313837
     c38:	45545000 	ldrbmi	r5, [r4, #-0]
            break;
     c3c:	50003231 	andpl	r3, r0, r1, lsr r2
        case 0x3:
            NVICICPR3 |= 1 << (irq & 0x1F);
     c40:	35324554 	ldrcc	r4, [r2, #-1364]!	; 0x554
     c44:	45545000 	ldrbmi	r5, [r4, #-0]
     c48:	50003632 	andpl	r3, r0, r2, lsr r6
     c4c:	37324554 			; <UNDEFINED> instruction: 0x37324554
     c50:	45545000 	ldrbmi	r5, [r4, #-0]
     c54:	4d003832 	stcmi	8, cr3, [r0, #-200]	; 0xffffff38
     c58:	4d45444f 	cfstrdmi	mvd4, [r5, #-316]	; 0xfffffec4
     c5c:	37454900 	strbcc	r4, [r5, -r0, lsl #18]
     c60:	00363138 	eorseq	r3, r6, r8, lsr r1
     c64:	44494453 	strbmi	r4, [r9], #-1107	; 0x453
            NVICISER3 |= 1 << (irq & 0x1F);
     c68:	47435300 	strbmi	r5, [r3, -r0, lsl #6]
     c6c:	53003143 	movwpl	r3, #323	; 0x143
     c70:	32434743 	subcc	r4, r3, #17563648	; 0x10c0000
     c74:	47435300 	strbmi	r5, [r3, -r0, lsl #6]
     c78:	53003343 	movwpl	r3, #835	; 0x343
     c7c:	34434743 	strbcc	r4, [r3], #-1859	; 0x743
     c80:	47435300 	strbmi	r5, [r3, -r0, lsl #6]
     c84:	53003543 	movwpl	r3, #1347	; 0x543
     c88:	36434743 	strbcc	r4, [r3], -r3, asr #14
            break;
    }
}
     c8c:	47435300 	strbmi	r5, [r3, -r0, lsl #6]
     c90:	55003743 	strpl	r3, [r0, #-1859]	; 0x743
     c94:	5f545241 	svcpl	0x00545241
/*
 * 关闭中断
 */

void disable_irq (int irq)
{
     c98:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
     c9c:	65707954 	ldrbvs	r7, [r0, #-2388]!	; 0x954
    int div;
    if (irq > 105)
     ca0:	00666544 	rsbeq	r6, r6, r4, asr #10
     ca4:	54524155 	ldrbpl	r4, [r2], #-341	; 0x155
        irq = 105;
     ca8:	5253495f 	subspl	r4, r3, #1556480	; 0x17c000
    div = irq / 32;
     cac:	4c41435f 	mcrrmi	3, 5, r4, r1, cr15
     cb0:	4341424c 	movtmi	r4, #4684	; 0x124c
     cb4:	564e004b 	strbpl	r0, [lr], -fp, asr #32
     cb8:	4d5f4349 	ldclmi	3, cr4, [pc, #-292]	; b9c <enable_irq+0x8c>
    switch (div)
     cbc:	614d6d65 	cmpvs	sp, r5, ror #26
     cc0:	54500070 	ldrbpl	r0, [r0], #-112	; 0x70
     cc4:	50003041 	andpl	r3, r0, r1, asr #32
     cc8:	00314154 	eorseq	r4, r1, r4, asr r1
     ccc:	32415450 	subcc	r5, r1, #1342177280	; 0x50000000
     cd0:	41545000 	cmpmi	r4, r0
     cd4:	54500033 	ldrbpl	r0, [r0], #-51	; 0x33
    {
        case 0x0:
            NVICICPR0 |= 1 << (irq & 0x1F);
     cd8:	50003441 	andpl	r3, r0, r1, asr #8
     cdc:	00354154 	eorseq	r4, r5, r4, asr r1
     ce0:	36415450 			; <UNDEFINED> instruction: 0x36415450
     ce4:	41545000 	cmpmi	r4, r0
     ce8:	54500037 	ldrbpl	r0, [r0], #-55	; 0x37
     cec:	50003841 	andpl	r3, r0, r1, asr #16
     cf0:	00394154 	eorseq	r4, r9, r4, asr r1
     cf4:	5f4c4c50 	svcpl	0x004c4c50
     cf8:	00303531 	eorseq	r3, r0, r1, lsr r5
     cfc:	32455450 	subcc	r5, r5, #1342177280	; 0x50000000
            break;
     d00:	4f530034 	svcmi	0x00530034
        case 0x1:
            NVICICPR1 |= 1 << (irq & 0x1F);
     d04:	43315450 	teqmi	r1, #1342177280	; 0x50000000
     d08:	50004746 	andpl	r4, r0, r6, asr #14
     d0c:	30314354 	eorscc	r4, r1, r4, asr r3
     d10:	43545000 	cmpmi	r4, #0
     d14:	50003131 	andpl	r3, r0, r1, lsr r1
     d18:	32314354 	eorscc	r4, r1, #1342177281	; 0x50000001
     d1c:	43545000 	cmpmi	r4, #0
     d20:	57003331 	smladxpl	r0, r1, r3, r3
     d24:	31383750 	teqcc	r8, r0, asr r7
     d28:	5f545f36 	svcpl	0x00545f36
            break;
        case 0x2:
            NVICICPR2 |= 1 << (irq & 0x1F);
     d2c:	45505954 	ldrbmi	r5, [r0, #-2388]	; 0x954
     d30:	50570030 	subspl	r0, r7, r0, lsr r0
     d34:	36313837 			; <UNDEFINED> instruction: 0x36313837
     d38:	545f545f 	ldrbpl	r5, [pc], #-1119	; d40 <disable_irq+0xa8>
     d3c:	31455059 	qdaddcc	r5, r9, r5
     d40:	43545000 	cmpmi	r4, #0
     d44:	50003631 	andpl	r3, r0, r1, lsr r6
     d48:	37314354 			; <UNDEFINED> instruction: 0x37314354
     d4c:	43545000 	cmpmi	r4, #0
     d50:	50003831 	andpl	r3, r0, r1, lsr r8
            break;
     d54:	39314354 	ldmdbcc	r1!, {r2, r4, r6, r8, r9, lr}
        case 0x3:
            NVICICPR3 |= 1 << (irq & 0x1F);
     d58:	42545000 	subsmi	r5, r4, #0
     d5c:	54500030 	ldrbpl	r0, [r0], #-48	; 0x30
     d60:	50003142 	andpl	r3, r0, r2, asr #2
     d64:	00324254 	eorseq	r4, r2, r4, asr r2
     d68:	33425450 	movtcc	r5, #9296	; 0x2450
     d6c:	42545000 	subsmi	r5, r4, #0
     d70:	54500034 	ldrbpl	r0, [r0], #-52	; 0x34
     d74:	50003542 	andpl	r3, r0, r2, asr #10
     d78:	00364254 	eorseq	r4, r6, r4, asr r2
     d7c:	37425450 	smlsldcc	r5, r2, r0, r4
            break;
    }
}
     d80:	42545000 	subsmi	r5, r4, #0
     d84:	54500038 	ldrbpl	r0, [r0], #-56	; 0x38
     d88:	50003942 	andpl	r3, r0, r2, asr #18
/*
 * 系统终端初始化函数
 */

 void systemTerm (void)
 {
     d8c:	325f4c4c 	subscc	r4, pc, #19456	; 0x4c00
     d90:	50003030 	andpl	r3, r0, r0, lsr r0
     UART_InitTypeDef uart_init_struct;
     uart_init_struct.UART_Uartx = TERM_PORT;
     d94:	34314454 	ldrtcc	r4, [r1], #-1108	; 0x454
     d98:	44545000 	ldrbmi	r5, [r4], #-0
     uart_init_struct.UART_BaudRate = TERM_BAUD;
     d9c:	55003531 	strpl	r3, [r0, #-1329]	; 0x531
     da0:	5f545241 	svcpl	0x00545241
     uart_init_struct.UART_RxPin = TERM_RX;
     da4:	73497852 	movtvc	r7, #38994	; 0x9852
     uart_init_struct.UART_TxPin = TERM_TX;
     da8:	4c500072 	mrrcmi	0, 7, r0, r0, cr2	; <UNPREDICTABLE>
     dac:	38345f4c 	ldmdacc	r4!, {r2, r3, r6, r8, r9, sl, fp, ip, lr}
     uart_init_struct.UART_RxIntEnable = TERM_RX_IRQ;
     db0:	52415500 	subpl	r5, r1, #0
     uart_init_struct.UART_RxIsr = TERM_RX_FUN;
     db4:	61555f54 	cmpvs	r5, r4, asr pc
     db8:	00787472 	rsbseq	r7, r8, r2, ror r4

     LPLD_UART_Init (uart_init_struct);
     dbc:	61736964 	cmnvs	r3, r4, ror #18
     dc0:	5f656c62 	svcpl	0x00656c62
     dc4:	00717269 	rsbseq	r7, r1, r9, ror #4
#if (TERM_RX_IRQ == TRUE)
     LPLD_UART_EnableIrq (uart_init_struct);
#endif

 }
     dc8:	6c6f6f62 	stclvs	15, cr6, [pc], #-392	; c48 <enable_irq+0x138>
     dcc:	006e6165 	rsbeq	r6, lr, r5, ror #2
//图像状态
volatile IMG_STATUS_e ov7725_eagle_img_flag = IMG_FINISH;

//ov7725初始化 
uint8 Ov7725_Init (void)
{
     dd0:	30435450 	subcc	r5, r3, r0, asr r4
     dd4:	43545000 	cmpmi	r4, #0
    uint16 i = 0;
     dd8:	54500031 	ldrbpl	r0, [r0], #-49	; 0x31
    uint8 device_Id = 0;
     ddc:	50003243 	andpl	r3, r0, r3, asr #4
     de0:	00334354 	eorseq	r4, r3, r4, asr r3
    uint8 reg_Buff[50] = {0};
     de4:	34435450 	strbcc	r5, [r3], #-1104	; 0x450
     de8:	43545000 	cmpmi	r4, #0
     dec:	54500035 	ldrbpl	r0, [r0], #-53	; 0x35
     df0:	50003643 	andpl	r3, r0, r3, asr #12
     df4:	00374354 	eorseq	r4, r7, r4, asr r3
     df8:	39435450 	stmdbcc	r3, {r4, r6, sl, ip, lr}^
     dfc:	4c4c5000 	marmi	acc0, r5, ip
     e00:	0030355f 	eorseq	r3, r0, pc, asr r5
     e04:	54444954 	strbpl	r4, [r4], #-2388	; 0x954
     e08:	44495500 	strbmi	r5, [r9], #-1280	; 0x500
     e0c:	5500484d 	strpl	r4, [r0, #-2125]	; 0x84d
     e10:	4c4d4449 	cfstrdmi	mvd4, [sp], {73}	; 0x49
     e14:	44545000 	ldrbmi	r5, [r4], #-0
     e18:	54500030 	ldrbpl	r0, [r0], #-48	; 0x30
     e1c:	50003144 	andpl	r3, r0, r4, asr #2
     e20:	00324454 	eorseq	r4, r2, r4, asr r4
     e24:	33445450 	movtcc	r5, #17488	; 0x4450
     e28:	44545000 	ldrbmi	r5, [r4], #-0
     e2c:	54500034 	ldrbpl	r0, [r0], #-52	; 0x34
     e30:	50003544 	andpl	r3, r0, r4, asr #10
     e34:	00364454 	eorseq	r4, r6, r4, asr r4
     e38:	37445450 	smlsldcc	r5, r4, r0, r4
     e3c:	44545000 	ldrbmi	r5, [r4], #-0
     e40:	54500038 	ldrbpl	r0, [r0], #-56	; 0x38
     e44:	55003944 	strpl	r3, [r0, #-2372]	; 0x944
     e48:	5f545241 	svcpl	0x00545241
     e4c:	69507852 	ldmdbvs	r0, {r1, r4, r6, fp, ip, sp, lr}^
     e50:	4c50006e 	mrrcmi	0, 6, r0, r0, cr14	; <UNPREDICTABLE>
     e54:	38315f4c 	ldmdacc	r1!, {r2, r3, r6, r8, r9, sl, fp, ip, lr}
     e58:	54500030 	ldrbpl	r0, [r0], #-48	; 0x30
     e5c:	50003843 	andpl	r3, r0, r3, asr #16
     e60:	30314154 	eorscc	r4, r1, r4, asr r1
     e64:	41545000 	cmpmi	r4, r0

    LPLD_SCCB_Init ();
     e68:	50003131 	andpl	r3, r0, r1, lsr r1
    
    Ov7725_Delay();
     e6c:	32314154 	eorscc	r4, r1, #21

    while (!LPLD_SCCB_WriteReg (OV7725_COM7, 0x80))
     e70:	41545000 	cmpmi	r4, r0
    {
        if (i ++ >= 500)
     e74:	50003331 	andpl	r3, r0, r1, lsr r3
     e78:	34314154 	ldrtcc	r4, [r1], #-340	; 0x154
     e7c:	41545000 	cmpmi	r4, r0
     e80:	50003531 	andpl	r3, r0, r1, lsr r5
     e84:	36314154 			; <UNDEFINED> instruction: 0x36314154
     e88:	41545000 	cmpmi	r4, r0
     e8c:	50003731 	andpl	r3, r0, r1, lsr r7
            return 0;
     e90:	38314154 	ldmdacc	r1!, {r2, r4, r6, r8, lr}

    LPLD_SCCB_Init ();
    
    Ov7725_Delay();

    while (!LPLD_SCCB_WriteReg (OV7725_COM7, 0x80))
     e94:	50434900 	subpl	r4, r3, r0, lsl #18
     e98:	41490052 	qdaddmi	r0, r2, r9
     e9c:	43005242 	movwmi	r5, #578	; 0x242
     ea0:	49444b4c 	stmdbmi	r4, {r2, r3, r6, r8, r9, fp, lr}^
     ea4:	50003456 	andpl	r3, r0, r6, asr r4
    {
        if (i ++ >= 500)
            return 0;
    }

    Ov7725_Delay();
     ea8:	00304554 	eorseq	r4, r0, r4, asr r5
    
    while (0 == LPLD_SCCB_ReadReg (OV7725_VER, &device_Id, 1));
     eac:	31455450 	cmpcc	r5, r0, asr r4
     eb0:	45545000 	ldrbmi	r5, [r4, #-0]
     eb4:	54500032 	ldrbpl	r0, [r0], #-50	; 0x32
     eb8:	50003345 	andpl	r3, r0, r5, asr #6
     ebc:	00344554 	eorseq	r4, r4, r4, asr r5
     ec0:	35455450 	strbcc	r5, [r5, #-1104]	; 0x450

    printf ("You get ID success, SENSOR ID is 0x%x", device_Id);
     ec4:	45545000 	ldrbmi	r5, [r4, #-0]
     ec8:	54500036 	ldrbpl	r0, [r0], #-54	; 0x36
     ecc:	50003745 	andpl	r3, r0, r5, asr #14
     ed0:	00384554 	eorseq	r4, r8, r4, asr r5
     ed4:	39455450 	stmdbcc	r5, {r4, r6, sl, ip, lr}^
    printf ("nconfig register Number is %d\n", ov7725_eagle_cfgnum);
     ed8:	73795300 	cmnvc	r9, #0
     edc:	436d6574 	cmnmi	sp, #486539264	; 0x1d000000
     ee0:	4365726f 	cmnmi	r5, #-268435450	; 0xf0000006
     ee4:	6b636f6c 	blvs	18dcc9c <__etext+0x18d3ff4>
     ee8:	43545000 	cmpmi	r4, #0
     eec:	50003431 	andpl	r3, r0, r1, lsr r4

    //判断摄像头是否为ov7725
    if (device_Id == OV7725_ID)
     ef0:	35314354 	ldrcc	r4, [r1, #-852]!	; 0x354
     ef4:	49545300 	ldmdbmi	r4, {r8, r9, ip, lr}^
    {
        for (i = 0; i < ov7725_eagle_cfgnum; i++)
     ef8:	54500052 	ldrbpl	r0, [r0], #-82	; 0x52
     efc:	00343241 	eorseq	r3, r4, r1, asr #4
        {
            if (0 == LPLD_SCCB_WriteReg(ov7725_eagle_reg[i].addr, ov7725_eagle_reg[i].val))
     f00:	32415450 	subcc	r5, r1, #1342177280	; 0x50000000
     f04:	54500035 	ldrbpl	r0, [r0], #-53	; 0x35
     f08:	00363241 	eorseq	r3, r6, r1, asr #4
     f0c:	32415450 	subcc	r5, r1, #1342177280	; 0x50000000
     f10:	54500037 	ldrbpl	r0, [r0], #-55	; 0x37
     f14:	00383241 	eorseq	r3, r8, r1, asr #4
     f18:	32415450 	subcc	r5, r1, #1342177280	; 0x50000000
     f1c:	50520039 	subspl	r0, r2, r9, lsr r0
     f20:	004c4552 	subeq	r4, ip, r2, asr r5
     f24:	48544350 	ldmdami	r4, {r4, r6, r8, r9, lr}^
     f28:	46434600 	strbmi	r4, [r3], -r0, lsl #12
     f2c:	46003147 	strmi	r3, [r0], -r7, asr #2
            {
               printf ("error: writeReg error 0x%x\n", ov7725_eagle_reg[i].addr);
     f30:	32474643 	subcc	r4, r7, #70254592	; 0x4300000
     f34:	726f5000 	rsbvc	r5, pc, #0
     f38:	6e695074 	mcrvs	0, 3, r5, cr9, cr4, {3}
     f3c:	756e4573 	strbvc	r4, [lr, #-1395]!	; 0x573
     f40:	6574006d 	ldrbvs	r0, [r4, #-109]!	; 0x6d
     f44:	5300706d 	movwpl	r7, #109	; 0x6d
     f48:	4d5f4d49 	ldclmi	13, cr4, [pc, #-292]	; e2c <Ov7725_Init+0x5c>
                return 0;
     f4c:	614d6d65 	cmpvs	sp, r5, ror #26
            }
            if (LPLD_SCCB_ReadReg(ov7725_eagle_reg[i].addr, &reg_Buff[i], 1))
     f50:	72745070 	rsbsvc	r5, r4, #112	; 0x70
     f54:	52415500 	subpl	r5, r1, #0
     f58:	61425f54 	cmpvs	r2, r4, asr pc
     f5c:	61526475 	cmpvs	r2, r5, ror r4
     f60:	55006574 	strpl	r6, [r0, #-1396]	; 0x574
     f64:	5f545241 	svcpl	0x00545241
     f68:	73497854 	movtvc	r7, #38996	; 0x9854
     f6c:	41550072 	cmpmi	r5, r2, ror r0
     f70:	545f5452 	ldrbpl	r5, [pc], #-1106	; f78 <Ov7725_Init+0x1a8>
     f74:	746e4978 	strbtvc	r4, [lr], #-2424	; 0x978
            {
                printf ("writeRe 0x%x success: 0x%x\n", ov7725_eagle_reg[i].addr, reg_Buff[i]);
     f78:	62616e45 	rsbvs	r6, r1, #1104	; 0x450
     f7c:	5000656c 	andpl	r6, r0, ip, ror #10
     f80:	30314454 	eorscc	r4, r1, r4, asr r4
     f84:	44545000 	ldrbmi	r5, [r4], #-0
     f88:	50003131 	andpl	r3, r0, r1, lsr r1
     f8c:	32314454 	eorscc	r4, r1, #1409286144	; 0x54000000
     f90:	44545000 	ldrbmi	r5, [r4], #-0
     f94:	52003331 	andpl	r3, r0, #-1006632960	; 0xc4000000
     f98:	46494643 	strbmi	r4, [r9], -r3, asr #12
     f9c:	4c50004f 	mrrcmi	0, 4, r0, r0, cr15	; <UNPREDICTABLE>
     fa0:	36395f4c 	ldrtcc	r5, [r9], -ip, asr #30
    printf ("nconfig register Number is %d\n", ov7725_eagle_cfgnum);

    //判断摄像头是否为ov7725
    if (device_Id == OV7725_ID)
    {
        for (i = 0; i < ov7725_eagle_cfgnum; i++)
     fa4:	6c6c5000 	stclvs	0, cr5, [ip], #-0
     fa8:	6974704f 	ldmdbvs	r4!, {r0, r1, r2, r3, r6, ip, sp, lr}^
     fac:	6e456e6f 	cdpvs	14, 4, cr6, cr5, cr15, {3}
     fb0:	52006d75 	andpl	r6, r0, #7488	; 0x1d40
     fb4:	46494657 			; <UNDEFINED> instruction: 0x46494657
     fb8:	434d004f 	movtmi	r0, #53327	; 0xd04f
            }
        }
    }
    else
    {
        return 0;
     fbc:	654d5f47 	strbvs	r5, [sp, #-3911]	; 0xf47
     fc0:	70614d6d 	rsbvc	r4, r1, sp, ror #26
    }
    return 1;
     fc4:	00727450 	rsbseq	r7, r2, r0, asr r4

}
     fc8:	31383743 	teqcc	r8, r3, asr #14
     fcc:	5f670036 	svcpl	0x00670036

//ov7725延时函数
void Ov7725_Delay(void)
{
     fd0:	65726f63 	ldrbvs	r6, [r2, #-3939]!	; 0xf63
     fd4:	6f6c635f 	svcvs	0x006c635f
    uint16 i, n;
    for (i = 0; i < 3000; i++)
     fd8:	55006b63 	strpl	r6, [r0, #-2915]	; 0xb63
     fdc:	5f545241 	svcpl	0x00545241
    {
        for (n = 0; n < 200; n++)
     fe0:	6e497852 	mcrvs	8, 2, r7, cr9, cr2, {2}
     fe4:	616e4574 	smcvs	58452	; 0xe454
     fe8:	00656c62 	rsbeq	r6, r5, r2, ror #24
     fec:	444b4c43 	strbmi	r4, [fp], #-3139	; 0xc43
     ff0:	00315649 	eorseq	r5, r1, r9, asr #12
     ff4:	444b4c43 	strbmi	r4, [fp], #-3139	; 0xc43

//ov7725延时函数
void Ov7725_Delay(void)
{
    uint16 i, n;
    for (i = 0; i < 3000; i++)
     ff8:	00325649 	eorseq	r5, r2, r9, asr #12
     ffc:	5f47434d 	svcpl	0x0047434d
    1000:	4d6d654d 	cfstr64mi	mvdx6, [sp, #-308]!	; 0xfffffecc
    1004:	52007061 	andpl	r7, r0, #97	; 0x61
        for (n = 0; n < 200; n++)
        {
            asm("nop");
        }
    }
}
    1008:	00544449 	subseq	r4, r4, r9, asr #8
    100c:	54524155 	ldrbpl	r4, [r2], #-341	; 0x155
    1010:	5078545f 	rsbspl	r5, r8, pc, asr r4

//DMA中断触发函数
void Ov7725_eagle_dma (void)
{
    1014:	49006e69 	stmdbmi	r0, {r0, r3, r5, r6, r9, sl, fp, sp, lr}
    1018:	00524543 	subseq	r4, r2, r3, asr #10
    ov7725_eagle_img_flag = IMG_FINISH;
    101c:	62616e65 	rsbvs	r6, r1, #1616	; 0x650
    1020:	695f656c 	ldmdbvs	pc, {r2, r3, r5, r6, r8, sl, sp, lr}^	; <UNPREDICTABLE>
    1024:	50007172 	andpl	r7, r0, r2, ror r1
    //关闭DMA通道
    DMA_DIS(DMA_CH0);
    1028:	004c5443 	subeq	r5, ip, r3, asr #8
    102c:	54524155 	ldrbpl	r4, [r2], #-341	; 0x155
    1030:	6d654d5f 	stclvs	13, cr4, [r5, #-380]!	; 0xfffffe84
    1034:	0070614d 	rsbseq	r6, r0, sp, asr #2
    1038:	54504f53 	ldrbpl	r4, [r0], #-3923	; 0xf53
    103c:	4f530031 	svcmi	0x00530031
    //DMA0->INT |= 0x1u << 0;
    //enable_irq(INT_PORTA - 16);
    //图片进行解压
    Ov7725_img_extract(Pix_Data, img, PHOTO_SIZE/8);
    1040:	00325450 	eorseq	r5, r2, r0, asr r4
    1044:	5f4d4953 	svcpl	0x004d4953
    1048:	4d6d654d 	cfstr64mi	mvdx6, [sp, #-308]!	; 0xfffffecc
    104c:	53007061 	movwpl	r7, #97	; 0x61
    1050:	3454504f 	ldrbcc	r5, [r4], #-79	; 0x4f
    1054:	504f5300 	subpl	r5, pc, r0, lsl #6
    //解压完成标志置位
    ready_send_flag = 1;
    1058:	53003554 	movwpl	r3, #1364	; 0x554
    105c:	3654504f 	ldrbcc	r5, [r4], -pc, asr #32
    1060:	504f5300 	subpl	r5, pc, r0, lsl #6
    1064:	50003754 	andpl	r3, r0, r4, asr r7
    get_midline(Pix_Data, 60, 80);
    1068:	5074726f 	rsbspl	r7, r4, pc, ror #4
    106c:	45736e69 	ldrbmi	r6, [r3, #-3689]!	; 0xe69
    1070:	5f6d756e 	svcpl	0x006d756e
    1074:	65707954 	ldrbvs	r7, [r0, #-2388]!	; 0x954
    1078:	72617500 	rsbvc	r7, r1, #0
         //重新装载DMA目标地址
        DMA_DADDR(DMA_CH0) = (uint32)img;
    107c:	6e695f74 	mcrvs	15, 3, r5, cr9, cr4, {3}
    1080:	735f7469 	cmpvc	pc, #1761607680	; 0x69000000
    1084:	63757274 	cmnvs	r5, #1073741831	; 0x40000007
    1088:	564e0074 			; <UNDEFINED> instruction: 0x564e0074
    108c:	4d5f4349 	ldclmi	3, cr4, [pc, #-292]	; f70 <Ov7725_Init+0x1a0>
    1090:	614d6d65 	cmpvs	sp, r5, ror #26
   //Ov7725_sendimg(Pix_Data, PHOTO_SIZE);
    //clear PORTA isr set bit
    PORTA_ISFR = ~0;
    1094:	72745070 	rsbsvc	r5, r4, #112	; 0x70
    1098:	73797300 	cmnvc	r9, #0
    109c:	546d6574 	strbtpl	r6, [sp], #-1396	; 0x574
    10a0:	006d7265 	rsbeq	r7, sp, r5, ror #4
    LPLD_GPIO_EnableIrq(OV_PTA_init);
    10a4:	52505349 	subspl	r5, r0, #603979777	; 0x24000001
    10a8:	37534900 	ldrbcc	r4, [r3, -r0, lsl #18]
    10ac:	00363138 	eorseq	r3, r6, r8, lsr r1
    10b0:	74737953 	ldrbtvc	r7, [r3], #-2387	; 0x953
    10b4:	6e496d65 	cdpvs	13, 4, cr6, cr9, cr5, {3}
    //DMA0->INT |= 0x1u << 0;
}
    10b8:	50007469 	andpl	r7, r0, r9, ror #8

//场中断开始判断函数
void Ov7725_eagle_vsync(void)
{
    10bc:	30314254 	eorscc	r4, r1, r4, asr r2
    //printf ("runing eagle_vsync\n");
    //判断场中断是否开始
    if (ov7725_eagle_img_flag == IMG_START)
    10c0:	42545000 	subsmi	r5, r4, #0
    10c4:	50003131 	andpl	r3, r0, r1, lsr r1
    10c8:	36314254 			; <UNDEFINED> instruction: 0x36314254
    10cc:	42545000 	subsmi	r5, r4, #0
    {
        ov7725_eagle_img_flag = IMG_GATHER;
    10d0:	50003731 	andpl	r3, r0, r1, lsr r7
    10d4:	38314254 	ldmdacc	r1!, {r2, r4, r6, r9, lr}
    10d8:	42545000 	subsmi	r5, r4, #0
    10dc:	47003931 	smladxmi	r0, r1, r9, r3
        disable_irq (INT_PORTA - 16);
    10e0:	5f4f4950 	svcpl	0x004f4950
    10e4:	316e6950 	cmncc	lr, r0, asr r9
        //LPLD_GPIO_DisableIrq(OV_PTA_init);
        //enable_irq (DMA_CH0 + INT_DMA0_DMA16 - 16);
        DMA_EN(DMA_CH0);
    10e8:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
    10ec:	69505f4f 	ldmdbvs	r0, {r0, r1, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
    10f0:	4700326e 	strmi	r3, [r0, -lr, ror #4]
    10f4:	5f4f4950 	svcpl	0x004f4950
    10f8:	336e6950 	cmncc	lr, #1310720	; 0x140000
    10fc:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
        //LPLD_DMA_EnableIrq(OV_dma_init);
        //重新装载DMA目标地址
        DMA_DADDR(DMA_CH0) = (uint32)img;
    1100:	69505f4f 	ldmdbvs	r0, {r0, r1, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
    1104:	4700356e 	strmi	r3, [r0, -lr, ror #10]
    1108:	5f4f4950 	svcpl	0x004f4950
    110c:	366e6950 			; <UNDEFINED> instruction: 0x366e6950
    1110:	43504700 	cmpmi	r0, #0
    1114:	4900524c 	stmdbmi	r0, {r2, r3, r6, r9, ip, lr}
    1118:	535f474d 	cmppl	pc, #20185088	; 0x1340000
    }
    else
    {
        //disable_irq (INT_PORTA);
        //LPLD_GPIO_DisableIrq(OV_PTA_init);
        disable_irq (INT_PORTA - 16);
    111c:	55544154 	ldrbpl	r4, [r4, #-340]	; 0x154
    1120:	00655f53 	rsbeq	r5, r5, r3, asr pc
        ov7725_eagle_img_flag = IMG_FAIL;
    1124:	505f564f 	subspl	r5, pc, pc, asr #12
    1128:	695f4454 	ldmdbvs	pc, {r2, r4, r6, sl, lr}^	; <UNPREDICTABLE>
    112c:	0074696e 	rsbseq	r6, r4, lr, ror #18
    }
}
    1130:	5f414d44 	svcpl	0x00414d44

//ov7725开始采集图像
void Ov7725_eagle_get_img(void)
{
    1134:	69726550 	ldmdbvs	r2!, {r4, r6, r8, sl, sp, lr}^
    1138:	6369646f 	cmnvs	r9, #1862270976	; 0x6f000000
    ov7725_eagle_img_flag = IMG_START;
    113c:	67697254 			; <UNDEFINED> instruction: 0x67697254
    1140:	45726567 	ldrbmi	r6, [r2, #-1383]!	; 0x567
    1144:	6c62616e 	stfvse	f6, [r2], #-440	; 0xfffffe48
    //write 1 clear int 
    PORTA_ISFR = ~0;
    1148:	46440065 	strbmi	r0, [r4], -r5, rrx
    114c:	73005243 	movwvc	r5, #579	; 0x243
    1150:	656c6372 	strbvs	r6, [ip, #-882]!	; 0x372
    1154:	6564006e 	strbvs	r0, [r4, #-110]!	; 0x6e
    DMA_DADDR(DMA_CH0) = (uint32)img;
    1158:	65636976 	strbvs	r6, [r3, #-2422]!	; 0x976
    115c:	0064495f 	rsbeq	r4, r4, pc, asr r9
    1160:	65646973 	strbvs	r6, [r4, #-2419]!	; 0x973
    1164:	66656c5f 			; <UNDEFINED> instruction: 0x66656c5f
    1168:	4d490074 	stclmi	0, cr0, [r9, #-464]	; 0xfffffe30
    116c:	54535f47 	ldrbpl	r5, [r3], #-3911	; 0xf47
    1170:	4900504f 	stmdbmi	r0, {r0, r1, r2, r3, r6, ip, lr}
    LPLD_GPIO_EnableIrq(OV_PTA_init);
    1174:	475f474d 	ldrbmi	r4, [pc, -sp, asr #14]
    1178:	45485441 	strbmi	r5, [r8, #-1089]	; 0x441
    117c:	6d640052 	stclvs	0, cr0, [r4, #-328]!	; 0xfffffeb8
    1180:	6f705f61 	svcvs	0x00705f61
}
    1184:	32787472 	rsbscc	r7, r8, #1912602624	; 0x72000000
 *  @param      srclen          二值化图像的占用空间大小
 *  @since      v5.0            img_extract(img, imgbuff,CAMERA_SIZE);
 *  Sample usage:   sendimg(imgbuff, CAMERA_W * CAMERA_H);                    //发送到上位机
 */
void Ov7725_img_extract(uint8 *dst, uint8 *src, uint32 srclen)
{
    1188:	66667562 	strbtvs	r7, [r6], -r2, ror #10
    118c:	696e695f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}^
    1190:	50470074 	subpl	r0, r7, r4, ror r0
    uint8 colour[2] = {255, 0}; //0 和 1 分别对应的颜色
    1194:	505f4f49 	subspl	r4, pc, r9, asr #30
    1198:	34326e69 	ldrtcc	r6, [r2], #-3689	; 0xe69
    119c:	0031335f 	eorseq	r3, r1, pc, asr r3
    //注：野火的摄像头 1(or255)表示 白色，0表示 黑色
    uint8 tmpsrc;
    while(srclen --)
    11a0:	5f414d44 	svcpl	0x00414d44
    {
        tmpsrc = *src++;
    11a4:	6f6a614d 	svcvs	0x006a614d
    11a8:	6f6f4c72 	svcvs	0x006f4c72
    11ac:	746e4370 	strbtvc	r4, [lr], #-880	; 0x370
        *dst++ = colour[(tmpsrc >> 7) & 0x01];
    11b0:	524f5000 	subpl	r5, pc, #0
    11b4:	654d5f54 	strbvs	r5, [sp, #-3924]	; 0xf54
    11b8:	70614d6d 	rsbvc	r4, r1, sp, ror #26
    11bc:	00727450 	rsbseq	r7, r2, r0, asr r4
    11c0:	3737764f 	ldrcc	r7, [r7, -pc, asr #12]!
    11c4:	695f3532 	ldmdbvs	pc, {r1, r4, r5, r8, sl, ip, sp}^	; <UNPREDICTABLE>
    11c8:	655f676d 	ldrbvs	r6, [pc, #-1901]	; a63 <SystemInit+0xab>
    11cc:	61727478 	cmnvs	r2, r8, ror r4
    11d0:	44007463 	strmi	r7, [r0], #-1123	; 0x463
        *dst++ = colour[(tmpsrc >> 6) & 0x01];
    11d4:	4d5f414d 	ldfmie	f4, [pc, #-308]	; 10a8 <Ov7725_eagle_dma+0x94>
    11d8:	726f6e69 	rsbvc	r6, pc, #1680	; 0x690
    11dc:	65747942 	ldrbvs	r7, [r4, #-2370]!	; 0x942
    11e0:	00746e43 	rsbseq	r6, r4, r3, asr #28
    11e4:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    11e8:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
    11ec:	77682f62 	strbvc	r2, [r8, -r2, ror #30]!
    11f0:	7665642f 	strbtvc	r6, [r5], -pc, lsr #8
        *dst++ = colour[(tmpsrc >> 5) & 0x01];
    11f4:	37766f5f 			; <UNDEFINED> instruction: 0x37766f5f
    11f8:	2e353237 	mrccs	2, 1, r3, cr5, cr7, {1}
    11fc:	6f630063 	svcvs	0x00630063
    1200:	00746e75 	rsbseq	r6, r4, r5, ror lr
    1204:	73676d69 	cmnvc	r7, #6720	; 0x1a40
    1208:	00657a69 	rsbeq	r7, r5, r9, ror #20
    120c:	5f616d64 	svcpl	0x00616d64
    1210:	00716572 	rsbseq	r6, r1, r2, ror r5
    1214:	45545942 	ldrbmi	r5, [r4, #-2370]	; 0x942
        *dst++ = colour[(tmpsrc >> 4) & 0x01];
    1218:	69730073 	ldmdbvs	r3!, {r0, r1, r4, r5, r6}^
    121c:	725f6564 	subsvc	r6, pc, #419430400	; 0x19000000
    1220:	74686769 	strbtvc	r6, [r8], #-1897	; 0x769
    1224:	414d4400 	cmpmi	sp, r0, lsl #8
    1228:	756f535f 	strbvc	r5, [pc, #-863]!	; ed1 <Ov7725_Init+0x101>
    122c:	44656372 	strbtmi	r6, [r5], #-882	; 0x372
    1230:	53617461 	cmnpl	r1, #1627389952	; 0x61000000
    1234:	00657a69 	rsbeq	r7, r5, r9, ror #20
        *dst++ = colour[(tmpsrc >> 3) & 0x01];
    1238:	52465349 	subpl	r5, r6, #603979777	; 0x24000001
    123c:	37766f00 	ldrbcc	r6, [r6, -r0, lsl #30]!
    1240:	5f353237 	svcpl	0x00353237
    1244:	6c676165 	stfvse	f6, [r7], #-404	; 0xfffffe6c
    1248:	6d695f65 	stclvs	15, cr5, [r9, #-404]!	; 0xfffffe6c
    124c:	6c665f67 	stclvs	15, cr5, [r6], #-412	; 0xfffffe64
    1250:	47006761 	strmi	r6, [r0, -r1, ror #14]
    1254:	5f4f4950 	svcpl	0x004f4950
    1258:	316e6950 	cmncc	lr, r0, asr r9
        *dst++ = colour[(tmpsrc >> 2) & 0x01];
    125c:	33325f36 	teqcc	r2, #216	; 0xd8
    1260:	524f5000 	subpl	r5, pc, #0
    1264:	654d5f54 	strbvs	r5, [sp, #-3924]	; 0xf54
    1268:	70614d6d 	rsbvc	r4, r1, sp, ror #26
    126c:	45464400 	strbmi	r4, [r6, #-1024]	; 0x400
    1270:	4d490052 	stclmi	0, cr0, [r9, #-328]	; 0xfffffeb8
    1274:	4f4e5f47 	svcmi	0x004e5f47
    1278:	494e4954 	stmdbmi	lr, {r2, r4, r6, r8, fp, lr}^
        *dst++ = colour[(tmpsrc >> 1) & 0x01];
    127c:	764f0054 			; <UNDEFINED> instruction: 0x764f0054
    1280:	35323737 	ldrcc	r3, [r2, #-1847]!	; 0x737
    1284:	6970475f 	ldmdbvs	r0!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, lr}^
    1288:	6e495f6f 	cdpvs	15, 4, cr5, cr9, cr15, {3}
    128c:	62007469 	andvs	r7, r0, #1761607680	; 0x69000000
    1290:	6e657479 	mcrvs	4, 3, r7, cr5, cr9, {3}
    1294:	57464400 	strbpl	r4, [r6, -r0, lsl #8]
    1298:	764f0052 			; <UNDEFINED> instruction: 0x764f0052
    129c:	35323737 	ldrcc	r3, [r2, #-1847]!	; 0x737
        *dst++ = colour[(tmpsrc >> 0) & 0x01];
    12a0:	6e65735f 	mcrvs	3, 3, r7, cr5, cr15, {2}
    12a4:	676d6964 	strbvs	r6, [sp, -r4, ror #18]!
    12a8:	43484300 	movtmi	r4, #33536	; 0x8300
    12ac:	69004746 	stmdbvs	r0, {r1, r2, r6, r8, r9, sl, lr}
    12b0:	6461676d 	strbtvs	r6, [r1], #-1901	; 0x76d
    12b4:	44007264 	strmi	r7, [r0], #-612	; 0x264
    12b8:	535f414d 	cmppl	pc, #1073741843	; 0x40000013
void Ov7725_img_extract(uint8 *dst, uint8 *src, uint32 srclen)
{
    uint8 colour[2] = {255, 0}; //0 和 1 分别对应的颜色
    //注：野火的摄像头 1(or255)表示 白色，0表示 黑色
    uint8 tmpsrc;
    while(srclen --)
    12bc:	6372756f 	cmnvs	r2, #465567744	; 0x1bc00000
    12c0:	64644165 	strbtvs	r4, [r4], #-357	; 0x165
    12c4:	66664f72 	uqsub16vs	r4, r6, r2
    12c8:	00746573 	rsbseq	r6, r4, r3, ror r5
    12cc:	3737766f 	ldrcc	r7, [r7, -pc, ror #12]!
    12d0:	655f3532 	ldrbvs	r3, [pc, #-1330]	; da6 <systemTerm+0x1a>
        *dst++ = colour[(tmpsrc >> 3) & 0x01];
        *dst++ = colour[(tmpsrc >> 2) & 0x01];
        *dst++ = colour[(tmpsrc >> 1) & 0x01];
        *dst++ = colour[(tmpsrc >> 0) & 0x01];
    }
}
    12d4:	656c6761 	strbvs	r6, [ip, #-1889]!	; 0x761
    12d8:	6766635f 			; <UNDEFINED> instruction: 0x6766635f
    12dc:	006d756e 	rsbeq	r7, sp, lr, ror #10
 *  @note       不同的上位机，不同的命令，这里使用 eSmartCameraCar软件，
                如果使用其他上位机，则需要修改代码。
 *  Sample usage:   sendimg(imgbuff, CAMERA_W * CAMERA_H);                    //发送到上位机
 */
void Ov7725_sendimg(uint8 *imgaddr, uint32 imgsize)
{
    12e0:	746e6975 	strbtvc	r6, [lr], #-2421	; 0x975
    12e4:	4f003631 	svcmi	0x00003631
    12e8:	32373776 	eorscc	r3, r7, #30932992	; 0x1d80000
    uint8 cmd[4] = {0, 255, 1, 0 };    //yy_摄像头串口调试 使用的命令
    12ec:	73695f35 	cmnvc	r9, #212	; 0xd4
    12f0:	50470072 	subpl	r0, r7, r2, ror r0
    12f4:	505f4f49 	subspl	r4, pc, r9, asr #30
    12f8:	30326e69 	eorscc	r6, r2, r9, ror #28
    
    LPLD_UART_PutCharArr(TERM_PORT, (char *)cmd, sizeof(cmd));
    12fc:	37764f00 	ldrbcc	r4, [r6, -r0, lsl #30]!
    1300:	5f353237 	svcpl	0x00353237
    1304:	616c6544 	cmnvs	ip, r4, asr #10
    1308:	764f0079 			; <UNDEFINED> instruction: 0x764f0079
    130c:	35323737 	ldrcc	r3, [r2, #-1847]!	; 0x737
    LPLD_UART_PutCharArr(TERM_PORT, (char *)imgaddr, imgsize);
    1310:	6761655f 			; <UNDEFINED> instruction: 0x6761655f
    1314:	645f656c 	ldrbvs	r6, [pc], #-1388	; 131c <Ov7725_sendimg+0x3c>
    1318:	4400616d 	strmi	r6, [r0], #-365	; 0x16d
    131c:	525f414d 	subspl	r4, pc, #1073741843	; 0x40000013
    1320:	47007165 	strmi	r7, [r0, -r5, ror #2]

    //uart_putbuff(FIRE_PORT, cmd, sizeof(cmd));    //先发送命令

    //uart_putbuff(FIRE_PORT, imgaddr, imgsize); //再发送图像
}
    1324:	5f4f4950 	svcpl	0x004f4950
    1328:	326e6950 	rsbcc	r6, lr, #1310720	; 0x140000

//OV7725GPIO口初始化
void Ov7725_Gpio_Init(void)
{
    132c:	50470037 	subpl	r0, r7, r7, lsr r0
    1330:	505f4f49 	subspl	r4, pc, r9, asr #30
    //OV数据口初始化 B0～B7
    OV_PTB_init.GPIO_PTx = PTB;
    1334:	38326e69 	ldmdacc	r2!, {r0, r3, r5, r6, r9, sl, fp, sp, lr}
    1338:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
    133c:	69505f4f 	ldmdbvs	r0, {r0, r1, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
    1340:	0039326e 	eorseq	r3, r9, lr, ror #4
    OV_PTB_init.GPIO_Dir = DIR_INPUT;
    1344:	3737764f 	ldrcc	r7, [r7, -pc, asr #12]!
    1348:	495f3532 	ldmdbmi	pc, {r1, r4, r5, r8, sl, ip, sp}^	; <UNPREDICTABLE>
    134c:	0074696e 	rsbseq	r6, r4, lr, ror #18
    1350:	5f414d44 	svcpl	0x00414d44
    OV_PTB_init.GPIO_Pins = GPIO_Pin0_7;
    1354:	74736544 	ldrbtvc	r6, [r3], #-1348	; 0x544
    1358:	72646441 	rsbvc	r6, r4, #1090519040	; 0x41000000
    135c:	74656700 	strbtvc	r6, [r5], #-1792	; 0x700
    //禁止中断和DMA请求 禁用PULL 输入源下拉
    OV_PTB_init.GPIO_PinControl = IRQC_DIS |
    1360:	64696d5f 	strbtvs	r6, [r9], #-3423	; 0xd5f
    1364:	656e696c 	strbvs	r6, [lr, #-2412]!	; 0x96c
    1368:	67657200 	strbvs	r7, [r5, -r0, lsl #4]!
    136c:	6675425f 			; <UNDEFINED> instruction: 0x6675425f
                                  INPUT_PULL_DIS|
                                  INPUT_PULL_DOWN;
    LPLD_GPIO_Init (OV_PTB_init);
    1370:	65720066 	ldrbvs	r0, [r2, #-102]!	; 0x66
    1374:	00735f67 	rsbseq	r5, r3, r7, ror #30
    1378:	4f495047 	svcmi	0x00495047
    137c:	6e69505f 	mcrvs	0, 3, r5, cr9, cr15, {2}

    //OV场信号接口初始化 A29 
    OV_PTA_init.GPIO_PTx = PTA;
    1380:	50470034 	subpl	r0, r7, r4, lsr r0
    1384:	505f4f49 	subspl	r4, pc, r9, asr #30
    1388:	00376e69 	eorseq	r6, r7, r9, ror #28
    138c:	4f495047 	svcmi	0x00495047
    1390:	6e69505f 	mcrvs	0, 3, r5, cr9, cr15, {2}
    OV_PTA_init.GPIO_Dir = DIR_INPUT;
    1394:	50470038 	subpl	r0, r7, r8, lsr r0
    1398:	505f4f49 	subspl	r4, pc, r9, asr #30
    139c:	00396e69 	eorseq	r6, r9, r9, ror #28
    OV_PTA_init.GPIO_Pins = GPIO_Pin29;
    13a0:	5f414d44 	svcpl	0x00414d44
    13a4:	6f6a614d 	svcvs	0x006a614d
    13a8:	6d6f4372 	stclvs	3, cr4, [pc, #-456]!	; 11e8 <Ov7725_img_extract+0x60>
    13ac:	74656c70 	strbtvc	r6, [r5], #-3184	; 0xc70
    //场中断IO设置，上升沿触发IR，输入上拉，使能滤波
    OV_PTA_init.GPIO_PinControl = IRQC_RI |
    13b0:	746e4965 	strbtvc	r4, [lr], #-2405	; 0x965
    13b4:	62616e45 	rsbvs	r6, r1, #1104	; 0x450
    13b8:	4400656c 	strmi	r6, [r0], #-1388	; 0x56c
    13bc:	435f414d 	cmpmi	pc, #1073741843	; 0x40000013
                                    INPUT_PULL_UP|
                                    INPUT_PF_EN;
    OV_PTA_init.GPIO_Isr = Ov7725_isr;
    13c0:	44007848 	strmi	r7, [r0], #-2120	; 0x848
    13c4:	425f414d 	subsmi	r4, pc, #1073741843	; 0x40000013
    13c8:	6e455459 	mcrvs	4, 2, r5, cr5, cr9, {2}
    13cc:	414d4400 	cmpmi	sp, r0, lsl #8
    13d0:	6a614d5f 	bvs	1854954 <__etext+0x184bcac>
    LPLD_GPIO_Init (OV_PTA_init);
    13d4:	6148726f 	cmpvs	r8, pc, ror #4
    13d8:	6f43666c 	svcvs	0x0043666c
    13dc:	656c706d 	strbvs	r7, [ip, #-109]!	; 0x6d
    13e0:	6e496574 	mcrvs	5, 2, r6, cr9, cr4, {3}

    //OV PCLK信号接口初始化: PTA27-PCLK 
    OV_PTD_init.GPIO_PTx = PTA;
    13e4:	616e4574 	smcvs	58452	; 0xe454
    13e8:	00656c62 	rsbeq	r6, r5, r2, ror #24
    13ec:	4f495047 	svcmi	0x00495047
    13f0:	6e69505f 	mcrvs	0, 3, r5, cr9, cr15, {2}
    13f4:	35315f38 	ldrcc	r5, [r1, #-3896]!	; 0xf38
    OV_PTD_init.GPIO_Pins = GPIO_Pin27;
    13f8:	414d4400 	cmpmi	sp, r0, lsl #8
    13fc:	756f535f 	strbvc	r5, [pc, #-863]!	; 10a5 <Ov7725_eagle_dma+0x91>
    1400:	41656372 	smcmi	22066	; 0x5632
    OV_PTD_init.GPIO_Dir = DIR_INPUT;
    1404:	00726464 	rsbseq	r6, r2, r4, ror #8
    1408:	5f414d44 	svcpl	0x00414d44
    140c:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
    1410:	65707954 	ldrbvs	r7, [r0, #-2388]!	; 0x954
    //PCLK信号，下降沿触发DMA，输入上拉
    OV_PTD_init.GPIO_PinControl = IRQC_DMAFA | INPUT_PULL_UP;
    1414:	00666544 	rsbeq	r6, r6, r4, asr #10
    1418:	656e696c 	strbvs	r6, [lr, #-2412]!	; 0x96c
    141c:	64696d5f 	strbtvs	r6, [r9], #-3423	; 0xd5f
    1420:	37764f00 	ldrbcc	r4, [r6, -r0, lsl #30]!
    LPLD_GPIO_Init (OV_PTD_init);
    1424:	5f353237 	svcpl	0x00353237
    1428:	5f616d44 	svcpl	0x00616d44
    142c:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
    1430:	414d4400 	cmpmi	sp, r0, lsl #8
    1434:	5f58554d 	svcpl	0x0058554d

}
    1438:	4d6d654d 	cfstr64mi	mvdx6, [sp, #-308]!	; 0xfffffecc
 
//OV7725 DMA初始化 
void Ov7725_Dma_Init (void)
{
    143c:	63007061 	movwvs	r7, #97	; 0x61
    1440:	756f6c6f 	strbvc	r6, [pc, #-3183]!	; 7d9 <__vector_table+0x7d9>
    OV_dma_init.DMA_CHx = DMA_CH0;
    1444:	4d440072 	stclmi	0, cr0, [r4, #-456]	; 0xfffffe38
    1448:	614c5f41 	cmpvs	ip, r1, asr #30
    144c:	65447473 	strbvs	r7, [r4, #-1139]	; 0x473
    OV_dma_init.DMA_Req = PORTA_DMAREQ;
    1450:	64417473 	strbvs	r7, [r1], #-1139	; 0x473
    1454:	64417264 	strbvs	r7, [r1], #-612	; 0x264
    1458:	5047006a 	subpl	r0, r7, sl, rrx
    145c:	00524843 	subseq	r4, r2, r3, asr #16
    OV_dma_init.DMA_MajorLoopCnt = PHOTO_SIZE / 8;
    1460:	4f495047 	svcmi	0x00495047
    1464:	6e69505f 	mcrvs	0, 3, r5, cr9, cr15, {2}
    1468:	00375f30 	eorseq	r5, r7, r0, lsr pc
    OV_dma_init.DMA_MinorByteCnt = 1;
    146c:	3737764f 	ldrcc	r7, [r7, -pc, asr #12]!
    1470:	655f3532 	ldrbvs	r3, [pc, #-1330]	; f46 <Ov7725_Init+0x176>
    1474:	656c6761 	strbvs	r6, [ip, #-1889]!	; 0x761
    1478:	7973765f 	ldmdbvc	r3!, {r0, r1, r2, r3, r4, r6, r9, sl, ip, sp, lr}^
    
    OV_dma_init.DMA_SourceAddr = (uint32)(&GPIOB_PDIR);
    147c:	4f00636e 	svcmi	0x0000636e
    1480:	54505f56 	ldrbpl	r5, [r0], #-3926	; 0xf56
    1484:	6e695f42 	cdpvs	15, 6, cr5, cr9, cr2, {2}
    1488:	4f007469 	svcmi	0x00007469
    OV_dma_init.DMA_DestAddr = (uint32)img;
    148c:	6d645f56 	stclvs	15, cr5, [r4, #-344]!	; 0xfffffea8
    1490:	6e695f61 	cdpvs	15, 6, cr5, cr9, cr1, {3}
    1494:	47007469 	strmi	r7, [r0, -r9, ror #8]
    1498:	5f4f4950 	svcpl	0x004f4950
    149c:	306e6950 	rsbcc	r6, lr, r0, asr r9
    OV_dma_init.DMA_DestAddrOffset = 1;
    14a0:	69704700 	ldmdbvs	r0!, {r8, r9, sl, lr}^
    14a4:	6e69506f 	cdpvs	0, 6, cr5, cr9, cr15, {3}
    14a8:	756e4573 	strbvc	r4, [lr, #-1395]!	; 0x573
    OV_dma_init.DMA_Isr = Ov7725_eagle_dma;
    14ac:	5047006d 	subpl	r0, r7, sp, rrx
    14b0:	505f4f49 	subspl	r4, pc, r9, asr #30
    14b4:	30316e69 	eorscc	r6, r1, r9, ror #28
    14b8:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
    14bc:	69505f4f 	ldmdbvs	r0, {r0, r1, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
    LPLD_DMA_Init (OV_dma_init);
    14c0:	0031316e 	eorseq	r3, r1, lr, ror #2
    14c4:	4f495047 	svcmi	0x00495047
    14c8:	6e69505f 	mcrvs	0, 3, r5, cr9, cr15, {2}
    14cc:	47003231 	smladxmi	r0, r1, r2, r3
    14d0:	5f4f4950 	svcpl	0x004f4950
    14d4:	316e6950 	cmncc	lr, r0, asr r9
    14d8:	50470033 	subpl	r0, r7, r3, lsr r0
    14dc:	505f4f49 	subspl	r4, pc, r9, asr #30

    LPLD_DMA_DisableReq(DMA_CH0);
    14e0:	34316e69 	ldrtcc	r6, [r1], #-3689	; 0xe69
    14e4:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
    14e8:	69505f4f 	ldmdbvs	r0, {r0, r1, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
    14ec:	0035316e 	eorseq	r3, r5, lr, ror #2
    14f0:	4f495047 	svcmi	0x00495047
    14f4:	6e69505f 	mcrvs	0, 3, r5, cr9, cr15, {2}
    //disable_irq (INT_PORTA - 16);
    LPLD_GPIO_EnableIrq (OV_PTA_init);
    14f8:	47003631 	smladxmi	r0, r1, r6, r3
    14fc:	5f4f4950 	svcpl	0x004f4950
    1500:	316e6950 	cmncc	lr, r0, asr r9
    1504:	50470037 	subpl	r0, r7, r7, lsr r0
    1508:	505f4f49 	subspl	r4, pc, r9, asr #30
    DMA0->INT |= 0x1u <<0;
    150c:	38316e69 	ldmdacc	r1!, {r0, r3, r5, r6, r9, sl, fp, sp, lr}
    1510:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
    1514:	69505f4f 	ldmdbvs	r0, {r0, r1, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
    1518:	0039316e 	eorseq	r3, r9, lr, ror #2
    151c:	3737766f 	ldrcc	r7, [r7, -pc, ror #12]!
    1520:	655f3532 	ldrbvs	r3, [pc, #-1330]	; ff6 <Ov7725_Delay+0x26>
    //允许DMA通道传输完成中断
    //enable_irq (DMA_CH0);
    LPLD_DMA_EnableIrq (OV_dma_init);
    1524:	656c6761 	strbvs	r6, [ip, #-1889]!	; 0x761
    1528:	6765725f 			; <UNDEFINED> instruction: 0x6765725f
    152c:	414d4400 	cmpmi	sp, r0, lsl #8
    1530:	7273495f 	rsbsvc	r4, r3, #1556480	; 0x17c000
    1534:	474d4900 	strbmi	r4, [sp, -r0, lsl #18]
    1538:	4154535f 	cmpmi	r4, pc, asr r3
    153c:	44005452 	strmi	r5, [r0], #-1106	; 0x452
    1540:	554d414d 	strbpl	r4, [sp, #-333]	; 0x14d
    //使能通道x的DMA请求
    //LPLD_DMA_EnableReq(DMA_CH0);
}
    1544:	654d5f58 	strbvs	r5, [sp, #-3928]	; 0xf58
    1548:	70614d6d 	rsbvc	r4, r1, sp, ror #26

//ov7725中断
void Ov7725_isr (void)
{
    154c:	00727450 	rsbseq	r7, r2, r0, asr r4
    1550:	3737764f 	ldrcc	r7, [r7, -pc, asr #12]!
    uint8 n = 0;
    1554:	655f3532 	ldrbvs	r3, [pc, #-1330]	; 102a <Ov7725_eagle_dma+0x16>
    while (!PORTA_ISFR);
    1558:	656c6761 	strbvs	r6, [ip, #-1889]!	; 0x761
    155c:	7465675f 	strbtvc	r6, [r5], #-1887	; 0x75f
    1560:	676d695f 			; <UNDEFINED> instruction: 0x676d695f
    1564:	706d7400 	rsbvc	r7, sp, r0, lsl #8
    1568:	00637273 	rsbeq	r7, r3, r3, ror r2
    uint32 flag = (PORTA->ISFR);
    156c:	5f414d44 	svcpl	0x00414d44
    1570:	6f747541 	svcvs	0x00747541
    1574:	61736944 	cmnvs	r3, r4, asr #18
    (PORTA -> ISFR) = ~0;
    1578:	52656c62 	rsbpl	r6, r5, #25088	; 0x6200
    157c:	49007165 	stmdbmi	r0, {r0, r2, r5, r6, r8, ip, sp, lr}
    1580:	465f474d 	ldrbmi	r4, [pc], -sp, asr #14
    1584:	004c4941 	subeq	r4, ip, r1, asr #18
   
    n = 29;
    1588:	5f414d44 	svcpl	0x00414d44
    158c:	74736544 	ldrbtvc	r6, [r3], #-1348	; 0x544
    //printf ("flag = %x\n", flag);
    if (flag & (1<<n))
    1590:	72646441 	rsbvc	r6, r4, #1090519040	; 0x41000000
    1594:	7366664f 	cmnvc	r6, #82837504	; 0x4f00000
    1598:	47007465 	strmi	r7, [r0, -r5, ror #8]
    159c:	5f4f4950 	svcpl	0x004f4950
    15a0:	326e6950 	rsbcc	r6, lr, #1310720	; 0x140000
    {
        //场中断开始 
        //set 場中断
        ov7725_eagle_img_flag = IMG_START;
    15a4:	50470031 	subpl	r0, r7, r1, lsr r0
    15a8:	505f4f49 	subspl	r4, pc, r9, asr #30
    15ac:	32326e69 	eorscc	r6, r2, #1680	; 0x690
        //关闭PORTA中断
        disable_irq (INT_PORTA - 16);
    15b0:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
    15b4:	69505f4f 	ldmdbvs	r0, {r0, r1, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
        //LPLD_GPIO_DisableIrq(OV_PTA_init);
        //enable_irq (DMA_CH0 + INT_DMA0_DMA16 - 16);
        //重新装载DMA目标地址
        //DMA_DADDR(DMA_CH0) = (uint32)img;
        //开启DMA通道
        DMA_EN(DMA_CH0);
    15b8:	0033326e 	eorseq	r3, r3, lr, ror #4
    15bc:	4f495047 	svcmi	0x00495047
    15c0:	6e69505f 	mcrvs	0, 3, r5, cr9, cr15, {2}
    15c4:	47003432 	smladxmi	r0, r2, r4, r3
    15c8:	5f4f4950 	svcpl	0x004f4950
    15cc:	326e6950 	rsbcc	r6, lr, #1310720	; 0x140000
        //LPLD_DMA_EnableIrq(OV_dma_init);
    }
}
    15d0:	50470035 	subpl	r0, r7, r5, lsr r0
    15d4:	505f4f49 	subspl	r4, pc, r9, asr #30

//移植野火的函数
void dma_portx2buff_init(uint8 CHn, void *SADDR, void *DADDR, uint8 dma_req, DMA_BYTEn byten, uint32 count, uint32 cfg)
{
    15d8:	36326e69 	ldrtcc	r6, [r2], -r9, ror #28
    15dc:	474d4900 	strbmi	r4, [sp, -r0, lsl #18]
    15e0:	4e49465f 	mcrmi	6, 2, r4, cr9, cr15, {2}
    15e4:	00485349 	subeq	r5, r8, r9, asr #6
    uint8 BYTEs = (byten == DMA_BYTE1 ? 1 : (byten == DMA_BYTE2 ? 2 : (byten == DMA_BYTE4 ? 4 : 16)));
    15e8:	4f495047 	svcmi	0x00495047
    15ec:	6e69505f 	mcrvs	0, 3, r5, cr9, cr15, {2}
    15f0:	47003033 	smladxmi	r0, r3, r0, r3
    15f4:	5f4f4950 	svcpl	0x004f4950
    15f8:	336e6950 	cmncc	lr, #1310720	; 0x140000
    15fc:	4d440031 	stclmi	0, cr0, [r4, #-196]	; 0xffffff3c
    1600:	614c5f41 	cmpvs	ip, r1, asr #30
    1604:	6f537473 	svcvs	0x00537473
    1608:	65637275 	strbvs	r7, [r3, #-629]!	; 0x275
    160c:	72646441 	rsbvc	r6, r4, #1090519040	; 0x41000000
    1610:	006a6441 	rsbeq	r6, sl, r1, asr #8
    1614:	5f414d44 	svcpl	0x00414d44
    
    SIM_SCGC7 |= SIM_SCGC7_DMA_MASK;
    1618:	74736544 	ldrbtvc	r6, [r3], #-1348	; 0x544
    161c:	61746144 	cmnvs	r4, r4, asr #2
    1620:	657a6953 	ldrbvs	r6, [sl, #-2387]!	; 0x953
    1624:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
    1628:	43535f44 	cmpmi	r3, #272	; 0x110
    162c:	575f4243 	ldrbpl	r4, [pc, -r3, asr #4]
    1630:	65746972 	ldrbvs	r6, [r4, #-2418]!	; 0x972
    1634:	00676552 	rsbeq	r6, r7, r2, asr r5
    SIM_SCGC6 |= SIM_SCGC6_DMAMUX0_MASK;
    1638:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    163c:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
    1640:	77682f62 	strbvc	r2, [r8, -r2, ror #30]!
    1644:	7665642f 	strbtvc	r6, [r5], -pc, lsr #8
    1648:	6363735f 	cmnvs	r3, #2080374785	; 0x7c000001
    164c:	00632e62 	rsbeq	r2, r3, r2, ror #28
    1650:	444c504c 	strbmi	r5, [ip], #-76	; 0x4c
    1654:	4343535f 	movtmi	r5, #13151	; 0x335f
    1658:	65525f42 	ldrbvs	r5, [r2, #-3906]	; 0xf42
    165c:	76696563 	strbtvc	r6, [r9], -r3, ror #10

    DMA_SADDR(CHn) = (uint32) SADDR;
    1660:	74794265 	ldrbtvc	r4, [r9], #-613	; 0x265
    1664:	504c0065 	subpl	r0, ip, r5, rrx
    1668:	535f444c 	cmppl	pc, #1275068416	; 0x4c000000
    166c:	5f424343 	svcpl	0x00424343
    1670:	72617453 	rsbvc	r7, r1, #1392508928	; 0x53000000
    1674:	504c0074 	subpl	r0, ip, r4, ror r0
    DMA_DADDR(CHn) = (uint32) DADDR;
    1678:	535f444c 	cmppl	pc, #1275068416	; 0x4c000000
    167c:	5f424343 	svcpl	0x00424343
    1680:	616c6544 	cmnvs	ip, r4, asr #10
    1684:	504c0079 	subpl	r0, ip, r9, ror r0
    1688:	535f444c 	cmppl	pc, #1275068416	; 0x4c000000
    168c:	5f424343 	svcpl	0x00424343
    1690:	74696157 	strbtvc	r6, [r9], #-343	; 0x157
    DMA_SOFF(CHn) = 0x00u;
    1694:	006b6341 	rsbeq	r6, fp, r1, asr #6
    1698:	676e656c 	strbvs	r6, [lr, -ip, ror #10]!
    169c:	4c006874 	stcmi	8, cr6, [r0], {116}	; 0x74
    16a0:	5f444c50 	svcpl	0x00444c50
    16a4:	42434353 	submi	r4, r3, #1275068417	; 0x4c000001
    16a8:	696e495f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, lr}^
    16ac:	65720074 	ldrbvs	r0, [r2, #-116]!	; 0x74
    DMA_DOFF(CHn) = BYTEs;
    16b0:	64615f67 	strbtvs	r5, [r1], #-3943	; 0xf67
    16b4:	4c007264 	sfmmi	f7, 4, [r0], {100}	; 0x64
    16b8:	5f444c50 	svcpl	0x00444c50
    16bc:	42434353 	submi	r4, r3, #1275068417	; 0x4c000001
    16c0:	6b63415f 	blvs	18d1c44 <__etext+0x18c8f9c>
    16c4:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
    16c8:	43535f44 	cmpmi	r3, #272	; 0x110
    DMA_ATTR(CHn) = (0
    16cc:	4e5f4243 	cdpmi	2, 5, cr4, cr15, cr3, {2}
    16d0:	6b63416f 	blvs	18d1c94 <__etext+0x18c8fec>
    16d4:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
                     |DMA_ATTR_SMOD(0x0)
                     |DMA_ATTR_SSIZE(byten)
    16d8:	43535f44 	cmpmi	r3, #272	; 0x110
    16dc:	535f4243 	cmppl	pc, #805306372	; 0x30000004
    16e0:	42646e65 	rsbmi	r6, r4, #1616	; 0x650

    DMA_SADDR(CHn) = (uint32) SADDR;
    DMA_DADDR(CHn) = (uint32) DADDR;
    DMA_SOFF(CHn) = 0x00u;
    DMA_DOFF(CHn) = BYTEs;
    DMA_ATTR(CHn) = (0
    16e4:	00657479 	rsbeq	r7, r5, r9, ror r4
    16e8:	444c504c 	strbmi	r5, [ip], #-76	; 0x4c
    16ec:	4343535f 	movtmi	r5, #13151	; 0x335f
    16f0:	65525f42 	ldrbvs	r5, [r2, #-3906]	; 0xf42
    16f4:	65526461 	ldrbvs	r6, [r2, #-1121]	; 0x461
    16f8:	504c0067 	subpl	r0, ip, r7, rrx
    16fc:	535f444c 	cmppl	pc, #1275068416	; 0x4c000000
    1700:	5f424343 	svcpl	0x00424343
                     |DMA_ATTR_SMOD(0x0)
                     |DMA_ATTR_SSIZE(byten)
                     |DMA_ATTR_DMOD(0x0)
                     |DMA_ATTR_DSIZE(byten)
                    );
    DMA_CITER_ELINKNO(CHn) = DMA_CITER_ELINKNO_CITER(count);
    1704:	706f7453 	rsbvc	r7, pc, r3, asr r4	; <UNPREDICTABLE>
    1708:	43444100 	movtmi	r4, #16640	; 0x4100
    170c:	696e495f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, lr}^
    1710:	70795474 	rsbsvc	r5, r9, r4, ror r4
    1714:	66654465 	strbtvs	r4, [r5], -r5, ror #8
    1718:	43444100 	movtmi	r4, #16640	; 0x4100
    171c:	7273495f 	rsbsvc	r4, r3, #1556480	; 0x17c000
    1720:	43444100 	movtmi	r4, #16640	; 0x4100
    1724:	6167505f 	qdsubvs	r5, pc, r7	; <UNPREDICTABLE>
    1728:	6e696147 	powvsem	f6, f1, f7
    DMA_BITER_ELINKNO(CHn) = DMA_BITER_ELINKNO_BITER(count);
    172c:	44414400 	strbmi	r4, [r1], #-1024	; 0x400
    1730:	41440030 	cmpmi	r4, r0, lsr r0
    1734:	44003144 	strmi	r3, [r0], #-324	; 0x144
    1738:	00324441 	eorseq	r4, r2, r1, asr #8
    173c:	33444144 	movtcc	r4, #16708	; 0x4144
    1740:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
    1744:	44415f44 	strbmi	r5, [r1], #-3908	; 0xf44
    1748:	69445f43 	stmdbvs	r4, {r0, r1, r6, r8, r9, sl, fp, ip, lr}^
    174c:	6c626173 	stfvse	f6, [r2], #-460	; 0xfffffe34
    1750:	71724965 	cmnvc	r2, r5, ror #18

    DMA_CR &= ~DMA_CR_EMLM_MASK;
    1754:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
    1758:	44415f44 	strbmi	r5, [r1], #-3908	; 0xf44
    175c:	6e495f43 	cdpvs	15, 4, cr5, cr9, cr3, {2}
    1760:	4c007469 	cfstrsmi	mvf7, [r0], {105}	; 0x69
    1764:	5f444c50 	svcpl	0x00444c50
    1768:	5f434441 	svcpl	0x00434441

    DMA_NBYTES_MLNO(CHn) = DMA_NBYTES_MLNO_NBYTES(BYTEs);
    176c:	62616e45 	rsbvs	r6, r1, #1104	; 0x450
    1770:	6f43656c 	svcvs	0x0043656c
    1774:	7265766e 	rsbvc	r7, r5, #115343360	; 0x6e00000
    1778:	6e6f6973 	mcrvs	9, 3, r6, cr15, cr3, {3}
    177c:	69746c00 	ldmdbvs	r4!, {sl, fp, sp, lr}^
    1780:	6900656d 	stmdbvs	r0, {r0, r2, r3, r5, r6, r8, sl, sp, lr}
    1784:	665f7273 			; <UNDEFINED> instruction: 0x665f7273

    DMA_SLAST(CHn) = 0;
    1788:	00636e75 	rsbeq	r6, r3, r5, ror lr
    178c:	5f434441 	svcpl	0x00434441
    1790:	76417748 	strbvc	r7, [r1], -r8, asr #14
    1794:	6c655367 	stclvs	3, cr5, [r5], #-412	; 0xfffffe64
    1798:	43444100 	movtmi	r4, #16640	; 0x4100
    179c:	78754d5f 	ldmdavc	r5!, {r0, r1, r2, r3, r4, r6, r8, sl, fp, lr}^
    17a0:	006c6553 	rsbeq	r6, ip, r3, asr r5
    17a4:	444c504c 	strbmi	r5, [ip], #-76	; 0x4c
    DMA_DLAST_SGA(CHn) = (uint32)((cfg & DADDR_KEEPON) == 0 ? (-count) : 0);
    17a8:	4344415f 	movtmi	r4, #16735	; 0x415f
    17ac:	6c61435f 	stclvs	3, cr4, [r1], #-380	; 0xfffffe84
    17b0:	43444100 	movtmi	r4, #16640	; 0x4100
    17b4:	6364415f 	cmnvs	r4, #-1073741801	; 0xc0000017
    17b8:	44410078 	strbmi	r0, [r1], #-120	; 0x78
    17bc:	41003031 	tstmi	r0, r1, lsr r0
    17c0:	00313144 	eorseq	r3, r1, r4, asr #2
    17c4:	32314441 	eorscc	r4, r1, #1090519040	; 0x41000000
    17c8:	31444100 	mrscc	r4, (UNDEF: 84)
    17cc:	44410033 	strbmi	r0, [r1], #-51	; 0x33
    17d0:	41003431 	tstmi	r0, r1, lsr r4
    17d4:	00353144 	eorseq	r3, r5, r4, asr #2
    DMA_CSR(CHn) = (0
    17d8:	36314441 	ldrtcc	r4, [r1], -r1, asr #8
    17dc:	31444100 	mrscc	r4, (UNDEF: 84)
    17e0:	44410037 	strbmi	r0, [r1], #-55	; 0x37
    17e4:	41003831 	tstmi	r0, r1, lsr r8
    17e8:	00393144 	eorseq	r3, r9, r4, asr #2
    17ec:	444c504c 	strbmi	r5, [ip], #-76	; 0x4c
    17f0:	4344415f 	movtmi	r4, #16735	; 0x415f
                    |DMA_CSR_BWC(3)
                    |DMA_CSR_DREQ_MASK
                    |DMA_CSR_INTMAJOR_MASK
                   );

    DMAMUX_CHCFG_REG(DMAMUX0_BASE_PTR, CHn) = (0                
    17f4:	7465475f 	strbtvc	r4, [r5], #-1887	; 0x75f
    17f8:	75736552 	ldrbvc	r6, [r3, #-1362]!	; 0x552
    17fc:	4100746c 	tstmi	r0, ip, ror #8
    1800:	00303244 	eorseq	r3, r0, r4, asr #4
    1804:	31324441 	teqcc	r2, r1, asr #8
    1808:	32444100 	subcc	r4, r4, #0
    180c:	44410032 	strbmi	r0, [r1], #-50	; 0x32
    |DMAMUX_CHCFG_ENBL_MASK
    |DMAMUX_CHCFG_SOURCE(dma_req));
    DMA_DIS(CHn);
    1810:	41003332 	tstmi	r0, r2, lsr r3
    1814:	00353244 	eorseq	r3, r5, r4, asr #4
    1818:	36324441 	ldrtcc	r4, [r2], -r1, asr #8
    181c:	32444100 	subcc	r4, r4, #0
    1820:	44410037 	strbmi	r0, [r1], #-55	; 0x37
    1824:	41003832 	tstmi	r0, r2, lsr r8
    1828:	00393244 	eorseq	r3, r9, r4, asr #4
    182c:	5f434441 	svcpl	0x00434441
    1830:	5f525349 	svcpl	0x00525349
    DMA_IRQ_CLEAN(CHn);
    1834:	4c4c4143 	stfmie	f4, [ip], {67}	; 0x43
    1838:	4b434142 	blmi	10d1d48 <__etext+0x10c90a0>
    183c:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
    1840:	44415f44 	strbmi	r5, [r1], #-3908	; 0xf44
    1844:	65445f43 	strbvs	r5, [r4, #-3907]	; 0xf43
    1848:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xe69
    184c:	33444100 	movtcc	r4, #16640	; 0x4100
    1850:	44410030 	strbmi	r0, [r1], #-48	; 0x30
}
    1854:	41003133 	tstmi	r0, r3, lsr r1
    1858:	5f304344 	svcpl	0x00304344


//提取中线
void get_midline(uint8 *img, uint8 h, uint8 w)
{
    185c:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
    1860:	6c646e61 	stclvs	14, cr6, [r4], #-388	; 0xfffffe7c
    1864:	43007265 	movwmi	r7, #613	; 0x265
    1868:	00304d4c 	eorseq	r4, r0, ip, asr #26
    int16 p = 0, i = 0, line_mid = 39;
    186c:	314d4c43 	cmpcc	sp, r3, asr #24
    1870:	4d4c4300 	stclmi	3, cr4, [ip, #-0]
    1874:	4c430032 	mcrrmi	0, 3, r0, r3, cr2
    1878:	4300334d 	movwmi	r3, #845	; 0x34d
    187c:	00344d4c 	eorseq	r4, r4, ip, asr #26
    int8 side_left = 0, side_right = 79;
    1880:	5f636461 	svcpl	0x00636461
    1884:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xe69
    1888:	7274735f 	rsbsvc	r7, r4, #2080374785	; 0x7c000001

    if (img[(h-1)*w + line_mid] == 0xff)
    188c:	75746375 	ldrbvc	r6, [r4, #-885]!	; 0x375
    1890:	41006572 	tstmi	r0, r2, ror r5
    1894:	435f4344 	cmpmi	pc, #268435457	; 0x10000001
    1898:	6e456c61 	cdpvs	12, 4, cr6, cr5, cr1, {3}
    189c:	656c6261 	strbvs	r6, [ip, #-609]!	; 0x261
    18a0:	4d4c4300 	stclmi	3, cr4, [ip, #-0]
    18a4:	4c430044 	mcrrmi	0, 4, r0, r3, cr4
    {
        for (i = h - 1; i >= 0; i --)
    18a8:	4100534d 	tstmi	r0, sp, asr #6
    18ac:	425f4344 	subsmi	r4, pc, #268435457	; 0x10000001
    18b0:	6f4d7469 	svcvs	0x004d7469
    18b4:	41006564 	tstmi	r0, r4, ror #10
        {
            for (p = line_mid - 1; p > 0; p --)
    18b8:	68436364 	stmdavs	r3, {r2, r5, r6, r8, r9, sp, lr}^
    18bc:	756e456e 	strbvc	r4, [lr, #-1390]!	; 0x56e
    18c0:	79545f6d 	ldmdbvc	r4, {r0, r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
            {
                if (img[i * w + p] == 0)
    18c4:	6d006570 	cfstr32vs	mvfx6, [r0, #-448]	; 0xfffffe40
    18c8:	62617875 	rsbvs	r7, r1, #7667712	; 0x750000
    18cc:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
    18d0:	44415f44 	strbmi	r5, [r1], #-3908	; 0xf44
    18d4:	6e455f43 	cdpvs	15, 4, cr5, cr5, cr3, {2}
    18d8:	656c6261 	strbvs	r6, [ip, #-609]!	; 0x261
                    if ((img[i * w + p - 1] == 0) 
    18dc:	00717249 	rsbseq	r7, r1, r9, asr #4
    18e0:	43636441 	cmnmi	r3, #1090519040	; 0x41000000
    18e4:	6e456e68 	cdpvs	14, 4, cr6, cr5, cr8, {3}
    18e8:	4c006d75 	stcmi	13, cr6, [r0], {117}	; 0x75
    18ec:	5f444c50 	svcpl	0x00444c50
    18f0:	5f434441 	svcpl	0x00434441
    18f4:	5f6e6843 	svcpl	0x006e6843
    18f8:	62616e45 	rsbvs	r6, r1, #1104	; 0x450
                            && (line_mid-p-1>= 0))
    18fc:	4300656c 	movwmi	r6, #1388	; 0x56c
    1900:	0030504c 	eorseq	r5, r0, ip, asr #32
    1904:	31504c43 	cmpcc	r0, r3, asr #24
    1908:	504c4300 	subpl	r4, ip, r0, lsl #6
                    {
                        side_left = p;
    190c:	4c430032 	mcrrmi	0, 3, r0, r3, cr2
                        p = p - 2;
    1910:	43003350 	movwmi	r3, #848	; 0x350
    1914:	0034504c 	eorseq	r5, r4, ip, asr #32
    1918:	44504c43 	ldrbmi	r4, [r0], #-3139	; 0xc43
                        for (; p >= 0; p --)
                            img[i * w + p] = 0;
    191c:	504c4300 	subpl	r4, ip, r0, lsl #6
    1920:	69640053 	stmdbvs	r4!, {r0, r1, r4, r6}^
    1924:	41006666 	tstmi	r0, r6, ror #12
    1928:	535f4344 	cmppl	pc, #268435457	; 0x10000001
    192c:	6c706d61 	ldclvs	13, cr6, [r0], #-388	; 0xfffffe7c
    1930:	6d695465 	cfstrdvs	mvd5, [r9, #-404]!	; 0xfffffe6c
    1934:	67664365 	strbvs	r4, [r6, -r5, ror #6]!
                    if ((img[i * w + p - 1] == 0) 
                            && (line_mid-p-1>= 0))
                    {
                        side_left = p;
                        p = p - 2;
                        for (; p >= 0; p --)
    1938:	43444100 	movtmi	r4, #16640	; 0x4100
    193c:	6e6f4c5f 	mcrvs	12, 3, r4, cr15, cr15, {2}
    1940:	6d615367 	stclvs	3, cr5, [r1, #-412]!	; 0xfffffe64
    1944:	54656c70 	strbtpl	r6, [r5], #-3184	; 0xc70

    if (img[(h-1)*w + line_mid] == 0xff)
    {
        for (i = h - 1; i >= 0; i --)
        {
            for (p = line_mid - 1; p > 0; p --)
    1948:	53656d69 	cmnpl	r5, #6720	; 0x1a40
    194c:	41006c65 	tstmi	r0, r5, ror #24
    1950:	4d5f4344 	ldclmi	3, cr4, [pc, #-272]	; 1848 <dma_portx2buff_init+0x270>
    1954:	614d6d65 	cmpvs	sp, r5, ror #26
                        p = p - 2;
                        for (; p >= 0; p --)
                            img[i * w + p] = 0;
                    }
            }
            for (p = line_mid + 1; p < w -1; p ++)
    1958:	72745070 	rsbsvc	r5, r4, #112	; 0x70
    195c:	43444100 	movtmi	r4, #16640	; 0x4100
    1960:	52495f31 	subpl	r5, r9, #196	; 0xc4
            {
                if (img[i * w + p] == 0)
    1964:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
    1968:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
    196c:	43444100 	movtmi	r4, #16640	; 0x4100
    1970:	6669445f 			; <UNDEFINED> instruction: 0x6669445f
    1974:	646f4d66 	strbtvs	r4, [pc], #-3430	; 197c <get_midline+0x120>
    1978:	44410065 	strbmi	r0, [r1], #-101	; 0x65
                {
                    if ((img[i * w + p + 1] == 0)&&(p+1<w))
    197c:	77485f43 	strbvc	r5, [r8, -r3, asr #30]
    1980:	43677254 	cmnmi	r7, #1073741829	; 0x40000005
    1984:	41006766 	tstmi	r0, r6, ror #14
    1988:	4d5f4344 	ldclmi	3, cr4, [pc, #-272]	; 1880 <get_midline+0x24>
    198c:	614d6d65 	cmpvs	sp, r5, ror #26
    1990:	64610070 	strbtvs	r0, [r1], #-112	; 0x70
    1994:	4c007863 	stcmi	8, cr7, [r0], {99}	; 0x63
    1998:	5f444c50 	svcpl	0x00444c50
    199c:	5f434441 	svcpl	0x00434441
    19a0:	00746547 	rsbseq	r6, r4, r7, asr #10
    19a4:	5f6c6163 	svcpl	0x006c6163
                    {
                        side_right = p;
    19a8:	00726176 	rsbseq	r6, r2, r6, ror r1
                        p = p + 2;
    19ac:	444c504c 	strbmi	r5, [ip], #-76	; 0x4c
    19b0:	4344415f 	movtmi	r4, #16735	; 0x415f
    19b4:	7465475f 	strbtvc	r4, [r5], #-1887	; 0x75f
                        for (; p < w; p ++)
                            img[i * w + p] = 0;
    19b8:	6e314353 	mrcvs	3, 1, r4, cr1, cr3, {2}
    19bc:	4f434f43 	svcmi	0x00434f43
    19c0:	43444100 	movtmi	r4, #16640	; 0x4100
    19c4:	5253495f 	subspl	r4, r3, #1556480	; 0x17c000
    19c8:	43444100 	movtmi	r4, #16640	; 0x4100
    19cc:	616d445f 	cmnvs	sp, pc, asr r4
    19d0:	62616e45 	rsbvs	r6, r1, #1104	; 0x450
                {
                    if ((img[i * w + p + 1] == 0)&&(p+1<w))
                    {
                        side_right = p;
                        p = p + 2;
                        for (; p < w; p ++)
    19d4:	6800656c 	stmdavs	r0, {r2, r3, r5, r6, r8, sl, sp, lr}
    19d8:	67727477 			; <UNDEFINED> instruction: 0x67727477
    19dc:	32444100 	subcc	r4, r4, #0
    19e0:	2e2e0034 	mcrcs	0, 1, r0, cr14, cr4, {1}
                        p = p - 2;
                        for (; p >= 0; p --)
                            img[i * w + p] = 0;
                    }
            }
            for (p = line_mid + 1; p < w -1; p ++)
    19e4:	2f2e2e2f 	svccs	0x002e2e2f
    19e8:	2f62696c 	svccs	0x0062696c
    19ec:	682f7768 	stmdavs	pc!, {r3, r5, r6, r8, r9, sl, ip, sp, lr}	; <UNPREDICTABLE>
    19f0:	64615f77 	strbtvs	r5, [r1], #-3959	; 0xf77
    19f4:	00632e63 	rsbeq	r2, r3, r3, ror #28
    19f8:	31414d44 	cmpcc	r1, r4, asr #26
                        for (; p < w; p ++)
                            img[i * w + p] = 0;
                    }
                }
            }
            line_mid = (side_left + side_right) / 2;
    19fc:	52495f30 	subpl	r5, r9, #192	; 0xc0
    1a00:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
    1a04:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
    1a08:	74736400 	ldrbtvc	r6, [r3], #-1024	; 0x400
    1a0c:	6464615f 	strbtvs	r6, [r4], #-351	; 0x15f
            img[i * w + line_mid] = 0;
    1a10:	66666f72 	uqsub16vs	r6, r6, r2
    1a14:	00746573 	rsbseq	r6, r4, r3, ror r5
    1a18:	6f747561 	svcvs	0x00747561
    1a1c:	7369645f 	cmnvc	r9, #1593835520	; 0x5f000000
    1a20:	656c6261 	strbvs	r6, [ip, #-609]!	; 0x261
    1a24:	414d4400 	cmpmi	sp, r0, lsl #8
    1a28:	495f3331 	ldmdbmi	pc, {r0, r4, r5, r8, r9, ip, sp}^	; <UNPREDICTABLE>
    int16 p = 0, i = 0, line_mid = 39;
    int8 side_left = 0, side_right = 79;

    if (img[(h-1)*w + line_mid] == 0xff)
    {
        for (i = h - 1; i >= 0; i --)
    1a2c:	61485152 	cmpvs	r8, r2, asr r1
    1a30:	656c646e 	strbvs	r6, [ip, #-1134]!	; 0x46e
    1a34:	4d440072 	stclmi	0, cr0, [r4, #-456]	; 0xfffffe38
    1a38:	495f3041 	ldmdbmi	pc, {r0, r6, ip, sp}^	; <UNPREDICTABLE>
            }
            line_mid = (side_left + side_right) / 2;
            img[i * w + line_mid] = 0;
        }
    }
}
    1a3c:	61485152 	cmpvs	r8, r2, asr r1
    1a40:	656c646e 	strbvs	r6, [ip, #-1134]!	; 0x46e
    1a44:	4d440072 	stclmi	0, cr0, [r4, #-456]	; 0xfffffe38
  ptb.GPIO_PinControl = NULL;
  LPLD_GPIO_Init(ptb);
}*/

void LPLD_SCCB_Init(void)
{
    1a48:	5f343141 	svcpl	0x00343141
    1a4c:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
  GPIO_InitTypeDef ptb;
  /********û޸ֵ ʼ***********/
  ptb.GPIO_PTx = PTA;
    1a50:	6c646e61 	stclvs	14, cr6, [r4], #-388	; 0xfffffe7c
    1a54:	44007265 	strmi	r7, [r0], #-613	; 0x265
  ptb.GPIO_Pins = GPIO_Pin25 | GPIO_Pin26;
    1a58:	5f36414d 	svcpl	0x0036414d
    1a5c:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
  /********û޸ֵ ***********/
  ptb.GPIO_Dir = DIR_OUTPUT;
    1a60:	6c646e61 	stclvs	14, cr6, [r4], #-388	; 0xfffffe7c
  ptb.GPIO_Output = OUTPUT_H;
    1a64:	44007265 	strmi	r7, [r0], #-613	; 0x265
    1a68:	5f33414d 	svcpl	0x0033414d
  ptb.GPIO_PinControl = INPUT_PULL_UP;
    1a6c:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
  LPLD_GPIO_Init(ptb);
    1a70:	6c646e61 	stclvs	14, cr6, [r4], #-388	; 0xfffffe7c
    1a74:	44007265 	strmi	r7, [r0], #-613	; 0x265
    1a78:	5f39414d 	svcpl	0x0039414d
    1a7c:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
}
    1a80:	6c646e61 	stclvs	14, cr6, [r4], #-388	; 0xfffffe7c
    1a84:	64007265 	strvs	r7, [r0], #-613	; 0x265
 * :
 *    1-ɹ
 *    0-ʧ
 */
uint8 LPLD_SCCB_WriteReg(uint16 reg_addr , uint8 data)
{		
    1a88:	615f7473 	cmpvs	pc, r3, ror r4	; <UNPREDICTABLE>
    1a8c:	00726464 	rsbseq	r6, r2, r4, ror #8
    1a90:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    1a94:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
  if(!LPLD_SCCB_Start())
    1a98:	77682f62 	strbvc	r2, [r8, -r2, ror #30]!
    1a9c:	5f77682f 	svcpl	0x0077682f
  {
    return 0;
    1aa0:	2e616d64 	cdpcs	13, 6, cr6, cr1, cr4, {3}
    1aa4:	4d440063 	stclmi	0, cr0, [r4, #-396]	; 0xfffffe74
  }
  LPLD_SCCB_SendByte(SCCB_DEV_ADR ); 
    1aa8:	5f313141 	svcpl	0x00313141
    1aac:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
  if(!LPLD_SCCB_WaitAck())
    1ab0:	6c646e61 	stclvs	14, cr6, [r4], #-388	; 0xfffffe7c
    1ab4:	73007265 	movwvc	r7, #613	; 0x265
  {
    LPLD_SCCB_Stop(); 
    1ab8:	615f6372 	cmpvs	pc, r2, ror r3	; <UNPREDICTABLE>
    return 0;
    1abc:	6f726464 	svcvs	0x00726464
    1ac0:	65736666 	ldrbvs	r6, [r3, #-1638]!	; 0x666
  }
  LPLD_SCCB_SendByte((uint8)(reg_addr & 0x00FF));   
    1ac4:	72730074 	rsbsvc	r0, r3, #116	; 0x74
    1ac8:	73645f63 	cmnvc	r4, #396	; 0x18c
  LPLD_SCCB_WaitAck();	
    1acc:	00657a69 	rsbeq	r7, r5, r9, ror #20
  LPLD_SCCB_SendByte(data);
    1ad0:	5f747364 	svcpl	0x00747364
    1ad4:	7473616c 	ldrbtvc	r6, [r3], #-364	; 0x16c
  LPLD_SCCB_WaitAck();   
    1ad8:	006a6461 	rsbeq	r6, sl, r1, ror #8
  LPLD_SCCB_Stop(); 
    1adc:	6f6a616d 	svcvs	0x006a616d
  return 1;
    1ae0:	6e635f72 	mcrvs	15, 3, r5, cr3, cr2, {3}
}									 
    1ae4:	4d440074 	stclmi	0, cr0, [r4, #-464]	; 0xfffffe30
    1ae8:	495f3141 	ldmdbmi	pc, {r0, r6, r8, ip, sp}^	; <UNPREDICTABLE>
    1aec:	61485152 	cmpvs	r8, r2, asr r1
 * :
 *    1-ɹ
 *    0-ʧ
 */          
uint8 LPLD_SCCB_ReadReg(uint8 reg_addr, uint8* data, uint16 length)
{	
    1af0:	656c646e 	strbvs	r6, [ip, #-1134]!	; 0x46e
    1af4:	6d640072 	stclvs	0, cr0, [r4, #-456]!	; 0xfffffe38
    1af8:	6e695f61 	cdpvs	15, 6, cr5, cr9, cr1, {3}
    1afc:	735f7469 	cmpvc	pc, #1761607680	; 0x69000000
  if(!LPLD_SCCB_Start())
    1b00:	63757274 	cmnvs	r5, #1073741831	; 0x40000007
    1b04:	4d440074 	stclmi	0, cr0, [r4, #-464]	; 0xfffffe30
    1b08:	495f3741 	ldmdbmi	pc, {r0, r6, r8, r9, sl, ip, sp}^	; <UNPREDICTABLE>
  {
    return 0;
    1b0c:	61485152 	cmpvs	r8, r2, asr r1
  }
  LPLD_SCCB_SendByte( SCCB_DEV_ADR ); 
    1b10:	656c646e 	strbvs	r6, [ip, #-1134]!	; 0x46e
    1b14:	4d440072 	stclmi	0, cr0, [r4, #-456]	; 0xfffffe38
  if( !LPLD_SCCB_WaitAck() )
    1b18:	495f3441 	ldmdbmi	pc, {r0, r6, sl, ip, sp}^	; <UNPREDICTABLE>
    1b1c:	61485152 	cmpvs	r8, r2, asr r1
    1b20:	656c646e 	strbvs	r6, [ip, #-1134]!	; 0x46e
  {
    LPLD_SCCB_Stop(); 
    1b24:	696d0072 	stmdbvs	sp!, {r1, r4, r5, r6}^
    return 0;
    1b28:	5f726f6e 	svcpl	0x00726f6e
  }
  LPLD_SCCB_SendByte( reg_addr ); 
    1b2c:	00746e63 	rsbseq	r6, r4, r3, ror #28
    1b30:	444c504c 	strbmi	r5, [ip], #-76	; 0x4c
  LPLD_SCCB_WaitAck();	
    1b34:	414d445f 	cmpmi	sp, pc, asr r4
  LPLD_SCCB_Stop(); 
    1b38:	666f535f 			; <UNDEFINED> instruction: 0x666f535f
  
  if(!LPLD_SCCB_Start())
    1b3c:	72617774 	rsbvc	r7, r1, #30408704	; 0x1d00000
    1b40:	61745365 	cmnvs	r4, r5, ror #6
    1b44:	65537472 	ldrbvs	r7, [r3, #-1138]	; 0x472
  {
    return 0;
    1b48:	63697672 	cmnvs	r9, #119537664	; 0x7200000
  }
  LPLD_SCCB_SendByte( SCCB_DEV_ADR + 1 );
    1b4c:	72730065 	rsbsvc	r0, r3, #101	; 0x65
    1b50:	616c5f63 	cmnvs	ip, r3, ror #30
  
  if(!LPLD_SCCB_WaitAck())
    1b54:	64617473 	strbtvs	r7, [r1], #-1139	; 0x473
    1b58:	4d44006a 	stclmi	0, cr0, [r4, #-424]	; 0xfffffe58
    1b5c:	495f3841 	ldmdbmi	pc, {r0, r6, fp, ip, sp}^	; <UNPREDICTABLE>
  {
    LPLD_SCCB_Stop(); 
    1b60:	61485152 	cmpvs	r8, r2, asr r1
    return 0;
    1b64:	656c646e 	strbvs	r6, [ip, #-1134]!	; 0x46e
  }
  while(length)
  {
    *data = LPLD_SCCB_ReceiveByte();
    1b68:	504c0072 	subpl	r0, ip, r2, ror r0
    1b6c:	445f444c 	ldrbmi	r4, [pc], #-1100	; 1b74 <LPLD_SCCB_ReadReg+0x84>
    1b70:	455f414d 	ldrbmi	r4, [pc, #-333]	; 1a2b <get_midline+0x1cf>
    if(length == 1)
    1b74:	6c62616e 	stfvse	f6, [r2], #-440	; 0xfffffe48
    1b78:	71724965 	cmnvc	r2, r5, ror #18
    {
      LPLD_SCCB_NoAck();
    1b7c:	414d4400 	cmpmi	sp, r0, lsl #8
    }
    else
    {
      LPLD_SCCB_Ack(); 
    1b80:	495f3231 	ldmdbmi	pc, {r0, r4, r5, r9, ip, sp}^	; <UNPREDICTABLE>
    }
    data++;
    1b84:	61485152 	cmpvs	r8, r2, asr r1
    1b88:	656c646e 	strbvs	r6, [ip, #-1134]!	; 0x46e
    length--;
    1b8c:	4d440072 	stclmi	0, cr0, [r4, #-456]	; 0xfffffe38
    1b90:	5f353141 	svcpl	0x00353141
  if(!LPLD_SCCB_WaitAck())
  {
    LPLD_SCCB_Stop(); 
    return 0;
  }
  while(length)
    1b94:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
    1b98:	6c646e61 	stclvs	14, cr6, [r4], #-388	; 0xfffffe7c
      LPLD_SCCB_Ack(); 
    }
    data++;
    length--;
  }
  LPLD_SCCB_Stop();
    1b9c:	4c007265 	sfmmi	f7, 4, [r0], {101}	; 0x65
  return 1;
    1ba0:	5f444c50 	svcpl	0x00444c50
}
    1ba4:	5f414d44 	svcpl	0x00414d44
    1ba8:	61736944 	cmnvs	r3, r4, asr #18
/*
 * LPLD_SCCB_Start
 * SCCBʼźţڲ
 */
uint8 LPLD_SCCB_Start(void)
{
    1bac:	49656c62 	stmdbmi	r5!, {r1, r5, r6, sl, fp, sp, lr}^
  SCCB_SDA_O=1;//ߵƽ
    1bb0:	44007172 	strmi	r7, [r0], #-370	; 0x172
    1bb4:	5f32414d 	svcpl	0x0032414d
    1bb8:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
    1bbc:	6c646e61 	stclvs	14, cr6, [r4], #-388	; 0xfffffe7c
  SCCB_SCL=1;   //ʱߵƽ 
    1bc0:	70007265 	andvc	r7, r0, r5, ror #4
    1bc4:	6f697265 	svcvs	0x00697265
    1bc8:	5f636964 	svcpl	0x00636964
  SCCB_DELAY();
    1bcc:	67697274 			; <UNDEFINED> instruction: 0x67697274
    1bd0:	4d440067 	stclmi	0, cr0, [r4, #-412]	; 0xfffffe64
  
  SCCB_SDA_IN();//Ϊ
    1bd4:	495f3541 	ldmdbmi	pc, {r0, r6, r8, sl, ip, sp}^	; <UNPREDICTABLE>
    1bd8:	61485152 	cmpvs	r8, r2, asr r1
    1bdc:	656c646e 	strbvs	r6, [ip, #-1134]!	; 0x46e
    1be0:	504c0072 	subpl	r0, ip, r2, ror r0
  if(!SCCB_SDA_I)
    1be4:	445f444c 	ldrbmi	r4, [pc], #-1100	; 1bec <LPLD_SCCB_Start+0x40>
    1be8:	495f414d 	ldmdbmi	pc, {r0, r2, r3, r6, r8, lr}^	; <UNPREDICTABLE>
    1bec:	0074696e 	rsbseq	r6, r4, lr, ror #18
  {
    SCCB_SDA_OUT();	
    1bf0:	5f637273 	svcpl	0x00637273
    1bf4:	72646461 	rsbvc	r6, r4, #1627389952	; 0x61000000
    1bf8:	74736400 	ldrbtvc	r6, [r3], #-1024	; 0x400
    1bfc:	6973645f 	ldmdbvs	r3!, {r0, r1, r2, r3, r4, r6, sl, sp, lr}^
    return 0;
    1c00:	4c00657a 	cfstr32mi	mvfx6, [r0], {122}	; 0x7a
  }
  SCCB_SDA_OUT();//Ϊ;	
    1c04:	5f444c50 	svcpl	0x00444c50
    1c08:	5f4d5446 	svcpl	0x004d5446
    1c0c:	61656c43 	cmnvs	r5, r3, asr #24
    1c10:	756f4372 	strbvc	r4, [pc, #-882]!	; 18a6 <get_midline+0x4a>
  SCCB_SDA_O=0; //͵ƽ
    1c14:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
    1c18:	4d4f4300 	stclmi	3, cr4, [pc, #-0]	; 1c20 <LPLD_SCCB_Start+0x74>
    1c1c:	454e4942 	strbmi	r4, [lr, #-2370]	; 0x942
  
  SCCB_DELAY();
    1c20:	4d544600 	ldclmi	6, cr4, [r4, #-0]
    1c24:	646f4d5f 	strbtvs	r4, [pc], #-3423	; 1c2c <LPLD_SCCB_Start+0x80>
  
  SCCB_SDA_IN();//Ϊ
    1c28:	75620065 	strbvc	r0, [r2, #-101]!	; 0x65
    1c2c:	6c635f73 	stclvs	15, cr5, [r3], #-460	; 0xfffffe34
    1c30:	7a685f6b 	bvc	1a199e4 <__etext+0x1a10d3c>
    1c34:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
  if(SCCB_SDA_I) 
    1c38:	54465f44 	strbpl	r5, [r6], #-3908	; 0xf44
    1c3c:	69505f4d 	ldmdbvs	r0, {r0, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
    1c40:	6965446e 	stmdbvs	r5!, {r1, r2, r3, r5, r6, sl, lr}^
  {
    SCCB_SDA_OUT();
    1c44:	0074696e 	rsbseq	r6, r4, lr, ror #18
    1c48:	32646f6d 	rsbcc	r6, r4, #436	; 0x1b4
    1c4c:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
    1c50:	54465f44 	strbpl	r5, [r6], #-3908	; 0xf44
    return 0;
    1c54:	57505f4d 	ldrbpl	r5, [r0, -sp, asr #30]
  }
  SCCB_SDA_OUT();//Ϊ
    1c58:	6e455f4d 	cdpvs	15, 4, cr5, cr5, cr13, {2}
    1c5c:	656c6261 	strbvs	r6, [ip, #-609]!	; 0x261
    1c60:	5f746400 	svcpl	0x00746400
    1c64:	00766964 	rsbseq	r6, r6, r4, ror #18
  SCCB_SDA_O=0;//͵ƽ
    1c68:	5f4d5446 	svcpl	0x004d5446
    1c6c:	45696f54 	strbmi	r6, [r9, #-3924]!	; 0xf54
    1c70:	6c62616e 	stfvse	f6, [r2], #-440	; 0xfffffe48
  return 1;
    1c74:	504c0065 	subpl	r0, ip, r5, rrx
}
    1c78:	465f444c 	ldrbmi	r4, [pc], -ip, asr #8
/*
 * LPLD_SCCB_Stop
 * SCCBֹͣźţڲ
 */
static void LPLD_SCCB_Stop(void)
{
    1c7c:	495f4d54 	ldmdbmi	pc, {r2, r4, r6, r8, sl, fp, lr}^	; <UNPREDICTABLE>
  SCCB_SCL=0;
    1c80:	6e495f43 	cdpvs	15, 4, cr5, cr9, cr3, {2}
    1c84:	46007469 	strmi	r7, [r0], -r9, ror #8
    1c88:	515f4d54 	cmppl	pc, r4, asr sp	; <UNPREDICTABLE>
    1c8c:	646f4d64 	strbtvs	r4, [pc], #-3428	; 1c94 <LPLD_SCCB_Stop+0x18>
  SCCB_SDA_O=0;
    1c90:	54460065 	strbpl	r0, [r6], #-101	; 0x65
    1c94:	77505f4d 	ldrbvc	r5, [r0, -sp, asr #30]
    1c98:	6165446d 	cmnvs	r5, sp, ror #8
  SCCB_DELAY();
    1c9c:	6d697464 	cfstrdvs	mvd7, [r9, #-400]!	; 0xfffffe70
    1ca0:	76694465 	strbtvc	r4, [r9], -r5, ror #8
  
  SCCB_SCL=1;
    1ca4:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
    1ca8:	54465f44 	strbpl	r5, [r6], #-3908	; 0xf44
    1cac:	43495f4d 	movtmi	r5, #40781	; 0x9f4d
    1cb0:	616e455f 	cmnvs	lr, pc, asr r5
  SCCB_SDA_O=1;
    1cb4:	00656c62 	rsbeq	r6, r5, r2, ror #24
    1cb8:	544c4946 	strbpl	r4, [ip], #-2374	; 0x946
    1cbc:	46005245 	strmi	r5, [r0], -r5, asr #4
  SCCB_DELAY();
    1cc0:	5f314d54 	svcpl	0x00314d54
    1cc4:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
}
    1cc8:	6c646e61 	stclvs	14, cr6, [r4], #-388	; 0xfffffe7c
/*
 * LPLD_SCCB_Stop
 * SCCBӦźţڲ
 */
static void LPLD_SCCB_Ack(void)
{	
    1ccc:	4c007265 	sfmmi	f7, 4, [r0], {101}	; 0x65
  SCCB_SCL=0;
    1cd0:	5f444c50 	svcpl	0x00444c50
    1cd4:	5f4d5446 	svcpl	0x004d5446
    1cd8:	5f4d5750 	svcpl	0x004d5750
    1cdc:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
  SCCB_DELAY();
    1ce0:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
    1ce4:	54465f44 	strbpl	r5, [r6], #-3908	; 0xf44
  
  SCCB_SDA_O=0;
    1ce8:	44515f4d 	ldrbmi	r5, [r1], #-3917	; 0xf4d
    1cec:	696e495f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, lr}^
    1cf0:	65720074 	ldrbvs	r0, [r2, #-116]!	; 0x74
  SCCB_DELAY();
    1cf4:	746c7573 	strbtvc	r7, [ip], #-1395	; 0x573
    1cf8:	5f746400 	svcpl	0x00746400
  
  SCCB_SCL=1;
    1cfc:	4c006e65 	stcmi	14, cr6, [r0], {101}	; 0x65
    1d00:	5f444c50 	svcpl	0x00444c50
    1d04:	5f4d5446 	svcpl	0x004d5446
    1d08:	48437349 	stmdami	r3, {r0, r3, r6, r8, r9, ip, sp, lr}^
  SCCB_DELAY();
    1d0c:	4600466e 	strmi	r4, [r0], -lr, ror #12
    1d10:	4d5f4d54 	ldclmi	13, cr4, [pc, #-336]	; 1bc8 <LPLD_SCCB_Start+0x1c>
  
  SCCB_SCL=0;
    1d14:	614d6d65 	cmpvs	sp, r5, ror #26
    1d18:	44510070 	ldrbmi	r0, [r1], #-112	; 0x70
    1d1c:	4c525443 	cfldrdmi	mvd5, [r2], {67}	; 0x43
  SCCB_DELAY();
    1d20:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
    1d24:	54465f44 	strbpl	r5, [r6], #-3908	; 0xf44
}
    1d28:	69445f4d 	stmdbvs	r4, {r0, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
/*
 * LPLD_SCCB_NoAck
 * SCCBӦźţڲ
 */
static void LPLD_SCCB_NoAck(void)
{	
    1d2c:	6c626173 	stfvse	f6, [r2], #-460	; 0xfffffe34
  SCCB_SCL=0;
    1d30:	6e684365 	cdpvs	3, 6, cr4, cr8, cr5, {3}
    1d34:	4d544600 	ldclmi	6, cr4, [r4, #-0]
    1d38:	696e495f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, lr}^
    1d3c:	70795474 	rsbsvc	r5, r9, r4, ror r4
  SCCB_DELAY();
    1d40:	66654465 	strbtvs	r4, [r5], -r5, ror #8
    1d44:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
  SCCB_SDA_O=1;
    1d48:	54465f44 	strbpl	r5, [r6], #-3908	; 0xf44
    1d4c:	69445f4d 	stmdbvs	r4, {r0, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
    1d50:	6c626173 	stfvse	f6, [r2], #-460	; 0xfffffe34
  SCCB_DELAY();
    1d54:	71724965 	cmnvc	r2, r5, ror #18
    1d58:	536e4300 	cmnpl	lr, #0
  SCCB_SCL=1;
    1d5c:	57530043 	ldrbpl	r0, [r3, -r3, asr #32]
    1d60:	5254434f 	subspl	r4, r4, #1006632961	; 0x3c000001
    1d64:	504c004c 	subpl	r0, ip, ip, asr #32
    1d68:	465f444c 	ldrbmi	r4, [pc], -ip, asr #8
  SCCB_DELAY();
    1d6c:	515f4d54 	cmppl	pc, r4, asr sp	; <UNPREDICTABLE>
    1d70:	69445f44 	stmdbvs	r4, {r2, r6, r8, r9, sl, fp, ip, lr}^
  SCCB_SCL=0;
    1d74:	6c626173 	stfvse	f6, [r2], #-460	; 0xfffffe34
    1d78:	75760065 	ldrbvc	r0, [r6, #-101]!	; 0x65
    1d7c:	33746e69 	cmncc	r4, #1680	; 0x690
  SCCB_DELAY();
    1d80:	75640032 	strbvc	r0, [r4, #-50]!	; 0x32
    1d84:	2e007974 	mcrcs	9, 0, r7, cr0, cr4, {3}
}
    1d88:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
/*
 * LPLD_SCCB_WaitAck
 * SCCBȴӦźţڲ
 */
static uint8 LPLD_SCCB_WaitAck(void) 	
{
    1d8c:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
  SCCB_SCL=0;//ʱߵ͵ƽ
    1d90:	2f77682f 	svccs	0x0077682f
    1d94:	665f7768 	ldrbvs	r7, [pc], -r8, ror #14
    1d98:	632e6d74 	teqvs	lr, #7424	; 0x1d00
    1d9c:	6d746600 	ldclvs	6, cr6, [r4, #-0]
  SCCB_DELAY(); 
    1da0:	57500078 			; <UNDEFINED> instruction: 0x57500078
    1da4:	414f4c4d 	cmpmi	pc, sp, asr #24
  
 SCCB_SDA_IN();//Ϊ**
    1da8:	504c0044 	subpl	r0, ip, r4, asr #32
    1dac:	465f444c 	ldrbmi	r4, [pc], -ip, asr #8
    1db0:	495f4d54 	ldmdbmi	pc, {r2, r4, r6, r8, sl, fp, lr}^	; <UNPREDICTABLE>
  SCCB_DELAY();
    1db4:	464f5473 			; <UNDEFINED> instruction: 0x464f5473
    1db8:	54554f00 	ldrbpl	r4, [r5], #-3840	; 0xf00
  
  SCCB_SCL=1;//ʱ߸ߵƽ
    1dbc:	4b53414d 	blmi	14d22f8 <__etext+0x14c9650>
    1dc0:	4e4f4300 	cdpmi	3, 4, cr4, cr15, cr0, {0}
    1dc4:	4c4f5254 	sfmmi	f5, 2, [pc], {84}	; 0x54
    1dc8:	504c0053 	subpl	r0, ip, r3, asr r0
  
  SCCB_DELAY();
    1dcc:	465f444c 	ldrbmi	r4, [pc], -ip, asr #8
    1dd0:	505f4d54 	subspl	r4, pc, r4, asr sp	; <UNPREDICTABLE>
  
  if(SCCB_SDA_I)
    1dd4:	435f4d57 	cmpmi	pc, #5568	; 0x15c0
    1dd8:	676e6168 	strbvs	r6, [lr, -r8, ror #2]!
    1ddc:	74754465 	ldrbtvc	r4, [r5], #-1125	; 0x465
  {
    SCCB_SDA_OUT();
    1de0:	54460079 	strbpl	r0, [r6], #-121	; 0x79
    1de4:	53495f4d 	movtpl	r5, #40781	; 0x9f4d
    1de8:	41435f52 	cmpmi	r3, r2, asr pc
    1dec:	41424c4c 	cmpmi	r2, ip, asr #24
    SCCB_SCL=0;
    1df0:	46004b43 	strmi	r4, [r0], -r3, asr #22
    1df4:	5f324d54 	svcpl	0x00324d54
    1df8:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
    return 0;
    1dfc:	6c646e61 	stclvs	14, cr6, [r4], #-388	; 0xfffffe7c
    1e00:	46007265 	strmi	r7, [r0], -r5, ror #4
  }
  SCCB_SDA_OUT();//Ϊ
    1e04:	505f4d54 	subspl	r4, pc, r4, asr sp	; <UNPREDICTABLE>
    1e08:	65446d77 	strbvs	r6, [r4, #-3447]	; 0xd77
    1e0c:	69746461 	ldmdbvs	r4!, {r0, r5, r6, sl, sp, lr}^
  SCCB_SCL=0; //ʱߵ͵ƽ
    1e10:	6643656d 	strbvs	r6, [r3], -sp, ror #10
    1e14:	504c0067 	subpl	r0, ip, r7, rrx
    1e18:	465f444c 	ldrbmi	r4, [pc], -ip, asr #8
    1e1c:	435f4d54 	cmpmi	pc, #5376	; 0x1500
  return 1;
    1e20:	7261656c 	rsbvc	r6, r1, #452984832	; 0x1b000000
}
    1e24:	00464f54 	subeq	r4, r6, r4, asr pc
/*
 * LPLD_SCCB_SendByte
 * SCCBݣڲ
 */
static void LPLD_SCCB_SendByte(uint8 data) 
{
    1e28:	444c504c 	strbmi	r5, [ip], #-76	; 0x4c
    1e2c:	4d54465f 	ldclmi	6, cr4, [r4, #-380]	; 0xfffffe84
    1e30:	7465475f 	strbtvc	r4, [r5], #-1887	; 0x75f
  uint8 i=8;
    1e34:	6e756f43 	cdpvs	15, 7, cr6, cr5, cr3, {2}
  while(i--)
    1e38:	00726574 	rsbseq	r6, r2, r4, ror r5
  {
    SCCB_SCL=0;
    1e3c:	43544c46 	cmpmi	r4, #17920	; 0x4600
    1e40:	004c5254 	subeq	r5, ip, r4, asr r2
    1e44:	4954554f 	ldmdbmi	r4, {r0, r1, r2, r3, r6, r8, sl, ip, lr}^
    SCCB_DELAY();
    1e48:	0054494e 	subseq	r4, r4, lr, asr #18
    1e4c:	5f4d5446 	svcpl	0x004d5446
    if(data&0x80)
    1e50:	466d7750 			; <UNDEFINED> instruction: 0x466d7750
    1e54:	00716572 	rsbseq	r6, r1, r2, ror r5
    {
      SCCB_SDA_O=1; 
    1e58:	765f7464 	ldrbvc	r7, [pc], -r4, ror #8
    1e5c:	4c006c61 	stcmi	12, cr6, [r0], {97}	; 0x61
    1e60:	5f444c50 	svcpl	0x00444c50
    1e64:	5f4d5446 	svcpl	0x004d5446
    }
    else 
    {
      SCCB_SDA_O=0;   
    1e68:	61656c43 	cmnvs	r5, r3, asr #24
    1e6c:	6e484372 	mcrvs	3, 2, r4, cr8, cr2, {3}
    1e70:	54460046 	strbpl	r0, [r6], #-70	; 0x46
    1e74:	68435f4d 	stmdavs	r3, {r0, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
    }
    data<<=1;
    1e78:	54460030 	strbpl	r0, [r6], #-48	; 0x30
    1e7c:	68435f4d 	stmdavs	r3, {r0, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
    SCCB_DELAY();
    1e80:	54460031 	strbpl	r0, [r6], #-49	; 0x31
    1e84:	68435f4d 	stmdavs	r3, {r0, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
    SCCB_SCL=1;
    1e88:	54460032 	strbpl	r0, [r6], #-50	; 0x32
    1e8c:	68435f4d 	stmdavs	r3, {r0, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
    1e90:	54460033 	strbpl	r0, [r6], #-51	; 0x33
    SCCB_DELAY();
    1e94:	68435f4d 	stmdavs	r3, {r0, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
    1e98:	54460034 	strbpl	r0, [r6], #-52	; 0x34
 * SCCBݣڲ
 */
static void LPLD_SCCB_SendByte(uint8 data) 
{
  uint8 i=8;
  while(i--)
    1e9c:	68435f4d 	stmdavs	r3, {r0, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
    1ea0:	54460035 	strbpl	r0, [r6], #-53	; 0x35
    1ea4:	68435f4d 	stmdavs	r3, {r0, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
    1ea8:	54460036 	strbpl	r0, [r6], #-54	; 0x36
    1eac:	68435f4d 	stmdavs	r3, {r0, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
    1eb0:	54460037 	strbpl	r0, [r6], #-55	; 0x37
    data<<=1;
    SCCB_DELAY();
    SCCB_SCL=1;
    SCCB_DELAY();
  }
  SCCB_SCL=0;
    1eb4:	495f304d 	ldmdbmi	pc, {r0, r2, r3, r6, ip, sp}^	; <UNPREDICTABLE>
    1eb8:	61485152 	cmpvs	r8, r2, asr r1
    1ebc:	656c646e 	strbvs	r6, [ip, #-1134]!	; 0x46e
    1ec0:	504c0072 	subpl	r0, ip, r2, ror r0
}
    1ec4:	465f444c 	ldrbmi	r4, [pc], -ip, asr #8
    1ec8:	445f4d54 	ldrbmi	r4, [pc], #-3412	; 1ed0 <LPLD_SCCB_ReceiveByte+0x4>
/*
 * LPLD_SCCB_SendByte
 * SCCBݣڲ
 */
static uint8 LPLD_SCCB_ReceiveByte(void)  
{ 
    1ecc:	696e6965 	stmdbvs	lr!, {r0, r2, r5, r6, r8, fp, sp, lr}^
    1ed0:	4e430074 	mcrmi	0, 2, r0, cr3, cr4, {3}
  uint8 i=8;
    1ed4:	004e4954 	subeq	r4, lr, r4, asr r9
  uint8 ReceiveByte=0;
    1ed8:	5f4d5446 	svcpl	0x004d5446
    1edc:	00525349 	subseq	r5, r2, r9, asr #6
  
  SCCB_SDA_O=1;	
    1ee0:	54545845 	ldrbpl	r5, [r4], #-2117	; 0x845
    1ee4:	00474952 	subeq	r4, r7, r2, asr r9
    1ee8:	444c504c 	strbmi	r5, [ip], #-76	; 0x4c
  SCCB_DELAY();
    1eec:	4d54465f 	ldclmi	6, cr4, [r4, #-380]	; 0xfffffe84
    1ef0:	6e69505f 	mcrvs	0, 3, r5, cr9, cr15, {2}
  
  SCCB_SDA_IN();	
    1ef4:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
    1ef8:	4d544600 	ldclmi	6, cr4, [r4, #-0]
    1efc:	6d77505f 	ldclvs	0, cr5, [r7, #-380]!	; 0xfffffe84
    1f00:	64616544 	strbtvs	r6, [r1], #-1348	; 0x544
  
  while(i--)
  {
    ReceiveByte<<=1;      
    1f04:	656d6974 	strbvs	r6, [sp, #-2420]!	; 0x974
    1f08:	006c6156 	rsbeq	r6, ip, r6, asr r1
    SCCB_SCL=0;
    1f0c:	444c504c 	strbmi	r5, [ip], #-76	; 0x4c
    1f10:	4d54465f 	ldclmi	6, cr4, [r4, #-380]	; 0xfffffe84
    1f14:	4345445f 	movtmi	r4, #21599	; 0x545f
    1f18:	696e495f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, lr}^
    SCCB_DELAY();
    1f1c:	4c460074 	mcrrmi	0, 7, r0, r6, cr4
    1f20:	4c4f5054 	mcrrmi	0, 5, r5, pc, cr4
    
    SCCB_SCL=1;
    1f24:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
    1f28:	54465f44 	strbpl	r5, [r6], #-3908	; 0xf44
    1f2c:	6e455f4d 	cdpvs	15, 4, cr5, cr5, cr13, {2}
    SCCB_DELAY();	
    1f30:	656c6261 	strbvs	r6, [ip, #-609]!	; 0x261
    1f34:	00717249 	rsbseq	r7, r1, r9, asr #4
    
    if(SCCB_SDA_I)
    1f38:	74706163 	ldrbtvc	r6, [r0], #-355	; 0x163
    1f3c:	5f657275 	svcpl	0x00657275
    1f40:	65676465 	strbvs	r6, [r7, #-1125]!	; 0x465
    1f44:	444f4d00 	strbmi	r4, [pc], #-3328	; 1f4c <LPLD_SCCB_ReceiveByte+0x80>
    {
      ReceiveByte|=0x01;
    1f48:	504c0045 	subpl	r0, ip, r5, asr #32
    1f4c:	465f444c 	ldrbmi	r4, [pc], -ip, asr #8
  SCCB_SDA_O=1;	
  SCCB_DELAY();
  
  SCCB_SDA_IN();	
  
  while(i--)
    1f50:	495f4d54 	ldmdbmi	pc, {r2, r4, r6, r8, sl, fp, lr}^	; <UNPREDICTABLE>
    1f54:	0074696e 	rsbseq	r6, r4, lr, ror #18
    1f58:	43564e49 	cmpmi	r6, #1168	; 0x490
    1f5c:	004c5254 	subeq	r5, ip, r4, asr r2
    1f60:	444c504c 	strbmi	r5, [ip], #-76	; 0x4c
    1f64:	4d54465f 	ldclmi	6, cr4, [r4, #-380]	; 0xfffffe84
    {
      ReceiveByte|=0x01;
    }
    
  }
  SCCB_SDA_OUT();
    1f68:	5f44515f 	svcpl	0x0044515f
    1f6c:	62616e45 	rsbvs	r6, r1, #1104	; 0x450
    1f70:	4400656c 	strmi	r6, [r0], #-1388	; 0x56c
  SCCB_SCL=0;
    1f74:	54444145 	strbpl	r4, [r4], #-325	; 0x145
    1f78:	00454d49 	subeq	r4, r5, r9, asr #26
    1f7c:	5f4d5446 	svcpl	0x004d5446
    1f80:	4d6d654d 	cfstr64mi	mvdx6, [sp, #-308]!	; 0xfffffecc
  
  return ReceiveByte;
}
    1f84:	74507061 	ldrbvc	r7, [r0], #-97	; 0x61
    1f88:	504c0072 	subpl	r0, ip, r2, ror r0
    1f8c:	465f444c 	ldrbmi	r4, [pc], -ip, asr #8
/*
 * LPLD_SCCB_SendByte
 * SCCBʱڲ
 */
static void LPLD_SCCB_Delay(uint16 i)
{	
    1f90:	475f4d54 			; <UNDEFINED> instruction: 0x475f4d54
    1f94:	6c437465 	cfstrdvs	mvd7, [r3], {101}	; 0x65
    1f98:	7669446b 	strbtvc	r4, [r9], -fp, ror #8
  while(i) 
    i--; 
    1f9c:	4d544600 	ldclmi	6, cr4, [r4, #-0]
    1fa0:	7273495f 	rsbsvc	r4, r3, #1556480	; 0x17c000
 * LPLD_SCCB_SendByte
 * SCCBʱڲ
 */
static void LPLD_SCCB_Delay(uint16 i)
{	
  while(i) 
    1fa4:	4d544600 	ldclmi	6, cr4, [r4, #-0]
    1fa8:	4168505f 	qdsubmi	r5, pc, r8	; <UNPREDICTABLE>
    i--; 
}
    1fac:	4d544600 	ldclmi	6, cr4, [r4, #-0]
    1fb0:	4268505f 	rsbmi	r5, r8, #95	; 0x5f
 * 输出:
 *    0--配置错误
 *    1--配置成功
 */
uint8 LPLD_ADC_Init(ADC_InitTypeDef adc_init_structure)
{
    1fb4:	4d544600 	ldclmi	6, cr4, [r4, #-0]
    1fb8:	6d74465f 	ldclvs	6, cr4, [r4, #-380]!	; 0xfffffe84
    1fbc:	59530078 	ldmdbpl	r3, {r3, r4, r5, r6}^
    1fc0:	6600434e 	strvs	r4, [r0], -lr, asr #6
  uint8 i;
  ADC_MemMapPtr adcx = adc_init_structure.ADC_Adcx;
    1fc4:	695f6d74 	ldmdbvs	pc, {r2, r4, r5, r6, r8, sl, fp, sp, lr}^	; <UNPREDICTABLE>
  uint8 diff = adc_init_structure.ADC_DiffMode;
    1fc8:	5f74696e 	svcpl	0x0074696e
    1fcc:	75727473 	ldrbvc	r7, [r2, #-1139]!	; 0x473
  uint8 mode = adc_init_structure.ADC_BitMode;
    1fd0:	72757463 	rsbsvc	r7, r5, #1660944384	; 0x63000000
  uint8 time = adc_init_structure.ADC_SampleTimeCfg;
    1fd4:	74460065 	strbvc	r0, [r6], #-101	; 0x65
    1fd8:	6e68436d 	cdpvs	3, 6, cr4, cr8, cr13, {3}
  uint8 ltime = adc_init_structure.ADC_LongSampleTimeSel;
    1fdc:	6d756e45 	ldclvs	14, cr6, [r5, #-276]!	; 0xfffffeec
  uint8 avg = adc_init_structure.ADC_HwAvgSel;
    1fe0:	6d744600 	ldclvs	6, cr4, [r4, #-0]
    1fe4:	456e6843 	strbmi	r6, [lr, #-2115]!	; 0x843
  uint8 muxab = adc_init_structure.ADC_MuxSel;
    1fe8:	5f6d756e 	svcpl	0x006d756e
  uint8 pga = adc_init_structure.ADC_PgaGain;
    1fec:	65707954 	ldrbvs	r7, [r0, #-2388]!	; 0x954
    1ff0:	41545300 	cmpmi	r4, r0, lsl #6
  uint8 hwtrg = adc_init_structure.ADC_HwTrgCfg;
    1ff4:	00535554 	subseq	r5, r3, r4, asr r5
  ADC_ISR_CALLBACK isr_func = adc_init_structure.ADC_Isr;
    1ff8:	5f4d5446 	svcpl	0x004d5446
 
  //配置ADC时钟 //这里貌似只配置了两个还要另行配置其他的几个
  if(adcx == ADC0)
    1ffc:	446b6c43 	strbtmi	r6, [fp], #-3139	; 0xc43
    2000:	61007669 	tstvs	r0, r9, ror #12
    2004:	6e67696c 	cdpvs	9, 6, cr6, cr7, cr12, {3}
    2008:	4e595300 	cdpmi	3, 5, cr5, cr9, cr0, {0}
  {
    i=0;
    200c:	464e4f43 	strbmi	r4, [lr], -r3, asr #30
    SIM_SCGC6 |= SIM_SCGC6_ADC0_MASK;   // 开启ADC0时钟
    2010:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
    2014:	54465f44 	strbpl	r5, [r6], #-3908	; 0xf44
    2018:	65475f4d 	strbvs	r5, [r7, #-3917]	; 0xf4d
    201c:	56684374 			; <UNDEFINED> instruction: 0x56684374
    2020:	4c006c61 	stcmi	12, cr6, [r0], {97}	; 0x61
    2024:	5f444c50 	svcpl	0x00444c50
    2028:	4f495047 	svcmi	0x00495047
    202c:	74754f5f 	ldrbtvc	r4, [r5], #-3935	; 0xf5f
    2030:	00747570 	rsbseq	r7, r4, r0, ror r5
    2034:	6f697067 	svcvs	0x00697067
    2038:	696e695f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}^
  }
  else if(adcx == ADC1)
    203c:	74735f74 	ldrbtvc	r5, [r3], #-3956	; 0xf74
    2040:	74637572 	strbtvc	r7, [r3], #-1394	; 0x572
    2044:	00657275 	rsbeq	r7, r5, r5, ror r2
  {
    i=1;
    2048:	444c504c 	strbmi	r5, [ip], #-76	; 0x4c
    204c:	4950475f 	ldmdbmi	r0, {r0, r1, r2, r3, r4, r6, r8, r9, sl, lr}^
    SIM_SCGC3 |= SIM_SCGC3_ADC1_MASK;   // 开启ADC1时钟
    2050:	6e495f4f 	cdpvs	15, 4, cr5, cr9, cr15, {2}
    2054:	4c007469 	cfstrsmi	mvf7, [r0], {105}	; 0x69
    2058:	5f444c50 	svcpl	0x00444c50
    205c:	4f495047 	svcmi	0x00495047
    2060:	7369445f 	cmnvc	r9, #1593835520	; 0x5f000000
    2064:	656c6261 	strbvs	r6, [ip, #-609]!	; 0x261
    2068:	00717249 	rsbseq	r7, r1, r9, asr #4
    206c:	444c504c 	strbmi	r5, [ip], #-76	; 0x4c
    2070:	4950475f 	ldmdbmi	r0, {r0, r1, r2, r3, r4, r6, r8, r9, sl, lr}^
    2074:	6f545f4f 	svcvs	0x00545f4f
  }
  else 
  {
    return 0;
    2078:	656c6767 	strbvs	r6, [ip, #-1895]!	; 0x767
    207c:	6400625f 	strvs	r6, [r0], #-607	; 0x25f
  }

  if(adc_init_structure.ADC_CalEnable == TRUE)
    2080:	33617461 	cmncc	r1, #1627389952	; 0x61000000
    2084:	6f700032 	svcvs	0x00700032
    LPLD_ADC_Cal(adcx);  //进行ADC校准
    2088:	00787472 	rsbseq	r7, r8, r2, ror r4
  
  //设置ADCCFG1寄存器
  adcx->CFG1  &=   (~ADC_CFG1_ADLPC_MASK);         // 重新为正常使用进行配置
    208c:	736e6970 	cmnvc	lr, #1835008	; 0x1c0000
    2090:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
    2094:	50475f44 	subpl	r5, r7, r4, asr #30
  adcx->CFG1  |=    ADC_CFG1_ADIV(ADIV_1)          // ADC输入时钟分频为 1
    2098:	4f5f4f49 	svcmi	0x005f4f49
                  | (time)                           // 设置长短时间采样模式
                  | ADC_CFG1_ADICLK(ADICLK_BUS_2)  // ADC输入时钟源为 BusClk
    209c:	75707475 	ldrbvc	r7, [r0, #-1141]!	; 0x475
    20a0:	00625f74 	rsbeq	r5, r2, r4, ror pc
    20a4:	54524f50 	ldrbpl	r4, [r2], #-3920	; 0xf50
                  | ADC_CFG1_MODE(mode);           //设置ADC转换精度
    20a8:	52495f43 	subpl	r5, r9, #268	; 0x10c
    20ac:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
    20b0:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
  if(adc_init_structure.ADC_CalEnable == TRUE)
    LPLD_ADC_Cal(adcx);  //进行ADC校准
  
  //设置ADCCFG1寄存器
  adcx->CFG1  &=   (~ADC_CFG1_ADLPC_MASK);         // 重新为正常使用进行配置
  adcx->CFG1  |=    ADC_CFG1_ADIV(ADIV_1)          // ADC输入时钟分频为 1
    20b4:	524f5000 	subpl	r5, pc, #0
                  | (time)                           // 设置长短时间采样模式
                  | ADC_CFG1_ADICLK(ADICLK_BUS_2)  // ADC输入时钟源为 BusClk
                  | ADC_CFG1_MODE(mode);           //设置ADC转换精度

  //设置ADCCFG2寄存器
  adcx->CFG2 &=  (~ADC_CFG2_ADACKEN_MASK);   //禁用异步时钟输出
    20b8:	495f4454 	ldmdbmi	pc, {r2, r4, r6, sl, lr}^	; <UNPREDICTABLE>
    20bc:	61485152 	cmpvs	r8, r2, asr r1
    20c0:	656c646e 	strbvs	r6, [ip, #-1134]!	; 0x46e
  adcx->CFG2 |=    (muxab)                      // ADC复用选择
    20c4:	4f500072 	svcmi	0x00500072
                 | (ADC_CFG2_ADHSC_MASK)        // 高速转换
                 | ADC_CFG2_ADLSTS(ltime);    // 长采样时间时钟周期选择
    20c8:	5f455452 	svcpl	0x00455452
    20cc:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
    20d0:	6c646e61 	stclvs	14, cr6, [r4], #-388	; 0xfffffe7c
    20d4:	4c007265 	sfmmi	f7, 4, [r0], {101}	; 0x65
    20d8:	5f444c50 	svcpl	0x00444c50
                  | ADC_CFG1_ADICLK(ADICLK_BUS_2)  // ADC输入时钟源为 BusClk
                  | ADC_CFG1_MODE(mode);           //设置ADC转换精度

  //设置ADCCFG2寄存器
  adcx->CFG2 &=  (~ADC_CFG2_ADACKEN_MASK);   //禁用异步时钟输出
  adcx->CFG2 |=    (muxab)                      // ADC复用选择
    20dc:	4f495047 	svcmi	0x00495047
                 | (ADC_CFG2_ADHSC_MASK)        // 高速转换
                 | ADC_CFG2_ADLSTS(ltime);    // 长采样时间时钟周期选择
                                              // 总采样周期见K60技术文档 page:840
  //用于设定阈值
  adcx->CV1  = 0x1234u ; 
    20e0:	676f545f 			; <UNDEFINED> instruction: 0x676f545f
    20e4:	00656c67 	rsbeq	r6, r5, r7, ror #24
  adcx->CV2  = 0x5678u ;
    20e8:	444c504c 	strbmi	r5, [ip], #-76	; 0x4c
    20ec:	4950475f 	ldmdbmi	r0, {r0, r1, r2, r3, r4, r6, r8, r9, sl, lr}^
 
  adcx->SC2  &= ((~ADC_SC2_ACFE_MASK)     //关闭比较功能 
    20f0:	6e455f4f 	cdpvs	15, 4, cr5, cr5, cr15, {2}
    20f4:	656c6261 	strbvs	r6, [ip, #-609]!	; 0x261
    20f8:	00717249 	rsbseq	r7, r1, r9, asr #4
                 & (~ADC_SC2_DMAEN_MASK)); //关闭DMA
  adcx->SC2  |=  (hwtrg & ADC_SC2_ADTRG_MASK) //设置触发方式
    20fc:	5f62736c 	svcpl	0x0062736c
    2100:	006d756e 	rsbeq	r7, sp, lr, ror #10
    2104:	444c504c 	strbmi	r5, [ip], #-76	; 0x4c
    2108:	4950475f 	ldmdbmi	r0, {r0, r1, r2, r3, r4, r6, r8, r9, sl, lr}^
    210c:	6e495f4f 	cdpvs	15, 4, cr5, cr9, cr15, {2}
                 |  ADC_SC2_ACREN_MASK          //使能范围比较
                 |  ADC_SC2_ACFGT_MASK          //使能大于比较功能
                 |  ADC_SC2_REFSEL(REFSEL_EXT); //选择外部参考源VREFH和VREFL
  
  if(adc_init_structure.ADC_DmaEnable == TRUE) 
    2110:	5f747570 	svcpl	0x00747570
    2114:	50470062 	subpl	r0, r7, r2, rrx
    adcx->SC2  |= ADC_SC2_DMAEN_MASK;           //使能DMA
    2118:	495f4f49 	ldmdbmi	pc, {r0, r3, r6, r8, r9, sl, fp, lr}^	; <UNPREDICTABLE>
    211c:	6f005253 	svcvs	0x00005253
    2120:	75707475 	ldrbvc	r7, [r0, #-1141]!	; 0x475

  adcx->SC3  &=  (~ADC_SC3_CAL_MASK)          //关闭校准
    2124:	4f500074 	svcmi	0x00500074
    2128:	5f415452 	svcpl	0x00415452
    212c:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
                 & (~ADC_SC3_ADCO_MASK);         //选择一次转换
  adcx->SC3  |=  avg;                        //硬件平均
    2130:	6c646e61 	stclvs	14, cr6, [r4], #-388	; 0xfffffe7c
    2134:	64007265 	strvs	r7, [r0], #-613	; 0x265
    2138:	31617461 	cmncc	r1, r1, ror #8
  
  adcx->PGA  = pga<<ADC_PGA_PGAG_SHIFT; 
    213c:	524f5000 	subpl	r5, pc, #0
    2140:	495f4254 	ldmdbmi	pc, {r2, r4, r6, r9, lr}^	; <UNPREDICTABLE>
    2144:	61485152 	cmpvs	r8, r2, asr r1
  
  //校准完毕后再重新初始化ADC寄存器
  //adcx->SC1[0] = ADC_SC1_ADCH(AD31);    //复位SC1
  adcx->SC1[hwtrg & 0x01] = diff;         //设置单端、差分输入
    2148:	656c646e 	strbvs	r6, [ip, #-1134]!	; 0x46e
    214c:	2e2e0072 	mcrcs	0, 1, r0, cr14, cr2, {3}
    2150:	2f2e2e2f 	svccs	0x002e2e2f
    2154:	2f62696c 	svccs	0x0062696c
  
  if(isr_func!= NULL)
    2158:	682f7768 	stmdavs	pc!, {r3, r5, r6, r8, r9, sl, ip, sp, lr}	; <UNPREDICTABLE>
  {
    ADC_ISR[i] = isr_func;
    215c:	70675f77 	rsbvc	r5, r7, r7, ror pc
    2160:	632e6f69 	teqvs	lr, #420	; 0x1a4
    2164:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
    2168:	50475f44 	subpl	r5, r7, r4, asr #30
  }
  
  return 1;
    216c:	495f4f49 	ldmdbmi	pc, {r0, r3, r6, r8, r9, sl, fp, lr}^	; <UNPREDICTABLE>
}
    2170:	7475706e 	ldrbtvc	r7, [r5], #-110	; 0x6e
    2174:	54504c00 	ldrbpl	r4, [r0], #-3072	; 0xc00
    2178:	495f524d 	ldmdbmi	pc, {r0, r2, r3, r6, r9, ip, lr}^	; <UNPREDICTABLE>
    217c:	5474696e 	ldrbtpl	r6, [r4], #-2414	; 0x96e
 * 输出:
 *    0--配置错误
 *    1--配置成功
 */
uint8 LPLD_ADC_Deinit(ADC_InitTypeDef adc_init_structure)
{
    2180:	44657079 	strbtmi	r7, [r5], #-121	; 0x79
    2184:	4c006665 	stcmi	6, cr6, [r0], {101}	; 0x65
    2188:	524d5450 	subpl	r5, sp, #1342177280	; 0x50000000
    218c:	756c505f 	strbvc	r5, [ip, #-95]!	; 0x5f
  ADC_MemMapPtr adcx = adc_init_structure.ADC_Adcx;
    2190:	63416573 	movtvs	r6, #5491	; 0x1573
  uint8 hwtrg = adc_init_structure.ADC_HwTrgCfg;
    2194:	706e4963 	rsbvc	r4, lr, r3, ror #18
  
  adcx->SC1[hwtrg & 0x01] = ADC_SC1_ADCH(AD31);    //复位SC1
    2198:	4c007475 	cfstrsmi	mvf7, [r0], {117}	; 0x75
    219c:	524d5450 	subpl	r5, sp, #1342177280	; 0x50000000
    21a0:	7265505f 	rsbvc	r5, r5, #95	; 0x5f
    21a4:	4d646f69 	stclmi	15, cr6, [r4, #-420]!	; 0xfffffe5c
  
  //配置ADC时钟
  if(adcx == ADC0)
    21a8:	534f0073 	movtpl	r0, #61555	; 0xf073
    21ac:	654d5f43 	strbvs	r5, [sp, #-3907]	; 0xf43
    21b0:	70614d6d 	rsbvc	r4, r1, sp, ror #26
    21b4:	54504c00 	ldrbpl	r4, [r0], #-3072	; 0xc00
  {
    SIM_SCGC6 &= ~(SIM_SCGC6_ADC0_MASK);   // 关闭ADC0时钟
    21b8:	495f524d 	ldmdbmi	pc, {r0, r2, r3, r6, r9, ip, lr}^	; <UNPREDICTABLE>
    21bc:	6e45746e 	cdpvs	4, 4, cr7, cr5, cr14, {3}
    21c0:	656c6261 	strbvs	r6, [ip, #-609]!	; 0x261
    21c4:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
    21c8:	504c5f44 	subpl	r5, ip, r4, asr #30
    21cc:	5f524d54 	svcpl	0x00524d54
    21d0:	616c6544 	cmnvs	ip, r4, asr #10
    21d4:	00734d79 	rsbseq	r4, r3, r9, ror sp
    21d8:	444c504c 	strbmi	r5, [ip], #-76	; 0x4c
    21dc:	54504c5f 	ldrbpl	r4, [r0], #-3167	; 0xc5f
  }
  else if(adcx == ADC1)
    21e0:	475f524d 	ldrbmi	r5, [pc, -sp, asr #4]
    21e4:	75507465 	ldrbvc	r7, [r0, #-1125]	; 0x465
    21e8:	4165736c 	cmnmi	r5, ip, ror #6
    21ec:	4c006363 	stcmi	3, cr6, [r0], {99}	; 0x63
  {
    SIM_SCGC3 &= ~(SIM_SCGC3_ADC1_MASK);   // 关闭ADC1时钟
    21f0:	5f444c50 	svcpl	0x00444c50
    21f4:	4d54504c 	ldclmi	0, cr5, [r4, #-304]	; 0xfffffed0
    21f8:	65445f52 	strbvs	r5, [r4, #-3922]	; 0xf52
    21fc:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xe69
    2200:	2f2e2e00 	svccs	0x002e2e00
    2204:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; 2154 <LPLD_ADC_Init+0x1a0>
    2208:	682f6269 	stmdavs	pc!, {r0, r3, r5, r6, r9, sp, lr}	; <UNPREDICTABLE>
    220c:	77682f77 			; <UNDEFINED> instruction: 0x77682f77
    2210:	74706c5f 	ldrbtvc	r6, [r0], #-3167	; 0xc5f
    2214:	632e726d 	teqvs	lr, #-805306362	; 0xd0000006
  }
  else 
  {
    return 0;
    2218:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
    221c:	504c5f44 	subpl	r5, ip, r4, asr #30
  }
  
  return 1;
    2220:	5f524d54 	svcpl	0x00524d54
}
    2224:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
    2228:	54504c00 	ldrbpl	r4, [r0], #-3072	; 0xc00
    222c:	495f524d 	ldmdbmi	pc, {r0, r2, r3, r6, r9, ip, lr}^	; <UNPREDICTABLE>
 * 输出:
 *    AD通道转换值(右对齐)，若为差分转换结果，则为二进制补码格式(需强制转换为int16)
 *
 */
uint16 LPLD_ADC_Get(ADC_MemMapPtr adcx, AdcChnEnum_Type chn)
{
    2230:	4f005253 	svcmi	0x00005253
    2234:	4d5f4353 	ldclmi	3, cr4, [pc, #-332]	; 20f0 <LPLD_ADC_Init+0x13c>
    2238:	614d6d65 	cmpvs	sp, r5, ror #26
  adcx->SC1[0] &= ~(ADC_SC1_AIEN_MASK);
    223c:	72745070 	rsbsvc	r5, r4, #112	; 0x70
    2240:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
    2244:	504c5f44 	subpl	r5, ip, r4, asr #30
  adcx->SC1[0] &= ~(ADC_SC1_ADCH_MASK);
    2248:	5f524d54 	svcpl	0x00524d54
    224c:	62616e45 	rsbvs	r6, r1, #1104	; 0x450
    2250:	7249656c 	subvc	r6, r9, #452984832	; 0x1b000000
  adcx->SC1[0] |= ADC_SC1_ADCH(chn);
    2254:	504c0071 	subpl	r0, ip, r1, ror r0
    2258:	4c5f444c 	cfldrdmi	mvd4, [pc], {76}	; 0x4c
    225c:	524d5450 	subpl	r5, sp, #1342177280	; 0x50000000
    2260:	7369445f 	cmnvc	r9, #1593835520	; 0x5f000000
  while((adcx->SC1[0]&ADC_SC1_COCO_MASK) == 0); //等待转换完成  
    2264:	656c6261 	strbvs	r6, [ip, #-609]!	; 0x261
    2268:	00717249 	rsbseq	r7, r1, r9, asr #4
    226c:	6d74706c 	ldclvs	0, cr7, [r4, #-432]!	; 0xfffffe50
    2270:	6e695f72 	mcrvs	15, 3, r5, cr9, cr2, {3}
  return adcx->R[0];
    2274:	735f7469 	cmpvc	pc, #1761607680	; 0x69000000
}
    2278:	63757274 	cmnvs	r5, #1073741831	; 0x40000007
    227c:	65727574 	ldrbvs	r7, [r2, #-1396]!	; 0x574
    2280:	54504c00 	ldrbpl	r4, [r0], #-3072	; 0xc00
 * 输出:
 *    无
 *
 */
void LPLD_ADC_EnableConversion(ADC_MemMapPtr adcx, AdcChnEnum_Type chn, uint8 ab, boolean irq)
{
    2284:	4d5f524d 	lfmmi	f5, 2, [pc, #-308]	; 2158 <LPLD_ADC_Init+0x1a4>
    2288:	614d6d65 	cmpvs	sp, r5, ror #26
    228c:	72745070 	rsbsvc	r5, r4, #112	; 0x70
    2290:	54504c00 	ldrbpl	r4, [r0], #-3072	; 0xc00
  if(irq == TRUE)
    2294:	495f524d 	ldmdbmi	pc, {r0, r2, r3, r6, r9, ip, lr}^	; <UNPREDICTABLE>
  {
    adcx->SC1[ab] |= (ADC_SC1_AIEN_MASK);
    2298:	4c007273 	sfmmi	f7, 4, [r0], {115}	; 0x73
    229c:	524d5450 	subpl	r5, sp, #1342177280	; 0x50000000
    22a0:	6d654d5f 	stclvs	13, cr4, [r5, #-380]!	; 0xfffffe84
    22a4:	0070614d 	rsbseq	r6, r0, sp, asr #2
    22a8:	69726570 	ldmdbvs	r2!, {r4, r5, r6, r8, sl, sp, lr}^
  }
  adcx->SC1[ab] &= ~(ADC_SC1_ADCH_MASK);
    22ac:	6d5f646f 	cfldrdvs	mvd6, [pc, #-444]	; 20f8 <LPLD_ADC_Init+0x144>
    22b0:	504c0073 	subpl	r0, ip, r3, ror r0
    22b4:	5f524d54 	svcpl	0x00524d54
    22b8:	65646f4d 	strbvs	r6, [r4, #-3917]!	; 0xf4d
    22bc:	54504c00 	ldrbpl	r4, [r0], #-3072	; 0xc00
  adcx->SC1[ab] |= ADC_SC1_ADCH(chn);
    22c0:	495f524d 	ldmdbmi	pc, {r0, r2, r3, r6, r9, ip, lr}^	; <UNPREDICTABLE>
    22c4:	435f5253 	cmpmi	pc, #805306373	; 0x30000005
    22c8:	424c4c41 	submi	r4, ip, #16640	; 0x4100
    22cc:	004b4341 	subeq	r4, fp, r1, asr #6
    22d0:	5f54504c 	svcpl	0x0054504c
    22d4:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
}
    22d8:	6c646e61 	stclvs	14, cr6, [r4], #-388	; 0xfffffe7c
    22dc:	4c007265 	sfmmi	f7, 4, [r0], {101}	; 0x65
    22e0:	5f444c50 	svcpl	0x00444c50
 * 输出:
 *    AD通道转换值(右对齐)，若为差分转换结果，则为二进制补码格式(需强制转换为int16)
 *
 */
uint16 LPLD_ADC_GetResult(ADC_MemMapPtr adcx, uint8 ab)
{
    22e4:	4d54504c 	ldclmi	0, cr5, [r4, #-304]	; 0xfffffed0
    22e8:	65525f52 	ldrbvs	r5, [r2, #-3922]	; 0xf52
    22ec:	43746573 	cmnmi	r4, #482344960	; 0x1cc00000
  //参数检查
  return adcx->R[ab];
    22f0:	746e756f 	strbtvc	r7, [lr], #-1391	; 0x56f
    22f4:	70007265 	andvc	r7, r0, r5, ror #4
    22f8:	6573756c 	ldrbvs	r7, [r3, #-1388]!	; 0x56c
    22fc:	5f636361 	svcpl	0x00636361
}
    2300:	75706e69 	ldrbvc	r6, [r0, #-3689]!	; 0xe69
    2304:	756f0074 	strbvc	r0, [pc, #-116]!	; 2298 <LPLD_ADC_EnableConversion+0x14>
    2308:	76696474 			; <UNDEFINED> instruction: 0x76696474
*    0--SC1A寄存器COCO位置1
*    1--SC1B寄存器COCO位置1
 *
 */
uint8 LPLD_ADC_GetSC1nCOCO(ADC_MemMapPtr adcx)
{
    230c:	756f0031 	strbvc	r0, [pc, #-49]!	; 22e3 <LPLD_ADC_EnableConversion+0x5f>
    2310:	76696474 			; <UNDEFINED> instruction: 0x76696474
  if(adcx->SC1[0] & ADC_SC1_COCO_MASK)
    2314:	756f0032 	strbvc	r0, [pc, #-50]!	; 22ea <LPLD_ADC_GetResult+0x6>
    2318:	76696474 			; <UNDEFINED> instruction: 0x76696474
    231c:	6f630034 	svcvs	0x00630034
    return 0;
    2320:	645f6572 	ldrbvs	r6, [pc], #-1394	; 2328 <LPLD_ADC_GetSC1nCOCO+0x1c>
    2324:	2e007669 	cfmadd32cs	mvax3, mvfx7, mvfx0, mvfx9
  if(adcx->SC1[1] & ADC_SC1_COCO_MASK)
    2328:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    232c:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
    2330:	2f77682f 	svccs	0x0077682f
    return 1;
    2334:	6d5f7768 	ldclvs	7, cr7, [pc, #-416]	; 219c <LPLD_ADC_Deinit+0x1c>
  return -1;
    2338:	632e6763 	teqvs	lr, #25952256	; 0x18c0000
}
    233c:	6d657400 	cfstrdvs	mvd7, [r5, #-0]
    2340:	65725f70 	ldrbvs	r5, [r2, #-3952]!	; 0xf70
    2344:	41440067 	cmpmi	r4, r7, rrx
 *    0--配置错误
 *    1--配置成功
 *
 */
uint8 LPLD_ADC_EnableIrq(ADC_InitTypeDef adc_init_structure)
{
    2348:	4d5f4154 	ldfmie	f4, [pc, #-336]	; 2200 <LPLD_ADC_Deinit+0x80>
    234c:	46500055 			; <UNDEFINED> instruction: 0x46500055
    2350:	00525041 	subseq	r5, r2, r1, asr #32
    2354:	5f434d46 	svcpl	0x00434d46
  ADC_MemMapPtr adcx = adc_init_structure.ADC_Adcx;
    2358:	4d6d654d 	cfstr64mi	mvdx6, [sp, #-308]!	; 0xfffffecc
  
  if(adcx == ADC0)
    235c:	66007061 	strvs	r7, [r0], -r1, rrx
    2360:	6873616c 	ldmdavs	r3!, {r2, r3, r5, r6, r8, sp, lr}^
    2364:	7669645f 			; <UNDEFINED> instruction: 0x7669645f
    2368:	726f6300 	rsbvc	r6, pc, #0
    enable_irq(INT_ADC0 - 16);
    236c:	6c635f65 	stclvs	15, cr5, [r3], #-404	; 0xfffffe6c
    2370:	686d5f6b 	stmdavs	sp!, {r0, r1, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
  else if(adcx == ADC1)
    2374:	6c66007a 	stclvs	0, cr0, [r6], #-488	; 0xfffffe18
    2378:	75627865 	strbvc	r7, [r2, #-2149]!	; 0x865
    237c:	69645f73 	stmdbvs	r4!, {r0, r1, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    2380:	41540076 	cmpmi	r4, r6, ror r0
    enable_irq (INT_ADC1 - 16);
    2384:	00445647 	subeq	r5, r4, r7, asr #12
    2388:	41544144 	cmpmi	r4, r4, asr #2
  else
    return 0;
    238c:	004d555f 	subeq	r5, sp, pc, asr r5
    2390:	4f6c6c50 	svcmi	0x006c6c50
  return 1;
    2394:	6f697470 	svcvs	0x00697470
}
    2398:	756e456e 	strbvc	r4, [lr, #-1390]!	; 0x56e
    239c:	79545f6d 	ldmdbvc	r4, {r0, r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    23a0:	50006570 	andpl	r6, r0, r0, ror r5
    23a4:	31304246 	teqcc	r0, r6, asr #4
 *    0--配置错误
 *    1--配置成功
 *
 */
uint8 LPLD_ADC_DisableIrq(ADC_InitTypeDef adc_init_structure)
{
    23a8:	44005243 	strmi	r5, [r0], #-579	; 0x243
    23ac:	5f415441 	svcpl	0x00415441
    23b0:	70004d4c 	andvc	r4, r0, ip, asr #26
    23b4:	76696472 			; <UNDEFINED> instruction: 0x76696472
  ADC_MemMapPtr adcx = adc_init_structure.ADC_Adcx;
    23b8:	54414400 	strbpl	r4, [r1], #-1024	; 0x400
  
  if(adcx == ADC0)
    23bc:	4c4d5f41 	mcrrmi	15, 4, r5, sp, cr1
    23c0:	69647600 	stmdbvs	r4!, {r9, sl, ip, sp, lr}^
    23c4:	504c0076 	subpl	r0, ip, r6, ror r0
    23c8:	505f444c 	subspl	r4, pc, ip, asr #8
      disable_irq(INT_ADC0 - 16);
    23cc:	535f4c4c 	cmppl	pc, #19456	; 0x4c00
    23d0:	70757465 	rsbsvc	r7, r5, r5, ror #8
  else if(adcx == ADC1)
    23d4:	74756f00 	ldrbtvc	r6, [r5], #-3840	; 0xf00
    23d8:	33766964 	cmncc	r6, #1638400	; 0x190000
    23dc:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
    23e0:	65535f44 	ldrbvs	r5, [r3, #-3908]	; 0xf44
      disable_irq(INT_ADC1 - 16);
    23e4:	59535f74 	ldmdbpl	r3, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    23e8:	49445f53 	stmdbmi	r4, {r0, r1, r4, r6, r8, r9, sl, fp, ip, lr}^
  else
    return 0;
    23ec:	46500056 			; <UNDEFINED> instruction: 0x46500056
    23f0:	43333242 	teqmi	r3, #536870916	; 0x20000004

  return 1;
    23f4:	4d460052 	stclmi	0, cr0, [r6, #-328]	; 0xfffffeb8
}
    23f8:	654d5f43 	strbvs	r5, [sp, #-3907]	; 0xf43
    23fc:	70614d6d 	rsbvc	r4, r1, sp, ror #26
    2400:	00727450 	rsbseq	r7, r2, r0, asr r4
    2404:	5f6c6c70 	svcpl	0x006c6c70
 *    0--配置错误
 *    1--配置成功
 *
 */
uint8 LPLD_ADC_Chn_Enable(ADC_MemMapPtr adcx, AdcChnEnum_Type chn)
{
    2408:	71657266 	cmnvc	r5, r6, ror #4
    240c:	42445000 	submi	r5, r4, #0
    2410:	7165535f 	cmnvc	r5, pc, asr r3
  //判断复用引脚是a或b
  uint8 mux = (adcx->CFG2 & ADC_CFG2_MUXSEL_MASK)>>ADC_CFG2_MUXSEL_SHIFT;
    2414:	49727245 	ldmdbmi	r2!, {r0, r2, r6, r9, ip, sp, lr}^
    2418:	6e45746e 	cdpvs	4, 4, cr7, cr5, cr14, {3}
    241c:	656c6261 	strbvs	r6, [ip, #-609]!	; 0x261
    2420:	42445000 	submi	r5, r4, #0
    
  if(chn > AD30)
    2424:	756f435f 	strbvc	r4, [pc, #-863]!	; 20cd <LPLD_ADC_Init+0x119>
    return 0;
    2428:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
    242c:	69726550 	ldmdbvs	r2!, {r4, r6, r8, sl, sp, lr}^
  
  //不同的通道对应不同的引脚，因此需要判断并配置
  if(adcx == ADC0)
    2430:	734d646f 	movtvc	r6, #54383	; 0xd46f
    2434:	42445000 	submi	r5, r4, #0
    2438:	6d654d5f 	stclvs	13, cr4, [r5, #-380]!	; 0xfffffe84
    243c:	0070614d 	rsbseq	r6, r0, sp, asr #2
  {
    switch(chn)
    2440:	5f424450 	svcpl	0x00424450
    2444:	5f525349 	svcpl	0x00525349
    2448:	4c4c4143 	stfmie	f4, [ip], {67}	; 0x43
    244c:	4b434142 	blmi	10d295c <__etext+0x10c9cb4>
    2450:	42445000 	submi	r5, r4, #0
    2454:	52495f30 	subpl	r5, r9, #192	; 0xc0
    2458:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
    245c:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
    2460:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
    2464:	44505f44 	ldrbmi	r5, [r0], #-3908	; 0xf44
    2468:	64415f42 	strbvs	r5, [r1], #-3906	; 0xf42
    246c:	69725463 	ldmdbvs	r2!, {r0, r1, r5, r6, sl, ip, lr}^
    2470:	72656767 	rsbvc	r6, r5, #27000832	; 0x19c0000
    2474:	00676643 	rsbeq	r6, r7, r3, asr #12
    2478:	5f424450 	svcpl	0x00424450
    247c:	616c6544 	cmnvs	ip, r4, asr #10
    2480:	00735579 	rsbseq	r5, r3, r9, ror r5
    2484:	5f737562 	svcpl	0x00737562
    2488:	006b6c63 	rsbeq	r6, fp, r3, ror #24
    248c:	5f424450 	svcpl	0x00424450
    2490:	616c6544 	cmnvs	ip, r4, asr #10
    2494:	00734d79 	rsbseq	r4, r3, r9, ror sp
    2498:	48544144 	ldmdami	r4, {r2, r6, r8, lr}^
    249c:	54414400 	strbpl	r4, [r1], #-1024	; 0x400
    24a0:	4144004c 	cmpmi	r4, ip, asr #32
    24a4:	654d5f43 	strbvs	r5, [sp, #-3907]	; 0xf43
    24a8:	70614d6d 	rsbvc	r4, r1, sp, ror #26
    24ac:	00727450 	rsbseq	r7, r2, r0, asr r4
    24b0:	43544e49 	cmpmi	r4, #1168	; 0x490
    24b4:	42445000 	submi	r5, r4, #0
    24b8:	5f45535f 	svcpl	0x0045535f
    24bc:	00525349 	subseq	r5, r2, r9, asr #6
    24c0:	746c756d 	strbtvc	r7, [ip], #-1389	; 0x56d
    24c4:	42445000 	submi	r5, r4, #0
      case DAD1:   //ADC0_DP1 -- PGA2_DP
      case DAD2:   //PGA0_DP
      case DAD3:   //ADC0_DP3 -- PGA1_DP
        break;
      case AD4:   //ADC0_SE4b -- PTC2     
        if(mux == 1)    //b
    24c8:	6d654d5f 	stclvs	13, cr4, [r5, #-380]!	; 0xfffffe84
    24cc:	5070614d 	rsbspl	r6, r0, sp, asr #2
          PORTC->PCR[2] =  PORT_PCR_MUX(0);
    24d0:	64007274 	strvs	r7, [r0], #-628	; 0x274
    24d4:	00786361 	rsbseq	r6, r8, r1, ror #6
    24d8:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    24dc:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
        break;
      case AD5:   //ADC0_SE5b -- PTD1     
        if(mux == 1)    //b
    24e0:	77682f62 	strbvc	r2, [r8, -r2, ror #30]!
    24e4:	5f77682f 	svcpl	0x0077682f
          PORTD->PCR[1] =  PORT_PCR_MUX(0);
    24e8:	2e626470 	mcrcs	4, 3, r6, cr2, cr0, {3}
    24ec:	72740063 	rsbsvc	r0, r4, #99	; 0x63
    24f0:	65676972 	strbvs	r6, [r7, #-2418]!	; 0x972
    24f4:	64700072 	ldrbtvs	r0, [r0], #-114	; 0x72
        break;
      case AD6:   //ADC0_SE6b -- PTD5
      case AD7:   //ADC0_SE7b -- PTD6     
        if(mux == 1)    //b
    24f8:	6e695f62 	cdpvs	15, 6, cr5, cr9, cr2, {3}
    24fc:	735f7469 	cmpvc	pc, #1761607680	; 0x69000000
          PORTD->PCR[chn-1] =  PORT_PCR_MUX(0);
    2500:	63757274 	cmnvs	r5, #1073741831	; 0x40000007
    2504:	6c660074 	stclvs	0, cr0, [r6], #-464	; 0xfffffe30
    2508:	3374616f 	cmncc	r4, #-1073741797	; 0xc000001b
    250c:	65640032 	strbvs	r0, [r4, #-50]!	; 0x32
    2510:	7579616c 	ldrbvc	r6, [r9, #-364]!	; 0x16c
    2514:	44500073 	ldrbmi	r0, [r0], #-115	; 0x73
        break;
      case AD8:  //ADC0_SE8 -- PTB0
      case AD9:  //ADC0_SE9 -- PTB1
        PORTB->PCR[chn-8] =  PORT_PCR_MUX(0);
    2518:	6f435f42 	svcvs	0x00435f42
    251c:	6e69746e 	cdpvs	4, 6, cr7, cr9, cr14, {3}
    2520:	73756f75 	cmnvc	r5, #468	; 0x1d4
    2524:	65646f4d 	strbvs	r6, [r4, #-3917]!	; 0xf4d
    2528:	62616e45 	rsbvs	r6, r1, #1104	; 0x450
    252c:	5000656c 	andpl	r6, r0, ip, ror #10
        break;
      case AD10:  //ADC0_SE10 -- PTA7
      case AD11:  //ADC0_SE11 -- PTA8
        PORTA->PCR[chn-3] =  PORT_PCR_MUX(0);
    2530:	4c5f4244 	lfmmi	f4, 2, [pc], {68}	; 0x44
    2534:	4d64616f 	stfmie	f6, [r4, #-444]!	; 0xfffffe44
    2538:	5365646f 	cmnpl	r5, #1862270976	; 0x6f000000
    253c:	4c006c65 	stcmi	12, cr6, [r0], {101}	; 0x65
    2540:	5f444c50 	svcpl	0x00444c50
    2544:	5f424450 	svcpl	0x00424450
        break;
      case AD12:  //ADC0_SE12 -- PTB2
      case AD13:  //ADC0_SE13 -- PTB3
        PORTB->PCR[chn-10] =  PORT_PCR_MUX(0);
    2548:	54636144 	strbtpl	r6, [r3], #-324	; 0x144
    254c:	67676972 			; <UNDEFINED> instruction: 0x67676972
    2550:	66437265 	strbvs	r7, [r3], -r5, ror #4
    2554:	44500067 	ldrbmi	r0, [r0], #-103	; 0x67
    2558:	6d445f42 	stclvs	15, cr5, [r4, #-264]	; 0xfffffef8
    255c:	616e4561 	cmnvs	lr, r1, ror #10
        break;
      case AD14:  //ADC0_SE14 -- PTC0
      case AD15:  //ADC0_SE15 -- PTC1
        PORTC->PCR[chn-14] =  PORT_PCR_MUX(0);
    2560:	00656c62 	rsbeq	r6, r5, r2, ror #24
    2564:	5f424450 	svcpl	0x00424450
    2568:	616c6544 	cmnvs	ip, r4, asr #10
    256c:	50005379 	andpl	r5, r0, r9, ror r3
    2570:	495f4244 	ldmdbmi	pc, {r2, r6, r9, lr}^	; <UNPREDICTABLE>
    2574:	50005253 	andpl	r5, r0, r3, asr r2
        break;
      case AD16:   //ADC0_SE16
        break;
      case AD17:   //ADC0_SE17 -- PTE24
      case AD18:   //ADC0_SE18 -- PTE25
        PORTE->PCR[chn+7] =  PORT_PCR_MUX(0);
    2578:	435f4244 	cmpmi	pc, #1073741828	; 0x40000004
    257c:	746e756f 	strbtvc	r7, [lr], #-1391	; 0x56f
    2580:	65507265 	ldrbvs	r7, [r0, #-613]	; 0x265
    2584:	646f6972 	strbtvs	r6, [pc], #-2418	; 258c <LPLD_ADC_Chn_Enable+0x184>
    2588:	50007355 	andpl	r7, r0, r5, asr r3
    258c:	545f4244 	ldrbpl	r4, [pc], #-580	; 2594 <LPLD_ADC_Chn_Enable+0x18c>
        break;
    2590:	67676972 			; <UNDEFINED> instruction: 0x67676972
      case AD27:   //Bandgap (S.E)
      case AD29:   //VREFH (S.E)
      case AD30:   //VREFL
        break;
      default:
        return 0;  
    2594:	6e497265 	cdpvs	2, 4, cr7, cr9, cr5, {3}
    }
  }
  else if(adcx == ADC1)
    2598:	53747570 	cmnpl	r4, #469762048	; 0x1c000000
    259c:	6372756f 	cmnvs	r2, #465567744	; 0x1bc00000
    25a0:	6c655365 	stclvs	3, cr5, [r5], #-404	; 0xfffffe6c
    25a4:	65727000 	ldrbvs	r7, [r2, #-0]!
  {
    switch(chn)
    25a8:	6c616373 	stclvs	3, cr6, [r1], #-460	; 0xfffffe34
    25ac:	50007265 	andpl	r7, r0, r5, ror #4
    25b0:	495f4244 	ldmdbmi	pc, {r2, r6, r9, lr}^	; <UNPREDICTABLE>
    25b4:	5474696e 	ldrbtpl	r6, [r4], #-2414	; 0x96e
    25b8:	44657079 	strbtmi	r7, [r5], #-121	; 0x79
    25bc:	50006665 	andpl	r6, r0, r5, ror #12
    25c0:	004e454f 	subeq	r4, lr, pc, asr #10
    25c4:	4c444f50 	mcrrmi	15, 5, r4, r4, cr0
    25c8:	44500059 	ldrbmi	r0, [r0], #-89	; 0x59
    25cc:	73495f42 	movtvc	r5, #40770	; 0x9f42
    25d0:	44490072 	strbmi	r0, [r9], #-114	; 0x72
    25d4:	4400594c 	strmi	r5, [r0], #-2380	; 0x94c
    25d8:	4d5f4341 	ldclmi	3, cr4, [pc, #-260]	; 24dc <LPLD_ADC_Chn_Enable+0xd4>
    25dc:	614d6d65 	cmpvs	sp, r5, ror #26
    25e0:	64700070 	ldrbtvs	r0, [r0], #-112	; 0x70
    25e4:	63735f62 	cmnvs	r3, #392	; 0x188
    25e8:	6c756d5f 	ldclvs	13, cr6, [r5], #-380	; 0xfffffe84
    25ec:	50007374 	andpl	r7, r0, r4, ror r3
    25f0:	535f4244 	cmppl	pc, #1073741828	; 0x40000004
    25f4:	72457165 	subvc	r7, r5, #1073741849	; 0x40000019
    25f8:	72734972 	rsbsvc	r4, r3, #1867776	; 0x1c8000
    25fc:	42445000 	submi	r5, r4, #0
    2600:	756f435f 	strbvc	r4, [pc, #-863]!	; 22a9 <LPLD_ADC_EnableConversion+0x25>
    2604:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
    2608:	69726550 	ldmdbvs	r2!, {r4, r6, r8, sl, sp, lr}^
    260c:	0053646f 	subseq	r6, r3, pc, ror #8
    2610:	444c504c 	strbmi	r5, [ip], #-76	; 0x4c
    2614:	4244505f 	submi	r5, r4, #95	; 0x5f
    2618:	696e495f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, lr}^
    261c:	504c0074 	subpl	r0, ip, r4, ror r0
    2620:	505f444c 	subspl	r4, pc, ip, asr #8
    2624:	445f4244 	ldrbmi	r4, [pc], #-580	; 262c <LPLD_ADC_Chn_Enable+0x224>
    2628:	696e6965 	stmdbvs	lr!, {r0, r2, r5, r6, r8, fp, sp, lr}^
    262c:	44500074 	ldrbmi	r0, [r0], #-116	; 0x74
    2630:	6e495f42 	cdpvs	15, 4, cr5, cr9, cr2, {2}
        break;
      case AD4:   //ADC1_SE4a -- PTE0     //ADC1_SE4b -- PTC8
      case AD5:   //ADC1_SE5a -- PTE1     //ADC1_SE5b -- PTC9
      case AD6:   //ADC1_SE6a -- PTE2     //ADC1_SE6b -- PTC10
      case AD7:   //ADC1_SE7a -- PTE3     //ADC1_SE7b -- PTC11
        if(mux == 0)    //a
    2634:	616e4574 	smcvs	58452	; 0xe454
    2638:	00656c62 	rsbeq	r6, r5, r2, ror #24
          PORTE->PCR[chn-4] =  PORT_PCR_MUX(0);
    263c:	64616f6c 	strbtvs	r6, [r1], #-3948	; 0xf6c
    2640:	65646f6d 	strbvs	r6, [r4, #-3949]!	; 0xf6d
    2644:	746e6900 	strbtvc	r6, [lr], #-2304	; 0x900
    2648:	6c65645f 	cfstrdvs	mvd6, [r5], #-380	; 0xfffffe84
    264c:	50007961 	andpl	r7, r0, r1, ror #18
        else            //b
          PORTC->PCR[chn+4] =  PORT_PCR_MUX(0);
        break;
    2650:	5f315449 	svcpl	0x00315449
      case AD6:   //ADC1_SE6a -- PTE2     //ADC1_SE6b -- PTC10
      case AD7:   //ADC1_SE7a -- PTE3     //ADC1_SE7b -- PTC11
        if(mux == 0)    //a
          PORTE->PCR[chn-4] =  PORT_PCR_MUX(0);
        else            //b
          PORTC->PCR[chn+4] =  PORT_PCR_MUX(0);
    2654:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
    2658:	6c646e61 	stclvs	14, cr6, [r4], #-388	; 0xfffffe7c
    265c:	4c007265 	sfmmi	f7, 4, [r0], {101}	; 0x65
    2660:	4c415644 	mcrrmi	6, 4, r5, r1, cr4
    2664:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
        break;
    2668:	49505f44 	ldmdbmi	r0, {r2, r6, r8, r9, sl, fp, ip, lr}^
      case AD8:  //ADC1_SE8 -- PTB0
      case AD9:  //ADC1_SE9 -- PTB1
        PORTB->PCR[chn-8] =  PORT_PCR_MUX(0);
    266c:	65445f54 	strbvs	r5, [r4, #-3924]	; 0xf54
    2670:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xe69
    2674:	54495000 	strbpl	r5, [r9], #-0
    2678:	5253495f 	subspl	r4, r3, #1556480	; 0x17c000
    267c:	4c41435f 	mcrrmi	3, 5, r4, r1, cr15
        break;
    2680:	4341424c 	movtmi	r4, #4684	; 0x124c
      case AD10:  //ADC1_SE10 -- PTB4
      case AD11:  //ADC1_SE11 -- PTB5
      case AD12:  //ADC1_SE12 -- PTB6
      case AD13:  //ADC1_SE13 -- PTB7
        PORTB->PCR[chn-6] =  PORT_PCR_MUX(0);
    2684:	504c004b 	subpl	r0, ip, fp, asr #32
    2688:	505f444c 	subspl	r4, pc, ip, asr #8
    268c:	495f5449 	ldmdbmi	pc, {r0, r3, r6, sl, ip, lr}^	; <UNPREDICTABLE>
    2690:	0074696e 	rsbseq	r6, r4, lr, ror #18
    2694:	444c504c 	strbmi	r5, [ip], #-76	; 0x4c
        break;
    2698:	5449505f 	strbpl	r5, [r9], #-95	; 0x5f
      case AD14:  //ADC1_SE14 -- PTB10
      case AD15:  //ADC1_SE15 -- PTB11
        PORTB->PCR[chn-4] =  PORT_PCR_MUX(0);
    269c:	6d69545f 	cfstrdvs	mvd5, [r9, #-380]!	; 0xfffffe84
    26a0:	74654765 	strbtvc	r4, [r5], #-1893	; 0x765
    26a4:	4c007355 	stcmi	3, cr7, [r0], {85}	; 0x55
    26a8:	5f444c50 	svcpl	0x00444c50
    26ac:	5f544950 	svcpl	0x00544950
        break;
    26b0:	656d6954 	strbvs	r6, [sp, #-2388]!	; 0x954
      case AD16:   //ADC1_SE16
        break;
      case AD17:  //ADC1_SE17 -- PTA17
        PORTA->PCR[chn] =  PORT_PCR_MUX(0);
    26b4:	72617453 	rsbvc	r7, r1, #1392508928	; 0x53000000
    26b8:	49500074 	ldmdbmi	r0, {r2, r4, r5, r6}^
    26bc:	6e495f54 	mcrvs	15, 2, r5, cr9, cr4, {2}
    26c0:	79547469 	ldmdbvc	r4, {r0, r3, r5, r6, sl, ip, sp, lr}^
        break;
    26c4:	65446570 	strbvs	r6, [r4, #-1392]	; 0x570
      case AD27:   //Bandgap (S.E)
      case AD29:   //VREFH (S.E)
      case AD30:   //VREFL
        break;
      default:
        return 0;  
    26c8:	49500066 	ldmdbmi	r0, {r1, r2, r5, r6}^
    26cc:	73495f54 	movtvc	r5, #40788	; 0x9f54
    }
  }
  else
  {
    return 0;
    26d0:	49500072 	ldmdbmi	r0, {r1, r4, r5, r6}^
    {
      case DAD0:   //ADC0_DP0 -- PGA0_DP
      case DAD1:   //ADC0_DP1 -- PGA2_DP
      case DAD2:   //PGA0_DP
      case DAD3:   //ADC0_DP3 -- PGA1_DP
        break;
    26d4:	495f3354 	ldmdbmi	pc, {r2, r4, r6, r8, r9, ip, sp}^	; <UNPREDICTABLE>
      case AD4:   //ADC0_SE4b -- PTC2     
        if(mux == 1)    //b
          PORTC->PCR[2] =  PORT_PCR_MUX(0);
        break;
    26d8:	61485152 	cmpvs	r8, r2, asr r1
      case AD5:   //ADC0_SE5b -- PTD1     
        if(mux == 1)    //b
          PORTD->PCR[1] =  PORT_PCR_MUX(0);
        break;
    26dc:	656c646e 	strbvs	r6, [ip, #-1134]!	; 0x46e
      case AD6:   //ADC0_SE6b -- PTD5
      case AD7:   //ADC0_SE7b -- PTD6     
        if(mux == 1)    //b
          PORTD->PCR[chn-1] =  PORT_PCR_MUX(0);
        break;
    26e0:	49500072 	ldmdbmi	r0, {r1, r4, r5, r6}^
    {
      case DAD0:   //ADC1_DP0 -- PGA1_DP
      case DAD1:   //ADC1_DP1 -- PGA3_DP
      case DAD2:   //PGA1_DP 
      case DAD3:   //ADC1_DP3 -- PGA0_DP
        break;
    26e4:	654d5f54 	strbvs	r5, [sp, #-3924]	; 0xf54
  else
  {
    return 0;
  }
  
  return 1;
    26e8:	70614d6d 	rsbvc	r4, r1, sp, ror #26
}
    26ec:	00727450 	rsbseq	r7, r2, r0, asr r4
    26f0:	5f544950 	svcpl	0x00544950
    26f4:	78746950 	ldmdavc	r4!, {r4, r6, r8, fp, sp, lr}^
 * 输出:
 *    0--配置错误
 *    1--配置成功
 */
static uint8 LPLD_ADC_Cal(ADC_MemMapPtr adcx)
{
    26f8:	54495000 	strbpl	r5, [r9], #-0
    26fc:	52495f32 	subpl	r5, r9, #200	; 0xc8
  //32次硬件平均、ADCK不超过4MHz
  //参考高=Vdda、正常功耗模式
  //可忽略的配置：
  //输入通道、转换模式连续功能、比较功能、精度、差分单端
  //设置ADCCFG1寄存器
  adcx->CFG1  &= (~ADC_CFG1_ADLPC_MASK);          // 正常功耗配置
    2700:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
    2704:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
    2708:	54495000 	strbpl	r5, [r9], #-0
  adcx->CFG1  |=  ADC_CFG1_ADIV(ADIV_8)          // ADC输入时钟分频为8
    270c:	6d654d5f 	stclvs	13, cr4, [r5, #-380]!	; 0xfffffe84
    2710:	0070614d 	rsbseq	r6, r0, sp, asr #2
    2714:	30544950 	subscc	r4, r4, r0, asr r9
                  | ADC_CFG1_ADLSMP_MASK           // 设置长时间采样模式
                  | ADC_CFG1_ADICLK(ADICLK_BUS_2); // ADC输入时钟源为 BusClk/2

  adcx->CFG2  &= (~ADC_CFG2_ADACKEN_MASK);
    2718:	5152495f 	cmppl	r2, pc, asr r9
    271c:	646e6148 	strbtvs	r6, [lr], #-328	; 0x148
    2720:	0072656c 	rsbseq	r6, r2, ip, ror #10
  adcx->CFG1  |=  ADC_CFG2_ADHSC_MASK         // 高速转换
    2724:	444c504c 	strbmi	r5, [ip], #-76	; 0x4c
    2728:	5449505f 	strbpl	r5, [r9], #-95	; 0x5f
    272c:	6d69545f 	cfstrdvs	mvd5, [r9, #-380]!	; 0xfffffe84
                 | ADC_CFG2_ADLSTS(LSAMTIME_20EX); // 长采样时间时钟周期选择 额外20个时钟周期，共24个ADCK周期
                                               // 总采样周期见K60技术文档 page:840
  //用于设定阈值
  adcx->CV1  = 0x1234u ; 
    2730:	6f6c4365 	svcvs	0x006c4365
    2734:	50006573 	andpl	r6, r0, r3, ror r5
  adcx->CV2  = 0x5678u ;
    2738:	505f5449 	subspl	r5, pc, r9, asr #8
    273c:	6f697265 	svcvs	0x00697265
  
  adcx->SC2 &=  (~ADC_SC2_ADTRG_MASK);        //使能软件触发作为校准
    2740:	6c005364 	stcvs	3, cr5, [r0], {100}	; 0x64
    2744:	6c617664 	stclvs	6, cr7, [r1], #-400	; 0xfffffe70
    2748:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
  adcx->SC2 |=  ADC_SC2_REFSEL(REFSEL_EXT);  //选择外部参考源VREFH和VREFL
    274c:	49505f44 	ldmdbmi	r0, {r2, r6, r8, r9, sl, fp, ip, lr}^
    2750:	6e455f54 	mcrvs	15, 2, r5, cr5, cr4, {2}
    
  adcx->SC3 &= ( ~ADC_SC3_ADCO_MASK & ~ADC_SC3_AVGS_MASK );  //设置单次转换，清除平均标志
    2754:	656c6261 	strbvs	r6, [ip, #-609]!	; 0x261
    2758:	00717249 	rsbseq	r7, r1, r9, asr #4
    275c:	474c4654 	smlsldmi	r4, ip, r4, r6
  adcx->SC3 |= ( ADC_SC3_AVGE_MASK | ADC_SC3_AVGS(HW_32AVG) );//打开平均标志，设置到最大采样平准
    2760:	54495000 	strbpl	r5, [r9], #-0
    2764:	7265505f 	rsbvc	r5, r5, #95	; 0x5f
    2768:	4d646f69 	stclmi	15, cr6, [r4, #-420]!	; 0xfffffe5c
  
  adcx->SC3 |= ADC_SC3_CAL_MASK ;                            //开始校准
    276c:	69700073 	ldmdbvs	r0!, {r0, r1, r4, r5, r6}^
    2770:	6e695f74 	mcrvs	15, 3, r5, cr9, cr4, {3}
    2774:	735f7469 	cmpvc	pc, #1761607680	; 0x69000000
  
  while((adcx->SC1[0] & ADC_SC1_COCO_MASK)== 0x00 );         //等待校准完成
    2778:	63757274 	cmnvs	r5, #1073741831	; 0x40000007
    277c:	65727574 	ldrbvs	r7, [r2, #-1396]!	; 0x574
    2780:	54495000 	strbpl	r5, [r9], #-0
    2784:	5253495f 	subspl	r4, r3, #1556480	; 0x17c000
  	
  if ((adcx->SC3& ADC_SC3_CALF_MASK) == ADC_SC3_CALF_MASK )
    2788:	2f2e2e00 	svccs	0x002e2e00
    278c:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; 26dc <LPLD_ADC_Chn_Enable+0x2d4>
    2790:	682f6269 	stmdavs	pc!, {r0, r3, r5, r6, r9, sp, lr}	; <UNPREDICTABLE>
  {  
   return 0;    //检查到校准错误，返回错误
    2794:	77682f77 			; <UNDEFINED> instruction: 0x77682f77
  }
  // Calculate plus-side calibration
  cal_var  = 0x00;
    2798:	7469705f 	strbtvc	r7, [r9], #-95	; 0x5f
    279c:	4300632e 	movwmi	r6, #814	; 0x32e
  cal_var  = adcx->CLP0;       
    27a0:	004c4156 	subeq	r4, ip, r6, asr r1
  cal_var += adcx->CLP1;      
    27a4:	5f544950 	svcpl	0x00544950
    27a8:	69726550 	ldmdbvs	r2!, {r4, r6, r8, sl, sp, lr}^
    27ac:	7355646f 	cmpvc	r5, #1862270976	; 0x6f000000
  cal_var += adcx->CLP2;      
    27b0:	41484300 	mrsmi	r4, (UNDEF: 120)
    27b4:	4c454e4e 	mcrrmi	14, 4, r4, r5, cr14
    27b8:	54495000 	strbpl	r5, [r9], #-0
  cal_var += adcx->CLP3;      
    27bc:	7469705f 	strbtvc	r7, [r9], #-95	; 0x5f
    27c0:	49500078 	ldmdbmi	r0, {r3, r4, r5, r6}^
    27c4:	4c007854 	stcmi	8, cr7, [r0], {84}	; 0x54
  cal_var += adcx->CLP4;      
    27c8:	5f444c50 	svcpl	0x00444c50
    27cc:	5f544950 	svcpl	0x00544950
    27d0:	61736944 	cmnvs	r3, r4, asr #18
  cal_var += adcx->CLPS;      
    27d4:	49656c62 	stmdbmi	r5!, {r1, r5, r6, sl, fp, sp, lr}^
    27d8:	43007172 	movwmi	r7, #370	; 0x172
    27dc:	5f524154 	svcpl	0x00524154
  cal_var  = cal_var/2;
    27e0:	56414c53 			; <UNDEFINED> instruction: 0x56414c53
    27e4:	2e2e0045 	cdpcs	0, 2, cr0, cr14, cr5, {2}
  cal_var |= 0x8000; // Set MSB
    27e8:	2f2e2e2f 	svccs	0x002e2e2f
    27ec:	2f62696c 	svccs	0x0062696c
    27f0:	682f7768 	stmdavs	pc!, {r3, r5, r6, r8, r9, sl, ip, sp, lr}	; <UNPREDICTABLE>
  
  adcx->PG = ADC_PG_PG(cal_var);
    27f4:	70735f77 	rsbsvc	r5, r3, r7, ror pc
    27f8:	00632e69 	rsbeq	r2, r3, r9, ror #28

  // Calculate minus-side calibration
  cal_var = 0x00;
    27fc:	30495053 	subcc	r5, r9, r3, asr r0
  cal_var =  adcx->CLM0; 
    2800:	5253495f 	subspl	r4, r3, #1556480	; 0x17c000
    2804:	49505300 	ldmdbmi	r0, {r8, r9, ip, lr}^
  cal_var += adcx->CLM1;
    2808:	7363505f 	cmnvc	r3, #95	; 0x5f
    280c:	6e695033 	mcrvs	0, 3, r5, cr9, cr3, {1}
    2810:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
  cal_var += adcx->CLM2;
    2814:	50535f44 	subspl	r5, r3, r4, asr #30
    2818:	614d5f49 	cmpvs	sp, r9, asr #30
    281c:	72657473 	rsbvc	r7, r5, #1929379840	; 0x73000000
  cal_var += adcx->CLM3;
    2820:	6972575f 	ldmdbvs	r2!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, ip, lr}^
    2824:	65526574 	ldrbvs	r6, [r2, #-1396]	; 0x574
    2828:	70006461 	andvc	r6, r0, r1, ror #8
  cal_var += adcx->CLM4;
    282c:	5f347363 	svcpl	0x00347363
    2830:	006e6970 	rsbeq	r6, lr, r0, ror r9
    2834:	30495053 	subcc	r5, r9, r3, asr r0
  cal_var += adcx->CLMS;
    2838:	5152495f 	cmppl	r2, pc, asr r9
    283c:	646e6148 	strbtvs	r6, [lr], #-328	; 0x148
    2840:	0072656c 	rsbseq	r6, r2, ip, ror #10
  cal_var = cal_var/2;
    2844:	5f495053 	svcpl	0x00495053
    2848:	6f73694d 	svcvs	0x0073694d
  cal_var |= 0x8000; // Set MSB
    284c:	006e6950 	rsbeq	r6, lr, r0, asr r9
    2850:	78736370 	ldmdavc	r3!, {r4, r5, r6, r8, r9, sp, lr}^
    2854:	73637000 	cmnvc	r3, #0

  adcx->MG   = ADC_MG_MG(cal_var); 
    2858:	69705f31 	ldmdbvs	r0!, {r0, r4, r5, r8, r9, sl, fp, ip, lr}^
  adcx->SC3 &= ~ADC_SC3_CAL_MASK ; //清除校验标志
    285c:	5053006e 	subspl	r0, r3, lr, rrx
    2860:	63505f49 	cmpvs	r0, #292	; 0x124
    2864:	69503473 	ldmdbvs	r0, {r0, r1, r4, r5, r6, sl, ip, sp}^
  
  return 1;
    2868:	7551006e 	ldrbvc	r0, [r1, #-110]	; 0x6e
}
    286c:	45657565 	strbmi	r7, [r5, #-1381]!	; 0x565
    2870:	525f646e 	subspl	r6, pc, #1845493760	; 0x6e000000
    2874:	65757165 	ldrbvs	r7, [r5, #-357]!	; 0x165
 * 与启动文件startup_K60.s中的中断向量表关联
 * 用户无需修改，程序自动进入对应通道中断函数
 */

void ADC0_IRQHandler(void)
{
    2878:	695f7473 	ldmdbvs	pc, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^	; <UNPREDICTABLE>
    ADC_ISR[0]();
    287c:	5300746e 	movwpl	r7, #1134	; 0x46e
    2880:	525f4950 	subspl	r4, pc, #1310720	; 0x140000
    2884:	46494678 			; <UNDEFINED> instruction: 0x46494678
}
    2888:	72445f4f 	subvc	r5, r4, #316	; 0x13c

void ADC1_IRQHandler(void)
{
    288c:	496e6961 	stmdbmi	lr!, {r0, r5, r6, r8, fp, sp, lr}^
    ADC_ISR[1]();
    2890:	7349746e 	movtvc	r7, #37998	; 0x946e
    2894:	78720072 	ldmdavc	r2!, {r1, r4, r5, r6}^
    2898:	4f464946 	svcmi	0x00464946
}
    289c:	65766f5f 	ldrbvs	r6, [r6, #-3935]!	; 0xf5f
 * :
 *    0--ô
 *    1--óɹ
 */
uint8 LPLD_DMA_Init(DMA_InitTypeDef dma_init_struct)
{
    28a0:	6f6c6672 	svcvs	0x006c6672
    28a4:	6e695f77 	mcrvs	15, 3, r5, cr9, cr7, {3}
    28a8:	504c0074 	subpl	r0, ip, r4, ror r0
    28ac:	535f444c 	cmppl	pc, #1275068416	; 0x4c000000
  uint8 chx = dma_init_struct.DMA_CHx;
    28b0:	4d5f4950 	ldclmi	9, cr4, [pc, #-320]	; 2778 <LPLD_ADC_Cal+0x80>
    28b4:	65747361 	ldrbvs	r7, [r4, #-865]!	; 0x361
  uint8 req = dma_init_struct.DMA_Req;
    28b8:	65525f72 	ldrbvs	r5, [r2, #-3954]	; 0xf72
    28bc:	53006461 	movwpl	r6, #1121	; 0x461
  boolean periodic_trigg = dma_init_struct.DMA_PeriodicTriggerEnable;
    28c0:	455f4950 	ldrbmi	r4, [pc, #-2384]	; 1f78 <LPLD_SCCB_ReceiveByte+0xac>
    28c4:	6c62616e 	stfvse	f6, [r2], #-440	; 0xfffffe48
  uint16 major_cnt = dma_init_struct.DMA_MajorLoopCnt;
    28c8:	46785265 	ldrbtmi	r5, [r8], -r5, ror #4
  uint32 minor_cnt = dma_init_struct.DMA_MinorByteCnt;
    28cc:	004f4649 	subeq	r4, pc, r9, asr #12
  uint32 src_addr = dma_init_struct.DMA_SourceAddr;
    28d0:	5f495053 	svcpl	0x00495053
  uint8 src_dsize = dma_init_struct.DMA_SourceDataSize;
    28d4:	49467854 	stmdbmi	r6, {r2, r4, r6, fp, ip, sp, lr}^
    28d8:	555f4f46 	ldrbpl	r4, [pc, #-3910]	; 199a <get_midline+0x13e>
  int16 src_addroffset = dma_init_struct.DMA_SourceAddrOffset;
    28dc:	7265646e 	rsbvc	r6, r5, #1845493760	; 0x6e000000
  int32 src_lastadj = dma_init_struct.DMA_LastSourceAddrAdj;
    28e0:	776f6c66 	strbvc	r6, [pc, -r6, ror #24]!
  uint32 dst_addr = dma_init_struct.DMA_DestAddr;
    28e4:	45746e49 	ldrbmi	r6, [r4, #-3657]!	; 0xe49
  uint8 dst_dsize = dma_init_struct.DMA_DestDataSize;
    28e8:	6c62616e 	stfvse	f6, [r2], #-440	; 0xfffffe48
    28ec:	50530065 	subspl	r0, r3, r5, rrx
  int16 dst_addroffset = dma_init_struct.DMA_DestAddrOffset;
    28f0:	78525f49 	ldmdavc	r2, {r0, r3, r6, r8, r9, sl, fp, ip, lr}^
  int32 dst_lastadj = dma_init_struct.DMA_LastDestAddrAdj;
    28f4:	4f464946 	svcmi	0x00464946
  boolean auto_disable = dma_init_struct.DMA_AutoDisableReq;
    28f8:	6172445f 	cmnvs	r2, pc, asr r4
    28fc:	6e496e69 	cdpvs	14, 4, cr6, cr9, cr9, {3}
  //ASSERT( src_addr != NULL );      //Դַж
  //ASSERT( (src_dsize <= DMA_SRC_32BIT)||(src_dsize == DMA_SRC_16BYTE) );     //ԴݴСж
  //ASSERT( dst_addr != NULL );      //Ŀĵַж
  //ASSERT( (dst_dsize <= DMA_DST_32BIT)||(dst_dsize == DMA_DST_16BYTE) );     //ĿݴСж
 
  if (chx > DMA_CH15)
    2900:	616e4574 	smcvs	58452	; 0xe454
    2904:	00656c62 	rsbeq	r6, r5, r2, ror #24
    return 0;
    2908:	5f495053 	svcpl	0x00495053
  if (req > DMA_MUX_63)
    290c:	6f437854 	svcvs	0x00437854
    2910:	656c706d 	strbvs	r7, [ip, #-109]!	; 0x6d
    return 0;
    2914:	6e496574 	mcrvs	5, 2, r6, cr9, cr4, {3}
    2918:	72734974 	rsbsvc	r4, r3, #1900544	; 0x1d0000
  if (major_cnt > 0x7FFF)
    291c:	736f6d00 	cmnvc	pc, #0
    2920:	69705f69 	ldmdbvs	r0!, {r0, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    return 0;
    2924:	7073006e 	rsbsvc	r0, r3, lr, rrx
  if (src_addr == 0)
    2928:	53007869 	movwpl	r7, #2153	; 0x869
    292c:	4d5f4950 	ldclmi	9, cr4, [pc, #-320]	; 27f4 <LPLD_ADC_Cal+0xfc>
    return 0;
    2930:	5069736f 	rsbpl	r7, r9, pc, ror #6
  if ((src_dsize > DMA_SRC_32BIT) || (src_dsize != DMA_SRC_16BYTE))
    2934:	54006e69 	strpl	r6, [r0], #-3689	; 0xe69
    2938:	31524658 	cmpcc	r2, r8, asr r6
    293c:	46585400 	ldrbmi	r5, [r8], -r0, lsl #8
    return 0;
    2940:	44003252 	strmi	r3, [r0], #-594	; 0x252
    2944:	6e696172 	mcrvs	1, 3, r6, cr9, cr2, {3}
  if (dst_addr == 0)
    2948:	5f746e49 	svcpl	0x00746e49
    return 0;
    294c:	00727369 	rsbseq	r7, r2, r9, ror #6
    2950:	444c504c 	strbmi	r5, [ip], #-76	; 0x4c
  if ((dst_dsize > DMA_DST_32BIT) || (dst_dsize != DMA_SRC_16BYTE))
    2954:	4950535f 	ldmdbmi	r0, {r0, r1, r2, r3, r4, r6, r8, r9, ip, lr}^
    2958:	6965445f 	stmdbvs	r5!, {r0, r1, r2, r3, r4, r6, sl, lr}^
    295c:	0074696e 	rsbseq	r6, r4, lr, ror #18
    return 0;
    2960:	32495053 	subcc	r5, r9, #83	; 0x53

  SIM_SCGC7 |= SIM_SCGC7_DMA_MASK;     //DMAģʱ
    2964:	5253495f 	subspl	r4, r3, #1556480	; 0x17c000
    2968:	46585200 	ldrbmi	r5, [r8], -r0, lsl #4
    296c:	52003052 	andpl	r3, r0, #82	; 0x52
    2970:	33524658 	cmpcc	r2, #92274688	; 0x5800000
    2974:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
    2978:	50535f44 	subspl	r5, r3, r4, asr #30
    297c:	6e455f49 	cdpvs	15, 4, cr5, cr5, cr9, {2}
    2980:	656c6261 	strbvs	r6, [ip, #-609]!	; 0x261
  SIM_SCGC6 |= SIM_SCGC6_DMAMUX0_MASK;  //DMAͨ·ʱ   
    2984:	00717249 	rsbseq	r7, r1, r9, asr #4
    2988:	635f7874 	cmpvs	pc, #7602176	; 0x740000
    298c:	6c706d6f 	ldclvs	13, cr6, [r0], #-444	; 0xfffffe44
    2990:	5f657465 	svcpl	0x00657465
    2994:	00746e69 	rsbseq	r6, r4, r9, ror #28
    2998:	5f495053 	svcpl	0x00495053
    299c:	62616e45 	rsbvs	r6, r1, #1104	; 0x450
    29a0:	7854656c 	ldmdavc	r4, {r2, r3, r5, r6, r8, sl, sp, lr}^
    29a4:	4f464946 	svcmi	0x00464946
    29a8:	46585200 	ldrbmi	r5, [r8], -r0, lsl #4
  
  //رͨxӲDMA 
  DMA0->ERQ &= ~(1<<chx);
    29ac:	52003152 	andpl	r3, r0, #-2147483628	; 0x80000014
    29b0:	32524658 	subscc	r4, r2, #92274688	; 0x5800000
    29b4:	49505300 	ldmdbmi	r0, {r8, r9, ip, lr}^
    29b8:	4678525f 			; <UNDEFINED> instruction: 0x4678525f
    29bc:	5f4f4649 	svcpl	0x004f4649
    29c0:	7265764f 	rsbvc	r7, r5, #82837504	; 0x4f00000
    29c4:	776f6c66 	strbvc	r6, [pc, -r6, ror #24]!
    29c8:	45746e49 	ldrbmi	r6, [r4, #-3657]!	; 0xe49
    29cc:	6c62616e 	stfvse	f6, [r2], #-440	; 0xfffffe48
    29d0:	4f500065 	svcmi	0x00500065
  
  //ѡ ͨx DMAԴ
  DMAMUX->CHCFG[chx] = DMAMUX_CHCFG_SOURCE(req);
    29d4:	70005250 	andvc	r5, r0, r0, asr r2
    29d8:	5f337363 	svcpl	0x00337363
    29dc:	006e6970 	rsbeq	r6, lr, r0, ror r9
    29e0:	5f495053 	svcpl	0x00495053
    29e4:	31736350 	cmncc	r3, r0, asr r3
    29e8:	006e6950 	rsbeq	r6, lr, r0, asr r9
  //Ƿʹڴ
  if(periodic_trigg == TRUE)
    29ec:	52455352 	subpl	r5, r5, #1207959553	; 0x48000001
    29f0:	65764f00 	ldrbvs	r4, [r6, #-3840]!	; 0xf00
  {
    DMAMUX->CHCFG[chx] |= DMAMUX_CHCFG_TRIG_MASK;
    29f4:	6f6c6672 	svcvs	0x006c6672
    29f8:	746e4977 	strbtvc	r4, [lr], #-2423	; 0x977
    29fc:	7273695f 	rsbsvc	r6, r3, #1556480	; 0x17c000
    2a00:	73637000 	cmnvc	r3, #0
    2a04:	69705f30 	ldmdbvs	r0!, {r4, r5, r8, r9, sl, fp, ip, lr}^
    2a08:	6370006e 	cmnvs	r0, #110	; 0x6e
    2a0c:	705f3573 	subsvc	r3, pc, r3, ror r5	; <UNPREDICTABLE>
    2a10:	53006e69 	movwpl	r6, #3689	; 0xe69
    2a14:	545f4950 	ldrbpl	r4, [pc], #-2384	; 2a1c <LPLD_DMA_Init+0x17c>
  }
  else
  {
    DMAMUX->CHCFG[chx] &= ~(DMAMUX_CHCFG_TRIG_MASK);
    2a18:	46494678 			; <UNDEFINED> instruction: 0x46494678
    2a1c:	69465f4f 	stmdbvs	r6, {r0, r1, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
    2a20:	6e496c6c 	cdpvs	12, 4, cr6, cr9, cr12, {3}
    2a24:	72734974 	rsbsvc	r4, r3, #1900544	; 0x1d0000
    2a28:	49505300 	ldmdbmi	r0, {r8, r9, ip, lr}^
    2a2c:	4678545f 			; <UNDEFINED> instruction: 0x4678545f
    2a30:	5f4f4649 	svcpl	0x004f4649
    2a34:	6c6c6946 	stclvs	9, cr6, [ip], #-280	; 0xfffffee8
    2a38:	45746e49 	ldrbmi	r6, [r4, #-3657]!	; 0xe49
  }
  
  
  //Դַ   
  DMA0->TCD[chx].SADDR = DMA_SADDR_SADDR(src_addr);
    2a3c:	6c62616e 	stfvse	f6, [r2], #-440	; 0xfffffe48
    2a40:	63730065 	cmnvs	r3, #101	; 0x65
    2a44:	69705f6b 	ldmdbvs	r0!, {r0, r1, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    2a48:	5053006e 	subspl	r0, r3, lr, rrx
    2a4c:	75515f49 	ldrbvc	r5, [r1, #-3913]	; 0xf49
    2a50:	45657565 	strbmi	r7, [r5, #-1381]!	; 0x565
    2a54:	6e49646e 	cdpvs	4, 4, cr6, cr9, cr14, {3}
  //ִԴַĲ֮ԴַĻ/ƫƵַ
  DMA0->TCD[chx].SOFF = DMA_SOFF_SOFF(src_addroffset);
    2a58:	72734974 	rsbsvc	r4, r3, #1900544	; 0x1d0000
    2a5c:	46787200 	ldrbtmi	r7, [r8], -r0, lsl #4
    2a60:	5f4f4649 	svcpl	0x004f4649
    2a64:	62616e65 	rsbvs	r6, r1, #1616	; 0x650
    2a68:	7200656c 	andvc	r6, r0, #452984832	; 0x1b000000
    2a6c:	46494678 			; <UNDEFINED> instruction: 0x46494678
  //ԴַĴС
  DMA0->TCD[chx].ATTR = 0 | DMA_ATTR_SSIZE(src_dsize);
    2a70:	72445f4f 	subvc	r5, r4, #316	; 0x13c
    2a74:	5f6e6961 	svcpl	0x006e6961
    2a78:	00746e69 	rsbseq	r6, r4, r9, ror #28
    2a7c:	5f495053 	svcpl	0x00495053
    2a80:	506b6353 	rsbpl	r6, fp, r3, asr r3
    2a84:	53006e69 	movwpl	r6, #3689	; 0xe69
    2a88:	505f4950 	subspl	r4, pc, r0, asr r9	; <UNPREDICTABLE>
    2a8c:	50327363 	eorspl	r7, r2, r3, ror #6
    2a90:	74006e69 	strvc	r6, [r0], #-3689	; 0xe69
    2a94:	46494678 			; <UNDEFINED> instruction: 0x46494678
  //ļmajor iteration countﵽµԴַ
  DMA0->TCD[chx].SLAST = DMA_SLAST_SLAST(src_lastadj);
    2a98:	6e655f4f 	cdpvs	15, 6, cr5, cr5, cr15, {2}
    2a9c:	656c6261 	strbvs	r6, [ip, #-609]!	; 0x261
    2aa0:	49505300 	ldmdbmi	r0, {r8, r9, ip, lr}^
    2aa4:	4678545f 			; <UNDEFINED> instruction: 0x4678545f
    2aa8:	5f4f4649 	svcpl	0x004f4649
    2aac:	65646e55 	strbvs	r6, [r4, #-3669]!	; 0xe55
    2ab0:	6f6c6672 	svcvs	0x006c6672
    2ab4:	746e4977 	strbtvc	r4, [lr], #-2423	; 0x977
  
  //Ŀĵַ 
  DMA0->TCD[chx].DADDR = DMA_DADDR_DADDR(dst_addr);
    2ab8:	00727349 	rsbseq	r7, r2, r9, asr #6
    2abc:	49467874 	stmdbmi	r6, {r2, r4, r5, r6, fp, ip, sp, lr}^
    2ac0:	755f4f46 	ldrbvc	r4, [pc, #-3910]	; 1b82 <LPLD_SCCB_ReadReg+0x92>
    2ac4:	7265646e 	rsbvc	r6, r5, #1845493760	; 0x6e000000
    2ac8:	776f6c66 	strbvc	r6, [pc, -r6, ror #24]!
    2acc:	746e695f 	strbtvc	r6, [lr], #-2399	; 0x95f
    2ad0:	46585400 	ldrbmi	r5, [r8], -r0, lsl #8
  //ִĿĵַĲ֮ĿĵַĻ/ƫƵַ
  DMA0->TCD[chx].DOFF = DMA_DOFF_DOFF(dst_addroffset);
    2ad4:	54003052 	strpl	r3, [r0], #-82	; 0x52
    2ad8:	33524658 	cmpcc	r2, #92274688	; 0x5800000
    2adc:	49505300 	ldmdbmi	r0, {r8, r9, ip, lr}^
    2ae0:	4678545f 			; <UNDEFINED> instruction: 0x4678545f
    2ae4:	5f4f4649 	svcpl	0x004f4649
    2ae8:	75716552 	ldrbvc	r6, [r1, #-1362]!	; 0x552
    2aec:	53747365 	cmnpl	r4, #-1811939327	; 0x94000001
    2af0:	63656c65 	cmnvs	r5, #25856	; 0x6500
  //ĿĵַĴ
  DMA0->TCD[chx].ATTR |= DMA_ATTR_DSIZE(dst_dsize);
    2af4:	50530074 	subspl	r0, r3, r4, ror r0
    2af8:	495f3149 	ldmdbmi	pc, {r0, r3, r6, r8, ip, sp}^	; <UNPREDICTABLE>
    2afc:	73005253 	movwvc	r5, #595	; 0x253
    2b00:	695f6970 	ldmdbvs	pc, {r4, r5, r6, r8, fp, sp, lr}^	; <UNPREDICTABLE>
    2b04:	5f74696e 	svcpl	0x0074696e
    2b08:	75727473 	ldrbvc	r7, [r2, #-1139]!	; 0x473
    2b0c:	72757463 	rsbsvc	r7, r5, #1660944384	; 0x63000000
    2b10:	50530065 	subspl	r0, r3, r5, rrx
    2b14:	654d5f49 	strbvs	r5, [sp, #-3913]	; 0xf49
    2b18:	70614d6d 	rsbvc	r4, r1, sp, ror #26
    2b1c:	69707300 	ldmdbvs	r0!, {r8, r9, ip, sp, lr}^
    2b20:	646f6d5f 	strbtvs	r6, [pc], #-3423	; 2b28 <LPLD_DMA_Init+0x288>
    2b24:	50530065 	subspl	r0, r3, r5, rrx
    2b28:	63505f49 	cmpvs	r0, #292	; 0x124
    2b2c:	69503573 	ldmdbvs	r0, {r0, r1, r4, r5, r6, r8, sl, ip, sp}^
    2b30:	7874006e 	ldmdavc	r4!, {r1, r2, r3, r5, r6}^
  //ļmajor iteration countﵽµĿĵַ
  DMA0->TCD[chx].DLAST_SGA = DMA_DLAST_SGA_DLASTSGA(dst_lastadj);
    2b34:	4f464946 	svcmi	0x00464946
    2b38:	6c69465f 	stclvs	6, cr4, [r9], #-380	; 0xfffffe84
    2b3c:	6e695f6c 	cdpvs	15, 6, cr5, cr9, cr12, {3}
    2b40:	75510074 	ldrbvc	r0, [r1, #-116]	; 0x74
    2b44:	45657565 	strbmi	r7, [r5, #-1381]!	; 0x565
    2b48:	6552646e 	ldrbvs	r6, [r2, #-1134]	; 0x46e
    2b4c:	73695f71 	cmnvc	r9, #452	; 0x1c4
  //ĬΪͨӹܣӴ˹
  if( 1 == 1)
  {
    //===============ȣѭ====================================
    //ѭ current major loop count
    DMA0->TCD[chx].CITER_ELINKNO = DMA_CITER_ELINKNO_CITER(major_cnt);
    2b50:	63730072 	cmnvs	r3, #114	; 0x72
    2b54:	69645f6b 	stmdbvs	r4!, {r0, r1, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    2b58:	696d0076 	stmdbvs	sp!, {r1, r2, r4, r5, r6}^
    2b5c:	705f6f73 	subsvc	r6, pc, r3, ror pc	; <UNPREDICTABLE>
    2b60:	70006e69 	andvc	r6, r0, r9, ror #28
    2b64:	5f327363 	svcpl	0x00327363
    2b68:	006e6970 	rsbeq	r6, lr, r0, ror r9
    2b6c:	5f495053 	svcpl	0x00495053
    2b70:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
    2b74:	65707954 	ldrbvs	r7, [r0, #-2388]!	; 0x954
    //ʼѭѭΪʱ򣬽װʼѭֵ
    DMA0->TCD[chx].BITER_ELINKNO = DMA_CITER_ELINKNO_CITER(major_cnt);
    2b78:	00666544 	rsbeq	r6, r6, r4, asr #10
    2b7c:	6c6c6946 	stclvs	9, cr6, [ip], #-280	; 0xfffffee8
    2b80:	5f746e49 	svcpl	0x00746e49
    2b84:	00727369 	rsbseq	r7, r2, r9, ror #6
    2b88:	5f495053 	svcpl	0x00495053
    2b8c:	4d6d654d 	cfstr64mi	mvdx6, [sp, #-308]!	; 0xfffffecc
    2b90:	74507061 	ldrbvc	r7, [r0], #-97	; 0x61
    2b94:	55500072 	ldrbpl	r0, [r0, #-114]	; 0x72
    2b98:	5f524853 	svcpl	0x00524853
    2b9c:	56414c53 			; <UNDEFINED> instruction: 0x56414c53
  
  //ĬΪôѭַƫƹܣӴ˹
  if( 1 == 1)
  {
    //ѭһδֽڵĸ
    DMA0->TCD[chx].NBYTES_MLNO = DMA_NBYTES_MLNO_NBYTES(minor_cnt);
    2ba0:	63700045 	cmnvs	r0, #69	; 0x45
    2ba4:	74735f73 	ldrbtvc	r5, [r3], #-3955	; 0xf73
    2ba8:	00657461 	rsbeq	r7, r5, r1, ror #8
    2bac:	65646e55 	strbvs	r6, [r4, #-3669]!	; 0xe55
    2bb0:	6f6c6672 	svcvs	0x006c6672
    2bb4:	746e4977 	strbtvc	r4, [lr], #-2423	; 0x977
    2bb8:	7273695f 	rsbsvc	r6, r3, #1556480	; 0x17c000
    2bbc:	49505300 	ldmdbmi	r0, {r8, r9, ip, lr}^
  }
  
  //TCDƼĴ     
  DMA0->TCD[chx].CSR = 0;
    2bc0:	7363505f 	cmnvc	r3, #95	; 0x5f
    2bc4:	6e695030 	mcrvs	0, 3, r5, cr9, cr0, {1}
    2bc8:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
    2bcc:	50535f44 	subspl	r5, r3, r4, asr #30
    2bd0:	614d5f49 	cmpvs	sp, r9, asr #30
    2bd4:	72657473 	rsbvc	r7, r5, #1929379840	; 0x73000000
    2bd8:	6972575f 	ldmdbvs	r2!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, ip, lr}^
    2bdc:	53006574 	movwpl	r6, #1396	; 0x574
  
  //eDMAж
  if((dma_init_struct.DMA_Isr != NULL) && 
    2be0:	4d5f4950 	ldclmi	9, cr4, [pc, #-320]	; 2aa8 <LPLD_DMA_Init+0x208>
     (dma_init_struct.DMA_MajorCompleteIntEnable == TRUE))
    2be4:	5365646f 	cmnpl	r5, #1862270976	; 0x6f000000
  
  //TCDƼĴ     
  DMA0->TCD[chx].CSR = 0;
  
  //eDMAж
  if((dma_init_struct.DMA_Isr != NULL) && 
    2be8:	63656c65 	cmnvs	r5, #25856	; 0x6500
     (dma_init_struct.DMA_MajorCompleteIntEnable == TRUE))
  {

       DMA0->TCD[chx].CSR |= DMA_CSR_INTMAJOR_MASK; //ʹDMA ѭ ж
    2bec:	55500074 	ldrbpl	r0, [r0, #-116]	; 0x74
    2bf0:	00524853 	subseq	r4, r2, r3, asr r8
    2bf4:	444c504c 	strbmi	r5, [ip], #-76	; 0x4c
    2bf8:	4950535f 	ldmdbmi	r0, {r0, r1, r2, r3, r4, r6, r8, r9, ip, lr}^
    2bfc:	7369445f 	cmnvc	r9, #1593835520	; 0x5f000000
    2c00:	656c6261 	strbvs	r6, [ip, #-609]!	; 0x261
    2c04:	00717249 	rsbseq	r7, r1, r9, asr #4
    2c08:	5f495053 	svcpl	0x00495053
    2c0c:	6f437854 	svcvs	0x00437854
    2c10:	656c706d 	strbvs	r7, [ip, #-109]!	; 0x6d
    2c14:	6e496574 	mcrvs	5, 2, r6, cr9, cr4, {3}
    2c18:	616e4574 	smcvs	58452	; 0xe454
    2c1c:	00656c62 	rsbeq	r6, r5, r2, ror #24
    2c20:	5f495053 	svcpl	0x00495053
    2c24:	446b6353 	strbtmi	r6, [fp], #-851	; 0x353
    2c28:	64697669 	strbtvs	r7, [r9], #-1641	; 0x669
       DMA_ISR[chx] = dma_init_struct.DMA_Isr;
    2c2c:	53007265 	movwpl	r7, #613	; 0x265
    2c30:	5f314950 	svcpl	0x00314950
    2c34:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
    2c38:	6c646e61 	stclvs	14, cr6, [r4], #-388	; 0xfffffe7c
    2c3c:	53007265 	movwpl	r7, #613	; 0x265
  }
  if((dma_init_struct.DMA_Isr != NULL) && 
    2c40:	515f4950 	cmppl	pc, r0, asr r9	; <UNPREDICTABLE>
     (dma_init_struct.DMA_MajorHalfCompleteIntEnable == TRUE))
    2c44:	65756575 	ldrbvs	r6, [r5, #-1397]!	; 0x575
  {

       DMA0->TCD[chx].CSR |= DMA_CSR_INTMAJOR_MASK; //ʹDMA ѭ ж
       DMA_ISR[chx] = dma_init_struct.DMA_Isr;
  }
  if((dma_init_struct.DMA_Isr != NULL) && 
    2c48:	49646e45 	stmdbmi	r4!, {r0, r2, r6, r9, sl, fp, sp, lr}^
     (dma_init_struct.DMA_MajorHalfCompleteIntEnable == TRUE))
  {

       DMA0->TCD[chx].CSR |= DMA_CSR_INTHALF_MASK; //ʹDMA ѭһ ж
    2c4c:	6e45746e 	cdpvs	4, 4, cr7, cr5, cr14, {3}
    2c50:	656c6261 	strbvs	r6, [ip, #-609]!	; 0x261
    2c54:	49505300 	ldmdbmi	r0, {r8, r9, ip, lr}^
    2c58:	52495f32 	subpl	r5, r9, #200	; 0xc8
    2c5c:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
    2c60:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
    2c64:	41544300 	cmpmi	r4, r0, lsl #6
    2c68:	50530052 	subspl	r0, r3, r2, asr r0
    2c6c:	78525f49 	ldmdavc	r2, {r0, r3, r6, r8, r9, sl, fp, ip, lr}^
    2c70:	4f464946 	svcmi	0x00464946
    2c74:	65764f5f 	ldrbvs	r4, [r6, #-3935]!	; 0xf5f
    2c78:	6f6c6672 	svcvs	0x006c6672
    2c7c:	746e4977 	strbtvc	r4, [lr], #-2423	; 0x977
    2c80:	00727349 	rsbseq	r7, r2, r9, asr #6
    2c84:	444c504c 	strbmi	r5, [ip], #-76	; 0x4c
    2c88:	4950535f 	ldmdbmi	r0, {r0, r1, r2, r3, r4, r6, r8, r9, ip, lr}^
       DMA_ISR[chx] = dma_init_struct.DMA_Isr;
    2c8c:	696e495f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, lr}^
    2c90:	78740074 	ldmdavc	r4!, {r2, r4, r5, r6}^
    2c94:	4f464946 	svcmi	0x00464946
    2c98:	7165725f 	cmnvc	r5, pc, asr r2
    2c9c:	49505300 	ldmdbmi	r0, {r8, r9, ip, lr}^
  }
    
  if(auto_disable == TRUE)
    2ca0:	4950535f 	ldmdbmi	r0, {r0, r1, r2, r3, r4, r6, r8, r9, ip, lr}^
  {
     DMA0->TCD[chx].CSR |= DMA_CSR_DREQ_MASK; //ѭԶرDMA 
    2ca4:	78540078 	ldmdavc	r4, {r3, r4, r5, r6}^
    2ca8:	706d6f43 	rsbvc	r6, sp, r3, asr #30
    2cac:	6574656c 	ldrbvs	r6, [r4, #-1388]!	; 0x56c
    2cb0:	7273695f 	rsbsvc	r6, r3, #1556480	; 0x17c000
    2cb4:	46787200 	ldrbtmi	r7, [r8], -r0, lsl #4
    2cb8:	5f4f4649 	svcpl	0x004f4649
    2cbc:	00716572 	rsbseq	r6, r1, r2, ror r5
    2cc0:	5f495053 	svcpl	0x00495053
    2cc4:	49467852 	stmdbmi	r6, {r1, r4, r6, fp, ip, sp, lr}^
    2cc8:	525f4f46 	subspl	r4, pc, #280	; 0x118
    2ccc:	65757165 	ldrbvs	r7, [r5, #-357]!	; 0x165
    2cd0:	65537473 	ldrbvs	r7, [r3, #-1139]	; 0x473
    2cd4:	7463656c 	strbtvc	r6, [r3], #-1388	; 0x56c
    2cd8:	49505300 	ldmdbmi	r0, {r8, r9, ip, lr}^
    2cdc:	5253495f 	subspl	r4, r3, #1556480	; 0x17c000
    2ce0:	4c41435f 	mcrrmi	3, 5, r4, r1, cr15
    2ce4:	4341424c 	movtmi	r4, #4684	; 0x124c
  }
  else
  {
     DMA0->TCD[chx].CSR &= ~(DMA_CSR_DREQ_MASK); //ѭ󣬲رDMA
    2ce8:	4155004b 	cmpmi	r5, fp, asr #32
    2cec:	5f305452 	svcpl	0x00305452
    2cf0:	545f5852 	ldrbpl	r5, [pc], #-2130	; 2cf8 <LPLD_DMA_Init+0x458>
    2cf4:	52495f58 	subpl	r5, r9, #352	; 0x160
    2cf8:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
    2cfc:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
    2d00:	66726200 	ldrbtvs	r6, [r2], -r0, lsl #4
    2d04:	504c0061 	subpl	r0, ip, r1, rrx
    2d08:	555f444c 	ldrbpl	r4, [pc, #-1100]	; 28c4 <LPLD_DMA_Init+0x24>
    2d0c:	5f545241 	svcpl	0x00545241
    2d10:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
    2d14:	4c504c00 	mrrcmi	12, 0, r4, r0, cr0
    2d18:	41555f44 	cmpmi	r5, r4, asr #30
    2d1c:	475f5452 			; <UNDEFINED> instruction: 0x475f5452
    2d20:	68437465 	stmdavs	r3, {r0, r2, r5, r6, sl, ip, sp, lr}^
    2d24:	74007261 	strvc	r7, [r0], #-609	; 0x261
  } 
 
  //DMAͨʹ
  DMAMUX->CHCFG[chx] |= DMAMUX_CHCFG_ENBL_MASK;
    2d28:	69705f78 	ldmdbvs	r0!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    2d2c:	504c006e 	subpl	r0, ip, lr, rrx
    2d30:	555f444c 	ldrbpl	r4, [pc, #-1100]	; 28ec <LPLD_DMA_Init+0x4c>
    2d34:	5f545241 	svcpl	0x00545241
    2d38:	61736944 	cmnvs	r3, r4, asr #18
    2d3c:	49656c62 	stmdbmi	r5!, {r1, r5, r6, sl, fp, sp, lr}^
    2d40:	55007172 	strpl	r7, [r0, #-370]	; 0x172
    2d44:	5f545241 	svcpl	0x00545241
    2d48:	53495f54 	movtpl	r5, #40788	; 0x9f54
    
  return 1;
    2d4c:	61620052 	qdsubvs	r0, r2, r2
}
    2d50:	55006475 	strpl	r6, [r0, #-1141]	; 0x475
    2d54:	34545241 	ldrbcc	r5, [r4], #-577	; 0x241
    2d58:	5f58525f 	svcpl	0x0058525f
 * :
 *    0--ʧ
 *    1--ɹ
 */
uint8 LPLD_DMA_EnableIrq(DMA_InitTypeDef dma_init_struct)
{
    2d5c:	495f5854 	ldmdbmi	pc, {r2, r4, r6, fp, ip, lr}^	; <UNPREDICTABLE>
    2d60:	61485152 	cmpvs	r8, r2, asr r1
    2d64:	656c646e 	strbvs	r6, [ip, #-1134]!	; 0x46e
    2d68:	504c0072 	subpl	r0, ip, r2, ror r0
  enable_irq(dma_init_struct.DMA_CHx + INT_DMA0_DMA16 - 16);  
    2d6c:	555f444c 	ldrbpl	r4, [pc, #-1100]	; 2928 <LPLD_DMA_Init+0x88>
    2d70:	5f545241 	svcpl	0x00545241
  return 1;
    2d74:	43746547 	cmnmi	r4, #297795584	; 0x11c00000
}
    2d78:	5f726168 	svcpl	0x00726168
    2d7c:	73657250 	cmnvc	r5, #5
    2d80:	00746e65 	rsbseq	r6, r4, r5, ror #28
 * :
 *    0--ʧ
 *    1--ɹ
 */
uint8 LPLD_DMA_DisableIrq(DMA_InitTypeDef dma_init_struct)
{
    2d84:	54524155 	ldrbpl	r4, [r2], #-341	; 0x155
    2d88:	58525f31 	ldmdapl	r2, {r0, r4, r5, r8, r9, sl, fp, ip, lr}^
    2d8c:	5f58545f 	svcpl	0x0058545f
    2d90:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
  disable_irq(dma_init_struct.DMA_CHx + INT_DMA0_DMA16 - 16);
    2d94:	6c646e61 	stclvs	14, cr6, [r4], #-388	; 0xfffffe7c
    2d98:	75007265 	strvc	r7, [r0, #-613]	; 0x265
  return 1;
    2d9c:	5f747261 	svcpl	0x00747261
}
    2da0:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xe69
    2da4:	7274735f 	rsbsvc	r7, r4, #2080374785	; 0x7c000001
    2da8:	75746375 	ldrbvc	r6, [r4, #-885]!	; 0x375
 *
 * :
 *    
 */
void LPLD_DMA_SoftwareStartService(DMA_InitTypeDef dma_init_struct)
{
    2dac:	55006572 	strpl	r6, [r0, #-1394]	; 0x572
    2db0:	33545241 	cmpcc	r4, #268435460	; 0x10000004
    2db4:	5f58525f 	svcpl	0x0058525f
    2db8:	495f5854 	ldmdbmi	pc, {r2, r4, r6, fp, ip, lr}^	; <UNPREDICTABLE>
  DMA0->TCD[dma_init_struct.DMA_CHx].CSR |= DMA_CSR_START_MASK; 
    2dbc:	61485152 	cmpvs	r8, r2, asr r1
    2dc0:	656c646e 	strbvs	r6, [ip, #-1134]!	; 0x46e
    2dc4:	41550072 	cmpmi	r5, r2, ror r0
    2dc8:	5f355452 	svcpl	0x00355452
    2dcc:	545f5852 	ldrbpl	r5, [pc], #-2130	; 2dd4 <LPLD_DMA_SoftwareStartService+0x28>
    2dd0:	52495f58 	subpl	r5, r9, #352	; 0x160
    2dd4:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
    2dd8:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
    2ddc:	5f787200 	svcpl	0x00787200
    2de0:	00727369 	rsbseq	r7, r2, r9, ror #6
    2de4:	74726175 	ldrbtvc	r6, [r2], #-373	; 0x175
    2de8:	504c0078 	subpl	r0, ip, r8, ror r0
    2dec:	555f444c 	ldrbpl	r4, [pc, #-1100]	; 29a8 <LPLD_DMA_Init+0x108>
    2df0:	5f545241 	svcpl	0x00545241
    2df4:	62616e45 	rsbvs	r6, r1, #1104	; 0x450
}
    2df8:	7249656c 	subvc	r6, r9, #452984832	; 0x1b000000
    2dfc:	41550071 	cmpmi	r5, r1, ror r0
 * eDMAжϴ
 * ļstartup_K60.sеж
 * û޸ģԶӦͨжϺ
 */
void DMA0_IRQHandler(void)
{
    2e00:	5f325452 	svcpl	0x00325452
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[0]();
    2e04:	545f5852 	ldrbpl	r5, [pc], #-2130	; 2e0c <DMA0_IRQHandler+0xc>
    2e08:	52495f58 	subpl	r5, r9, #352	; 0x160
    2e0c:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
  //жϱ־λ
  DMA0->INT |= 0x1u<<0;
    2e10:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
    2e14:	2f2e2e00 	svccs	0x002e2e00
    2e18:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; 2d68 <LPLD_DMA_EnableIrq+0xc>
    2e1c:	682f6269 	stmdavs	pc!, {r0, r3, r5, r6, r9, sp, lr}	; <UNPREDICTABLE>
    2e20:	77682f77 			; <UNDEFINED> instruction: 0x77682f77
    2e24:	7261755f 	rsbvc	r7, r1, #398458880	; 0x17c00000
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2e28:	00632e74 	rsbeq	r2, r3, r4, ror lr

void DMA1_IRQHandler(void)
{
    2e2c:	63737973 	cmnvs	r3, #1884160	; 0x1cc000
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[1]();
    2e30:	4c006b6c 	stcmi	11, cr6, [r0], {108}	; 0x6c
    2e34:	5f444c50 	svcpl	0x00444c50
    2e38:	54524155 	ldrbpl	r4, [r2], #-341	; 0x155
  //жϱ־λ
  DMA0->INT |= 0x1u<<1;
    2e3c:	7475505f 	ldrbtvc	r5, [r5], #-95	; 0x5f
    2e40:	72616843 	rsbvc	r6, r1, #4390912	; 0x430000
    2e44:	5f787200 	svcpl	0x00787200
    2e48:	006e6970 	rsbeq	r6, lr, r0, ror r9
    2e4c:	444c504c 	strbmi	r5, [ip], #-76	; 0x4c
    2e50:	5241555f 	subpl	r5, r1, #398458880	; 0x17c00000
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2e54:	75505f54 	ldrbvc	r5, [r0, #-3924]	; 0xf54

void DMA2_IRQHandler(void)
{
    2e58:	61684374 	smcvs	33844	; 0x8434
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[2]();
    2e5c:	72724172 	rsbsvc	r4, r2, #-2147483620	; 0x8000001c
    2e60:	52415500 	subpl	r5, r1, #0
    2e64:	5f525f54 	svcpl	0x00525f54
  //жϱ־λ
  DMA0->INT |= 0x1u<<2;
    2e68:	00525349 	subseq	r5, r2, r9, asr #6
    2e6c:	695f7874 	ldmdbvs	pc, {r2, r4, r5, r6, fp, ip, sp, lr}^	; <UNPREDICTABLE>
    2e70:	69007273 	stmdbvs	r0, {r0, r1, r4, r5, r6, r9, ip, sp, lr}
    2e74:	68635f6e 	stmdavs	r3!, {r1, r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    2e78:	63007261 	movwvs	r7, #609	; 0x261
    2e7c:	5f726168 	svcpl	0x00726168
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2e80:	73657270 	cmnvc	r5, #7

void DMA3_IRQHandler(void)
{
    2e84:	00746e65 	rsbseq	r6, r4, r5, ror #28
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[3]();
    2e88:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    2e8c:	696c2f2e 	stmdbvs	ip!, {r1, r2, r3, r5, r8, r9, sl, fp, sp}^
    2e90:	6f632f62 	svcvs	0x00632f62
  //жϱ־λ
  DMA0->INT |= 0x1u<<3;
    2e94:	6e6f6d6d 	cdpvs	13, 6, cr6, cr15, cr13, {3}
    2e98:	2e6f692f 	cdpcs	9, 6, cr6, cr15, cr15, {1}
    2e9c:	756f0063 	strbvc	r0, [pc, #-99]!	; 2e41 <DMA1_IRQHandler+0x15>
    2ea0:	68635f74 	stmdavs	r3!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    2ea4:	70007261 	andvc	r7, r0, r1, ror #4
    2ea8:	746e6972 	strbtvc	r6, [lr], #-2418	; 0x972
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2eac:	61705f6b 	cmnvs	r0, fp, ror #30

void DMA4_IRQHandler(void)
{
    2eb0:	70735f64 	rsbsvc	r5, r3, r4, ror #30
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[4]();
    2eb4:	00656361 	rsbeq	r6, r5, r1, ror #6
    2eb8:	746e6f63 	strbtvc	r6, [lr], #-3939	; 0xf63
    2ebc:	0064785f 	rsbeq	r7, r4, pc, asr r8
  //жϱ־λ
  DMA0->INT |= 0x1u<<4;
    2ec0:	7274736e 	rsbsvc	r7, r4, #-1207959551	; 0xb8000001
    2ec4:	65640070 	strbvs	r0, [r4, #-112]!	; 0x70
    2ec8:	66007473 			; <UNDEFINED> instruction: 0x66007473
    2ecc:	646c6569 	strbtvs	r6, [ip], #-1385	; 0x569
    2ed0:	6469775f 	strbtvs	r7, [r9], #-1887	; 0x75f
    2ed4:	6e006874 	mcrvs	8, 0, r6, cr0, cr4, {3}
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2ed8:	006e656c 	rsbeq	r6, lr, ip, ror #10

void DMA5_IRQHandler(void)
{
    2edc:	6c617675 	stclvs	6, cr7, [r1], #-468	; 0xfffffe2c
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[5]();
    2ee0:	6d756e00 	ldclvs	14, cr6, [r5, #-0]
    2ee4:	73760070 	cmnvc	r6, #112	; 0x70
    2ee8:	00707274 	rsbseq	r7, r0, r4, ror r2
  //жϱ־λ
  DMA0->INT |= 0x1u<<5;
    2eec:	61765f5f 	cmnvs	r6, pc, asr pc
    2ef0:	73696c5f 	cmnvc	r9, #24320	; 0x5f00
    2ef4:	72700074 	rsbsvc	r0, r0, #116	; 0x74
    2ef8:	6b746e69 	blvs	1d1e8a4 <__etext+0x1d15bfc>
    2efc:	72707300 	rsbsvc	r7, r0, #0
    2f00:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2f04:	61766900 	cmnvs	r6, r0, lsl #18

void DMA6_IRQHandler(void)
{
    2f08:	6400706c 	strvs	r7, [r0], #-108	; 0x6c
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[6]();
    2f0c:	00656e6f 	rsbeq	r6, r5, pc, ror #28
    2f10:	6c617669 	stclvs	6, cr7, [r1], #-420	; 0xfffffe5c
    2f14:	49525000 	ldmdbmi	r2, {ip, lr}^
  //жϱ־λ
  DMA0->INT |= 0x1u<<6;
    2f18:	5f4b544e 	svcpl	0x004b544e
    2f1c:	4f464e49 	svcmi	0x00464e49
    2f20:	64617200 	strbtvs	r7, [r1], #-512	; 0x200
    2f24:	63007869 	movwvs	r7, #2153	; 0x869
    2f28:	656c7275 	strbvs	r7, [ip, #-629]!	; 0x275
    2f2c:	5f5f006e 	svcpl	0x005f006e
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2f30:	73007061 	movwvc	r7, #97	; 0x61

void DMA7_IRQHandler(void)
{
    2f34:	006c6176 	rsbeq	r6, ip, r6, ror r1
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[7]();
    2f38:	6e656c76 	mcrvs	12, 3, r6, cr5, cr6, {3}
    2f3c:	69727000 	ldmdbvs	r2!, {ip, sp, lr}^
    2f40:	5f6b746e 	svcpl	0x006b746e
  //жϱ־λ
  DMA0->INT |= 0x1u<<7;
    2f44:	63747570 	cmnvs	r4, #469762048	; 0x1c000000
    2f48:	2f2e2e00 	svccs	0x002e2e00
    2f4c:	6c2f2e2e 	stcvs	14, cr2, [pc], #-184	; 2e9c <DMA3_IRQHandler+0x18>
    2f50:	632f6269 	teqvs	pc, #-1879048186	; 0x90000006
    2f54:	6f6d6d6f 	svcvs	0x006d6d6f
    2f58:	72702f6e 	rsbsvc	r2, r0, #440	; 0x1b8
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2f5c:	66746e69 	ldrbtvs	r6, [r4], -r9, ror #28

void DMA8_IRQHandler(void)
{
    2f60:	6600632e 	strvs	r6, [r0], -lr, lsr #6
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[8]();
    2f64:	7367616c 	cmnvc	r7, #27
    2f68:	6573755f 	ldrbvs	r7, [r3, #-1375]!	; 0x55f
    2f6c:	76720064 	ldrbtvc	r0, [r2], -r4, rrx
  //жϱ־λ
  DMA0->INT |= 0x1u<<8;
    2f70:	65756c61 	ldrbvs	r6, [r5, #-3169]!	; 0xc61
    2f74:	69727000 	ldmdbvs	r2!, {ip, sp, lr}^
    2f78:	5f6b746e 	svcpl	0x006b746e
    2f7c:	5f646170 	svcpl	0x00646170
    2f80:	6f72657a 	svcvs	0x0072657a
    2f84:	666e6900 	strbtvs	r6, [lr], -r0, lsl #18
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2f88:	7270006f 	rsbsvc	r0, r0, #111	; 0x6f

void DMA9_IRQHandler(void)
{
    2f8c:	6b746e69 	blvs	1d1e938 <__etext+0x1d15c90>
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[9]();
    2f90:	6e6b6d5f 	mcrvs	13, 3, r6, cr11, cr15, {2}
    2f94:	74736d75 	ldrbtvc	r6, [r3], #-3445	; 0xd75
    2f98:	73760072 	cmnvc	r6, #114	; 0x72
  //жϱ־λ
  DMA0->INT |= 0x1u<<9;
    2f9c:	5f007274 	svcpl	0x00007274
    2fa0:	756e675f 	strbvc	r6, [lr, #-1887]!	; 0x75f
    2fa4:	61765f63 	cmnvs	r6, r3, ror #30
    2fa8:	73696c5f 	cmnvc	r9, #24320	; 0x5f00
    2fac:	73640074 	cmnvc	r4, #116	; 0x74
    2fb0:	72616863 	rsbvc	r6, r1, #6488064	; 0x630000
  
#if (UCOS_II > 0u)
  OSIntExit();          //֪ϵͳʱ뿪жϷӺ
#endif
}
    2fb4:	6e6f6300 	cdpvs	3, 6, cr6, cr15, cr0, {0}

void DMA10_IRQHandler(void)
{
    2fb8:	00755f74 	rsbseq	r5, r5, r4, ror pc
  OSIntEnter();
  OS_EXIT_CRITICAL();
#endif  
  
  //ûԶжϷ
  DMA_ISR[10]();
    2fbc:	6c617663 	stclvs	6, cr7, [r1], #-396	; 0xfffffe74
	...

Disassembly of section .comment:

00000000 <.comment>:
   0:	3a434347 	bcc	10d0d24 <__etext+0x10c807c>
   4:	4e472820 	cdpmi	8, 4, cr2, cr7, cr0, {1}
   8:	6f542055 	svcvs	0x00542055
   c:	20736c6f 	rsbscs	r6, r3, pc, ror #24
  10:	20726f66 	rsbscs	r6, r2, r6, ror #30
  14:	204d5241 	subcs	r5, sp, r1, asr #4
  18:	65626d45 	strbvs	r6, [r2, #-3397]!	; 0xd45
  1c:	64656464 	strbtvs	r6, [r5], #-1124	; 0x464
  20:	6f725020 	svcvs	0x00725020
  24:	73736563 	cmnvc	r3, #415236096	; 0x18c00000
  28:	2973726f 	ldmdbcs	r3!, {r0, r1, r2, r3, r5, r6, r9, ip, sp, lr}^
  2c:	372e3420 	strcc	r3, [lr, -r0, lsr #8]!
  30:	3220342e 	eorcc	r3, r0, #771751936	; 0x2e000000
  34:	30333130 	eorscc	r3, r3, r0, lsr r1
  38:	20333139 	eorscs	r3, r3, r9, lsr r1
  3c:	6c657228 	sfmvs	f7, 2, [r5], #-160	; 0xffffff60
  40:	65736165 	ldrbvs	r6, [r3, #-357]!	; 0x165
  44:	415b2029 	cmpmi	fp, r9, lsr #32
  48:	652f4d52 	strvs	r4, [pc, #-3410]!	; fffff2fe <__StackLimit+0xdffff2fe>
  4c:	6465626d 	strbtvs	r6, [r5], #-621	; 0x26d
  50:	2d646564 	cfstr64cs	mvdx6, [r4, #-400]!	; 0xfffffe70
  54:	2d375f34 	ldccs	15, cr5, [r7, #-208]!	; 0xffffff30
  58:	6e617262 	cdpvs	2, 6, cr7, cr1, cr2, {3}
  5c:	72206863 	eorvc	r6, r0, #6488064	; 0x630000
  60:	73697665 	cmnvc	r9, #105906176	; 0x6500000
  64:	206e6f69 	rsbcs	r6, lr, r9, ror #30
  68:	36323032 			; <UNDEFINED> instruction: 0x36323032
  6c:	005d3130 	subseq	r3, sp, r0, lsr r1

Disassembly of section .debug_frame:

00000000 <.debug_frame>:
       0:	0000000c 	andeq	r0, r0, ip
       4:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
       8:	7c020001 	stcvc	0, cr0, [r2], {1}
       c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
      10:	0000001c 	andeq	r0, r0, ip, lsl r0
      14:	00000000 	andeq	r0, r0, r0
      18:	00000800 	andeq	r0, r0, r0, lsl #16
      1c:	000000d6 	ldrdeq	r0, [r0], -r6
      20:	87080e41 	strhi	r0, [r8, -r1, asr #28]
      24:	41018e02 	tstmi	r1, r2, lsl #28
      28:	0c41180e 	mcrreq	8, 0, r1, r1, cr14
      2c:	00000807 	andeq	r0, r0, r7, lsl #16
      30:	0000000c 	andeq	r0, r0, ip
      34:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
      38:	7c020001 	stcvc	0, cr0, [r2], {1}
      3c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
      40:	0000001c 	andeq	r0, r0, ip, lsl r0
      44:	00000030 	andeq	r0, r0, r0, lsr r0
      48:	000008d8 	ldrdeq	r0, [r0], -r8
      4c:	0000003c 	andeq	r0, r0, ip, lsr r0
      50:	87080e41 	strhi	r0, [r8, -r1, asr #28]
      54:	41018e02 	tstmi	r1, r2, lsl #28
      58:	0d41100e 	stcleq	0, cr1, [r1, #-56]	; 0xffffffc8
      5c:	00000007 	andeq	r0, r0, r7
      60:	0000001c 	andeq	r0, r0, ip, lsl r0
      64:	00000030 	andeq	r0, r0, r0, lsr r0
      68:	00000914 	andeq	r0, r0, r4, lsl r9
      6c:	000000a4 	andeq	r0, r0, r4, lsr #1
      70:	87080e41 	strhi	r0, [r8, -r1, asr #28]
      74:	41018e02 	tstmi	r1, r2, lsl #28
      78:	0d41100e 	stcleq	0, cr1, [r1, #-56]	; 0xffffffc8
      7c:	00000007 	andeq	r0, r0, r7
      80:	0000000c 	andeq	r0, r0, ip
      84:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
      88:	7c020001 	stcvc	0, cr0, [r2], {1}
      8c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
      90:	00000018 	andeq	r0, r0, r8, lsl r0
      94:	00000080 	andeq	r0, r0, r0, lsl #1
      98:	000009b8 			; <UNDEFINED> instruction: 0x000009b8
      9c:	000000f4 	strdeq	r0, [r0], -r4
      a0:	87080e41 	strhi	r0, [r8, -r1, asr #28]
      a4:	41018e02 	tstmi	r1, r2, lsl #28
      a8:	0000070d 	andeq	r0, r0, sp, lsl #14
      ac:	00000018 	andeq	r0, r0, r8, lsl r0
      b0:	00000080 	andeq	r0, r0, r0, lsl #1
      b4:	00000aac 	andeq	r0, r0, ip, lsr #21
      b8:	00000064 	andeq	r0, r0, r4, rrx
      bc:	87040e41 	strhi	r0, [r4, -r1, asr #28]
      c0:	100e4101 	andne	r4, lr, r1, lsl #2
      c4:	00070d41 	andeq	r0, r7, r1, asr #26
      c8:	00000018 	andeq	r0, r0, r8, lsl r0
      cc:	00000080 	andeq	r0, r0, r0, lsl #1
      d0:	00000b10 	andeq	r0, r0, r0, lsl fp
      d4:	00000186 	andeq	r0, r0, r6, lsl #3
      d8:	87040e41 	strhi	r0, [r4, -r1, asr #28]
      dc:	180e4101 	stmdane	lr, {r0, r8, lr}
      e0:	00070d41 	andeq	r0, r7, r1, asr #26
      e4:	00000018 	andeq	r0, r0, r8, lsl r0
      e8:	00000080 	andeq	r0, r0, r0, lsl #1
      ec:	00000c98 	muleq	r0, r8, ip
      f0:	000000f2 	strdeq	r0, [r0], -r2
      f4:	87040e41 	strhi	r0, [r4, -r1, asr #28]
      f8:	180e4101 	stmdane	lr, {r0, r8, lr}
      fc:	00070d41 	andeq	r0, r7, r1, asr #26
     100:	0000001c 	andeq	r0, r0, ip, lsl r0
     104:	00000080 	andeq	r0, r0, r0, lsl #1
     108:	00000d8c 	andeq	r0, r0, ip, lsl #27
     10c:	00000044 	andeq	r0, r0, r4, asr #32
     110:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     114:	41018e02 	tstmi	r1, r2, lsl #28
     118:	0c41280e 	mcrreq	8, 0, r2, r1, cr14
     11c:	00002007 	andeq	r2, r0, r7
     120:	0000000c 	andeq	r0, r0, ip
     124:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     128:	7c020001 	stcvc	0, cr0, [r2], {1}
     12c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     130:	0000001c 	andeq	r0, r0, ip, lsl r0
     134:	00000120 	andeq	r0, r0, r0, lsr #2
     138:	00000dd0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     13c:	00000200 	andeq	r0, r0, r0, lsl #4
     140:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     144:	41018e02 	tstmi	r1, r2, lsl #28
     148:	0d41400e 	stcleq	0, cr4, [r1, #-56]	; 0xffffffc8
     14c:	00000007 	andeq	r0, r0, r7
     150:	00000018 	andeq	r0, r0, r8, lsl r0
     154:	00000120 	andeq	r0, r0, r0, lsr #2
     158:	00000fd0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     15c:	00000042 	andeq	r0, r0, r2, asr #32
     160:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     164:	100e4101 	andne	r4, lr, r1, lsl #2
     168:	00070d41 	andeq	r0, r7, r1, asr #26
     16c:	0000001c 	andeq	r0, r0, ip, lsl r0
     170:	00000120 	andeq	r0, r0, r0, lsr #2
     174:	00001014 	andeq	r1, r0, r4, lsl r0
     178:	000000a6 	andeq	r0, r0, r6, lsr #1
     17c:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     180:	41018e02 	tstmi	r1, r2, lsl #28
     184:	0c41100e 	mcrreq	0, 0, r1, r1, cr14
     188:	00000807 	andeq	r0, r0, r7, lsl #16
     18c:	00000018 	andeq	r0, r0, r8, lsl r0
     190:	00000120 	andeq	r0, r0, r0, lsr #2
     194:	000010bc 	strheq	r1, [r0], -ip
     198:	00000076 	andeq	r0, r0, r6, ror r0
     19c:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     1a0:	41018e02 	tstmi	r1, r2, lsl #28
     1a4:	0000070d 	andeq	r0, r0, sp, lsl #14
     1a8:	0000001c 	andeq	r0, r0, ip, lsl r0
     1ac:	00000120 	andeq	r0, r0, r0, lsr #2
     1b0:	00001134 	andeq	r1, r0, r4, lsr r1
     1b4:	00000054 	andeq	r0, r0, r4, asr r0
     1b8:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     1bc:	41018e02 	tstmi	r1, r2, lsl #28
     1c0:	0c41100e 	mcrreq	0, 0, r1, r1, cr14
     1c4:	00000807 	andeq	r0, r0, r7, lsl #16
     1c8:	00000018 	andeq	r0, r0, r8, lsl r0
     1cc:	00000120 	andeq	r0, r0, r0, lsr #2
     1d0:	00001188 	andeq	r1, r0, r8, lsl #3
     1d4:	00000156 	andeq	r0, r0, r6, asr r1
     1d8:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     1dc:	200e4101 	andcs	r4, lr, r1, lsl #2
     1e0:	00070d41 	andeq	r0, r7, r1, asr #26
     1e4:	0000001c 	andeq	r0, r0, ip, lsl r0
     1e8:	00000120 	andeq	r0, r0, r0, lsr #2
     1ec:	000012e0 	andeq	r1, r0, r0, ror #5
     1f0:	0000004a 	andeq	r0, r0, sl, asr #32
     1f4:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     1f8:	41018e02 	tstmi	r1, r2, lsl #28
     1fc:	0d41180e 	stcleq	8, cr1, [r1, #-56]	; 0xffffffc8
     200:	00000007 	andeq	r0, r0, r7
     204:	0000001c 	andeq	r0, r0, ip, lsl r0
     208:	00000120 	andeq	r0, r0, r0, lsr #2
     20c:	0000132c 	andeq	r1, r0, ip, lsr #6
     210:	0000010e 	andeq	r0, r0, lr, lsl #2
     214:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     218:	41018e02 	tstmi	r1, r2, lsl #28
     21c:	0c41100e 	mcrreq	0, 0, r1, r1, cr14
     220:	00000807 	andeq	r0, r0, r7, lsl #16
     224:	00000020 	andeq	r0, r0, r0, lsr #32
     228:	00000120 	andeq	r0, r0, r0, lsr #2
     22c:	0000143c 	andeq	r1, r0, ip, lsr r4
     230:	00000110 	andeq	r0, r0, r0, lsl r1
     234:	84140e41 	ldrhi	r0, [r4], #-3649	; 0xe41
     238:	86048505 	strhi	r8, [r4], -r5, lsl #10
     23c:	8e028703 	cdphi	7, 0, cr8, cr2, cr3, {0}
     240:	380e4101 	stmdacc	lr, {r0, r8, lr}
     244:	18070c41 	stmdane	r7, {r0, r6, sl, fp}
     248:	0000001c 	andeq	r0, r0, ip, lsl r0
     24c:	00000120 	andeq	r0, r0, r0, lsr #2
     250:	0000154c 	andeq	r1, r0, ip, asr #10
     254:	0000008c 	andeq	r0, r0, ip, lsl #1
     258:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     25c:	41018e02 	tstmi	r1, r2, lsl #28
     260:	0d41100e 	stcleq	0, cr1, [r1, #-56]	; 0xffffffc8
     264:	00000007 	andeq	r0, r0, r7
     268:	00000018 	andeq	r0, r0, r8, lsl r0
     26c:	00000120 	andeq	r0, r0, r0, lsr #2
     270:	000015d8 	ldrdeq	r1, [r0], -r8
     274:	00000284 	andeq	r0, r0, r4, lsl #5
     278:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     27c:	200e4101 	andcs	r4, lr, r1, lsl #2
     280:	00070d41 	andeq	r0, r7, r1, asr #26
     284:	00000018 	andeq	r0, r0, r8, lsl r0
     288:	00000120 	andeq	r0, r0, r0, lsr #2
     28c:	0000185c 	andeq	r1, r0, ip, asr r8
     290:	000001ea 	andeq	r0, r0, sl, ror #3
     294:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     298:	180e4101 	stmdane	lr, {r0, r8, lr}
     29c:	00070d41 	andeq	r0, r7, r1, asr #26
     2a0:	0000000c 	andeq	r0, r0, ip
     2a4:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     2a8:	7c020001 	stcvc	0, cr0, [r2], {1}
     2ac:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     2b0:	0000001c 	andeq	r0, r0, ip, lsl r0
     2b4:	000002a0 	andeq	r0, r0, r0, lsr #5
     2b8:	00001a48 	andeq	r1, r0, r8, asr #20
     2bc:	0000003e 	andeq	r0, r0, lr, lsr r0
     2c0:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     2c4:	41018e02 	tstmi	r1, r2, lsl #28
     2c8:	0c41280e 	mcrreq	8, 0, r2, r1, cr14
     2cc:	00002007 	andeq	r2, r0, r7
     2d0:	0000001c 	andeq	r0, r0, ip, lsl r0
     2d4:	000002a0 	andeq	r0, r0, r0, lsr #5
     2d8:	00001a88 	andeq	r1, r0, r8, lsl #21
     2dc:	00000066 	andeq	r0, r0, r6, rrx
     2e0:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     2e4:	41018e02 	tstmi	r1, r2, lsl #28
     2e8:	0d41100e 	stcleq	0, cr1, [r1, #-56]	; 0xffffffc8
     2ec:	00000007 	andeq	r0, r0, r7
     2f0:	0000001c 	andeq	r0, r0, ip, lsl r0
     2f4:	000002a0 	andeq	r0, r0, r0, lsr #5
     2f8:	00001af0 	strdeq	r1, [r0], -r0
     2fc:	000000bc 	strheq	r0, [r0], -ip
     300:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     304:	41018e02 	tstmi	r1, r2, lsl #28
     308:	0d41100e 	stcleq	0, cr1, [r1, #-56]	; 0xffffffc8
     30c:	00000007 	andeq	r0, r0, r7
     310:	00000018 	andeq	r0, r0, r8, lsl r0
     314:	000002a0 	andeq	r0, r0, r0, lsr #5
     318:	00001bac 	andeq	r1, r0, ip, lsr #23
     31c:	000000d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     320:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     324:	41018e02 	tstmi	r1, r2, lsl #28
     328:	0000070d 	andeq	r0, r0, sp, lsl #14
     32c:	00000018 	andeq	r0, r0, r8, lsl r0
     330:	000002a0 	andeq	r0, r0, r0, lsr #5
     334:	00001c7c 	andeq	r1, r0, ip, ror ip
     338:	0000004e 	andeq	r0, r0, lr, asr #32
     33c:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     340:	41018e02 	tstmi	r1, r2, lsl #28
     344:	0000070d 	andeq	r0, r0, sp, lsl #14
     348:	00000018 	andeq	r0, r0, r8, lsl r0
     34c:	000002a0 	andeq	r0, r0, r0, lsr #5
     350:	00001ccc 	andeq	r1, r0, ip, asr #25
     354:	0000005e 	andeq	r0, r0, lr, asr r0
     358:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     35c:	41018e02 	tstmi	r1, r2, lsl #28
     360:	0000070d 	andeq	r0, r0, sp, lsl #14
     364:	00000018 	andeq	r0, r0, r8, lsl r0
     368:	000002a0 	andeq	r0, r0, r0, lsr #5
     36c:	00001d2c 	andeq	r1, r0, ip, lsr #26
     370:	0000005e 	andeq	r0, r0, lr, asr r0
     374:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     378:	41018e02 	tstmi	r1, r2, lsl #28
     37c:	0000070d 	andeq	r0, r0, sp, lsl #14
     380:	00000018 	andeq	r0, r0, r8, lsl r0
     384:	000002a0 	andeq	r0, r0, r0, lsr #5
     388:	00001d8c 	andeq	r1, r0, ip, lsl #27
     38c:	0000009a 	muleq	r0, sl, r0
     390:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     394:	41018e02 	tstmi	r1, r2, lsl #28
     398:	0000070d 	andeq	r0, r0, sp, lsl #14
     39c:	0000001c 	andeq	r0, r0, ip, lsl r0
     3a0:	000002a0 	andeq	r0, r0, r0, lsr #5
     3a4:	00001e28 	andeq	r1, r0, r8, lsr #28
     3a8:	000000a2 	andeq	r0, r0, r2, lsr #1
     3ac:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     3b0:	41018e02 	tstmi	r1, r2, lsl #28
     3b4:	0d41180e 	stcleq	8, cr1, [r1, #-56]	; 0xffffffc8
     3b8:	00000007 	andeq	r0, r0, r7
     3bc:	0000001c 	andeq	r0, r0, ip, lsl r0
     3c0:	000002a0 	andeq	r0, r0, r0, lsr #5
     3c4:	00001ecc 	andeq	r1, r0, ip, asr #29
     3c8:	000000c2 	andeq	r0, r0, r2, asr #1
     3cc:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     3d0:	41018e02 	tstmi	r1, r2, lsl #28
     3d4:	0d41100e 	stcleq	0, cr1, [r1, #-56]	; 0xffffffc8
     3d8:	00000007 	andeq	r0, r0, r7
     3dc:	00000018 	andeq	r0, r0, r8, lsl r0
     3e0:	000002a0 	andeq	r0, r0, r0, lsr #5
     3e4:	00001f90 	muleq	r0, r0, pc	; <UNPREDICTABLE>
     3e8:	00000024 	andeq	r0, r0, r4, lsr #32
     3ec:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     3f0:	100e4101 	andne	r4, lr, r1, lsl #2
     3f4:	00070d41 	andeq	r0, r7, r1, asr #26
     3f8:	0000000c 	andeq	r0, r0, ip
     3fc:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     400:	7c020001 	stcvc	0, cr0, [r2], {1}
     404:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     408:	0000001c 	andeq	r0, r0, ip, lsl r0
     40c:	000003f8 	strdeq	r0, [r0], -r8
     410:	00001fb4 			; <UNDEFINED> instruction: 0x00001fb4
     414:	000001cc 	andeq	r0, r0, ip, asr #3
     418:	41100e41 	tstmi	r0, r1, asr #28
     41c:	0687180e 	streq	r1, [r7], lr, lsl #16
     420:	0e41058e 	cdpeq	5, 4, cr0, cr1, cr14, {4}
     424:	070d4130 	smladxeq	sp, r0, r1, r4
     428:	0000001c 	andeq	r0, r0, ip, lsl r0
     42c:	000003f8 	strdeq	r0, [r0], -r8
     430:	00002180 	andeq	r2, r0, r0, lsl #3
     434:	000000b0 	strheq	r0, [r0], -r0	; <UNPREDICTABLE>
     438:	41100e41 	tstmi	r0, r1, asr #28
     43c:	0587140e 	streq	r1, [r7, #1038]	; 0x40e
     440:	41200e41 	teqmi	r0, r1, asr #28
     444:	0000070d 	andeq	r0, r0, sp, lsl #14
     448:	00000018 	andeq	r0, r0, r8, lsl r0
     44c:	000003f8 	strdeq	r0, [r0], -r8
     450:	00002230 	andeq	r2, r0, r0, lsr r2
     454:	00000054 	andeq	r0, r0, r4, asr r0
     458:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     45c:	100e4101 	andne	r4, lr, r1, lsl #2
     460:	00070d41 	andeq	r0, r7, r1, asr #26
     464:	00000018 	andeq	r0, r0, r8, lsl r0
     468:	000003f8 	strdeq	r0, [r0], -r8
     46c:	00002284 	andeq	r2, r0, r4, lsl #5
     470:	0000005e 	andeq	r0, r0, lr, asr r0
     474:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     478:	100e4101 	andne	r4, lr, r1, lsl #2
     47c:	00070d41 	andeq	r0, r7, r1, asr #26
     480:	00000018 	andeq	r0, r0, r8, lsl r0
     484:	000003f8 	strdeq	r0, [r0], -r8
     488:	000022e4 	andeq	r2, r0, r4, ror #5
     48c:	00000026 	andeq	r0, r0, r6, lsr #32
     490:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     494:	100e4101 	andne	r4, lr, r1, lsl #2
     498:	00070d41 	andeq	r0, r7, r1, asr #26
     49c:	00000018 	andeq	r0, r0, r8, lsl r0
     4a0:	000003f8 	strdeq	r0, [r0], -r8
     4a4:	0000230c 	andeq	r2, r0, ip, lsl #6
     4a8:	0000003c 	andeq	r0, r0, ip, lsr r0
     4ac:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     4b0:	100e4101 	andne	r4, lr, r1, lsl #2
     4b4:	00070d41 	andeq	r0, r7, r1, asr #26
     4b8:	0000001c 	andeq	r0, r0, ip, lsl r0
     4bc:	000003f8 	strdeq	r0, [r0], -r8
     4c0:	00002348 	andeq	r2, r0, r8, asr #6
     4c4:	0000005e 	andeq	r0, r0, lr, asr r0
     4c8:	41100e41 	tstmi	r0, r1, asr #28
     4cc:	0687180e 	streq	r1, [r7], lr, lsl #16
     4d0:	0e41058e 	cdpeq	5, 4, cr0, cr1, cr14, {4}
     4d4:	070d4120 	streq	r4, [sp, -r0, lsr #2]
     4d8:	0000001c 	andeq	r0, r0, ip, lsl r0
     4dc:	000003f8 	strdeq	r0, [r0], -r8
     4e0:	000023a8 	andeq	r2, r0, r8, lsr #7
     4e4:	0000005e 	andeq	r0, r0, lr, asr r0
     4e8:	41100e41 	tstmi	r0, r1, asr #28
     4ec:	0687180e 	streq	r1, [r7], lr, lsl #16
     4f0:	0e41058e 	cdpeq	5, 4, cr0, cr1, cr14, {4}
     4f4:	070d4120 	streq	r4, [sp, -r0, lsr #2]
     4f8:	00000018 	andeq	r0, r0, r8, lsl r0
     4fc:	000003f8 	strdeq	r0, [r0], -r8
     500:	00002408 	andeq	r2, r0, r8, lsl #8
     504:	000002ee 	andeq	r0, r0, lr, ror #5
     508:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     50c:	180e4101 	stmdane	lr, {r0, r8, lr}
     510:	00070d41 	andeq	r0, r7, r1, asr #26
     514:	00000018 	andeq	r0, r0, r8, lsl r0
     518:	000003f8 	strdeq	r0, [r0], -r8
     51c:	000026f8 	strdeq	r2, [r0], -r8
     520:	00000180 	andeq	r0, r0, r0, lsl #3
     524:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     528:	180e4101 	stmdane	lr, {r0, r8, lr}
     52c:	00070d41 	andeq	r0, r7, r1, asr #26
     530:	00000018 	andeq	r0, r0, r8, lsl r0
     534:	000003f8 	strdeq	r0, [r0], -r8
     538:	00002878 	andeq	r2, r0, r8, ror r8
     53c:	00000012 	andeq	r0, r0, r2, lsl r0
     540:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     544:	41018e02 	tstmi	r1, r2, lsl #28
     548:	0000070d 	andeq	r0, r0, sp, lsl #14
     54c:	00000018 	andeq	r0, r0, r8, lsl r0
     550:	000003f8 	strdeq	r0, [r0], -r8
     554:	0000288c 	andeq	r2, r0, ip, lsl #17
     558:	00000012 	andeq	r0, r0, r2, lsl r0
     55c:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     560:	41018e02 	tstmi	r1, r2, lsl #28
     564:	0000070d 	andeq	r0, r0, sp, lsl #14
     568:	0000000c 	andeq	r0, r0, ip
     56c:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     570:	7c020001 	stcvc	0, cr0, [r2], {1}
     574:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     578:	0000001c 	andeq	r0, r0, ip, lsl r0
     57c:	00000568 	andeq	r0, r0, r8, ror #10
     580:	000028a0 	andeq	r2, r0, r0, lsr #17
     584:	000004bc 			; <UNDEFINED> instruction: 0x000004bc
     588:	41100e41 	tstmi	r0, r1, asr #28
     58c:	0587140e 	streq	r1, [r7, #1038]	; 0x40e
     590:	41400e41 	cmpmi	r0, r1, asr #28
     594:	0000070d 	andeq	r0, r0, sp, lsl #14
     598:	0000001c 	andeq	r0, r0, ip, lsl r0
     59c:	00000568 	andeq	r0, r0, r8, ror #10
     5a0:	00002d5c 	andeq	r2, r0, ip, asr sp
     5a4:	00000026 	andeq	r0, r0, r6, lsr #32
     5a8:	41100e41 	tstmi	r0, r1, asr #28
     5ac:	0687180e 	streq	r1, [r7], lr, lsl #16
     5b0:	0d41058e 	cfstr64eq	mvdx0, [r1, #-568]	; 0xfffffdc8
     5b4:	00000007 	andeq	r0, r0, r7
     5b8:	0000001c 	andeq	r0, r0, ip, lsl r0
     5bc:	00000568 	andeq	r0, r0, r8, ror #10
     5c0:	00002d84 	andeq	r2, r0, r4, lsl #27
     5c4:	00000026 	andeq	r0, r0, r6, lsr #32
     5c8:	41100e41 	tstmi	r0, r1, asr #28
     5cc:	0687180e 	streq	r1, [r7], lr, lsl #16
     5d0:	0d41058e 	cfstr64eq	mvdx0, [r1, #-568]	; 0xfffffdc8
     5d4:	00000007 	andeq	r0, r0, r7
     5d8:	00000018 	andeq	r0, r0, r8, lsl r0
     5dc:	00000568 	andeq	r0, r0, r8, ror #10
     5e0:	00002dac 	andeq	r2, r0, ip, lsr #27
     5e4:	00000054 	andeq	r0, r0, r4, asr r0
     5e8:	41100e41 	tstmi	r0, r1, asr #28
     5ec:	0587140e 	streq	r1, [r7, #1038]	; 0x40e
     5f0:	00070d41 	andeq	r0, r7, r1, asr #26
     5f4:	00000018 	andeq	r0, r0, r8, lsl r0
     5f8:	00000568 	andeq	r0, r0, r8, ror #10
     5fc:	00002e00 	andeq	r2, r0, r0, lsl #28
     600:	0000002a 	andeq	r0, r0, sl, lsr #32
     604:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     608:	41018e02 	tstmi	r1, r2, lsl #28
     60c:	0000070d 	andeq	r0, r0, sp, lsl #14
     610:	00000018 	andeq	r0, r0, r8, lsl r0
     614:	00000568 	andeq	r0, r0, r8, ror #10
     618:	00002e2c 	andeq	r2, r0, ip, lsr #28
     61c:	0000002a 	andeq	r0, r0, sl, lsr #32
     620:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     624:	41018e02 	tstmi	r1, r2, lsl #28
     628:	0000070d 	andeq	r0, r0, sp, lsl #14
     62c:	00000018 	andeq	r0, r0, r8, lsl r0
     630:	00000568 	andeq	r0, r0, r8, ror #10
     634:	00002e58 	andeq	r2, r0, r8, asr lr
     638:	0000002a 	andeq	r0, r0, sl, lsr #32
     63c:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     640:	41018e02 	tstmi	r1, r2, lsl #28
     644:	0000070d 	andeq	r0, r0, sp, lsl #14
     648:	00000018 	andeq	r0, r0, r8, lsl r0
     64c:	00000568 	andeq	r0, r0, r8, ror #10
     650:	00002e84 	andeq	r2, r0, r4, lsl #29
     654:	0000002a 	andeq	r0, r0, sl, lsr #32
     658:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     65c:	41018e02 	tstmi	r1, r2, lsl #28
     660:	0000070d 	andeq	r0, r0, sp, lsl #14
     664:	00000018 	andeq	r0, r0, r8, lsl r0
     668:	00000568 	andeq	r0, r0, r8, ror #10
     66c:	00002eb0 			; <UNDEFINED> instruction: 0x00002eb0
     670:	0000002a 	andeq	r0, r0, sl, lsr #32
     674:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     678:	41018e02 	tstmi	r1, r2, lsl #28
     67c:	0000070d 	andeq	r0, r0, sp, lsl #14
     680:	00000018 	andeq	r0, r0, r8, lsl r0
     684:	00000568 	andeq	r0, r0, r8, ror #10
     688:	00002edc 	ldrdeq	r2, [r0], -ip
     68c:	0000002a 	andeq	r0, r0, sl, lsr #32
     690:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     694:	41018e02 	tstmi	r1, r2, lsl #28
     698:	0000070d 	andeq	r0, r0, sp, lsl #14
     69c:	00000018 	andeq	r0, r0, r8, lsl r0
     6a0:	00000568 	andeq	r0, r0, r8, ror #10
     6a4:	00002f08 	andeq	r2, r0, r8, lsl #30
     6a8:	0000002a 	andeq	r0, r0, sl, lsr #32
     6ac:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     6b0:	41018e02 	tstmi	r1, r2, lsl #28
     6b4:	0000070d 	andeq	r0, r0, sp, lsl #14
     6b8:	00000018 	andeq	r0, r0, r8, lsl r0
     6bc:	00000568 	andeq	r0, r0, r8, ror #10
     6c0:	00002f34 	andeq	r2, r0, r4, lsr pc
     6c4:	0000002a 	andeq	r0, r0, sl, lsr #32
     6c8:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     6cc:	41018e02 	tstmi	r1, r2, lsl #28
     6d0:	0000070d 	andeq	r0, r0, sp, lsl #14
     6d4:	00000018 	andeq	r0, r0, r8, lsl r0
     6d8:	00000568 	andeq	r0, r0, r8, ror #10
     6dc:	00002f60 	andeq	r2, r0, r0, ror #30
     6e0:	0000002a 	andeq	r0, r0, sl, lsr #32
     6e4:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     6e8:	41018e02 	tstmi	r1, r2, lsl #28
     6ec:	0000070d 	andeq	r0, r0, sp, lsl #14
     6f0:	00000018 	andeq	r0, r0, r8, lsl r0
     6f4:	00000568 	andeq	r0, r0, r8, ror #10
     6f8:	00002f8c 	andeq	r2, r0, ip, lsl #31
     6fc:	0000002a 	andeq	r0, r0, sl, lsr #32
     700:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     704:	41018e02 	tstmi	r1, r2, lsl #28
     708:	0000070d 	andeq	r0, r0, sp, lsl #14
     70c:	00000018 	andeq	r0, r0, r8, lsl r0
     710:	00000568 	andeq	r0, r0, r8, ror #10
     714:	00002fb8 			; <UNDEFINED> instruction: 0x00002fb8
     718:	0000002a 	andeq	r0, r0, sl, lsr #32
     71c:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     720:	41018e02 	tstmi	r1, r2, lsl #28
     724:	0000070d 	andeq	r0, r0, sp, lsl #14
     728:	00000018 	andeq	r0, r0, r8, lsl r0
     72c:	00000568 	andeq	r0, r0, r8, ror #10
     730:	00002fe4 	andeq	r2, r0, r4, ror #31
     734:	0000002a 	andeq	r0, r0, sl, lsr #32
     738:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     73c:	41018e02 	tstmi	r1, r2, lsl #28
     740:	0000070d 	andeq	r0, r0, sp, lsl #14
     744:	00000018 	andeq	r0, r0, r8, lsl r0
     748:	00000568 	andeq	r0, r0, r8, ror #10
     74c:	00003010 	andeq	r3, r0, r0, lsl r0
     750:	0000002a 	andeq	r0, r0, sl, lsr #32
     754:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     758:	41018e02 	tstmi	r1, r2, lsl #28
     75c:	0000070d 	andeq	r0, r0, sp, lsl #14
     760:	00000018 	andeq	r0, r0, r8, lsl r0
     764:	00000568 	andeq	r0, r0, r8, ror #10
     768:	0000303c 	andeq	r3, r0, ip, lsr r0
     76c:	0000002a 	andeq	r0, r0, sl, lsr #32
     770:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     774:	41018e02 	tstmi	r1, r2, lsl #28
     778:	0000070d 	andeq	r0, r0, sp, lsl #14
     77c:	00000018 	andeq	r0, r0, r8, lsl r0
     780:	00000568 	andeq	r0, r0, r8, ror #10
     784:	00003068 	andeq	r3, r0, r8, rrx
     788:	0000002a 	andeq	r0, r0, sl, lsr #32
     78c:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     790:	41018e02 	tstmi	r1, r2, lsl #28
     794:	0000070d 	andeq	r0, r0, sp, lsl #14
     798:	00000018 	andeq	r0, r0, r8, lsl r0
     79c:	00000568 	andeq	r0, r0, r8, ror #10
     7a0:	00003094 	muleq	r0, r4, r0
     7a4:	0000002a 	andeq	r0, r0, sl, lsr #32
     7a8:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     7ac:	41018e02 	tstmi	r1, r2, lsl #28
     7b0:	0000070d 	andeq	r0, r0, sp, lsl #14
     7b4:	0000000c 	andeq	r0, r0, ip
     7b8:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     7bc:	7c020001 	stcvc	0, cr0, [r2], {1}
     7c0:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     7c4:	00000020 	andeq	r0, r0, r0, lsr #32
     7c8:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
     7cc:	000030c0 	andeq	r3, r0, r0, asr #1
     7d0:	000001ee 	andeq	r0, r0, lr, ror #3
     7d4:	41100e41 	tstmi	r0, r1, asr #28
     7d8:	0687180e 	streq	r1, [r7], lr, lsl #16
     7dc:	0e41058e 	cdpeq	5, 4, cr0, cr1, cr14, {4}
     7e0:	070c4130 	smladxeq	ip, r0, r1, r4
     7e4:	00000020 	andeq	r0, r0, r0, lsr #32
     7e8:	00000020 	andeq	r0, r0, r0, lsr #32
     7ec:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
     7f0:	000032b0 			; <UNDEFINED> instruction: 0x000032b0
     7f4:	0000011c 	andeq	r0, r0, ip, lsl r1
     7f8:	41100e41 	tstmi	r0, r1, asr #28
     7fc:	0687180e 	streq	r1, [r7], lr, lsl #16
extern GPIO_InitTypeDef OV_PTA_init;

extern char ready_send_flag;

int main (void)
{
     800:	0e41058e 	cdpeq	5, 4, cr0, cr1, cr14, {4}
     804:	070c4128 	streq	r4, [ip, -r8, lsr #2]

    Ov7725_Init ();
     808:	00000018 	andeq	r0, r0, r8, lsl r0
    Ov7725_Delay();
     80c:	0000001c 	andeq	r0, r0, ip, lsl r0

    //Ov7725_Dma_Init();
    Ov7725_Gpio_Init ();
     810:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
    dma_portx2buff_init (DMA_CH0, (void *)(&GPIOB_PDIR), (void *)img,PORTA_DMAREQ ,DMA_BYTE1, PHOTO_SIZE / 8, DADDR_KEEPON);
     814:	000033cc 	andeq	r3, r0, ip, asr #7
     818:	000000a6 	andeq	r0, r0, r6, lsr #1
     81c:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     820:	41018e02 	tstmi	r1, r2, lsl #28
     824:	0d41200e 	stcleq	0, cr2, [r1, #-56]	; 0xffffffc8
     828:	00000007 	andeq	r0, r0, r7
     82c:	00000018 	andeq	r0, r0, r8, lsl r0
     830:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
     834:	00003474 	andeq	r3, r0, r4, ror r4
     838:	00000088 	andeq	r0, r0, r8, lsl #1
     83c:	87040e41 	strhi	r0, [r4, -r1, asr #28]
    //装载DMA中断
    DMA_ISR[DMA_CH0] = Ov7725_eagle_dma;
     840:	200e4101 	andcs	r4, lr, r1, lsl #2
     844:	00070d41 	andeq	r0, r7, r1, asr #26
     848:	0000001c 	andeq	r0, r0, ip, lsl r0
     84c:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
     850:	000034fc 	strdeq	r3, [r0], -ip
    //关闭DMA通道
    DMA_DIS(DMA_CH0);
     854:	0000004c 	andeq	r0, r0, ip, asr #32
     858:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     85c:	41018e02 	tstmi	r1, r2, lsl #28
     860:	0d41100e 	stcleq	0, cr1, [r1, #-56]	; 0xffffffc8
     864:	00000007 	andeq	r0, r0, r7
     868:	0000001c 	andeq	r0, r0, ip, lsl r0
    //关GPIO中断
    disable_irq(INT_PORTA - 16);
     86c:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
     870:	00003548 	andeq	r3, r0, r8, asr #10
    //清DMA中断置为标志
    DMA_IRQ_CLEAN(DMA_CH0);
     874:	00000122 	andeq	r0, r0, r2, lsr #2
     878:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     87c:	41018e02 	tstmi	r1, r2, lsl #28
     880:	0d41100e 	stcleq	0, cr1, [r1, #-56]	; 0xffffffc8
     884:	00000007 	andeq	r0, r0, r7
     888:	00000018 	andeq	r0, r0, r8, lsl r0
    //使能DMA中断
    DMA_IRQ_EN (DMA_CH0);
     88c:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
     890:	0000366c 	andeq	r3, r0, ip, ror #12
    //开启GPIO中断
    LPLD_GPIO_EnableIrq(OV_PTA_init);
     894:	00000022 	andeq	r0, r0, r2, lsr #32
     898:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     89c:	100e4101 	andne	r4, lr, r1, lsl #2
     8a0:	00070d41 	andeq	r0, r7, r1, asr #26
     8a4:	00000018 	andeq	r0, r0, r8, lsl r0
    {
        //获取图像
        //Ov7725_eagle_get_img ();
        //解压图像
        //Ov7725_img_extract (Pix_Data, img, PHOTO_SIZE/8);
        if(ready_send_flag)
     8a8:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
     8ac:	00003690 	muleq	r0, r0, r6
     8b0:	0000001e 	andeq	r0, r0, lr, lsl r0
     8b4:	87040e41 	strhi	r0, [r4, -r1, asr #28]
        {
            //发送图片到上位机
            //get_midline(Pix_Data, 60, 80);
            Ov7725_sendimg (Pix_Data, PHOTO_SIZE);
     8b8:	100e4101 	andne	r4, lr, r1, lsl #2
     8bc:	00070d41 	andeq	r0, r7, r1, asr #26
     8c0:	00000018 	andeq	r0, r0, r8, lsl r0
     8c4:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
            ready_send_flag = 0;
     8c8:	000036b0 			; <UNDEFINED> instruction: 0x000036b0
     8cc:	00000032 	andeq	r0, r0, r2, lsr r0
     8d0:	87040e41 	strhi	r0, [r4, -r1, asr #28]
        }
    }
     8d4:	100e4101 	andne	r4, lr, r1, lsl #2
 * \param  void
 *
 * \return void
 */
void Default_Handler(void)
{
     8d8:	00070d41 	andeq	r0, r7, r1, asr #26
     8dc:	00000018 	andeq	r0, r0, r8, lsl r0
#define VECTORNUM       (*(volatile char *) (0xE000ED04))
  //while (1);
  char vtr = VECTORNUM;
     8e0:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
     8e4:	000036e4 	andeq	r3, r0, r4, ror #13
     8e8:	0000003a 	andeq	r0, r0, sl, lsr r0
  printf ("\n ******************\n");
     8ec:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     8f0:	100e4101 	andne	r4, lr, r1, lsl #2
     8f4:	00070d41 	andeq	r0, r7, r1, asr #26
  printf ("Default Handler Error\n");
     8f8:	00000018 	andeq	r0, r0, r8, lsl r0
     8fc:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
     900:	00003720 	andeq	r3, r0, r0, lsr #14
  printf ("On vector %d **** Interrupt\n", vtr);
     904:	0000002a 	andeq	r0, r0, sl, lsr #32
     908:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     90c:	100e4101 	andne	r4, lr, r1, lsl #2
     910:	00070d41 	andeq	r0, r7, r1, asr #26
 * \param  void
 *
 * \return void
 */
void Reset_Handler(void)
{
     914:	00000018 	andeq	r0, r0, r8, lsl r0
     918:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
  unsigned char *source;
  unsigned char *destination;

  /* watchdog disable */
  *((volatile unsigned short *)0x4005200E) = 0xC520;
     91c:	0000374c 	andeq	r3, r0, ip, asr #14
     920:	00000026 	andeq	r0, r0, r6, lsr #32
     924:	87040e41 	strhi	r0, [r4, -r1, asr #28]
  *((volatile unsigned short *)0x4005200E) = 0xD928;
     928:	100e4101 	andne	r4, lr, r1, lsl #2
     92c:	00070d41 	andeq	r0, r7, r1, asr #26
     930:	00000018 	andeq	r0, r0, r8, lsl r0
     934:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
  *((volatile unsigned short *)0x40052000) = 0x01D2;
     938:	00003774 	andeq	r3, r0, r4, ror r7
     93c:	0000001a 	andeq	r0, r0, sl, lsl r0
     940:	87040e41 	strhi	r0, [r4, -r1, asr #28]

  /* copy data values from ROM to RAM */
  source = (unsigned char *)&_etext;
     944:	100e4101 	andne	r4, lr, r1, lsl #2
     948:	00070d41 	andeq	r0, r7, r1, asr #26
     94c:	00000018 	andeq	r0, r0, r8, lsl r0
  destination = (unsigned char *)&_sdata;
     950:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
     954:	00003790 	muleq	r0, r0, r7
  while (destination < (unsigned char*)&_edata) {
     958:	0000001a 	andeq	r0, r0, sl, lsl r0
    *(destination++) = *(source++);
     95c:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     960:	100e4101 	andne	r4, lr, r1, lsl #2
     964:	00070d41 	andeq	r0, r7, r1, asr #26
     968:	0000001c 	andeq	r0, r0, ip, lsl r0
     96c:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
     970:	000037ac 	andeq	r3, r0, ip, lsr #15
  *((volatile unsigned short *)0x40052000) = 0x01D2;

  /* copy data values from ROM to RAM */
  source = (unsigned char *)&_etext;
  destination = (unsigned char *)&_sdata;
  while (destination < (unsigned char*)&_edata) {
     974:	00000092 	muleq	r0, r2, r0
     978:	41100e41 	tstmi	r0, r1, asr #28
     97c:	0687180e 	streq	r1, [r7], lr, lsl #16
    *(destination++) = *(source++);
  }

  /* clear bss section */
  source = (unsigned char *)&_sbss;
     980:	0e41058e 	cdpeq	5, 4, cr0, cr1, cr14, {4}
     984:	070d4120 	streq	r4, [sp, -r0, lsr #2]
     988:	0000001c 	andeq	r0, r0, ip, lsl r0
  destination = (unsigned char *)&_ebss;
     98c:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
     990:	00003840 	andeq	r3, r0, r0, asr #16
  while (source < destination ) {
     994:	00000092 	muleq	r0, r2, r0
    *source++ = 0;
     998:	41100e41 	tstmi	r0, r1, asr #28
     99c:	0687180e 	streq	r1, [r7], lr, lsl #16
     9a0:	0e41058e 	cdpeq	5, 4, cr0, cr1, cr14, {4}
     9a4:	070d4120 	streq	r4, [sp, -r0, lsr #2]
  }

  /* clear bss section */
  source = (unsigned char *)&_sbss;
  destination = (unsigned char *)&_ebss;
  while (source < destination ) {
     9a8:	0000001c 	andeq	r0, r0, ip, lsl r0
     9ac:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
    *source++ = 0;
  }
 //进入系统初始化函数
  SystemInit();
     9b0:	000038d4 	ldrdeq	r3, [r0], -r4
 //进入用户函数
  main();
     9b4:	00000052 	andeq	r0, r0, r2, asr r0
 * \param  void
 *
 * \return void
 */
void SystemInit(void)
{
     9b8:	87080e41 	strhi	r0, [r8, -r1, asr #28]
  //使能所有IO口时钟
  SIM_SCGC5 |= (SIM_SCGC5_PORTA_MASK | SIM_SCGC5_PORTB_MASK
     9bc:	41018e02 	tstmi	r1, r2, lsl #28
     9c0:	0d41100e 	stcleq	0, cr1, [r1, #-56]	; 0xffffffc8
     9c4:	00000007 	andeq	r0, r0, r7
     9c8:	0000001c 	andeq	r0, r0, ip, lsl r0
     9cc:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
     9d0:	00003928 	andeq	r3, r0, r8, lsr #18
     9d4:	00000042 	andeq	r0, r0, r2, asr #32
     9d8:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     9dc:	41018e02 	tstmi	r1, r2, lsl #28
     9e0:	0d41100e 	stcleq	0, cr1, [r1, #-56]	; 0xffffffc8
              | SIM_SCGC5_PORTC_MASK | SIM_SCGC5_PORTD_MASK
              | SIM_SCGC5_PORTE_MASK);
  //初始化各部分时钟：系统内核主频、总线时钟、FlexBus时钟、Flash时钟
  LPLD_PLL_Setup(CORE_CLK_MHZ);
     9e4:	00000007 	andeq	r0, r0, r7
     9e8:	0000001c 	andeq	r0, r0, ip, lsl r0
  
  //更新内核主频
  SystemCoreClockUpdate();
     9ec:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
  
  //获取各部分时钟
  g_core_clock = SystemCoreClock;
     9f0:	0000396c 	andeq	r3, r0, ip, ror #18
     9f4:	000001ba 			; <UNDEFINED> instruction: 0x000001ba
     9f8:	41100e41 	tstmi	r0, r1, asr #28
     9fc:	0587140e 	streq	r1, [r7, #1038]	; 0x40e
     a00:	41380e41 	teqmi	r8, r1, asr #28
  g_bus_clock = g_core_clock / ((uint32_t)((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV2_MASK) >> SIM_CLKDIV1_OUTDIV2_SHIFT)+ 1u);
     a04:	0000070d 	andeq	r0, r0, sp, lsl #14
     a08:	0000001c 	andeq	r0, r0, ip, lsl r0
     a0c:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
     a10:	00003b28 	andeq	r3, r0, r8, lsr #22
     a14:	0000010c 	andeq	r0, r0, ip, lsl #2
     a18:	41100e41 	tstmi	r0, r1, asr #28
     a1c:	0587140e 	streq	r1, [r7, #1038]	; 0x40e
     a20:	41280e41 	teqmi	r8, r1, asr #28
     a24:	0000070d 	andeq	r0, r0, sp, lsl #14
     a28:	00000018 	andeq	r0, r0, r8, lsl r0
     a2c:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
     a30:	00003c34 	andeq	r3, r0, r4, lsr ip
     a34:	0000093a 	andeq	r0, r0, sl, lsr r9
     a38:	87040e41 	strhi	r0, [r4, -r1, asr #28]
  g_flexbus_clock =  g_core_clock / ((uint32_t)((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV3_MASK) >> SIM_CLKDIV1_OUTDIV3_SHIFT)+ 1u);
     a3c:	100e4101 	andne	r4, lr, r1, lsl #2
     a40:	00070d41 	andeq	r0, r7, r1, asr #26
     a44:	00000018 	andeq	r0, r0, r8, lsl r0
     a48:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
     a4c:	00004570 	andeq	r4, r0, r0, ror r5
     a50:	00000658 	andeq	r0, r0, r8, asr r6
     a54:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     a58:	100e4101 	andne	r4, lr, r1, lsl #2
     a5c:	00070d41 	andeq	r0, r7, r1, asr #26
     a60:	0000001c 	andeq	r0, r0, ip, lsl r0
     a64:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
     a68:	00004bc8 	andeq	r4, r0, r8, asr #23
     a6c:	00000070 	andeq	r0, r0, r0, ror r0
  g_flash_clock =  g_core_clock / ((uint32_t)((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV4_MASK) >> SIM_CLKDIV1_OUTDIV4_SHIFT)+ 1u);
     a70:	41100e41 	tstmi	r0, r1, asr #28
     a74:	0587140e 	streq	r1, [r7, #1038]	; 0x40e
     a78:	41200e41 	teqmi	r0, r1, asr #28
     a7c:	0000070d 	andeq	r0, r0, sp, lsl #14
     a80:	00000018 	andeq	r0, r0, r8, lsl r0
     a84:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
     a88:	00004c38 	andeq	r4, r0, r8, lsr ip
     a8c:	0000001c 	andeq	r0, r0, ip, lsl r0
     a90:	41100e41 	tstmi	r0, r1, asr #28
     a94:	0587140e 	streq	r1, [r7, #1038]	; 0x40e
     a98:	00070d41 	andeq	r0, r7, r1, asr #26
     a9c:	00000018 	andeq	r0, r0, r8, lsl r0
     aa0:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
     aa4:	00004c54 	andeq	r4, r0, r4, asr ip
 
    //初始化系统终端
  systemTerm ();
     aa8:	00000012 	andeq	r0, r0, r2, lsl r0
 *
 * @brief  更新全局变量SystemCoreClock的值，以便获取最新的系统内核频率。
 *         
 */
void SystemCoreClockUpdate (void) 
{
     aac:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     ab0:	41018e02 	tstmi	r1, r2, lsl #28
    uint32_t temp;
    temp =  CPU_XTAL_CLK_HZ *((uint32_t)(MCG_C6 & MCG_C6_VDIV_MASK) + 16u );
     ab4:	0000070d 	andeq	r0, r0, sp, lsl #14
     ab8:	00000018 	andeq	r0, r0, r8, lsl r0
     abc:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
     ac0:	00004c68 	andeq	r4, r0, r8, ror #24
     ac4:	00000012 	andeq	r0, r0, r2, lsl r0
     ac8:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     acc:	41018e02 	tstmi	r1, r2, lsl #28
     ad0:	0000070d 	andeq	r0, r0, sp, lsl #14
     ad4:	00000018 	andeq	r0, r0, r8, lsl r0
     ad8:	000007b4 			; <UNDEFINED> instruction: 0x000007b4
    temp = (uint32_t)(temp/((uint32_t)(MCG_C5 & MCG_C5_PRDIV_MASK) +1u ))/2;
     adc:	00004c7c 	andeq	r4, r0, ip, ror ip
     ae0:	00000012 	andeq	r0, r0, r2, lsl r0
     ae4:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     ae8:	41018e02 	tstmi	r1, r2, lsl #28
     aec:	0000070d 	andeq	r0, r0, sp, lsl #14
     af0:	0000000c 	andeq	r0, r0, ip
     af4:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     af8:	7c020001 	stcvc	0, cr0, [r2], {1}
    SystemCoreClock = temp;
     afc:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     b00:	0000001c 	andeq	r0, r0, ip, lsl r0
     b04:	00000af0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
}
     b08:	00004c90 	muleq	r0, r0, ip
     b0c:	00000156 	andeq	r0, r0, r6, asr r1
/*
 * 使能中断
 */

void enable_irq (int irq)
{
     b10:	41100e41 	tstmi	r0, r1, asr #28
     b14:	0587140e 	streq	r1, [r7, #1038]	; 0x40e
    int div;
    if (irq > 105)
     b18:	41300e41 	teqmi	r0, r1, asr #28
     b1c:	0000070d 	andeq	r0, r0, sp, lsl #14
        irq = 105;
     b20:	0000001c 	andeq	r0, r0, ip, lsl r0
    div = irq / 32;
     b24:	00000af0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     b28:	00004de8 	andeq	r4, r0, r8, ror #27
     b2c:	000000f2 	strdeq	r0, [r0], -r2
     b30:	41100e41 	tstmi	r0, r1, asr #28
    switch (div)
     b34:	0687180e 	streq	r1, [r7], lr, lsl #16
     b38:	0e41058e 	cdpeq	5, 4, cr0, cr1, cr14, {4}
     b3c:	070d4120 	streq	r4, [sp, -r0, lsr #2]
     b40:	0000001c 	andeq	r0, r0, ip, lsl r0
     b44:	00000af0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     b48:	00004edc 	ldrdeq	r4, [r0], -ip
     b4c:	00000106 	andeq	r0, r0, r6, lsl #2
     b50:	41100e41 	tstmi	r0, r1, asr #28
    {
        case 0x0:
            NVICICPR0 |= 1 << (irq & 0x1F);
     b54:	0587140e 	streq	r1, [r7, #1038]	; 0x40e
     b58:	41280e41 	teqmi	r8, r1, asr #28
     b5c:	0000070d 	andeq	r0, r0, sp, lsl #14
     b60:	00000018 	andeq	r0, r0, r8, lsl r0
     b64:	00000af0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     b68:	00004fe4 	andeq	r4, r0, r4, ror #31
     b6c:	00000020 	andeq	r0, r0, r0, lsr #32
     b70:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     b74:	100e4101 	andne	r4, lr, r1, lsl #2
     b78:	00070d41 	andeq	r0, r7, r1, asr #26
            NVICISER0 |= 1 << (irq & 0x1F);
     b7c:	00000018 	andeq	r0, r0, r8, lsl r0
     b80:	00000af0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     b84:	00005004 	andeq	r5, r0, r4
     b88:	0000003c 	andeq	r0, r0, ip, lsr r0
     b8c:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     b90:	100e4101 	andne	r4, lr, r1, lsl #2
     b94:	00070d41 	andeq	r0, r7, r1, asr #26
     b98:	00000018 	andeq	r0, r0, r8, lsl r0
     b9c:	00000af0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
            break;
     ba0:	00005040 	andeq	r5, r0, r0, asr #32
        case 0x1:
            NVICICPR1 |= 1 << (irq & 0x1F);
     ba4:	00000020 	andeq	r0, r0, r0, lsr #32
     ba8:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     bac:	100e4101 	andne	r4, lr, r1, lsl #2
     bb0:	00070d41 	andeq	r0, r7, r1, asr #26
     bb4:	00000018 	andeq	r0, r0, r8, lsl r0
     bb8:	00000af0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     bbc:	00005060 	andeq	r5, r0, r0, rrx
     bc0:	0000002a 	andeq	r0, r0, sl, lsr #32
     bc4:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     bc8:	100e4101 	andne	r4, lr, r1, lsl #2
            NVICISER1 |= 1 << (irq & 0x1F);
     bcc:	00070d41 	andeq	r0, r7, r1, asr #26
     bd0:	00000018 	andeq	r0, r0, r8, lsl r0
     bd4:	00000af0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     bd8:	0000508c 	andeq	r5, r0, ip, lsl #1
     bdc:	0000001c 	andeq	r0, r0, ip, lsl r0
     be0:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     be4:	180e4101 	stmdane	lr, {r0, r8, lr}
     be8:	00070d41 	andeq	r0, r7, r1, asr #26
     bec:	00000018 	andeq	r0, r0, r8, lsl r0
            break;
        case 0x2:
            NVICICPR2 |= 1 << (irq & 0x1F);
     bf0:	00000af0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     bf4:	000050a8 	andeq	r5, r0, r8, lsr #1
     bf8:	0000002a 	andeq	r0, r0, sl, lsr #32
     bfc:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     c00:	100e4101 	andne	r4, lr, r1, lsl #2
     c04:	00070d41 	andeq	r0, r7, r1, asr #26
     c08:	00000018 	andeq	r0, r0, r8, lsl r0
     c0c:	00000af0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     c10:	000050d4 	ldrdeq	r5, [r0], -r4
     c14:	00000022 	andeq	r0, r0, r2, lsr #32
            NVICISER2 |= 1 << (irq & 0x1F);
     c18:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     c1c:	41018e02 	tstmi	r1, r2, lsl #28
     c20:	0000070d 	andeq	r0, r0, sp, lsl #14
     c24:	00000018 	andeq	r0, r0, r8, lsl r0
     c28:	00000af0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     c2c:	000050f8 	strdeq	r5, [r0], -r8
     c30:	00000022 	andeq	r0, r0, r2, lsr #32
     c34:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     c38:	41018e02 	tstmi	r1, r2, lsl #28
            break;
     c3c:	0000070d 	andeq	r0, r0, sp, lsl #14
        case 0x3:
            NVICICPR3 |= 1 << (irq & 0x1F);
     c40:	00000018 	andeq	r0, r0, r8, lsl r0
     c44:	00000af0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     c48:	0000511c 	andeq	r5, r0, ip, lsl r1
     c4c:	00000022 	andeq	r0, r0, r2, lsr #32
     c50:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     c54:	41018e02 	tstmi	r1, r2, lsl #28
     c58:	0000070d 	andeq	r0, r0, sp, lsl #14
     c5c:	00000018 	andeq	r0, r0, r8, lsl r0
     c60:	00000af0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     c64:	00005140 	andeq	r5, r0, r0, asr #2
            NVICISER3 |= 1 << (irq & 0x1F);
     c68:	00000022 	andeq	r0, r0, r2, lsr #32
     c6c:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     c70:	41018e02 	tstmi	r1, r2, lsl #28
     c74:	0000070d 	andeq	r0, r0, sp, lsl #14
     c78:	00000018 	andeq	r0, r0, r8, lsl r0
     c7c:	00000af0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     c80:	00005164 	andeq	r5, r0, r4, ror #2
     c84:	00000022 	andeq	r0, r0, r2, lsr #32
     c88:	87080e41 	strhi	r0, [r8, -r1, asr #28]
            break;
    }
}
     c8c:	41018e02 	tstmi	r1, r2, lsl #28
     c90:	0000070d 	andeq	r0, r0, sp, lsl #14
     c94:	0000000c 	andeq	r0, r0, ip
/*
 * 关闭中断
 */

void disable_irq (int irq)
{
     c98:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     c9c:	7c020001 	stcvc	0, cr0, [r2], {1}
    int div;
    if (irq > 105)
     ca0:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     ca4:	00000018 	andeq	r0, r0, r8, lsl r0
        irq = 105;
     ca8:	00000c94 	muleq	r0, r4, ip
    div = irq / 32;
     cac:	00005188 	andeq	r5, r0, r8, lsl #3
     cb0:	000001a0 	andeq	r0, r0, r0, lsr #3
     cb4:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     cb8:	280e4101 	stmdacs	lr, {r0, r8, lr}
    switch (div)
     cbc:	00070d41 	andeq	r0, r7, r1, asr #26
     cc0:	00000018 	andeq	r0, r0, r8, lsl r0
     cc4:	00000c94 	muleq	r0, r4, ip
     cc8:	00005328 	andeq	r5, r0, r8, lsr #6
     ccc:	00000066 	andeq	r0, r0, r6, rrx
     cd0:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     cd4:	41018e02 	tstmi	r1, r2, lsl #28
    {
        case 0x0:
            NVICICPR0 |= 1 << (irq & 0x1F);
     cd8:	0000070d 	andeq	r0, r0, sp, lsl #14
     cdc:	00000014 	andeq	r0, r0, r4, lsl r0
     ce0:	00000c94 	muleq	r0, r4, ip
     ce4:	00005390 	muleq	r0, r0, r3
     ce8:	00000022 	andeq	r0, r0, r2, lsr #32
     cec:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     cf0:	070d4101 	streq	r4, [sp, -r1, lsl #2]
     cf4:	00000018 	andeq	r0, r0, r8, lsl r0
     cf8:	00000c94 	muleq	r0, r4, ip
     cfc:	000053b4 			; <UNDEFINED> instruction: 0x000053b4
            break;
     d00:	00000014 	andeq	r0, r0, r4, lsl r0
        case 0x1:
            NVICICPR1 |= 1 << (irq & 0x1F);
     d04:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     d08:	41018e02 	tstmi	r1, r2, lsl #28
     d0c:	0000070d 	andeq	r0, r0, sp, lsl #14
     d10:	00000018 	andeq	r0, r0, r8, lsl r0
     d14:	00000c94 	muleq	r0, r4, ip
     d18:	000053c8 	andeq	r5, r0, r8, asr #7
     d1c:	00000014 	andeq	r0, r0, r4, lsl r0
     d20:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     d24:	41018e02 	tstmi	r1, r2, lsl #28
     d28:	0000070d 	andeq	r0, r0, sp, lsl #14
            break;
        case 0x2:
            NVICICPR2 |= 1 << (irq & 0x1F);
     d2c:	00000014 	andeq	r0, r0, r4, lsl r0
     d30:	00000c94 	muleq	r0, r4, ip
     d34:	000053dc 	ldrdeq	r5, [r0], -ip
     d38:	00000026 	andeq	r0, r0, r6, lsr #32
     d3c:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     d40:	070d4101 	streq	r4, [sp, -r1, lsl #2]
     d44:	00000018 	andeq	r0, r0, r8, lsl r0
     d48:	00000c94 	muleq	r0, r4, ip
     d4c:	00005404 	andeq	r5, r0, r4, lsl #8
     d50:	000000c0 	andeq	r0, r0, r0, asr #1
            break;
     d54:	87040e41 	strhi	r0, [r4, -r1, asr #28]
        case 0x3:
            NVICICPR3 |= 1 << (irq & 0x1F);
     d58:	100e4101 	andne	r4, lr, r1, lsl #2
     d5c:	00070d41 	andeq	r0, r7, r1, asr #26
     d60:	00000018 	andeq	r0, r0, r8, lsl r0
     d64:	00000c94 	muleq	r0, r4, ip
     d68:	000054c4 	andeq	r5, r0, r4, asr #9
     d6c:	0000002a 	andeq	r0, r0, sl, lsr #32
     d70:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     d74:	41018e02 	tstmi	r1, r2, lsl #28
     d78:	0000070d 	andeq	r0, r0, sp, lsl #14
     d7c:	0000000c 	andeq	r0, r0, ip
            break;
    }
}
     d80:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     d84:	7c020001 	stcvc	0, cr0, [r2], {1}
     d88:	000d0c0e 	andeq	r0, sp, lr, lsl #24
/*
 * 系统终端初始化函数
 */

 void systemTerm (void)
 {
     d8c:	0000001c 	andeq	r0, r0, ip, lsl r0
     d90:	00000d7c 	andeq	r0, r0, ip, ror sp
     UART_InitTypeDef uart_init_struct;
     uart_init_struct.UART_Uartx = TERM_PORT;
     d94:	000054f0 	strdeq	r5, [r0], -r0
     d98:	000002c2 	andeq	r0, r0, r2, asr #5
     uart_init_struct.UART_BaudRate = TERM_BAUD;
     d9c:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     da0:	41018e02 	tstmi	r1, r2, lsl #28
     uart_init_struct.UART_RxPin = TERM_RX;
     da4:	0d41180e 	stcleq	8, cr1, [r1, #-56]	; 0xffffffc8
     uart_init_struct.UART_TxPin = TERM_TX;
     da8:	00000007 	andeq	r0, r0, r7
     dac:	00000018 	andeq	r0, r0, r8, lsl r0
     uart_init_struct.UART_RxIntEnable = TERM_RX_IRQ;
     db0:	00000d7c 	andeq	r0, r0, ip, ror sp
     uart_init_struct.UART_RxIsr = TERM_RX_FUN;
     db4:	000057b4 			; <UNDEFINED> instruction: 0x000057b4
     db8:	0000009e 	muleq	r0, lr, r0

     LPLD_UART_Init (uart_init_struct);
     dbc:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     dc0:	200e4101 	andcs	r4, lr, r1, lsl #2
     dc4:	00070d41 	andeq	r0, r7, r1, asr #26
#if (TERM_RX_IRQ == TRUE)
     LPLD_UART_EnableIrq (uart_init_struct);
#endif

 }
     dc8:	0000000c 	andeq	r0, r0, ip
     dcc:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
//图像状态
volatile IMG_STATUS_e ov7725_eagle_img_flag = IMG_FINISH;

//ov7725初始化 
uint8 Ov7725_Init (void)
{
     dd0:	7c020001 	stcvc	0, cr0, [r2], {1}
     dd4:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    uint16 i = 0;
     dd8:	00000020 	andeq	r0, r0, r0, lsr #32
    uint8 device_Id = 0;
     ddc:	00000dc8 	andeq	r0, r0, r8, asr #27
     de0:	00005854 	andeq	r5, r0, r4, asr r8
    uint8 reg_Buff[50] = {0};
     de4:	00000356 	andeq	r0, r0, r6, asr r3
     de8:	41100e41 	tstmi	r0, r1, asr #28
     dec:	07841c0e 	streq	r1, [r4, lr, lsl #24]
     df0:	058e0687 	streq	r0, [lr, #1671]	; 0x687
     df4:	41400e41 	cmpmi	r0, r1, asr #28
     df8:	0000070d 	andeq	r0, r0, sp, lsl #14
     dfc:	00000018 	andeq	r0, r0, r8, lsl r0
     e00:	00000dc8 	andeq	r0, r0, r8, asr #27
     e04:	00005bac 	andeq	r5, r0, ip, lsr #23
     e08:	00000080 	andeq	r0, r0, r0, lsl #1
     e0c:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     e10:	41018e02 	tstmi	r1, r2, lsl #28
     e14:	0000070d 	andeq	r0, r0, sp, lsl #14
     e18:	0000001c 	andeq	r0, r0, ip, lsl r0
     e1c:	00000dc8 	andeq	r0, r0, r8, asr #27
     e20:	00005c2c 	andeq	r5, r0, ip, lsr #24
     e24:	0000015e 	andeq	r0, r0, lr, asr r1
     e28:	840c0e41 	strhi	r0, [ip], #-3649	; 0xe41
     e2c:	87028503 	strhi	r8, [r2, -r3, lsl #10]
     e30:	300e4101 	andcc	r4, lr, r1, lsl #2
     e34:	00070d41 	andeq	r0, r7, r1, asr #26
     e38:	0000001c 	andeq	r0, r0, ip, lsl r0
     e3c:	00000dc8 	andeq	r0, r0, r8, asr #27
     e40:	00005d8c 	andeq	r5, r0, ip, lsl #27
     e44:	00000110 	andeq	r0, r0, r0, lsl r1
     e48:	84080e41 	strhi	r0, [r8], #-3649	; 0xe41
     e4c:	41018702 	tstmi	r1, r2, lsl #14
     e50:	0d41280e 	stcleq	8, cr2, [r1, #-56]	; 0xffffffc8
     e54:	00000007 	andeq	r0, r0, r7
     e58:	00000018 	andeq	r0, r0, r8, lsl r0
     e5c:	00000dc8 	andeq	r0, r0, r8, asr #27
     e60:	00005e9c 	muleq	r0, ip, lr
     e64:	000000de 	ldrdeq	r0, [r0], -lr

    LPLD_SCCB_Init ();
     e68:	87080e41 	strhi	r0, [r8, -r1, asr #28]
    
    Ov7725_Delay();
     e6c:	41018e02 	tstmi	r1, r2, lsl #28

    while (!LPLD_SCCB_WriteReg (OV7725_COM7, 0x80))
     e70:	0000070d 	andeq	r0, r0, sp, lsl #14
    {
        if (i ++ >= 500)
     e74:	0000000c 	andeq	r0, r0, ip
     e78:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     e7c:	7c020001 	stcvc	0, cr0, [r2], {1}
     e80:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     e84:	0000001c 	andeq	r0, r0, ip, lsl r0
     e88:	00000e74 	andeq	r0, r0, r4, ror lr
     e8c:	00005f7c 	andeq	r5, r0, ip, ror pc
            return 0;
     e90:	0000016e 	andeq	r0, r0, lr, ror #2

    LPLD_SCCB_Init ();
    
    Ov7725_Delay();

    while (!LPLD_SCCB_WriteReg (OV7725_COM7, 0x80))
     e94:	41100e41 	tstmi	r0, r1, asr #28
     e98:	0587140e 	streq	r1, [r7, #1038]	; 0x40e
     e9c:	41280e41 	teqmi	r8, r1, asr #28
     ea0:	0000070d 	andeq	r0, r0, sp, lsl #14
     ea4:	0000001c 	andeq	r0, r0, ip, lsl r0
    {
        if (i ++ >= 500)
            return 0;
    }

    Ov7725_Delay();
     ea8:	00000e74 	andeq	r0, r0, r4, ror lr
    
    while (0 == LPLD_SCCB_ReadReg (OV7725_VER, &device_Id, 1));
     eac:	000060ec 	andeq	r6, r0, ip, ror #1
     eb0:	00000048 	andeq	r0, r0, r8, asr #32
     eb4:	41100e41 	tstmi	r0, r1, asr #28
     eb8:	0687180e 	streq	r1, [r7], lr, lsl #16
     ebc:	0e41058e 	cdpeq	5, 4, cr0, cr1, cr14, {4}
     ec0:	070d4120 	streq	r4, [sp, -r0, lsr #2]

    printf ("You get ID success, SENSOR ID is 0x%x", device_Id);
     ec4:	0000001c 	andeq	r0, r0, ip, lsl r0
     ec8:	00000e74 	andeq	r0, r0, r4, ror lr
     ecc:	00006134 	andeq	r6, r0, r4, lsr r1
     ed0:	0000002e 	andeq	r0, r0, lr, lsr #32
     ed4:	41100e41 	tstmi	r0, r1, asr #28
    printf ("nconfig register Number is %d\n", ov7725_eagle_cfgnum);
     ed8:	0687180e 	streq	r1, [r7], lr, lsl #16
     edc:	0e41058e 	cdpeq	5, 4, cr0, cr1, cr14, {4}
     ee0:	070d4120 	streq	r4, [sp, -r0, lsr #2]
     ee4:	0000001c 	andeq	r0, r0, ip, lsl r0
     ee8:	00000e74 	andeq	r0, r0, r4, ror lr
     eec:	00006164 	andeq	r6, r0, r4, ror #2

    //判断摄像头是否为ov7725
    if (device_Id == OV7725_ID)
     ef0:	0000002e 	andeq	r0, r0, lr, lsr #32
     ef4:	41100e41 	tstmi	r0, r1, asr #28
    {
        for (i = 0; i < ov7725_eagle_cfgnum; i++)
     ef8:	0687180e 	streq	r1, [r7], lr, lsl #16
     efc:	0e41058e 	cdpeq	5, 4, cr0, cr1, cr14, {4}
        {
            if (0 == LPLD_SCCB_WriteReg(ov7725_eagle_reg[i].addr, ov7725_eagle_reg[i].val))
     f00:	070d4120 	streq	r4, [sp, -r0, lsr #2]
     f04:	00000018 	andeq	r0, r0, r8, lsl r0
     f08:	00000e74 	andeq	r0, r0, r4, ror lr
     f0c:	00006194 	muleq	r0, r4, r1
     f10:	00000118 	andeq	r0, r0, r8, lsl r1
     f14:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     f18:	100e4101 	andne	r4, lr, r1, lsl #2
     f1c:	00070d41 	andeq	r0, r7, r1, asr #26
     f20:	00000018 	andeq	r0, r0, r8, lsl r0
     f24:	00000e74 	andeq	r0, r0, r4, ror lr
     f28:	000062ac 	andeq	r6, r0, ip, lsr #5
     f2c:	000000e6 	andeq	r0, r0, r6, ror #1
            {
               printf ("error: writeReg error 0x%x\n", ov7725_eagle_reg[i].addr);
     f30:	87040e41 	strhi	r0, [r4, -r1, asr #28]
     f34:	180e4101 	stmdane	lr, {r0, r8, lr}
     f38:	00070d41 	andeq	r0, r7, r1, asr #26
     f3c:	00000018 	andeq	r0, r0, r8, lsl r0
     f40:	00000e74 	andeq	r0, r0, r4, ror lr
     f44:	00006394 	muleq	r0, r4, r3
     f48:	00000074 	andeq	r0, r0, r4, ror r0
                return 0;
     f4c:	87040e41 	strhi	r0, [r4, -r1, asr #28]
            }
            if (LPLD_SCCB_ReadReg(ov7725_eagle_reg[i].addr, &reg_Buff[i], 1))
     f50:	100e4101 	andne	r4, lr, r1, lsl #2
     f54:	00070d41 	andeq	r0, r7, r1, asr #26
     f58:	00000018 	andeq	r0, r0, r8, lsl r0
     f5c:	00000e74 	andeq	r0, r0, r4, ror lr
     f60:	00006408 	andeq	r6, r0, r8, lsl #8
     f64:	0000002e 	andeq	r0, r0, lr, lsr #32
     f68:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     f6c:	41018e02 	tstmi	r1, r2, lsl #28
     f70:	0000070d 	andeq	r0, r0, sp, lsl #14
     f74:	00000018 	andeq	r0, r0, r8, lsl r0
            {
                printf ("writeRe 0x%x success: 0x%x\n", ov7725_eagle_reg[i].addr, reg_Buff[i]);
     f78:	00000e74 	andeq	r0, r0, r4, ror lr
     f7c:	00006438 	andeq	r6, r0, r8, lsr r4
     f80:	0000002e 	andeq	r0, r0, lr, lsr #32
     f84:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     f88:	41018e02 	tstmi	r1, r2, lsl #28
     f8c:	0000070d 	andeq	r0, r0, sp, lsl #14
     f90:	00000018 	andeq	r0, r0, r8, lsl r0
     f94:	00000e74 	andeq	r0, r0, r4, ror lr
     f98:	00006468 	andeq	r6, r0, r8, ror #8
     f9c:	0000002e 	andeq	r0, r0, lr, lsr #32
     fa0:	87080e41 	strhi	r0, [r8, -r1, asr #28]
    printf ("nconfig register Number is %d\n", ov7725_eagle_cfgnum);

    //判断摄像头是否为ov7725
    if (device_Id == OV7725_ID)
    {
        for (i = 0; i < ov7725_eagle_cfgnum; i++)
     fa4:	41018e02 	tstmi	r1, r2, lsl #28
     fa8:	0000070d 	andeq	r0, r0, sp, lsl #14
     fac:	00000018 	andeq	r0, r0, r8, lsl r0
     fb0:	00000e74 	andeq	r0, r0, r4, ror lr
     fb4:	00006498 	muleq	r0, r8, r4
     fb8:	0000002e 	andeq	r0, r0, lr, lsr #32
            }
        }
    }
    else
    {
        return 0;
     fbc:	87080e41 	strhi	r0, [r8, -r1, asr #28]
     fc0:	41018e02 	tstmi	r1, r2, lsl #28
    }
    return 1;
     fc4:	0000070d 	andeq	r0, r0, sp, lsl #14

}
     fc8:	0000000c 	andeq	r0, r0, ip
     fcc:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff

//ov7725延时函数
void Ov7725_Delay(void)
{
     fd0:	7c020001 	stcvc	0, cr0, [r2], {1}
     fd4:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    uint16 i, n;
    for (i = 0; i < 3000; i++)
     fd8:	0000001c 	andeq	r0, r0, ip, lsl r0
     fdc:	00000fc8 	andeq	r0, r0, r8, asr #31
    {
        for (n = 0; n < 200; n++)
     fe0:	000064c8 	andeq	r6, r0, r8, asr #9
     fe4:	000007aa 	andeq	r0, r0, sl, lsr #15
     fe8:	41100e41 	tstmi	r0, r1, asr #28
     fec:	0587140e 	streq	r1, [r7, #1038]	; 0x40e
     ff0:	41500e41 	cmpmi	r0, r1, asr #28
     ff4:	0000070d 	andeq	r0, r0, sp, lsl #14

//ov7725延时函数
void Ov7725_Delay(void)
{
    uint16 i, n;
    for (i = 0; i < 3000; i++)
     ff8:	0000001c 	andeq	r0, r0, ip, lsl r0
     ffc:	00000fc8 	andeq	r0, r0, r8, asr #31
    1000:	00006c74 	andeq	r6, r0, r4, ror ip
    1004:	000000fa 	strdeq	r0, [r0], -sl
        for (n = 0; n < 200; n++)
        {
            asm("nop");
        }
    }
}
    1008:	41100e41 	tstmi	r0, r1, asr #28
    100c:	0687180e 	streq	r1, [r7], lr, lsl #16
    1010:	0e41058e 	cdpeq	5, 4, cr0, cr1, cr14, {4}

//DMA中断触发函数
void Ov7725_eagle_dma (void)
{
    1014:	070d4120 	streq	r4, [sp, -r0, lsr #2]
    1018:	0000001c 	andeq	r0, r0, ip, lsl r0
    ov7725_eagle_img_flag = IMG_FINISH;
    101c:	00000fc8 	andeq	r0, r0, r8, asr #31
    1020:	00006d70 	andeq	r6, r0, r0, ror sp
    1024:	00000076 	andeq	r0, r0, r6, ror r0
    //关闭DMA通道
    DMA_DIS(DMA_CH0);
    1028:	41100e41 	tstmi	r0, r1, asr #28
    102c:	0687180e 	streq	r1, [r7], lr, lsl #16
    1030:	0e41058e 	cdpeq	5, 4, cr0, cr1, cr14, {4}
    1034:	070d4120 	streq	r4, [sp, -r0, lsr #2]
    1038:	0000001c 	andeq	r0, r0, ip, lsl r0
    103c:	00000fc8 	andeq	r0, r0, r8, asr #31
    //DMA0->INT |= 0x1u << 0;
    //enable_irq(INT_PORTA - 16);
    //图片进行解压
    Ov7725_img_extract(Pix_Data, img, PHOTO_SIZE/8);
    1040:	00006de8 	andeq	r6, r0, r8, ror #27
    1044:	00000076 	andeq	r0, r0, r6, ror r0
    1048:	41100e41 	tstmi	r0, r1, asr #28
    104c:	0687180e 	streq	r1, [r7], lr, lsl #16
    1050:	0e41058e 	cdpeq	5, 4, cr0, cr1, cr14, {4}
    1054:	070d4120 	streq	r4, [sp, -r0, lsr #2]
    //解压完成标志置位
    ready_send_flag = 1;
    1058:	00000018 	andeq	r0, r0, r8, lsl r0
    105c:	00000fc8 	andeq	r0, r0, r8, asr #31
    1060:	00006e60 	andeq	r6, r0, r0, ror #28
    1064:	0000006c 	andeq	r0, r0, ip, rrx
    get_midline(Pix_Data, 60, 80);
    1068:	87040e41 	strhi	r0, [r4, -r1, asr #28]
    106c:	180e4101 	stmdane	lr, {r0, r8, lr}
    1070:	00070d41 	andeq	r0, r7, r1, asr #26
    1074:	00000018 	andeq	r0, r0, r8, lsl r0
    1078:	00000fc8 	andeq	r0, r0, r8, asr #31
         //重新装载DMA目标地址
        DMA_DADDR(DMA_CH0) = (uint32)img;
    107c:	00006ecc 	andeq	r6, r0, ip, asr #29
    1080:	00000036 	andeq	r0, r0, r6, lsr r0
    1084:	87040e41 	strhi	r0, [r4, -r1, asr #28]
    1088:	180e4101 	stmdane	lr, {r0, r8, lr}
    108c:	00070d41 	andeq	r0, r7, r1, asr #26
    1090:	00000018 	andeq	r0, r0, r8, lsl r0
   //Ov7725_sendimg(Pix_Data, PHOTO_SIZE);
    //clear PORTA isr set bit
    PORTA_ISFR = ~0;
    1094:	00000fc8 	andeq	r0, r0, r8, asr #31
    1098:	00006f04 	andeq	r6, r0, r4, lsl #30
    109c:	00000048 	andeq	r0, r0, r8, asr #32
    10a0:	87040e41 	strhi	r0, [r4, -r1, asr #28]
    LPLD_GPIO_EnableIrq(OV_PTA_init);
    10a4:	100e4101 	andne	r4, lr, r1, lsl #2
    10a8:	00070d41 	andeq	r0, r7, r1, asr #26
    10ac:	00000018 	andeq	r0, r0, r8, lsl r0
    10b0:	00000fc8 	andeq	r0, r0, r8, asr #31
    10b4:	00006f4c 	andeq	r6, r0, ip, asr #30
    //DMA0->INT |= 0x1u << 0;
}
    10b8:	00000150 	andeq	r0, r0, r0, asr r1

//场中断开始判断函数
void Ov7725_eagle_vsync(void)
{
    10bc:	87080e41 	strhi	r0, [r8, -r1, asr #28]
    //printf ("runing eagle_vsync\n");
    //判断场中断是否开始
    if (ov7725_eagle_img_flag == IMG_START)
    10c0:	41018e02 	tstmi	r1, r2, lsl #28
    10c4:	0000070d 	andeq	r0, r0, sp, lsl #14
    10c8:	00000018 	andeq	r0, r0, r8, lsl r0
    10cc:	00000fc8 	andeq	r0, r0, r8, asr #31
    {
        ov7725_eagle_img_flag = IMG_GATHER;
    10d0:	0000709c 	muleq	r0, ip, r0
    10d4:	00000150 	andeq	r0, r0, r0, asr r1
    10d8:	87080e41 	strhi	r0, [r8, -r1, asr #28]
    10dc:	41018e02 	tstmi	r1, r2, lsl #28
        disable_irq (INT_PORTA - 16);
    10e0:	0000070d 	andeq	r0, r0, sp, lsl #14
    10e4:	00000018 	andeq	r0, r0, r8, lsl r0
        //LPLD_GPIO_DisableIrq(OV_PTA_init);
        //enable_irq (DMA_CH0 + INT_DMA0_DMA16 - 16);
        DMA_EN(DMA_CH0);
    10e8:	00000fc8 	andeq	r0, r0, r8, asr #31
    10ec:	000071ec 	andeq	r7, r0, ip, ror #3
    10f0:	00000150 	andeq	r0, r0, r0, asr r1
    10f4:	87080e41 	strhi	r0, [r8, -r1, asr #28]
    10f8:	41018e02 	tstmi	r1, r2, lsl #28
    10fc:	0000070d 	andeq	r0, r0, sp, lsl #14
        //LPLD_DMA_EnableIrq(OV_dma_init);
        //重新装载DMA目标地址
        DMA_DADDR(DMA_CH0) = (uint32)img;
    1100:	0000000c 	andeq	r0, r0, ip
    1104:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    1108:	7c020001 	stcvc	0, cr0, [r2], {1}
    110c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    1110:	0000001c 	andeq	r0, r0, ip, lsl r0
    1114:	00001100 	andeq	r1, r0, r0, lsl #2
    1118:	0000733c 	andeq	r7, r0, ip, lsr r3
    }
    else
    {
        //disable_irq (INT_PORTA);
        //LPLD_GPIO_DisableIrq(OV_PTA_init);
        disable_irq (INT_PORTA - 16);
    111c:	000004da 	ldrdeq	r0, [r0], -sl
    1120:	41100e41 	tstmi	r0, r1, asr #28
        ov7725_eagle_img_flag = IMG_FAIL;
    1124:	0684180e 	streq	r1, [r4], lr, lsl #16
    1128:	0e410587 	cdpeq	5, 4, cr0, cr1, cr7, {4}
    112c:	070d4138 	smladxeq	sp, r8, r1, r4
    }
}
    1130:	00000018 	andeq	r0, r0, r8, lsl r0

//ov7725开始采集图像
void Ov7725_eagle_get_img(void)
{
    1134:	00001100 	andeq	r1, r0, r0, lsl #2
    1138:	00007818 	andeq	r7, r0, r8, lsl r8
    ov7725_eagle_img_flag = IMG_START;
    113c:	0000002e 	andeq	r0, r0, lr, lsr #32
    1140:	87040e41 	strhi	r0, [r4, -r1, asr #28]
    1144:	100e4101 	andne	r4, lr, r1, lsl #2
    //write 1 clear int 
    PORTA_ISFR = ~0;
    1148:	00070d41 	andeq	r0, r7, r1, asr #26
    114c:	00000018 	andeq	r0, r0, r8, lsl r0
    1150:	00001100 	andeq	r1, r0, r0, lsl #2
    1154:	00007848 	andeq	r7, r0, r8, asr #16
    DMA_DADDR(DMA_CH0) = (uint32)img;
    1158:	0000001e 	andeq	r0, r0, lr, lsl r0
    115c:	87040e41 	strhi	r0, [r4, -r1, asr #28]
    1160:	100e4101 	andne	r4, lr, r1, lsl #2
    1164:	00070d41 	andeq	r0, r7, r1, asr #26
    1168:	00000018 	andeq	r0, r0, r8, lsl r0
    116c:	00001100 	andeq	r1, r0, r0, lsl #2
    1170:	00007868 	andeq	r7, r0, r8, ror #16
    LPLD_GPIO_EnableIrq(OV_PTA_init);
    1174:	0000002c 	andeq	r0, r0, ip, lsr #32
    1178:	87040e41 	strhi	r0, [r4, -r1, asr #28]
    117c:	100e4101 	andne	r4, lr, r1, lsl #2
    1180:	00070d41 	andeq	r0, r7, r1, asr #26
}
    1184:	0000001c 	andeq	r0, r0, ip, lsl r0
 *  @param      srclen          二值化图像的占用空间大小
 *  @since      v5.0            img_extract(img, imgbuff,CAMERA_SIZE);
 *  Sample usage:   sendimg(imgbuff, CAMERA_W * CAMERA_H);                    //发送到上位机
 */
void Ov7725_img_extract(uint8 *dst, uint8 *src, uint32 srclen)
{
    1188:	00001100 	andeq	r1, r0, r0, lsl #2
    118c:	00007894 	muleq	r0, r4, r8
    1190:	00000046 	andeq	r0, r0, r6, asr #32
    uint8 colour[2] = {255, 0}; //0 和 1 分别对应的颜色
    1194:	87080e41 	strhi	r0, [r8, -r1, asr #28]
    1198:	41018e02 	tstmi	r1, r2, lsl #28
    119c:	0d41180e 	stcleq	8, cr1, [r1, #-56]	; 0xffffffc8
    //注：野火的摄像头 1(or255)表示 白色，0表示 黑色
    uint8 tmpsrc;
    while(srclen --)
    11a0:	00000007 	andeq	r0, r0, r7
    {
        tmpsrc = *src++;
    11a4:	0000001c 	andeq	r0, r0, ip, lsl r0
    11a8:	00001100 	andeq	r1, r0, r0, lsl #2
    11ac:	000078dc 	ldrdeq	r7, [r0], -ip
        *dst++ = colour[(tmpsrc >> 7) & 0x01];
    11b0:	000000a6 	andeq	r0, r0, r6, lsr #1
    11b4:	41100e41 	tstmi	r0, r1, asr #28
    11b8:	0687180e 	streq	r1, [r7], lr, lsl #16
    11bc:	0d41058e 	cfstr64eq	mvdx0, [r1, #-568]	; 0xfffffdc8
    11c0:	00000007 	andeq	r0, r0, r7
    11c4:	0000001c 	andeq	r0, r0, ip, lsl r0
    11c8:	00001100 	andeq	r1, r0, r0, lsl #2
    11cc:	00007984 	andeq	r7, r0, r4, lsl #19
    11d0:	000000a6 	andeq	r0, r0, r6, lsr #1
        *dst++ = colour[(tmpsrc >> 6) & 0x01];
    11d4:	41100e41 	tstmi	r0, r1, asr #28
    11d8:	0687180e 	streq	r1, [r7], lr, lsl #16
    11dc:	0d41058e 	cfstr64eq	mvdx0, [r1, #-568]	; 0xfffffdc8
    11e0:	00000007 	andeq	r0, r0, r7
    11e4:	00000018 	andeq	r0, r0, r8, lsl r0
    11e8:	00001100 	andeq	r1, r0, r0, lsl #2
    11ec:	00007a2c 	andeq	r7, r0, ip, lsr #20
    11f0:	0000006e 	andeq	r0, r0, lr, rrx
        *dst++ = colour[(tmpsrc >> 5) & 0x01];
    11f4:	87080e41 	strhi	r0, [r8, -r1, asr #28]
    11f8:	41018e02 	tstmi	r1, r2, lsl #28
    11fc:	0000070d 	andeq	r0, r0, sp, lsl #14
    1200:	00000018 	andeq	r0, r0, r8, lsl r0
    1204:	00001100 	andeq	r1, r0, r0, lsl #2
    1208:	00007a9c 	muleq	r0, ip, sl
    120c:	0000006e 	andeq	r0, r0, lr, rrx
    1210:	87080e41 	strhi	r0, [r8, -r1, asr #28]
    1214:	41018e02 	tstmi	r1, r2, lsl #28
        *dst++ = colour[(tmpsrc >> 4) & 0x01];
    1218:	0000070d 	andeq	r0, r0, sp, lsl #14
    121c:	00000018 	andeq	r0, r0, r8, lsl r0
    1220:	00001100 	andeq	r1, r0, r0, lsl #2
    1224:	00007b0c 	andeq	r7, r0, ip, lsl #22
    1228:	0000006e 	andeq	r0, r0, lr, rrx
    122c:	87080e41 	strhi	r0, [r8, -r1, asr #28]
    1230:	41018e02 	tstmi	r1, r2, lsl #28
    1234:	0000070d 	andeq	r0, r0, sp, lsl #14
        *dst++ = colour[(tmpsrc >> 3) & 0x01];
    1238:	00000018 	andeq	r0, r0, r8, lsl r0
    123c:	00001100 	andeq	r1, r0, r0, lsl #2
    1240:	00007b7c 	andeq	r7, r0, ip, ror fp
    1244:	0000006e 	andeq	r0, r0, lr, rrx
    1248:	87080e41 	strhi	r0, [r8, -r1, asr #28]
    124c:	41018e02 	tstmi	r1, r2, lsl #28
    1250:	0000070d 	andeq	r0, r0, sp, lsl #14
    1254:	00000018 	andeq	r0, r0, r8, lsl r0
    1258:	00001100 	andeq	r1, r0, r0, lsl #2
        *dst++ = colour[(tmpsrc >> 2) & 0x01];
    125c:	00007bec 	andeq	r7, r0, ip, ror #23
    1260:	0000006e 	andeq	r0, r0, lr, rrx
    1264:	87080e41 	strhi	r0, [r8, -r1, asr #28]
    1268:	41018e02 	tstmi	r1, r2, lsl #28
    126c:	0000070d 	andeq	r0, r0, sp, lsl #14
    1270:	00000018 	andeq	r0, r0, r8, lsl r0
    1274:	00001100 	andeq	r1, r0, r0, lsl #2
    1278:	00007c5c 	andeq	r7, r0, ip, asr ip
        *dst++ = colour[(tmpsrc >> 1) & 0x01];
    127c:	0000006e 	andeq	r0, r0, lr, rrx
    1280:	87080e41 	strhi	r0, [r8, -r1, asr #28]
    1284:	41018e02 	tstmi	r1, r2, lsl #28
    1288:	0000070d 	andeq	r0, r0, sp, lsl #14
    128c:	0000000c 	andeq	r0, r0, ip
    1290:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    1294:	7c020001 	stcvc	0, cr0, [r2], {1}
    1298:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    129c:	00000018 	andeq	r0, r0, r8, lsl r0
        *dst++ = colour[(tmpsrc >> 0) & 0x01];
    12a0:	0000128c 	andeq	r1, r0, ip, lsl #5
    12a4:	00007ccc 	andeq	r7, r0, ip, asr #25
    12a8:	00000016 	andeq	r0, r0, r6, lsl r0
    12ac:	87080e41 	strhi	r0, [r8, -r1, asr #28]
    12b0:	41018e02 	tstmi	r1, r2, lsl #28
    12b4:	0000070d 	andeq	r0, r0, sp, lsl #14
    12b8:	0000001c 	andeq	r0, r0, ip, lsl r0
void Ov7725_img_extract(uint8 *dst, uint8 *src, uint32 srclen)
{
    uint8 colour[2] = {255, 0}; //0 和 1 分别对应的颜色
    //注：野火的摄像头 1(or255)表示 白色，0表示 黑色
    uint8 tmpsrc;
    while(srclen --)
    12bc:	0000128c 	andeq	r1, r0, ip, lsl #5
    12c0:	00007ce4 	andeq	r7, r0, r4, ror #25
    12c4:	00000024 	andeq	r0, r0, r4, lsr #32
    12c8:	87080e41 	strhi	r0, [r8, -r1, asr #28]
    12cc:	41018e02 	tstmi	r1, r2, lsl #28
    12d0:	0d41100e 	stcleq	0, cr1, [r1, #-56]	; 0xffffffc8
        *dst++ = colour[(tmpsrc >> 3) & 0x01];
        *dst++ = colour[(tmpsrc >> 2) & 0x01];
        *dst++ = colour[(tmpsrc >> 1) & 0x01];
        *dst++ = colour[(tmpsrc >> 0) & 0x01];
    }
}
    12d4:	00000007 	andeq	r0, r0, r7
    12d8:	00000018 	andeq	r0, r0, r8, lsl r0
    12dc:	0000128c 	andeq	r1, r0, ip, lsl #5
 *  @note       不同的上位机，不同的命令，这里使用 eSmartCameraCar软件，
                如果使用其他上位机，则需要修改代码。
 *  Sample usage:   sendimg(imgbuff, CAMERA_W * CAMERA_H);                    //发送到上位机
 */
void Ov7725_sendimg(uint8 *imgaddr, uint32 imgsize)
{
    12e0:	00007d08 	andeq	r7, r0, r8, lsl #26
    12e4:	00000016 	andeq	r0, r0, r6, lsl r0
    12e8:	87080e41 	strhi	r0, [r8, -r1, asr #28]
    uint8 cmd[4] = {0, 255, 1, 0 };    //yy_摄像头串口调试 使用的命令
    12ec:	41018e02 	tstmi	r1, r2, lsl #28
    12f0:	0000070d 	andeq	r0, r0, sp, lsl #14
    12f4:	0000000c 	andeq	r0, r0, ip
    12f8:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    
    LPLD_UART_PutCharArr(TERM_PORT, (char *)cmd, sizeof(cmd));
    12fc:	7c020001 	stcvc	0, cr0, [r2], {1}
    1300:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    1304:	0000001c 	andeq	r0, r0, ip, lsl r0
    1308:	000012f4 	strdeq	r1, [r0], -r4
    130c:	00007d20 	andeq	r7, r0, r0, lsr #26
    LPLD_UART_PutCharArr(TERM_PORT, (char *)imgaddr, imgsize);
    1310:	00000058 	andeq	r0, r0, r8, asr r0
    1314:	87080e41 	strhi	r0, [r8, -r1, asr #28]
    1318:	41018e02 	tstmi	r1, r2, lsl #28
    131c:	0d41180e 	stcleq	8, cr1, [r1, #-56]	; 0xffffffc8
    1320:	00000007 	andeq	r0, r0, r7

    //uart_putbuff(FIRE_PORT, cmd, sizeof(cmd));    //先发送命令

    //uart_putbuff(FIRE_PORT, imgaddr, imgsize); //再发送图像
}
    1324:	00000018 	andeq	r0, r0, r8, lsl r0
    1328:	000012f4 	strdeq	r1, [r0], -r4

//OV7725GPIO口初始化
void Ov7725_Gpio_Init(void)
{
    132c:	00007d78 	andeq	r7, r0, r8, ror sp
    1330:	0000011e 	andeq	r0, r0, lr, lsl r1
    //OV数据口初始化 B0～B7
    OV_PTB_init.GPIO_PTx = PTB;
    1334:	87040e41 	strhi	r0, [r4, -r1, asr #28]
    1338:	380e4101 	stmdacc	lr, {r0, r8, lr}
    133c:	00070d41 	andeq	r0, r7, r1, asr #26
    1340:	0000001c 	andeq	r0, r0, ip, lsl r0
    OV_PTB_init.GPIO_Dir = DIR_INPUT;
    1344:	000012f4 	strdeq	r1, [r0], -r4
    1348:	00007e98 	muleq	r0, r8, lr
    134c:	00000038 	andeq	r0, r0, r8, lsr r0
    1350:	87080e41 	strhi	r0, [r8, -r1, asr #28]
    OV_PTB_init.GPIO_Pins = GPIO_Pin0_7;
    1354:	41018e02 	tstmi	r1, r2, lsl #28
    1358:	0d41200e 	stcleq	0, cr2, [r1, #-56]	; 0xffffffc8
    135c:	00000007 	andeq	r0, r0, r7
    //禁止中断和DMA请求 禁用PULL 输入源下拉
    OV_PTB_init.GPIO_PinControl = IRQC_DIS |
    1360:	0000001c 	andeq	r0, r0, ip, lsl r0
    1364:	000012f4 	strdeq	r1, [r0], -r4
    1368:	00007ed0 	ldrdeq	r7, [r0], -r0
    136c:	00000038 	andeq	r0, r0, r8, lsr r0
                                  INPUT_PULL_DIS|
                                  INPUT_PULL_DOWN;
    LPLD_GPIO_Init (OV_PTB_init);
    1370:	87080e41 	strhi	r0, [r8, -r1, asr #28]
    1374:	41018e02 	tstmi	r1, r2, lsl #28
    1378:	0d41200e 	stcleq	0, cr2, [r1, #-56]	; 0xffffffc8
    137c:	00000007 	andeq	r0, r0, r7

    //OV场信号接口初始化 A29 
    OV_PTA_init.GPIO_PTx = PTA;
    1380:	0000001c 	andeq	r0, r0, ip, lsl r0
    1384:	000012f4 	strdeq	r1, [r0], -r4
    1388:	00007f08 	andeq	r7, r0, r8, lsl #30
    138c:	000006da 	ldrdeq	r0, [r0], -sl
    1390:	87080e41 	strhi	r0, [r8, -r1, asr #28]
    OV_PTA_init.GPIO_Dir = DIR_INPUT;
    1394:	41018e02 	tstmi	r1, r2, lsl #28
    1398:	0d41780e 	stcleq	8, cr7, [r1, #-56]	; 0xffffffc8
    139c:	00000007 	andeq	r0, r0, r7
    OV_PTA_init.GPIO_Pins = GPIO_Pin29;
    13a0:	00000024 	andeq	r0, r0, r4, lsr #32
    13a4:	000012f4 	strdeq	r1, [r0], -r4
    13a8:	000085e4 	andeq	r8, r0, r4, ror #11
    13ac:	00000040 	andeq	r0, r0, r0, asr #32
    //场中断IO设置，上升沿触发IR，输入上拉，使能滤波
    OV_PTA_init.GPIO_PinControl = IRQC_RI |
    13b0:	80100e41 	andshi	r0, r0, r1, asr #28
    13b4:	82038104 	andhi	r8, r3, #1
    13b8:	41018302 	tstmi	r1, r2, lsl #6
    13bc:	0687180e 	streq	r1, [r7], lr, lsl #16
                                    INPUT_PULL_UP|
                                    INPUT_PF_EN;
    OV_PTA_init.GPIO_Isr = Ov7725_isr;
    13c0:	0e41058e 	cdpeq	5, 4, cr0, cr1, cr14, {4}
    13c4:	070d4130 	smladxeq	sp, r0, r1, r4
    13c8:	00000024 	andeq	r0, r0, r4, lsr #32
    13cc:	000012f4 	strdeq	r1, [r0], -r4
    13d0:	00008624 	andeq	r8, r0, r4, lsr #12
    LPLD_GPIO_Init (OV_PTA_init);
    13d4:	00000050 	andeq	r0, r0, r0, asr r0
    13d8:	810c0e41 	tsthi	ip, r1, asr #28
    13dc:	83028203 	movwhi	r8, #8707	; 0x2203
    13e0:	140e4101 	strne	r4, [lr], #-257	; 0x101

    //OV PCLK信号接口初始化: PTA27-PCLK 
    OV_PTD_init.GPIO_PTx = PTA;
    13e4:	048e0587 	streq	r0, [lr], #1415	; 0x587
    13e8:	41380e41 	teqmi	r8, r1, asr #28
    13ec:	0000070d 	andeq	r0, r0, sp, lsl #14
    13f0:	0000000c 	andeq	r0, r0, ip
    13f4:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    OV_PTD_init.GPIO_Pins = GPIO_Pin27;
    13f8:	7c020001 	stcvc	0, cr0, [r2], {1}
    13fc:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    1400:	0000000c 	andeq	r0, r0, ip
    OV_PTD_init.GPIO_Dir = DIR_INPUT;
    1404:	000013f0 	strdeq	r1, [r0], -r0
    1408:	00008b70 	andeq	r8, r0, r0, ror fp
    140c:	0000005e 	andeq	r0, r0, lr, asr r0
